(function () {
  this.Specto = this.Specto || {};
  this.Specto.utils = this.Specto.utils || {};
  this.Specto.utils.NavigatorHelper = this.Specto.utils.NavigatorHelper || {};

  Specto.utils.NavigatorHelper.userAgent = {
    isMobile: function () {
      let check = false;
      (function (a) {
        if (
          /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(
            a
          ) ||
          /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(
            a.substr(0, 4)
          )
        )
          check = true;
      })(navigator.userAgent || navigator.vendor || window.opera);
      return check;
    },
    isMobileAndTablet: function () {
      let check = false;
      (function (a) {
        if (
          /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(
            a
          ) ||
          /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(
            a.substr(0, 4)
          )
        )
          check = true;
      })(navigator.userAgent || navigator.vendor || window.opera);
      return check;
    },
  };
})();

// Bootstrap v4.1.3
const BootstrapKey = Object.freeze({
    active: "active",
    button: "btn",
    buttonDefault: "btn-default",
    buttonPrimary: "btn-primary",
    buttonSuccess: "btn-success",
    buttonGroup: "btn-group flex-wrap", /*In bootstrap 4, "btn-group" is not responsive. To make it responsive we should add "flex-wrap" class*/
    checkboxInline: "checkbox-inline", // TODO_N
    colXs: "col-", // "col-xs" in v3
    colSm: "col-sm-",
    colMd: "col-md-",
    colLg: "col-lg-",
    container: "container",
    disabled: "disabled",
    formGroup: "", //TODO_N
    controlLabel: "", //TODO_N
    formControl: "form-control",
    hidden: "d-none", // "hidden" in v3
    /*
        SVG images and IE 10
        In Internet Explorer 10, SVG images with .img-fluid are disproportionately sized. To fix this, add width: 100% \9; where necessary. 
        This fix improperly sizes other image formats, so Bootstrap doesn’t apply it automatically.    
    */
    imgResponsive: "img-fluid", // "img-responsive" in v3
    /*
        An official Bootstrap 4 migration guide for Input Groups say that:
        We’ve dropped .input-group-addon and .input-group-btn for two new classes, .input-group-prepend and .input-group-append.
        You must explicitly use an append or a prepend now, simplifying much of our CSS. Within an append or prepend, place your 
        buttons as they would exist anywhere else, but wrap text in .input-group-text.
        link: https://getbootstrap.com/docs/4.0/migration/#input-groups    
    */
    inputGroup: "input-group",
    //inputGroupAddon: "input-group-append", // "input-group-addon" in v3
    inputGroupPrepend: "input-group-prepend", // "input-group-addon" in v3
    inputGroupAppend: "input-group-append", // "input-group-addon" in v3
    //inputGroupButton: "input-group-append", // "input-group-btn" in v3
    inputGroupPrependBtn: "input-group-prepend", // "input-group-btn" in v3
    inputGroupAppendBtn: "input-group-append", // "input-group-btn" in v3
    inputGroupText: "input-group-text", // Does not exit on v3
    progress: "progress",
    progressBar: "progress-bar",
    progressBarStriped: "progress-bar-striped",
    progressBarInfo: "bg-info", // Does not exit on v3
    progressBarSuccess: "bg-success",
    progressBarDanger: "bg-danger",
    radioInline: "radio-inline", // TODO_N
    row: "row",
    tag: "label", // TODO_N
    textDanger: "text-danger",
    //select2-bootstrap
    select2BootstrapAppend: "select2-bootstrap-append", // TODO_N: Add comment + ...
    //select2 theme option
    select2Theme: "bootstrap4",
});

// FontAwesome v5.5.0
const FontAwesomeKey = Object.freeze({
    arrowUp: "fas fa-arrow-up",
    arrowDown: "fas fa-arrow-down",
    cloudDownload: "fas fa-cloud-download-alt",
    download: "fas fa-download",
    error: "fas fa-minus-circle",
    file: "far fa-file",
    picture: "far fa-image",
    remove: "fas fa-times",
    removeCircle: "fas fa-times-circle",
    search: "fas fa-search",
    trash: "far fa-trash-alt",
    upload: "fas fa-cloud-upload-alt",
    view: "far fa-eye",
    calendar: "far fa-calendar-alt",
    clock: "far fa-clock",
    edit: "fas fa-edit",
    add: "fas fa-plus",
    addCircle: "fas fa-plus-circle",
    eraser: "fas fa-eraser",
    settings: "fas fa-cog",
});

(function () {
    Element.prototype.customReset = function (exceptElements) {
        exceptElements = exceptElements || [];

        var getDefaultValueByType = function (value) {
            var defaultValue = "";

            if (value) {
                if (value.toLowerCase() == "true" || value.toLowerCase() == "false") {
                    defaultValue = "false";
                }
                else if (/^\d+$/.test(value)) {
                    defaultValue = 0;
                }
            }

            return defaultValue;
        };

        var form = $(this).closest('form').get(0);

        if (form) {
            $(':input', form).each(function () {
                var currentInput = this;

                if (!exceptElements.some(function (element, index, array) {
                    return $(element)[0] == currentInput;
                })) {
                    var tag = this.tagName.toLowerCase(); // normalize case

                    if (tag == 'select') {
                        // select elements need to have their 'selectedIndex' property set to -1 (this works for both single and multiple select elements)
                        //this.selectedIndex = 0;
                        $(this).not(".phone-edit-select").val(null).trigger("change");
                    }
                    else if (tag == 'textarea') {
                        this.value = "";
                    }
                    else {
                        var type = this.type;

                        if (type == 'checkbox') {
                            // checkboxes need to have their checked state cleared
                            this.checked = false;
                            $(this).change(); // trigger the change event
                        } else if (type == 'hidden') {
                            if (this.hasAttribute("default-value")) {
                                this.value = this.getAttribute("default-value");
                            }
                            else if (this.hasAttribute("data-val-required")) {
                                this.value = getDefaultValueByType(this.value);
                            }
                        }
                        else if (type == 'button' || type == 'submit' || type == 'reset') {
                            return true;
                        }
                        else if (type != 'radio') {
                            // Check any type excpt the above types (that is in if conditation) and 
                            //  the radio (coz the radio has a special case to handle it) 
                            // else if (type == 'text' || type == 'number' || type == 'password' || type == 'file' || ....) {
                            // to reset the value attr of text inputs, password inputs and fileUpload...
                            this.value = "";
                        }
                    }
                }
            });

            // Check the first radio field of each list
            $(".specto-list-group.radio-list").each(function () {
                var radioId = $(this).find(":input[type='radio']:first").attr("id");

                if (radioId) {
                    $('#' + radioId).prop('checked', 'true');
                }
            });
        }
    };
})();
(function ($) {
    var convertEmptyValuesToUndefined = function (obj) {
        var extendedObject = obj instanceof Array ? $.extend(true, [], obj) : $.extend(true, {}, obj);

        for (var key in extendedObject) {
            var value = extendedObject[key];

            // Note: We should not extend the jquery element, even though it is of type object
            if (!(value instanceof $)) {
                if (value === 0 || value === null) {
                    extendedObject[key] = undefined;
                }
                else if (typeof value == "object") { // if value is array [] or json object {} or null
                    //else if (value instanceof Object) { this line of code retrun true in case the value is a function
                    extendedObject[key] = convertEmptyValuesToUndefined(value);
                }
            }
        }

        return extendedObject;
    };

    $.customExtend = function () {
        // This extension is created to replace all empty values(null or zero) to undefined for all objects except the first one (coz we assume that the first object is the default)
        //   before calling the $.extend.
        // The reason is, when we call the jquery extends with the following parameters $.extend(defaults, options);
        //   if the options values contains null or zero, this will override the default values from the first object, but if a value from the options is undefined,
        //   the $.extend does not override the value from the first object.
        // Ex:
        // $.extend(fixedOptions, options, ...);
        // $.extend({}, fixedOptions, options, ...);
        // $.extend(true, fixedOptions, options, ...);
        // $.extend(true, {}, fixedOptions, options, ...);

        var firstObjectIndex = 0;
        var argumentsArray = [];

        while (arguments[firstObjectIndex]) {
            var argument = arguments[firstObjectIndex];

            argumentsArray.push(argument);
            firstObjectIndex++;

            if (typeof argument == "object" && Object.keys(argument).length) {
                // Break on the first filled object
                break;
            }
        };

        // Call convertEmptyValuesToUndefined function for all argument objects except the first filled object. 
        // Ex: firstObjectIndex:
        // $.extend(fixedOptions, options, ...); => firstObjectIndex = 1
        // $.extend({}, fixedOptions, options, ...); => firstObjectIndex = 2
        // $.extend(true, fixedOptions, options, ...); => firstObjectIndex = 2
        // $.extend(true, {}, fixedOptions, options, ...); => firstObjectIndex = 3
        for (var i = firstObjectIndex; i < arguments.length; i++) {
            argumentsArray.push(convertEmptyValuesToUndefined(arguments[i]));
        }

        return $.extend.apply(null, argumentsArray);
    };

    //********************** Bootstrap Extensions **********************//

    $.fn.addBsClass = function (key) {
        return this.addClass(BootstrapKey[key]);
    };

    $.fn.removeBsClass = function (key) {
        return this.removeClass(BootstrapKey[key]);
    };

    // columnClasses param is an object: { xs:.., sm:.., md:.., lg:.. }
    $.fn.addBsColClass = function (columns) {
        if (columns.hasOwnProperty("xs")) { //column.addClass("col-xs-" + colSize);
            this.addClass(BootstrapKey.colXs + columns.xs);
        }

        if (columns.hasOwnProperty("sm")) { //column.addClass("col-sm-" + colSize);
            this.addClass(BootstrapKey.colSm + columns.sm);
        }

        if (columns.hasOwnProperty("md")) { //column.addClass("col-md-" + colSize);
            this.addClass(BootstrapKey.colMd + columns.md);
        }

        if (columns.hasOwnProperty("lg")) { //column.addClass("col-lg-" + colSize);
            this.addClass(BootstrapKey.colLg + columns.lg);
        }

        return this;
    };

    //******************** Font Awesome Extensions *********************//

    $.fn.addFaClass = function (key) {
        return this.addClass(FontAwesomeKey[key]);
    };

    $.fn.removeFaClass = function (key) {
        return this.removeClass(FontAwesomeKey[key]);
    };

})(jQuery);
'use strict';

/**
 * Copyright Marc J. Schmidt. See the LICENSE file at the top-level
 * directory of this distribution and at
 * https://github.com/marcj/css-element-queries/blob/master/LICENSE.
 */
(function (root, factory) {
    if (typeof define === "function" && define.amd) {
        define(factory);
    } else if (typeof exports === "object") {
        module.exports = factory();
    } else {
        root.ResizeSensor = factory();
    }
}(typeof window !== 'undefined' ? window : this, function () {

    // Make sure it does not throw in a SSR (Server Side Rendering) situation
    if (typeof window === "undefined") {
        return null;
    }
    // https://github.com/Semantic-Org/Semantic-UI/issues/3855
    // https://github.com/marcj/css-element-queries/issues/257
    var globalWindow = typeof window != 'undefined' && window.Math == Math
        ? window
        : typeof self != 'undefined' && self.Math == Math
            ? self
            : Function('return this')();
    // Only used for the dirty checking, so the event callback count is limited to max 1 call per fps per sensor.
    // In combination with the event based resize sensor this saves cpu time, because the sensor is too fast and
    // would generate too many unnecessary events.
    var requestAnimationFrame = globalWindow.requestAnimationFrame ||
        globalWindow.mozRequestAnimationFrame ||
        globalWindow.webkitRequestAnimationFrame ||
        function (fn) {
            return globalWindow.setTimeout(fn, 20);
        };

    var cancelAnimationFrame = globalWindow.cancelAnimationFrame ||
        globalWindow.mozCancelAnimationFrame ||
        globalWindow.webkitCancelAnimationFrame ||
        function (timer) {
            globalWindow.clearTimeout(timer);
        };

    /**
     * Iterate over each of the provided element(s).
     *
     * @param {HTMLElement|HTMLElement[]} elements
     * @param {Function}                  callback
     */
    function forEachElement(elements, callback){
        var elementsType = Object.prototype.toString.call(elements);
        var isCollectionTyped = ('[object Array]' === elementsType
            || ('[object NodeList]' === elementsType)
            || ('[object HTMLCollection]' === elementsType)
            || ('[object Object]' === elementsType)
            || ('undefined' !== typeof jQuery && elements instanceof jQuery) //jquery
            || ('undefined' !== typeof Elements && elements instanceof Elements) //mootools
        );
        var i = 0, j = elements.length;
        if (isCollectionTyped) {
            for (; i < j; i++) {
                callback(elements[i]);
            }
        } else {
            callback(elements);
        }
    }

    /**
    * Get element size
    * @param {HTMLElement} element
    * @returns {Object} {width, height}
    */
    function getElementSize(element) {
        if (!element.getBoundingClientRect) {
            return {
                width: element.offsetWidth,
                height: element.offsetHeight
            }
        }

        var rect = element.getBoundingClientRect();
        return {
            width: Math.round(rect.width),
            height: Math.round(rect.height)
        }
    }

    /**
     * Apply CSS styles to element.
     *
     * @param {HTMLElement} element
     * @param {Object} style
     */
    function setStyle(element, style) {
        Object.keys(style).forEach(function(key) {
            element.style[key] = style[key];
        });
    }

    /**
     * Class for dimension change detection.
     *
     * @param {Element|Element[]|Elements|jQuery} element
     * @param {Function} callback
     *
     * @constructor
     */
    var ResizeSensor = function(element, callback) {
        //Is used when checking in reset() only for invisible elements
        var lastAnimationFrameForInvisibleCheck = 0;

        /**
         *
         * @constructor
         */
        function EventQueue() {
            var q = [];
            this.add = function(ev) {
                q.push(ev);
            };

            var i, j;
            this.call = function(sizeInfo) {
                for (i = 0, j = q.length; i < j; i++) {
                    q[i].call(this, sizeInfo);
                }
            };

            this.remove = function(ev) {
                var newQueue = [];
                for(i = 0, j = q.length; i < j; i++) {
                    if(q[i] !== ev) newQueue.push(q[i]);
                }
                q = newQueue;
            };

            this.length = function() {
                return q.length;
            }
        }

        /**
         *
         * @param {HTMLElement} element
         * @param {Function}    resized
         */
        function attachResizeEvent(element, resized) {
            if (!element) return;
            if (element.resizedAttached) {
                element.resizedAttached.add(resized);
                return;
            }

            element.resizedAttached = new EventQueue();
            element.resizedAttached.add(resized);

            element.resizeSensor = document.createElement('div');
            element.resizeSensor.dir = 'ltr';
            element.resizeSensor.className = 'resize-sensor';

            var style = {
                pointerEvents: 'none',
                position: 'absolute',
                left: '0px',
                top: '0px',
                right: '0px',
                bottom: '0px',
                overflow: 'hidden',
                zIndex: '-1',
                visibility: 'hidden',
                maxWidth: '100%'
            };
            var styleChild = {
                position: 'absolute',
                left: '0px',
                top: '0px',
                transition: '0s',
            };

            setStyle(element.resizeSensor, style);

            var expand = document.createElement('div');
            expand.className = 'resize-sensor-expand';
            setStyle(expand, style);

            var expandChild = document.createElement('div');
            setStyle(expandChild, styleChild);
            expand.appendChild(expandChild);

            var shrink = document.createElement('div');
            shrink.className = 'resize-sensor-shrink';
            setStyle(shrink, style);

            var shrinkChild = document.createElement('div');
            setStyle(shrinkChild, styleChild);
            setStyle(shrinkChild, { width: '200%', height: '200%' });
            shrink.appendChild(shrinkChild);

            element.resizeSensor.appendChild(expand);
            element.resizeSensor.appendChild(shrink);
            element.appendChild(element.resizeSensor);

            var computedStyle = window.getComputedStyle(element);
            var position = computedStyle ? computedStyle.getPropertyValue('position') : null;
            if ('absolute' !== position && 'relative' !== position && 'fixed' !== position && 'sticky' !== position) {
                element.style.position = 'relative';
            }

            var dirty = false;

            //last request animation frame id used in onscroll event
            var rafId = 0;
            var size = getElementSize(element);
            var lastWidth = 0;
            var lastHeight = 0;
            var initialHiddenCheck = true;
            lastAnimationFrameForInvisibleCheck = 0;

            var resetExpandShrink = function () {
                var width = element.offsetWidth;
                var height = element.offsetHeight;

                expandChild.style.width = (width + 10) + 'px';
                expandChild.style.height = (height + 10) + 'px';

                expand.scrollLeft = width + 10;
                expand.scrollTop = height + 10;

                shrink.scrollLeft = width + 10;
                shrink.scrollTop = height + 10;
            };

            var reset = function() {
                // Check if element is hidden
                if (initialHiddenCheck) {
                    var invisible = element.offsetWidth === 0 && element.offsetHeight === 0;
                    if (invisible) {
                        // Check in next frame
                        if (!lastAnimationFrameForInvisibleCheck){
                            lastAnimationFrameForInvisibleCheck = requestAnimationFrame(function(){
                                lastAnimationFrameForInvisibleCheck = 0;
                                reset();
                            });
                        }

                        return;
                    } else {
                        // Stop checking
                        initialHiddenCheck = false;
                    }
                }

                resetExpandShrink();
            };
            element.resizeSensor.resetSensor = reset;

            var onResized = function() {
                rafId = 0;

                if (!dirty) return;

                lastWidth = size.width;
                lastHeight = size.height;

                if (element.resizedAttached) {
                    element.resizedAttached.call(size);
                }
            };

            var onScroll = function() {
                size = getElementSize(element);
                dirty = size.width !== lastWidth || size.height !== lastHeight;

                if (dirty && !rafId) {
                    rafId = requestAnimationFrame(onResized);
                }

                reset();
            };

            var addEvent = function(el, name, cb) {
                if (el.attachEvent) {
                    el.attachEvent('on' + name, cb);
                } else {
                    el.addEventListener(name, cb);
                }
            };

            addEvent(expand, 'scroll', onScroll);
            addEvent(shrink, 'scroll', onScroll);

            // Fix for custom Elements and invisible elements
            lastAnimationFrameForInvisibleCheck = requestAnimationFrame(function(){
                lastAnimationFrameForInvisibleCheck = 0;
                reset();
            });
        }

        forEachElement(element, function(elem){
            attachResizeEvent(elem, callback);
        });

        this.detach = function(ev) {
            // clean up the unfinished animation frame to prevent a potential endless requestAnimationFrame of reset
            if (lastAnimationFrameForInvisibleCheck) {
                cancelAnimationFrame(lastAnimationFrameForInvisibleCheck);
                lastAnimationFrameForInvisibleCheck = 0;
            }
            ResizeSensor.detach(element, ev);
        };

        this.reset = function() {
            //To prevent invoking element.resizeSensor.resetSensor if it's undefined
            if (element.resizeSensor.resetSensor) {
                element.resizeSensor.resetSensor();
            }
        };
    };

    ResizeSensor.reset = function(element) {
        forEachElement(element, function(elem){
            //To prevent invoking element.resizeSensor.resetSensor if it's undefined
            if (element.resizeSensor.resetSensor) {
                elem.resizeSensor.resetSensor();
            }
        });
    };

    ResizeSensor.detach = function(element, ev) {
        forEachElement(element, function(elem){
            if (!elem) return;
            if(elem.resizedAttached && typeof ev === "function"){
                elem.resizedAttached.remove(ev);
                if(elem.resizedAttached.length()) return;
            }
            if (elem.resizeSensor) {
                if (elem.contains(elem.resizeSensor)) {
                    elem.removeChild(elem.resizeSensor);
                }
                delete elem.resizeSensor;
                delete elem.resizedAttached;
            }
        });
    };

    if (typeof MutationObserver !== "undefined") {
        var observer = new MutationObserver(function (mutations) {
            for (var i in mutations) {
                if (mutations.hasOwnProperty(i)) {
                    var items = mutations[i].addedNodes;
                    for (var j = 0; j < items.length; j++) {
                        if (items[j].resizeSensor) {
                            ResizeSensor.reset(items[j]);
                        }
                    }
                }
            }
        });

        document.addEventListener("DOMContentLoaded", function (event) {
            observer.observe(document.body, {
                childList: true,
                subtree: true,
            });
        });
    }

    return ResizeSensor;

}));

(function () {
  this.Specto = this.Specto || {};
  this.Specto.ui = this.Specto.ui || {};
  Specto.ui.defaults = Specto.ui.defaults || {};
  var ns = this.Specto.ui;

  /***************************************************************************************************/
  /***************************************** Element Queries *****************************************/

  //#region *************************** Documentation ***************************//

  //#region ************** Options *************//
  /* 
      options: {
          deepQuery: {
              enabled: true(default)/false, // Apply element queries on the main element and it's descendent elements
              searchQuery:.., // By default, we apply element queries on descendent elements, matching the default query
                                 classPattern. If this option is set, we will apply element queries on descendent elements, 
                                 matching this seachQuery value in addition to matching the default query classPattern.
          },
          // The following are the default values (Those values are based on bootstrap 4.3.1 version)
          queryBoundaries: [
              // extraLarge
              { minWidth: "1200", classPattern: "col-xl-" },
              // large
              { minWidth: "992", classPattern: "col-lg-" },
              // medium
              { minWidth: "768", classPattern: "col-md-" },
              // small
              { minWidth: "576", classPattern: "col-sm-" },
              // extraSmall
              { maxWidth: "575.98", classPattern: "col-" },
          ],

          detailsSlider: {
              resizable: true(default)/false,
              toggable: true(default)/false,
          },
          textTooltipLinesNumber: 1,
          resizeIcon: "fa fa-bars",
          toggleIcon: "fa fa-bars",
          deleteIcon: "fa fa-times",
      }
  */
  //#endregion *********** Options *************//

  //#endregion ************************ Documentation ***************************//


  //#region **************************** Entry Class ****************************//

  ns.ElementQueries = (function () {
      // Default options
      var defaults = $.extend({}, {
          deepQuery: {
              enabled: true, // Apply element queries on the main element and it's descendent elements
          },
          queryBoundaries: [ // queryBoundaries
              // extraLarge
              { minWidth: "1200", classPattern: "col-xl-" },
              // large
              { minWidth: "992", classPattern: "col-lg-" },
              // medium
              { minWidth: "768", classPattern: "col-md-" },
              // small
              { minWidth: "576", classPattern: "col-sm-" },
              // extraSmall
              { maxWidth: "575.98", classPattern: "col-" },
          ],
      }, Specto.ui.defaults.ElementQueries);

      var priv = new WeakMap();
      var _ = function (instance) { return priv.get(instance); };

      function ElementQueries(element, options) {
          this.options = $.extend(true, {}, defaults, options);

          var privateMembers = {
              $element: $(element), // Original container
          };

          priv.set(this, privateMembers);

          // Initialize the ElementQueries
          init.call(this);
      }

      //#region ___________________________ Private Methods ___________________________

      var init = function () {

      };

      //#region __________________ Queries __________________

      var getMatchedElementQuery = function () {
          var matchedElementQuery;

          var $element = _(this).$element;
          for (var i = 0; i < this.options.queryBoundaries.length; i++) {
              var elementQuey = this.options.queryBoundaries[i];

              var isMatch = false;
              if (elementQuey.hasOwnProperty("maxWidth")) {
                  if ($element.width() < elementQuey.maxWidth) {
                      isMatch = true;
                  }
              }
              else if (elementQuey.hasOwnProperty("minWidth")) {
                  if ($element.width() > elementQuey.minWidth) {
                      isMatch = true;
                  }
              }

              if (isMatch) {
                  matchedElementQuery = elementQuey;
                  break;
              }
          }

          return matchedElementQuery;
      };

      var getQueriesCssPatterns = function () {
          var queriesCssClasses = [];

          //queriesCssClasses.push(this.options.queryBoundaries.extraLarge.classPattern);
          //queriesCssClasses.push(this.options.queryBoundaries.large.classPattern);
          //queriesCssClasses.push(this.options.queryBoundaries.medium.classPattern);
          //queriesCssClasses.push(this.options.queryBoundaries.small.classPattern);
          //queriesCssClasses.push(this.options.queryBoundaries.extraSmall.classPattern);

          for (var i = 0; i < this.options.queryBoundaries.length; i++) {
              queriesCssClasses.push(this.options.queryBoundaries[i].classPattern);
          }

          return queriesCssClasses;
      };

      //#endregion _______________ Queries __________________


      //#region __________________ Element __________________

      var extractQueryClasses = function ($element) {
          var cssClassArray = [];

          this.options.queryBoundaries.forEach(function (query) {
              var classPattern = query.classPattern;

              //$element[0].className.match(/(^|\s)col-\S+/g);
              var reg = new RegExp(classPattern + "\\S+", "g");
              var matchedValue = $element[0].className.match(reg);
              if (matchedValue) {
                  // Get last matched css class
                  cssClassArray.push(matchedValue[matchedValue.length - 1]);
              }
          });

          return cssClassArray;
      };

      var isAnElementQuery = function ($element) {
          var elementQueryClasses = $element.data("query-classes");

          if (!elementQueryClasses || elementQueryClasses.length === 0) {
              // Extract query classes
              elementQueryClasses = extractQueryClasses.call(this, $element);
              $element.data("query-classes", elementQueryClasses);
          }

          return elementQueryClasses && elementQueryClasses.length;
      };

      var removeElementQueryClasses = function ($element) {
          var elementQueryClasses = $element.data("query-classes");

          $element.removeClass(function (index, css) {
              return elementQueryClasses.join(" ");
              //return (css.match(/(^|\s)col-\S+/g) || []).join(' ');
          });
      };

      var isPetternMatched = function (pattern, value) {
          var matchedValue = getMatchedPatternValue.call(this, pattern, value);
          return !!matchedValue;
      };

      var getMatchedPatternValue = function (pattern, value) {
          var reg = new RegExp(pattern + "\\d+", "g");
          var matchedValue = value.match(reg);

          if (matchedValue && matchedValue.length) {
              // Get last matched css class
              matchedValue = matchedValue[matchedValue.length - 1];
          }

          return matchedValue;
      };

      var findMatchedElementCssClass = function ($element, queryCssClassPattern) {
          var elementQueryClasses = $element.data("query-classes");

          var matchedCssClass;
          for (var i = 0; i < elementQueryClasses.length; i++) {
              //if (elementQueryClasses[i].indexOf(queryCssClassPattern) !== -1) {
              //    matchedCssClass = elementQueryClasses[i];
              //    break;
              //}
              if (isPetternMatched.call(this, queryCssClassPattern, elementQueryClasses[i])) {
                  matchedCssClass = elementQueryClasses[i];
                  break;
              }
          }

          return matchedCssClass;
      };

      var applyElementQuery = function ($element, queryCssClassPattern) {
          // Remove element query classes
          removeElementQueryClasses.call(this, $element);

          var queriesCssPatterns = getQueriesCssPatterns.call(this);
          var index = queriesCssPatterns.indexOf(queryCssClassPattern);
          var lastPatternIndex = queriesCssPatterns.length - 1;

          do {
              // Find the matched css class to query pattern
              var matchedCssClass = findMatchedElementCssClass.call(this, $element, queryCssClassPattern);
              if (matchedCssClass || index === lastPatternIndex) {
                  break;
              }

              // Change the element query pattern
              queryCssClassPattern = queriesCssPatterns[++index];

          } while (true);

          // Add matched css class to element
          if (matchedCssClass) {
              $element.addClass(matchedCssClass);
          }
      };

      //#endregion _______________ Element __________________


      //#endregion ________________________ Private Methods ___________________________


      ElementQueries.prototype.trigger = function () {
          var matchedQuery = getMatchedElementQuery.call(this);

          if (matchedQuery) {
              var $element = _(this).$element;
              if (isAnElementQuery.call(this, $element)) {
                  applyElementQuery.call(this, $element, matchedQuery.classPattern);
              }

              if (this.options.deepQuery && this.options.deepQuery.enabled) {
                  var me = this;
                  var $subElements = this.options.deepQuery.searchQuery ?
                                          $element.find(this.options.deepQuery.searchQuery) : $element.find("*");

                  $subElements.each(function () {
                      if (isAnElementQuery.call(me, $(this))) {
                          applyElementQuery.call(me, $(this), matchedQuery.classPattern);
                      }
                  });
              }
          }
      };

      return ElementQueries;
  })();

  //#endregion ************************* Entry Class ****************************//
})();

(function () {
	this.Specto = this.Specto || {};
	this.Specto.ui = this.Specto.ui || {};

	var ns = this.Specto.ui;

	/***************************************************************************************************/
	/*************************************** Tooltip on Overflow ****************************************/

	//#region **************************** Entry Class ****************************//

	/*
	 * @param {DOM} dom element
	 * @param {Object} options dict with keys(ellipsisLines)
	 * @property {Integer} ellipsisLines
	 * Note: We created this plugin based on an exist on from github with some changes:
	 *          https://gist.github.com/UziTech/d45102cdffb1039d4415
	 *       In this class we adding the ability to show tooltip for multilines ellipse text
	 */
	ns.TooltipOnOverflow = (function () {
		var defaults = {
			ellipsisLines: 1
		};

		function TooltipOnOverflow(element, options) {
			this.options = $.extend(true, {}, defaults, options);
			this.$element = $(element);

			init.call(this);
		}

		var init = function () {
			this.$element.on("mouseenter", onMouseEnter.bind(this));
		};

		var onMouseEnter = function (e) {
			var $element = this.$element;
			var clientWidth = $element[0].clientWidth;

			var text = extractText.call(this, $element);

			var textWidth = calculateTextWidth.call(this, text,
					$element.css("font-size"), $element.css("font-family"), $element.css("font-weight"));

			if (this.options.ellipsisLines > 1) {
				// If text is longer than the container width
				if (clientWidth < textWidth) {
					textWidth = getLastLineTextWidth.call(this, textWidth, clientWidth);
				}
			}

			// If text is longer than the container width
			if (clientWidth < textWidth) {
				$element.attr('title', text);
			} else {
				$element.removeAttr("title");
			}
		};

		var calculateTextWidth = function (text, fontSize, fontFamily, fontWeight) {
			var fs = fontSize || '12px',
					ff = fontFamily || 'Arial',
					fw = fontWeight || 'normal',
					o = $('<div>' + text + '</div>')
							.css({
								'position': 'absolute', 
								'float': 'left', 
								'white-space': 'nowrap', 
								'visibility': 'hidden', 
								'font-size': fs, 
								'font-family': ff, 
								'font-weight': fw 
							})
							.appendTo($('body')),
					w = o.width();

			o.remove();

			return w;
		};

		var extractText = function ($element) {
			var text = $element.text();

			if ($element.is("input")) {
				text = $element.val();
			}
			else if ($element.is("select")) {
				text = $("option:selected", $element[0]).text();
			}

			return text;
		};

		var getLastLineTextWidth = function (textWidth, containerWidth) {
			for (var i = 1; i < this.options.ellipsisLines; i++) {
				var remainingWords = textWidth - containerWidth;

				// Break if the value is negative
				if (remainingWords <= 0) {
					break;
				}

				textWidth = remainingWords;
			}

			// Last line text width
			return textWidth;
		};

		//TooltipOnOverflow.prototype.destroy = function () {
		//	this.$element.off("mouseenter");
		//};

		return TooltipOnOverflow;
	})();

	//#endregion ************************* Entry Class ****************************//


	//#region *************************** jQuery Plugin ***************************//

	var pluginName = "tooltipOnOverflow";

	'use strict';
	$.fn[pluginName] = function (param) {
		return this.each(function () {
			// Destroy created TooltipOnOverflow
			//if ($.data(this, pluginName)) {
			//var instance = $(this).data(pluginName);
			//instance.destroy();
			//}

			if (!$.data(this, pluginName)) {
				// Create a new instance of TooltipOnOverflow
				$.data(this, pluginName, new ns.TooltipOnOverflow(this, param));
			}
		});
	};

	//#endregion ************************ jQuery Plugin ***************************//
})();



(function () {
  this.Specto = this.Specto || {};
  this.Specto.ui = this.Specto.ui || {};
  Specto.ui.defaults = Specto.ui.defaults || {};
  var ns = this.Specto.ui;

  /***************************************************************************************************/
  /*************************************** Responsive Carousel ***************************************/

  //#region *************************** Documentation ***************************//

  //#region ********** Required Files **********//
  /*
      Required plugins:
          - OwlCarousel: (Version 2.2.1)
              <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/OwlCarousel2/2.2.1/assets/owl.carousel.min.css" 
                      integrity="sha512-GqP/pjlymwlPb6Vd7KmT5YbapvowpteRq9ffvufiXYZp0YpMTtR9tI6/v3U3hFi1N9MQmXum/yBfELxoY+S1Mw==" 
                      crossorigin="anonymous" />
              <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/OwlCarousel2/2.2.1/assets/owl.theme.default.css" 
                      integrity="sha512-9nh05jJrDiaIDxHB7KU6/kt5515wzTd72mQ5UYUBBBCIn0ztTHBgqHjfAS/kewylr8PUjCXpGr8ChhQjVtFVsg==" 
                      crossorigin="anonymous" />
              <script src="https://cdnjs.cloudflare.com/ajax/libs/OwlCarousel2/2.2.1/owl.carousel.min.js" 
                      integrity="sha512-lo4YgiwkxsVIJ5mex2b+VHUKlInSK2pFtkGFRzHsAL64/ZO5vaiCPmdGP3qZq1h9MzZzghrpDP336ScWugUMTg==" 
                      crossorigin="anonymous">
              </script>

          - ResizeSensor: Download ResizeSensor.js, from the following url: https://github.com/marcj/css-element-queries
              <script src="css-element-queries-master/ResizeSensor.js"></script>

          - jquery.ba-throttle-debounce: (Version 1.1)
              <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery-throttle-debounce/1.1/jquery.ba-throttle-debounce.min.js"></script>
  */
  //#endregion ******* Required Files **********//

  //#region *********** jQuery Plugin **********//
  /*
      $(selector).responsiveCarousel(options); Create plugin
      $(selector).responsiveCarousel("instance"); Get the current plugin instance
      //$(selector).responsiveCarousel("render"); // Return the carousel element to render it in somewhere

      $(selector).responsiveCarousel("addCard", cardId, cardElement); // Add a new card element
      $(selector).responsiveCarousel("removeCard", cardId); Remove a card by id

      $(selector).responsiveCarousel("isCardSelected", cardId); Check if card is selected
      $(selector).responsiveCarousel("selectCard", cardId); Select a card
      $(selector).responsiveCarousel("slideToCard", cardId); Slide to a specific card

      $(selector).responsiveCarousel("destroy"); Destroy the owl carousel
      $(selector).responsiveCarousel("refresh"); Refresh the owl carousel

      $(selector).responsiveCarousel("updateVisibleItems", itemsCount); Update carousel visible item
      $(selector).responsiveCarousel("refreshVisibleItems"); This method recalculates the appropriate number of visible items
  */
  //#endregion ******** jQuery Plugin **********//

  //#region ************** Options *************//
  /* 
      options: {
          rtl: false,
          cards: [{ id:.., element: $cards }],
          onAfterCreate: function (e, $carousel) {},
          onSelect: function (e, cardId, $card) {},
          onRemove: function (cardId, $card) {},
          carouselClass:..,
          selectedCardClass: "responsive-carousel-card--selected"(default),
          selectOnNavigate: true/false(default),
      }
  */
  //#endregion *********** Options *************//

  //#region ************** TODO_N **************//
  /*
     
  */
  //#endregion *********** TODO_N **************//

  //#endregion ************************ Documentation ***************************//


  //#region **************************** Entry Class ****************************//

  ns.ResponsiveCarousel = (function () {
      // Default options
      var defaults = $.extend({}, {
          rtl: false,
          cards: [],
          selectedCardClass: "responsive-carousel-card--selected",
          selectOnNavigate: false,
      }, Specto.ui.defaults.ResponsiveCarousel);

      var priv = new WeakMap();
      var _ = function (instance) { return priv.get(instance); };

      function ResponsiveCarousel(element, options) {
          this.options = $.extend(true, {}, defaults, options);

          var privateMembers = {
              $element: $(element),
              $carousel: null,
              cardWidth: null,
              cards: {},
              windowResizeHandler: null,
          };

          priv.set(this, privateMembers);

          // Initialize the ResponsiveCarousel
          init.call(this);
      }

      //#region ___________________________ Private Methods ___________________________

      var init = function () {
          var $element = _(this).$element;
          // 1. Create carousel
          var $carousel = _(this).$carousel = createCarousel.call(this);
          $carousel.appendTo($element);

          // 2. Create owl carousel plugin (convert carousel to owl carousel)
          createOwlCarouselPlugin.call(this);

          // 3. If there are initial cards in options, append them
          if (this.options.cards && this.options.cards.length) {
              this.addCards(this.options.cards);
          }

          // 4. Cache window resize handler with context
          //$(window).resize(this.refreshVisibleItems.bind(this));
          _(this).windowResizeHandler = this.refreshVisibleItems.bind(this);
          window.addEventListener('resize', _(this).windowResizeHandler);

          // Refresh all tree cards on the first load
          //var me = this;
          //setTimeout(function () {
          //    me.refreshVisibleItems.call(me);
          //}, 600);

          // 5. Add resize monitor on carousel wrapper
          //var me = this;
          //new ResizeSensor($element, function () {
          //    //me.refreshVisibleItems();
          //});
          new ResizeSensor($element, $.throttle(500, this.refreshVisibleItems.bind(this)));
      };

      //#region ______________ Control Creation _____________

      var createCarousel = function () {
          var $carousel = $("<div>")
                              .addClass("responsive-carousel")
                              .addClass("owl-carousel")
                              .addClass("owl-theme");

          if (this.options.rtl) {
              $carousel.addClass("responsive-carousel-rtl");
          }

          return $carousel;
      };
      
      var isSelectedCardVisible = function () {
          return _(this).$carousel.find(".owl-item.active > ." + this.options.selectedCardClass).length > 0;
      };

      var prepareOwlCarouselOptions = function (itemsCount) {
          var leftArrow = "<span class='req_owl_p'><i class='fa fa-angle-left'> </i></span>";
          var rightArrow = "<span class='req_owl_n'><i class='fa fa-angle-right'> </i></span>";

          var rtl = this.options.rtl;
          var leftNav = !rtl ? leftArrow : rightArrow;
          var rightNav = !rtl ? rightArrow : leftArrow;

          var carouselOptions = {
              items: itemsCount,
              rtl: rtl,
              loop: false,
              nav: true,
              //itemClass: "custom-carousel-item",
              navText: [leftNav, rightNav],
              margin: 10,
              responsive: {
                  0: {
                      center: true,
                      items: 1,
                  },
                  576: {

                  },
              },
              mouseDrag: false, // Disable slide on mouse drag
              touchDrag: false, // Disable slide on touch drag
              dotsEach: true,
              dots: false,
              callbacks: true
          };

          //if (itemsCount) {
          //    carouselOptions.items = itemsCount;
          //}

          return carouselOptions;
      };

      var createOwlCarouselPlugin = function (itemsCount) {
          var $carousel = _(this).$carousel;

          // Ceate owlCarousel plugin
          var carouselOptions = prepareOwlCarouselOptions.call(this, itemsCount);
          $carousel.owlCarousel(carouselOptions);

          if (this.options.selectOnNavigate) {
              var me = this;
              $carousel
                  .on("click", ".owl-prev", function (e) {
                      // If selected card is not visible, change the selection to the last visible card item
                      if (!isSelectedCardVisible.call(me)) {
                          var $lastVisibleCard = $carousel.find(".owl-item.active:last > .responsive-carousel-card");
                          var cardId = $lastVisibleCard.data("data-responsive-carousel-id");
                          selectCard.call(me, e, cardId);
                      }
                  })
                  .on("click", ".owl-next", function (e) {
                      // If selected card is not visible, change the selection to the first visible card item
                      if (!isSelectedCardVisible.call(me)) {
                          var $firstVisibleCard = $carousel.find(".owl-item.active:first > .responsive-carousel-card");
                          var cardId = $firstVisibleCard.data("data-responsive-carousel-id");
                          selectCard.call(me, e, cardId);
                      }
                  });
          }

          //.on("changed.owl.carousel", function (e) {
          //    debugger;
          //    $carousel.trigger('prev.owl.carousel');
          //    if (e.page.index + 1 == e.page.count) {
          //        console.log('last');
          //    }
          //    if (e.item.index == 0) {
          //        console.log('start');
          //    }
          //});

          // Workaround: Add a "card-group" class after creating the carousel for ".owl-stage"
          $carousel.find(".owl-stage").addClass("card-group");

          // Fire onAfterCreate callback
          if (this.options.onAfterCreate && $.isFunction(this.options.onAfterCreate)) {
              this.options.onAfterCreate($carousel);
          }
      };

      var destroyOwlCarouselPlugin = function () {
          var $carousel = _(this).$carousel;
          $carousel.owlCarousel("destroy");

          //TODO_N: After destroy, the plugin keeps an empty div inside the carousel.

          //  Find, how to reset the plugin completely.
          $carousel.find(".owl-stage").remove();
      };

      //#endregion ___________ Control Creation _____________


      //#region _______________ Card Creation _______________

      var prepareCard = function (cardId, $card) {
          var me = this;

          // Cache the card
          _(this).cards[cardId] = $card;

          $card
              .addClass("responsive-carousel-card")
              .data("data-responsive-carousel-id", cardId)
              .click(function (e) { // Register card onClick event
                  // Select a card
                  if (!me.isCardSelected(cardId)) {
                      selectCard.call(me, e, cardId);
                  }
              });
      };

      var initlizeCardsSettings = function ($card) {
          // Add a workaround: Cache card width only for the first time
          if (!_(this).cardWidth) {
              _(this).cardWidth = $card.outerWidth();
          }
      };

      var addCardToCarousel = function ($card) {
          // 1. Destroy the OwlCarousel plugin to recreate it
          destroyOwlCarouselPlugin.call(this);

          // 2. Append the node/card to a level
          _(this).$carousel.append($card);

          // 3. Re-create the OwlCarousel plugin
          createOwlCarouselPlugin.call(this);
      };

      var removeCardFromCarousel = function (index) {
          _(this).$carousel
                  .trigger('remove.owl.carousel', [index])
                  .trigger('refresh.owl.carousel');

          //var owlCarousel = jQuery(".owl-carousel").data('owlCarousel');
          //owlCarousel.removeItem(index);
      };

      var selectCard = function (e, cardId) {
          var selectedCardClass = this.options.selectedCardClass;

          // Remove selected class from siblings cards
          var $selectedCard = _(this).$carousel.find("." + selectedCardClass);
          if ($selectedCard.length) {
              $selectedCard.removeClass(selectedCardClass);
          }

          // Add selected class to the current card
          var $card = _(this).cards[cardId];
          $card.addClass(selectedCardClass);

          if (this.options.onSelect && $.isFunction(this.options.onSelect)) {
              this.options.onSelect(e, cardId, $card);
          }
      };

      var onAfterRemoveCard = function (removedCardIndex) {
          var carouselItemToBeSelected;

          // Get all items in this carousel
          var $carouselItems = _(this).$carousel.find(".owl-item");

          // After removing an item, if there is a next item, select it, otherwise select the previous one
          if ($carouselItems[removedCardIndex]) {
              carouselItemToBeSelected = $carouselItems[removedCardIndex];
          }
          else if ($carouselItems[removedCardIndex - 1]) {
              carouselItemToBeSelected = $carouselItems[removedCardIndex - 1];
          }

          if (carouselItemToBeSelected) {
              var $card = $(carouselItemToBeSelected).children().first();
              //$card.addClass(this.options.selectedCardClass);

              // Get id of card to be selected
              var cardId = $card.data("data-responsive-carousel-id");
              // Select the card
              selectCard.call(this, {}, cardId);
          }
      };

      //#endregion ____________ Card Creation _______________


      //#region ______________ Responsive Cards _____________

      var calculateCardTotalWidth = function () {
          var $firstCarouselItem = _(this).$carousel.find(".owl-item:first");

          // Get the margins of first carousel item
          var margins = $firstCarouselItem.length ?
                          $firstCarouselItem[0].style.marginLeft + $firstCarouselItem[0].style.marginRight : 0;

          // The total width of a card, is the card width + container margins
          return _(this).cardWidth + parseFloat(margins);
      };

      var calculateCardsCount = function () {
          var carouselWidth = getCarouselWidth.call(this);

          var cardTotalWidth = calculateCardTotalWidth.call(this);

          return Math.floor(carouselWidth / cardTotalWidth);
      };

      var getCarouselWidth = function () {
          return _(this).$carousel.find(".owl-stage-outer").width();
      };

      /*
      var fitOwlStageOuterWidth = function (allowedCardsCount) {
          var $carousel = _(this).$carousel;
          var $activeItems = $carousel.find(".owl-item.active");

          if ($activeItems.length) {
              var $firstCarouselItem = $($activeItems[0]);
              // Get the margins of first carousel item
              var margins = $firstCarouselItem.length ?
                              $firstCarouselItem[0].style.marginLeft + $firstCarouselItem[0].style.marginRight : 0;

              var itemTotalWidth = $firstCarouselItem.width() + parseFloat(margins);
              var visibleItemsCount = allowedCardsCount;//$activeItems.length;

              var owlStageWidth = itemTotalWidth * visibleItemsCount;

              // Change the width of owl stage outer
              $carousel.find(".owl-stage-outer").width(owlStageWidth);
          }
      };
      */

      //#endregion ___________ Responsive Cards _____________

      //#endregion ________________________ Private Methods ___________________________

      //ResponsiveCarousel.prototype.render = function () {
      //    return _(this).$carousel;
      //};

      ResponsiveCarousel.prototype.isEmpty = function () {
          return _(this).$carousel.find(".owl-item").length === 0;
      };

      ResponsiveCarousel.prototype.addCard = function (cardId, card) {
          var cards = _(this).cards;

          if (!_(this).cards.hasOwnProperty(cardId)) {
              var $card = $(card);

              // 1. Prepare card
              prepareCard.call(this, cardId, $card);

              // 2. Add card to carousel
              addCardToCarousel.call(this, $card);

              // 3. Note: This code should be after render the card on dom, to get correct values
              initlizeCardsSettings.call(this, $card);

              // 4. Finally, after adding a new card, we must refresh the carousel visible items
              this.refreshVisibleItems();
          }
      };

      ResponsiveCarousel.prototype.addCards = function (cards) {
          var $carousel = _(this).$carousel;

          if (cards && cards.length) {
              var cachedCards = _(this).cards;

              // 1. Destroy the OwlCarousel plugin to recreate it
              destroyOwlCarouselPlugin.call(this);

              // 2. Append the nodes/cards to a level
              for (var i = 0; i < cards.length; i++) {
                  var card = cards[i];

                  if (!cachedCards.hasOwnProperty(card.id)) {
                      var $card = $(card.element);

                      prepareCard.call(this, card.id, $card);

                      _(this).$carousel.append($card);

                      $carousel.append($card);
                  }
              }

              // 3. Note: This code should be after render the card on dom, to get correct values
              initlizeCardsSettings.call(this, $(cards[0].element));

              // 4. Re-create the OwlCarousel plugin
              createOwlCarouselPlugin.call(this);

              // 5. Refresh the number visible cards
              this.refreshVisibleItems();
          }
      };

      ResponsiveCarousel.prototype.removeCard = function (cardId) {
          var cards = _(this).cards;
          if (cards.hasOwnProperty(cardId)) {
              var $card = cards[cardId];

              // Delete the card object
              delete cards[cardId];

              // Remove the card from carousel on ui
              var index = $card.closest(".owl-item").index();

              // Remove card from carousel
              removeCardFromCarousel.call(this, index);

              // Fire onRemove callback
              if (this.options.onRemove && $.isFunction(this.options.onRemove)) {
                  this.options.onRemove(cardId, $card, this);
              }

              if ($card.hasClass(this.options.selectedCardClass)) {
                  if (!this.isEmpty()) {
                      // After removing an element. If there is a next element exist, we must 
                      //  select the next element, otherwise we must select the previous one
                      onAfterRemoveCard.call(this, index);
                  }
              }

              // Refresh the number visible cards
              this.refreshVisibleItems();
          }
      };

      ResponsiveCarousel.prototype.isCardSelected = function (cardId) {
          var isSelected = false;

          var $card = _(this).cards[cardId];

          if ($card) {
              isSelected = $card.hasClass(this.options.selectedCardClass);
          }

          return isSelected;
      };

      ResponsiveCarousel.prototype.selectCard = function (cardId) {
          selectCard.call(this, {}, cardId);
      };

      ResponsiveCarousel.prototype.slideToCard = function (cardId) {
          var $card = _(this).cards[cardId];

          if ($card) {
              var $slideItem = $card.closest(".owl-item");
              if (!$slideItem.hasClass("active")) {
                  _(this).$carousel.trigger('to.owl.carousel', $slideItem.index());
              }
          }
      };

      ResponsiveCarousel.prototype.destroy = function () {
          destroyOwlCarouselPlugin.call(this);

          //destroyOwlCarouselPlugin.call(this);
          _(this).$carousel
              .removeClass("responsive-carousel")
              .removeClass("responsive-carousel-rtl")
              .removeClass("owl-carousel")
              .removeClass("owl-theme");

          //$(window).off("resize", this.refreshVisibleItems);
          window.removeEventListener('resize', _(this).windowResizeHandler);
      };

      ResponsiveCarousel.prototype.refresh = function () {
          createOwlCarouselPlugin.call(this);
          this.refreshVisibleItems();
      };

      ResponsiveCarousel.prototype.updateVisibleItems = function (itemsCount) {
          //// Nodes/Cards per level
          ////var itemsCount = this.getCardsCount();//getMaxCardsAllowedPerLevel.call(this, $level);

          //// 1. Destroy the OwlCarousel plugin to recreate it
          //destroyOwlCarouselPlugin.call(this);

          ////// 2. Delete level card
          ////$node.remove();

          //// After removing the node/card, if the level is not empty, 
          //createOwlCarouselPlugin.call(this, itemsCount);

          var $carousel = _(this).$carousel;

          // Add a workaround to change the items count shown on carousel at runtime
          if ($carousel.data('owl.carousel')) {
              $carousel.data('owl.carousel').options.items = itemsCount;
              $carousel.trigger('refresh.owl.carousel');
          }
      };

      ResponsiveCarousel.prototype.refreshVisibleItems = function () {
          if (!this.isEmpty()) {
              var maxCardsAllowedPerLevel = calculateCardsCount.call(this);

              // Limit the number of showing cards inside each level carousel
              if (maxCardsAllowedPerLevel) {
                  this.updateVisibleItems(maxCardsAllowedPerLevel);
                  //fitOwlStageOuterWidth.call(this, maxCardsAllowedPerLevel);
                  //createOwlCarouselPlugin.call(this, maxCardsAllowedPerLevel);
              }
          }
      };

      return ResponsiveCarousel;
  })();

  //#endregion ************************* Entry Class ****************************//


  //#region *************************** jQuery Plugin ***************************//

  var pluginName = "responsiveCarousel";

  $.fn[pluginName] = function (param) {
      // All methods that should return the element
      var thisMethods = ['addCard', 'removeCard', 'selectCard', 'slideToCard', 'destroy', 'refresh',
                          'updateVisibleItems', 'refreshVisibleItems'];

      if (param === undefined || typeof param === 'object') {
          return this.each(function () {
              // Destroy created ResponsiveCarousel
              if ($.data(this, pluginName)) {
                  var instance = $(this).data(pluginName);
                  instance.destroy();
              }
              // Create a new instance of ResponsiveCarousel
              $.data(this, pluginName, new Specto.ui.ResponsiveCarousel(this, param));
          });
      }
      else if (typeof param === 'string') {
          // Get  main function argument values
          var args = Array.prototype.slice.call(arguments, 1);

          var returnValue;

          this.each(function () {
              var instance = $(this).data(pluginName);

              //if (instance == null && window.console && console.error) {
              if (instance === null) {
                  console.error('The ' + pluginName + '(\'' + param + '\') method was called on an '
                                  + 'element that is not using ' + pluginName + '.');
              }

              // Return current control instance
              if (param === 'instance') {
                  returnValue = instance;
              }
              else {

                  // Remove the instance from element data
                  if (param === 'destroy') {
                      $.data(this, pluginName, null);
                  }

                  // Call the method
                  returnValue = instance[param].apply(instance, args);
              }
          });

          // Check if we should be returning `this`
          if ($.inArray(param, thisMethods) > -1) {
              return this;
          }

          return returnValue;
      }
      //else {
      //    throw new Error('Invalid arguments for ' + pluginName + ': ' + param);
      //}
  };

  //#endregion ************************ jQuery Plugin ***************************//
})();

(function () {
    this.Specto = this.Specto || {};
    this.Specto.ui = this.Specto.ui || {};

    this.Specto.ui.select2 = this.Specto.ui.select2 || {};
    this.Specto.ui.select2.classes = this.Specto.ui.select2.classes || {};

    var ns = this.Specto.ui.select2.classes;

    /****************************************************************************************************/
    /***************************************** Select2 Base Edit ****************************************/

    /*
        TODO_N:
          - Register events before set value.
    */
    ns.Select2BaseEdit = (function () {

        //#region ______ CONST ______

        const CLASS_NAME = {
            plugin: {
                selectList: "select2-edit-list"
            },
            select2: {
                searchFieldClassName: "select2-search__field"
            },
        };

        //#endregion ___ CONST ______

        var defaults = {
            sortItems: false,
            allowEmptyItem: false,
            theme: BootstrapKey.select2Theme,
            placeholder: "",
            dropdownAutoWidth: true,
            width: "100%",
            minimumResultsForSearch: 1,
            multiple: false,
            allowClear: false,
            isReadOnly: false,
            dir: "ltr",
            attr: {},
        };

        function Select2BaseEdit(options) {
            if (options) {
                // When use $.extend, if the second object contains null or 0, those two values override the default values from the first object, but the undefined does not. 
                // So, for this reason, we use our created $.customExtend instead of $.extend.
                this.options = $.customExtend(true, {}, defaults, options);

                init.call(this);
            }
        }

        //#region ___________________________ Private Methods ___________________________

        var init = function () {
            // Get the options select input or create a new one
            this.$select = this.options.selectInput ? $(this.options.selectInput) : createSelectInput.call(this);

            if (this.options.items) {
                if (this.options.sortItems) {
                    sortOptions.call(this, this.options.items);
                }

                if (!this.options.allowEmptyItem) {
                    this.options.items.unshift({ id: "", text: "" });
                }
            }
        };

        var sortOptions = function (items) {
            items.sort(function (a, b) {
                if (a.text < b.text) return -1;
                if (a.text > b.text) return 1;
                return 0;
            });
        };

        var createSelectInput = function () {
            return $("<select>")
                        .addBsClass("formControl")
                        .addClass(CLASS_NAME.plugin.selectList);
        };

        var generateSelect2Options = function () {
            var select2Options = {
                theme: this.options.theme, //theme: "classic"
                placeholder: this.options.placeholder,
                dropdownAutoWidth: this.options.dropdownAutoWidth,
                width: this.options.width,
                minimumResultsForSearch: this.options.minimumResultsForSearch,
                multiple: this.options.multiple,
                allowClear: this.options.allowClear,
                disabled: this.options.isReadOnly,
                dir: this.options.dir,
                tags: false, //Important Note: Prevent select2 from dynamically create new options from text input by the user in the search box. 
                //Important Note: On dropdown click a list with dropdown list items is appended to the bottom of the DOM, so if a dropdown is created inside a modal there is 
                //  some issues appeared, thus why we change the parnet of dropdown list items to be the container itself so when modal is destroyed the list items also destroyed.
                //dropdownParent: {1}.parents('.modal').length ? $('#{7}') : null
                //dropdownParent: $('#{7}')
            };

            if (this.options.items) {
                select2Options.data = this.options.items;
            }

            return select2Options;
        };

        var onSelectInputChange = function (selectedValue) {
            if (this.options.onChangeCallback) {
                if (this.options.onChangeCallback instanceof Function) {
                    this.options.onChangeCallback(selectedValue);
                }
                else {
                    window[this.options.onChangeCallback](selectedValue);
                }
            }
        };

        var createSelect2 = function () {
            this.container.append(this.$select);

            this.$select.select2(generateSelect2Options.call(this));
        };

        var registerEvents = function () {
            // Register select change event
            registerSelectChangeEvent.call(this);

            // Register search keypress event
            if (this.options.onSearchKeypressCallback) {
                registerSearchKeypressEvent.call(this);
            }
        };

        var reRender = function () {
            // 1. Empty the old control and unbind any event from it
            this.$select.detach();
            //this.$select.unbind("change");

            // 2. Set the value to default before re-create a new control based on the old type (multiple or not)
            //var emptyValue = this.select2Options.multiple ? [] : "";
            var emptyValue = this.options.multiple ? [] : "";
            this.$select.val(emptyValue);

            // 3. Re-create the control
            createSelect2.call(this);

            // 4. Register the events for the new select2
            //registerEvents.call(this);

            // 5. Call on after render method on child class
            this._onAfterRender();
        };

        //#region _____________________ Events _____________________

        //var onPageReady = function () {
        //    var me = this;
        //    $(document).ready(function () {
        //        setValue.call(me, me.options.value.toString());
        //    });
        //};

        var registerSelectChangeEvent = function () {
            var me = this;

            this.$select.change(function () {
                // Call child class change event
                me._onSelectChange();

                onSelectInputChange.call(me, $(this).val());

                // Check if state of document to avoid call valid() method for the first time on setValue,
                //   if we don't set this check and there is a value for the first time so this will cause to stop the whole form validation.
                if (document.readyState === 'complete') {
                    if ($(this).valid instanceof Function)
                        $(this).valid();
                }
            });
        };

        var registerSearchKeypressEvent = function () {
            var me = this;

            this.$select.on("select2:open", function (e) {
                //debugger;
                // Always only one select2 search input is opened at a time
                $("." + CLASS_NAME.select2.searchFieldClassName).bind("keypress", function (e) {
                    if (me.options.onSearchKeypressCallback instanceof Function) {
                        return me.options.onSearchKeypressCallback(e, $(this).val());
                    }
                    else {
                        return window[me.options.onSearchKeypressCallback](e, $(this).val());
                    }
                });
            });

            this.$select.on("select2:closing", function () {
                $("." + CLASS_NAME.select2.searchFieldClassName).unbind("keypress");
            });
        };

        //#endregion __________________ Events _____________________

        //#endregion ________________________ Private Methods ___________________________


        //#region ___________________________ Abstract Methods __________________________

        //Protected Method
        Select2BaseEdit.prototype._hasValue = function () {
            throw "You must override the abstract method \'_hasValue\' in " + this.constructor.name + " child class";
        };

        //#endregion ________________________ Abstract Methods __________________________


        //#region ___________________________ Virtual Methods ___________________________

        //Protected Method
        Select2BaseEdit.prototype._onSelectChange = function () {
            // We need this method on some child classes
        };

        //Protected Method
        Select2BaseEdit.prototype._onAfterRender = function () {
            // We need this method on some child classes
        };

        //#endregion ________________________ Virtual Methods ___________________________


        //#region ____________________ Base Methods (Shared Methods) ____________________

        //Protected Method
        Select2BaseEdit.prototype._getSelectInput = function () {
            return this.$select;
        };

        //Public Method
        Select2BaseEdit.prototype.setValue = function (value) {
            // IMPORTANT NOTE: There is a bug when trying to set value using select2:
            //  If the id digit number is more than 1 digit, select2 always considers only the first digit as value and ignore the rest digits.
            //this.$select.select2('val', value);

            this.$select.val(value);//.trigger('change');
            this.change();
        };

        //Public Method
        Select2BaseEdit.prototype.getValue = function () {
            return this.$select.val();
        };

        //Public Method
        Select2BaseEdit.prototype.change = function () {
            // Trigger change event
            this.$select.trigger('change');
        };

        //#endregion _________________ Base Methods (Shared Methods) ____________________

        Select2BaseEdit.prototype.renderOn = function (container) {
            //TODO_N: Refactor the code, create a container inside the priv members instead of cache it here.
            this.container = container;

            if (this.options.attr.hasOwnProperty("class")) {
                this.$select.addClass(this.options.attr.class);
            }

            //container.append(this.$select);

            // Create select2 options
            //this.$select.select2(generateSelect2Options.call(this));

            createSelect2.call(this);

            //$select.bind('onSuccess', function () {
            //    $(this).removeClass('control-validation-error');
            //});

            //$select.bind('onError', function () {
            //    $(this).addClass('control-validation-error');
            //});

            /******************************************************************************/
            //TODO_N: Study this case (set value before or after register event).
            // For example: On PagingEdit this should be before regiter events and on question builder displayOptions this should be after.       
            // Set value
            if (this._hasValue()) {
                this.setValue(this.options.value.toString());
            }
            /******************************************************************************/

            // Register events
            registerEvents.call(this);

            // Call on after render method on child class
            this._onAfterRender();
        };

        Select2BaseEdit.prototype.resetData = function (data) {
            this.$select.select2('destroy').empty().select2({ data: data });
            reRender.call(this);
        };

        Select2BaseEdit.prototype.disabled = function (isDisabled) {
            this.$select.prop('disabled', isDisabled);
        };

        return Select2BaseEdit;
    })();
})();
//// ********************* select 2 single ******************************
(function () {
    this.Specto = this.Specto || {};
    this.Specto.ui = this.Specto.ui || {};

    this.Specto.ui.select2 = this.Specto.ui.select2 || {};
    this.Specto.ui.select2.classes = this.Specto.ui.select2.classes || {};

    var ns = this.Specto.ui.select2.classes;

    /****************************************************************************************************/
    /**************************************** Single Select2 Edit ***************************************/

    /*
        options: { 
            selectInput:.., [optional]
            class:..,
            items: [{ id:.., text:.., disabled: true/false }], 
            value:.., 
            sortItems: true/false(default),
            allowEmptyItem: true/false(default), 
            theme: "classic/bootstrap/...",
            placeholder:.., 
            dropdownAutoWidth: true(default)/false,
            width: "100%"(default),
            minimumResultsForSearch: 1(default),
            allowClear: true/false(default), 
            isReadOnly: true/false(default), 
            dir: "ltr"(default)/"rtl", 
            attr: {},
            onChangeCallback:..,
            onSearchKeypressCallback:..,
        }

        IMPORTANT NOTE: (The following js files are required and must be imported before this class)
          jqueryExtensions.js
    */
    ns.SingleSelect2Edit = (function (parent) {
        SingleSelect2Edit.prototype = new ns.Select2BaseEdit();
        SingleSelect2Edit.prototype.constructor = SingleSelect2Edit;

        function SingleSelect2Edit(options) {
            // When use $.extend, if the second object contains null or 0, those two values override the default values from the first object, but the undefined does not. 
            // So, for this reason, we use our created $.customExtend instead of $.extend.
            parent.call(this, $.customExtend(true, {}, options, {
                multiple: false
            }));
        }

        //#region __________________________ Override Methods ___________________________

        SingleSelect2Edit.prototype._hasValue = function () {
            return !!this.options.value;
        };

        //#endregion _______________________ Override Methods ___________________________

        return SingleSelect2Edit;
    })(ns.Select2BaseEdit);
})();
/// ***************************************************
// ****************************** select 2 multiple ***********************************//

(function () {
    this.Specto = this.Specto || {};
    this.Specto.ui = this.Specto.ui || {};

    this.Specto.ui.select2 = this.Specto.ui.select2 || {};
    this.Specto.ui.select2.classes = this.Specto.ui.select2.classes || {};

    var ns = this.Specto.ui.select2.classes;

    /****************************************************************************************************/
    /*************************************** Multiple Select2 Edit **************************************/

    /*
        options: { 
            selectInput:.., [optional]
            class:..,
            items: [{ id:.., text:.., disabled: true/false }], 
            value:.., 
            sortItems: true/false(default),
            allowEmptyItem: true/false(default), 
            theme: "classic/bootstrap/...",
            placeholder:.., 
            dropdownAutoWidth: true(default)/false,
            width: "100%"(default),
            minimumResultsForSearch: 1(default),
            allowClear: true/false(default), 
            isReadOnly: true/false(default), 
            dir: "ltr"(default)/"rtl", 
            attr: {},
            onChangeCallback:..,
            onSearchKeypressCallback:..,
        }

        IMPORTANT NOTE: (The following js files are required and must be imported before this class)
          jqueryExtensions.js
    */
    ns.MultipleSelect2Edit = (function (parent) {
        MultipleSelect2Edit.prototype = new ns.Select2BaseEdit();
        MultipleSelect2Edit.prototype.constructor = MultipleSelect2Edit;

        function MultipleSelect2Edit(options) {
            // When use $.extend, if the second object contains null or 0, those two values override the default values from the first object, but the undefined does not. 
            // So, for this reason, we use our created $.customExtend instead of $.extend.
            parent.call(this, $.customExtend(true, {}, options, {
                allowClear: false,
                multiple: true
            }));
        }

        //#region ___________________________ Private Methods ___________________________

        var fixMultipleSelect2 = function () {
            // Fix bug in select2 when multiple option is true and it has a placeholder.
            // Bug Description: For the first time of selecting an item, there are two tags drawn - the text of selected value in addition to the text of placeholder - 
            // because select2 considers the placeholder as a previous selected value. 
            // Workaround Fix: The placeholder option value is removed then the changed event explicitly triggered to set select2 value with the user selected one.
            var $select = this._getSelectInput();

            var values = $select.val();
            if (values && values.length > 0) {
                if (!values[0]) {
                    values.shift();
                    $select.val(values).trigger('change');
                }
            }
        };

        //#endregion ________________________ Private Methods ___________________________


        //#region __________________________ Override Methods ___________________________

        MultipleSelect2Edit.prototype._hasValue = function () {
            return this.options.value && this.options.value.length > 0;
        };

        //This is a virtual method
        MultipleSelect2Edit.prototype._onSelectChange = function () {
            fixMultipleSelect2.call(this);
        };

        //This is a virtual method
        MultipleSelect2Edit.prototype._onAfterRender = function () {
            fixMultipleSelect2.call(this);
        };

        //#endregion _______________________ Override Methods ___________________________

        return MultipleSelect2Edit;
    })(ns.Select2BaseEdit);
})();

//******************************************************************************************
//************************************************** Select 2 Edit *************************
(function () {
    this.Specto = this.Specto || {};
    this.Specto.ui = this.Specto.ui || {};

    var ns = this.Specto.ui;

    /****************************************************************************************************/
    /******************************************* Select2 Edit *******************************************/

    /*
        options: { 
            selectInput:.., [optional]
            class:..,
            items: [{ id:.., text:.., disabled: true/false }], 
            value:.., 
            sortItems: true/false(default),
            allowEmptyItem: true/false(default), 
            theme: "classic/bootstrap/...",
            multiple: true/false,
            placeholder:.., 
            dropdownAutoWidth: true(default)/false,
            width: "100%"(default),
            minimumResultsForSearch: 1(default),
            allowClear: true/false(default), 
            isReadOnly: true/false(default), 
            dir: "ltr"(default)/"rtl", 
            attr: {},
            onChangeCallback:..,
            onSearchKeypressCallback:..,
        }

        IMPORTANT NOTE: (The following js files are required and must be imported before this class)
          jqueryExtensions.js
    */
    ns.Select2Edit = (function () {
        function Select2Edit(options) {
            var select2Class;

            if (options.multiple) {
                select2Class = ns.select2.classes.MultipleSelect2Edit;
            }
            else {
                select2Class = ns.select2.classes.SingleSelect2Edit;
            }

            return new select2Class(options);
        }

        return Select2Edit;
    })();

    ns.Select2Renderer = (function () {
        function Select2Renderer(options) {
            var extendedOptions = $.customExtend(true, {}, options);

            var $selectInp = $('<select>').addBsClass("formControl");

            for (var i = 0; i < extendedOptions.items.length; i++) {
                var item = extendedOptions.items[i];

                var $option = $('<option>').val(item.id).append(item.text);
                $selectInp.append($option);
            }

            extendedOptions.selectInput = $selectInp[0].outerHTML;
            return new Specto.ui.Select2Edit(extendedOptions);
        }

        return Select2Renderer;
    })();

    $.fn.select2Edit = function (options) {
        $(this).each(function () {
            if (!$.data(this, "select2Edit")) {
                var extendedOptions = $.customExtend(true, {}, options);
                extendedOptions.selectInput = $(this);

                var select2Edit = new Specto.ui.Select2Edit(extendedOptions);
                //TODO_N: Implenet select2Edit to only convert a select to owr custom select2, 
                //  without the needed to call renderOn function. 
                // We use $(this).parent() as a workaround until the renderOn function is refactored.
                select2Edit.renderOn($(this).parent());

                $.data(this, "select2Edit", select2Edit);
            }
        });

        return this;
    };
})();

/*
    ns.Select2Renderer = (function () {
        function Select2Renderer(options) {
            var extendedOptions = $.customExtend(true, {}, options);

            return new Specto.ui.(extendedOptions);
        }

        return Select2Renderer;
    })();
*/

(function () {
    this.Specto = this.Specto || {};
    this.Specto.ui = this.Specto.ui || {};

    var ns = this.Specto.ui;

    /****************************************************************************************************/
    /***************************************** Paging Base Edit *****************************************/

    /*
        options: { 
            clientSideFiltering: true/false(default),
            url:.., If clientSideFiltering = false.
            data: [{ Key(columnName): value }], If clientSideFiltering = true
            firstSearchResult: { rowsCount:.., data:.. }, For server side filtering If clientSideFiltering = false. TODO_N
            pageSize: 5(default), 
            pageIndex: 1(default),
            pagesPerPartition: 10(default), 
            orderBy:.., 
            ascending: true/false(default),
            filters: [{ columnName:.., value:.., type:.. }], 
            searchColumns: [{ columnName:.., columnValue:.. }], 
            onPageChangeCallback:.., 
            dir: "ltr"(default)/"rtl", 
        }

        - filters 'type' represents a FilterType enum and it's value should be one of f the following values:
            Equals = 1,
            Contains = 2,
            StartsWith = 3,
            EndsWidth = 4,
            GreaterThan = 5,
            LessThan = 6,
            GreaterThanOrEquals = 7,
            LessThanOrEquals = 8,

        OnPageChange this class will call the server method (options.url) to applyFilter, so the function "applyFilter" passes to the server the following data:
           The "paging" object that should consist of: 
              pageSize: selectedDropdownValue, pageIndex: clickedpageIndex, orderBy:.., ascending:..,  filters: (if there is extra filters passed by options or updated by the function ""), searchColumns:.., 
    
        IMPORTANT NOTE: (The following js files are required and must be imported before this class)
          jqueryExtensions.js
    */
    ns.PagingBaseEdit = (function () {
        var defaults = {
            clientSideFiltering: false,
            pageSize: 5,
            pageIndex: 1,
            pagesPerPartition: 10,
            ascending: false,
            firstSearchResult: { rowsCount: 0, data: [] },
            dir: "ltr",
        };

        function PagingBaseEdit(options) {
            if (options) {
                // When use $.extend, if the second object contains null or 0, those two values override the default values from the first object, but the undefined does not. 
                // So, for this reason, we use our created $.customExtend instead of $.extend.
                this.options = $.customExtend(true, {}, defaults, options);

                this.filtering = createFiltering.call(this);

                initPagingInfo.call(this);

                //TODO_N: Refactor this code, get the first result inside the filtering class either for server side or client side
                if (this.options.clientSideFiltering) {
                    this.applyFilter(true, true, true);
                }
                else {
                    renderData.call(this, this.options.firstSearchResult, true, true);
                }
            }
        }

        var createFiltering = function () {
            var filtering;

            if (this.options.clientSideFiltering) {
                filtering = new ClientSideFiltering({ data: this.options.firstSearchResult.data });
            }
            else {
                filtering = new ServerSideFiltering({ url: this.options.url });
            }

            return filtering;
        }

        var initPagingInfo = function () {
            this.paging = {};

            this.paging.pageSize = this.options.pageSize;
            this.paging.pageIndex = this.options.pageIndex;
            this.paging.orderBy = this.options.orderBy;
            this.paging.ascending = this.options.ascending;
            this.paging.filters = this.options.filters;
            this.paging.searchColumns = this.options.searchColumns;

            this.rowsCount = 0;
            this.numberOfPages = 0;
            this.numberOfItemsPerPage = this.paging.pageSize;
        };

        var getPagingData = function () {
            return {
                pageSize: this.paging.pageSize,
                pageIndex: this.paging.pageIndex,
                orderBy: this.paging.orderBy,
                ascending: this.paging.ascending,
                filters: this.paging.filters,
                searchColumns: this.paging.searchColumns,
                param: this.options.param,
            };
        };

        var renderData = function (result, refreshTotalRows, reCreateRowsPerPageList) {
            if (typeof (result) === "string") {
                result = JSON.parse(result);
            }

            this.rowsCount = result.rowsCount;

            if (refreshTotalRows) {
                this.numberOfPages = Math.ceil(this.rowsCount / this.paging.pageSize);
                this.createPagingControl();
            }

            if (reCreateRowsPerPageList) {
                this.createRowsPerPageListControl();
            }

            if (this.options.onPageChangeCallback && this.options.onPageChangeCallback instanceof Function) {
                this.options.onPageChangeCallback(result.data);
            }
        };

        //#region ___________________________ Server Call ___________________________

        PagingBaseEdit.prototype.applyFilter = function (refreshTotalRows, reCreateRowsPerPageList, hideSpinner) {
            var me = this;

            this.filtering.filter(getPagingData.call(this), function (result) {
                renderData.call(me, result, refreshTotalRows, reCreateRowsPerPageList);
            });

            //$.ajax({
            //    type: "POST",
            //    url: this.options.url,
            //    async: true,
            //    data: getPagingData.call(me),
            //    beforeSend: function () {
            //        if (!hideSpinner) {
            //            me.showSpinner();
            //        }
            //    },
            //    complete: function () {
            //        if (!hideSpinner) {
            //            me.hideSpinner();
            //        }
            //    },
            //    success: function (result) {
            //        renderData.call(me, result, refreshTotalRows, reCreateRowsPerPageList);
            //    },
            //    error: function (data) {
            //    }
            //});
        };

        //#endregion ___________________________ Server Call ___________________________


        //#region ___________________________ Override Methods ___________________________

        PagingBaseEdit.prototype.createRowsPerPageListControl = function () {
            throw "You must override the abstract method \'createRowsPerPageListControl\' in " + this.constructor.name + " child class";
        };

        PagingBaseEdit.prototype.createPagingControl = function () {
            throw "You must override the abstract method \'createPagingControl\' in " + this.constructor.name + " child class";
        };

        PagingBaseEdit.prototype.showSpinner = function () {
            throw "You must override the abstract method \'showSpinner\' in " + this.constructor.name + " child class";
        };

        PagingBaseEdit.prototype.hideSpinner = function () {
            throw "You must override the abstract method \'hideSpinner\' in " + this.constructor.name + " child class";
        };

        //#endregion ___________________________ Override Methods ___________________________


        PagingBaseEdit.prototype.resetFilter = function (filters) {
            this.paging.pageIndex = 1;
            this.paging.pageSize = 5;
            this.paging.filters = filters;

            this.applyFilter(true, true, true);
        };

        PagingBaseEdit.prototype.resetSearchColumns = function (searchColumns) {
            this.paging.pageIndex = 1;
            this.paging.pageSize = 5;
            this.paging.searchColumns = searchColumns;

            this.applyFilter(true, true, true);
        };

        PagingBaseEdit.prototype.resetDefualtSearch = function () {
            initPagingInfo.call(this);
            this.applyFilter(true, true, true);
        };

        PagingBaseEdit.prototype.clear = function () {
            initPagingInfo.call(this);
            renderData.call(this, defaults.firstSearchResult, true, true);
        };

        PagingBaseEdit.prototype.resetParam = function (param) {
            this.options.param = param;
        };

        return PagingBaseEdit;
    })();

    //*****************************************************************************//
    //********************************* Filtering *********************************//

    var FilteringBase = function () {
        function FilteringBase() {

        }

        FilteringBase.prototype.filter = function (paging, onFilter) {
            throw "You must override the abstract method \'filter\' in " + this.constructor.name + " child class";
        };

        return FilteringBase;
    }();


    //***********************************************//
    //************ Server Side Filtering ************//

    /*
        options: {
            url: "",
        };
    */
    var ServerSideFiltering = function () {
        ServerSideFiltering.prototype = new FilteringBase();
        ServerSideFiltering.prototype.constructor = ServerSideFiltering;

        function ServerSideFiltering(options) {
            if (options) {
                this.options = $.customExtend(true, {}, options);
            }
        }

        /*
            paging: {
                pageIndex: ..,
                pageSize: .., 
                filters: [{ columnName:.., value:.., type:.. }], 
                searchColumns: [{ columnName:.., columnValue:.. }], 
                orderBy:.., 
                ascending: true/false(default),
            }
        */
        ServerSideFiltering.prototype.filter = function (paging, onFilter) {
            var me = this;

            $.ajax({
                type: "POST",
                url: this.options.url,
                async: true,
                data: paging,
                beforeSend: function () {
                    //if (!hideSpinner) {
                    //me.showSpinner(); // $('body').jLoadingOverlay('');
                    //}
                },
                complete: function () {
                    //if (!hideSpinner) {
                    //me.hideSpinner(); // $('body').jLoadingOverlay('close');
                    //}
                },
                success: function (result) {
                    // Trigger onFilter callback function
                    onFilter(result);
                },
                error: function (data) {
                }
            });
        };

        return ServerSideFiltering;
    }();

    //***********************************************//
    //************ Client Side Filtering ************//

    /*
    options: {
        data: [{ Key(columnName): value }],
    };
*/
    var ClientSideFiltering = function () {
        ClientSideFiltering.prototype = new FilteringBase();
        ClientSideFiltering.prototype.constructor = ClientSideFiltering;

        function ClientSideFiltering(options) {
            if (options) {
                this.options = $.customExtend(true, {}, options);
            }
        }

        /*
            paging: {
                pageIndex: ..,
                pageSize: .., 
                filters: [{ columnName:.., value:.., type:.. }], 
                searchColumns: [{ columnName:.., columnValue:.. }], 
                orderBy:.., 
                ascending: true/false(default),
            }
        */
        ClientSideFiltering.prototype.filter = function (paging, onFilter) {
            var searchData = $.extend(true, [], this.options.data);

            // Filters
            //if (paging.filters && paging.filters.length) {
            //    for (var i = 0; i < paging.filters.length; i++) {

            //    }
            //}

            // Search columns
            //if (paging.searchColumns && paging.searchColumns.length) {
            //    for (i = 0; i < paging.searchColumns.length; i++) {

            //    }
            //}

            // Get rows count before slice
            var rowsCount = searchData.length;

            // OrderBy
            //if (paging.orderBy) {

            //}

            // Get data per page
            var startIndex = (paging.pageIndex - 1) * paging.pageSize;
            var endIndex = startIndex + paging.pageSize;
            searchData = searchData.slice(startIndex, endIndex);

            // Prepare result object
            var result = {
                rowsCount: rowsCount,
                data: searchData
            };

            // Trigger onFilter callback function
            onFilter(result);
        };

        return ClientSideFiltering;
    }();

})();

// ********************************************************************
//************************ Paging Edit **************************************************************
(function () {
    this.Specto = this.Specto || {};
    this.Specto.ui = this.Specto.ui || {};

    var ns = this.Specto.ui;

    /***************************************************************************************************/
    /******************************************* Paging Edit *******************************************/

    /*
        options: { 
            clientSideFiltering: true/false(default),
            url:.., If clientSideFiltering = false.
            data: [{ Key(columnName): value }], If clientSideFiltering = true.
            pageSize: 5(default), 
            pageIndex: 1(default),
            pagesPerPartition: 8(default), 
            orderBy:.., 
            ascending: true/false(default),
            filters: [{ columnName:.., value:.., type:.. }], 
            searchColumns: [{ columnName:.., columnValue:.. }], 
            firstSearchResult: { rowsCount:.., data:.. }, 
            onPageChangeCallback:.., 
            param: [], 
            dir: "ltr"/"rtl", 
            localizer: { 
                FIRST: "First", 
                PREV: "Prev", 
                NEXT: "Next", 
                LAST: "Last",
                NUMBER_OF_ITEMS_PER_PAGE: "Number of items per page"
            },
        }

        - filters 'type' represents a FilterType enum and it's value should be one of f the following values:
            Equals = 1,
            Contains = 2,
            StartsWith = 3,
            EndsWidth = 4,
            GreaterThan = 5,
            LessThan = 6,
            GreaterThanOrEquals = 7,
            LessThanOrEquals = 8,

        OnPageChange this class will call the server method (options.url) to applyFilter, so the function "applyFilter" passes to the server the following data:
           The "paging" object that should consist of: 
              pageSize: selectedDropdownValue, pageIndex: clickedpageIndex, orderBy:.., ascending:..,  filters: (if there is extra filters passed by options or updated by the function ""), searchColumns:..,      
        
        IMPORTANT NOTE: (The following js files are required and must be imported before this class)
          jqueryExtensions.js
          UploadBaseEdit.js
    */
    ns.PagingEdit = (function (parent) {
        PagingEdit.prototype = new ns.PagingBaseEdit();
        PagingEdit.prototype.constructor = PagingEdit;

        //#region ______ CONST ______

        const CLASS_NAME = {
            plugin: {
                pagingEdit: "paging-edit",
                rowsPerPageListContainer: "paging-edit-rows-per-page-list-container",
                pager: "paging-edit-pager",
                pageNumberButton: "paging-page-number-btn",
                inputGroup: "paging-edit-input-group",
                rowsPerPageAddon: "paging-edit-rows-per-page-addon",
                activeButton: "active-button",
                //select2
                select2: "select2",
            }
        };

        //#endregion ___ CONST ______

        var defaults = {
            pagesPerPartition: 8
        };

        function PagingEdit(options) {
            // Initialize the PagingEdit
            init.call(this);

            // When use $.extend, if the second object contains null or 0, those two values override the default values from the first object, but the undefined does not. 
            // So, for this reason, we use our created $.customExtend instead of $.extend.
            parent.call(this, $.customExtend(true, {}, defaults, options));
        }
        //#region ___________________________ Private Methods ___________________________

        var init = function () {
            this.rowsPerPageListContainer = $("<div>")
                .addClass(CLASS_NAME.plugin.rowsPerPageListContainer);

            // Use bootstrap pagination
            //this.buttonGroup = $("<ui>")
            //                        .addClass(CLASS_NAME.plugin.pager)
            //                        .addClass("pagination");

            this.buttonGroup = $("<div>")
                                    .addClass(CLASS_NAME.plugin.pager)
                                    .addBsClass("buttonGroup");
        };

        //#endregion ________________________ Private Methods ___________________________

        //#region ___________________________ On Page Change ___________________________

        var disableLeftSideAndRightSideButtons = function () {
            this.firstPageBtn.attr("disabled", true);
            this.previousPageBtn.attr("disabled", true);
            this.nextPageBtn.attr("disabled", true);
            this.lastPageBtn.attr("disabled", true);
        };

        var changeLeftSideAndRightSideButtonsStatus = function (pageIndex) {
            this.firstPageBtn.removeAttr("disabled");
            this.previousPageBtn.removeAttr("disabled");
            this.nextPageBtn.removeAttr("disabled");
            this.lastPageBtn.removeAttr("disabled");

            if (pageIndex === 1) {
                this.firstPageBtn.attr("disabled", true);
                this.previousPageBtn.attr("disabled", true);
            }

            if (pageIndex === this.numberOfPages) {
                this.nextPageBtn.attr("disabled", true);
                this.lastPageBtn.attr("disabled", true);
            }
        };

        var onPageChange = function (pageIndex) {
            changeLeftSideAndRightSideButtonsStatus.call(this, pageIndex);

            this.paging.pageIndex = pageIndex;
            this.applyFilter(false, false, true);
        };

        var activeUiPageNumberButton = function (pageButton) {
            this.buttonGroup.find("." + CLASS_NAME.plugin.pageNumberButton)
                                        .removeBsClass("buttonPrimary")
                                        .addBsClass("buttonDefault")
                                        .removeClass(CLASS_NAME.plugin.activeButton);

            $(pageButton)
                .removeBsClass("buttonDefault")
                .addBsClass("buttonPrimary")
                .addClass(CLASS_NAME.plugin.activeButton);
        };

        var firePageNumberButtonClickEvent = function (pageIndex) {
            if (pageIndex > 0 && pageIndex <= this.numberOfPages) {
                this.buttonGroup.find("." + CLASS_NAME.plugin.pageNumberButton + "[pageIndex='" + pageIndex + "']").click();
            }
        };

        //#endregion ___________________________ On Page Change ___________________________


        //#region ___________________________ Pages Partition ___________________________

        var initializePartition = function () {
            this.firstPartitionPage = 1;
            this.lastPartitionPage = this.options.pagesPerPartition;

            if (this.numberOfPages > this.lastPartitionPage) {
                this.nextPartitionBtn.css("display", "inline-block");
            }
        };

        var displayPartitionPages = function () {
            var me = this;

            this.buttonGroup.find("." + CLASS_NAME.plugin.pageNumberButton)
                            .css("display", "none");

            this.buttonGroup.find("." + CLASS_NAME.plugin.pageNumberButton)
                            .filter(function () {
                                var currentPageIndex = parseInt($(this).attr("pageIndex"));
                                return currentPageIndex >= me.firstPartitionPage && currentPageIndex <= me.lastPartitionPage;
                            })
                            .css("display", "inline-block");

            if (this.firstPartitionPage === 1) {
                this.previousPartitionBtn.css("display", "none");
            }
            else {
                this.previousPartitionBtn.css("display", "inline-block");
            }

            if (this.numberOfPages <= this.lastPartitionPage) {
                this.nextPartitionBtn.css("display", "none");
            }
            else {
                this.nextPartitionBtn.css("display", "inline-block");
            }
        };

        var onPreviousPartitionClick = function () {
            this.firstPartitionPage = this.firstPartitionPage - this.options.pagesPerPartition;
            this.lastPartitionPage = this.lastPartitionPage - this.options.pagesPerPartition;

            displayPartitionPages.call(this);

            firePageNumberButtonClickEvent.call(this, this.lastPartitionPage);
        };

        var onNextPartitionClick = function () {
            this.firstPartitionPage = this.firstPartitionPage + this.options.pagesPerPartition;
            this.lastPartitionPage = this.lastPartitionPage + this.options.pagesPerPartition;

            displayPartitionPages.call(this);

            firePageNumberButtonClickEvent.call(this, this.firstPartitionPage);
        };

        //#endregion ___________________________ Pages Partition ___________________________


        //#region ___________________________ Page Navigation ___________________________

        var onFirstPageClick = function () {
            initializePartition.call(this);
            displayPartitionPages.call(this);

            firePageNumberButtonClickEvent.call(this, 1);
        };

        var onPreviousPageClick = function () {
            var previousPageIndex = this.paging.pageIndex - 1;

            if (previousPageIndex < this.firstPartitionPage) {
                onPreviousPartitionClick.call(this);
            }
            else {
                firePageNumberButtonClickEvent.call(this, previousPageIndex);
            }
        };

        var onNextPageClick = function (pageNumber) {
            var nextPageIndex = this.paging.pageIndex + 1;

            if (nextPageIndex > this.lastPartitionPage) {
                onNextPartitionClick.call(this);
            }
            else {
                firePageNumberButtonClickEvent.call(this, nextPageIndex);
            }
        };

        var onLastPageClick = function () {
            var numberOfPartitions = Math.ceil(this.numberOfPages / this.options.pagesPerPartition);
            var lastPageInPreviousPartition = (numberOfPartitions - 1) * this.options.pagesPerPartition;
            this.firstPartitionPage = lastPageInPreviousPartition + 1;
            this.lastPartitionPage = this.firstPartitionPage + this.options.pagesPerPartition - 1;

            displayPartitionPages.call(this);

            firePageNumberButtonClickEvent.call(this, this.numberOfPages);
        };

        //#endregion ___________________________ Page Navigation ___________________________


        //#region ___________________________ Control Creation ___________________________

        var createButton = function (content, onClickCallback) {
            // Use bootstrap pagination
            //var link = $("<a>")
            //                .addClass("page-link")
            //                .html(content);


            //return $("<li>")
            //            .addClass("page-item")
            //            .append(link).click(onClickCallback);

            return $("<button type='button'>")
                                    .addBsClass("button")
                                    .addBsClass("buttonDefault")
                                    .html(content)
                                    .click(onClickCallback);
        };

        var createLeftSideButtons = function () {
            var me = this;

            this.firstPageBtn = createButton(this.options.localizer["FIRST"], function () {
                onFirstPageClick.call(me);
            });

            this.previousPageBtn = createButton(this.options.localizer["PREV"], function () {
                onPreviousPageClick.call(me);
            });

            this.previousPartitionBtn = createButton("...", function () {
                onPreviousPartitionClick.call(me);
            }).css("display", "none");

            this.buttonGroup.append(this.firstPageBtn).append(this.previousPageBtn).append(this.previousPartitionBtn);
        };

        var createRigthSideButtons = function () {
            var me = this;

            this.nextPartitionBtn = createButton("...", function () {
                onNextPartitionClick.call(me);
            }).css("display", "none");

            this.nextPageBtn = createButton(this.options.localizer["NEXT"], function () {
                onNextPageClick.call(me);
            });


            this.lastPageBtn = createButton(this.options.localizer["LAST"], function () {
                onLastPageClick.call(me);
            });

            this.buttonGroup.append(this.nextPartitionBtn).append(this.nextPageBtn).append(this.lastPageBtn);
        };

        var createNumberingButtons = function () {
            var me = this;

            for (var pageIndex = 1; pageIndex <= this.numberOfPages; pageIndex++) {
                var pageBtn = createButton(pageIndex, function () {
                    var currentPagingButton = $(this);

                    // if the current button is not already active
                    if (!currentPagingButton.hasClass(CLASS_NAME.plugin.activeButton)) {
                        // a. Change the style of the button to show as active
                        activeUiPageNumberButton.call(me, this);

                        // b. Get server data based on the clicked page
                        var clickedPageIndex = parseInt(currentPagingButton.attr("pageIndex"));
                        onPageChange.call(me, clickedPageIndex);
                    }
                }).addClass(CLASS_NAME.plugin.pageNumberButton)
                              .attr("pageIndex", pageIndex);


                // Hide all paging buttons that is not in the first partition
                if (pageIndex > this.options.pagesPerPartition) {
                    pageBtn.css("display", "none");
                }

                this.buttonGroup.append(pageBtn);
            }
        };

        //#endregion ___________________________ Control Creation ___________________________


        //#region ___________________________ Overridden Methods - Control Creation ___________________________

        PagingEdit.prototype.createRowsPerPageListControl = function () {
            this.rowsPerPageListContainer.empty();

            var loopCount = 0;

            // 1. Calculate the number of loops
            if (this.rowsCount !== 0) {
                var maximumRowsPerPage = 50;
                loopCount = maximumRowsPerPage / this.numberOfItemsPerPage;

                if (this.rowsCount < maximumRowsPerPage) {
                    loopCount = Math.ceil(this.rowsCount / this.numberOfItemsPerPage);
                }
            }

            // 2. Create a list and fill it with numbers multiplicated by the pageSize value that is passed as parameter on the first time or get the default value
            var listItems = [];
            for (var i = 1; i <= loopCount; i++) {
                var rowsPerPage = i * this.numberOfItemsPerPage;
                listItems.push({ id: rowsPerPage, text: rowsPerPage });
            }

            // 3. Create select2
            var me = this;
            var select2Edit = new ns.Select2Edit({
                items: listItems,
                value: this.numberOfItemsPerPage, // (1 * this.numberOfItemsPerPage)
                width: "62px",
                dir: this.options.dir || "ltr",
                onChangeCallback: function (selectedValue) {
                    if (me.numberOfPages > 0) {
                        me.paging.pageSize = parseInt(selectedValue);
                        me.paging.pageIndex = 1;

                        me.applyFilter(true, false, false);
                    }
                }
            });

            select2Edit.renderOn(this.rowsPerPageListContainer);

            // 4. Apply select2 custom attributes
            var rowsPerPageSelect2 = this.rowsPerPageListContainer.find("." + CLASS_NAME.plugin.select2)
            // a. Override the select2 display style
            rowsPerPageSelect2.css("display", "inline-block");

            // b. Set select2 tooltip
            rowsPerPageSelect2.tooltip({
                title: this.options.localizer["NUMBER_OF_ITEMS_PER_PAGE"],
                placement: "bottom"
            });
        };

        PagingEdit.prototype.createPagingControl = function () {
            var me = this;

            this.buttonGroup.empty();

            // 1. Create left side buttons (First, Previous, PreviousPartition(...))
            createLeftSideButtons.call(this);

            // 2. Create paging buttons with numbers
            createNumberingButtons.call(this);

            // 3. Create left side buttons (NextPartition(...), Next, Last)
            createRigthSideButtons.call(this);

            // 4. Reflect the control ui for the first data result
            if (this.numberOfPages > 0) {
                // a. Active the first page
                var firstPageButton = this.buttonGroup.find("." + CLASS_NAME.plugin.pageNumberButton + "[pageIndex='1']");
                activeUiPageNumberButton.call(this, firstPageButton);

                // b. For the first time disabled the "First, Previous" buttons and enable "Next, Last" buttons
                changeLeftSideAndRightSideButtonsStatus.call(this, 1);

                // c. For the first time hide the "previous partition" button. Show the "next partition" button in case the last page is not in the first partition
                initializePartition.call(this);
            }
            else {
                disableLeftSideAndRightSideButtons.call(this);
            }
        };

        //#endregion ___________________________ Overridden Methods - Control Creation ___________________________


        //#region ___________________________ Overridden Methods - Show / Hide Spinner ___________________________

        PagingEdit.prototype.showSpinner = function () {
            $('body').jLoadingOverlay('');
        };

        PagingEdit.prototype.hideSpinner = function () {
            $('body').jLoadingOverlay('close');
        };

        //#endregion ___________________________ Overridden Methods - Show / Hide Spinner ___________________________


        PagingEdit.prototype.renderOn = function (controlContainer) {
            var container = $("<div>").addClass(CLASS_NAME.plugin.pagingEdit);

            if (this.options.dir === "rtl") {
                container.addClass("dir-rtl");
            }

            var inputGroup = $("<div>")
                                .addClass(CLASS_NAME.plugin.inputGroup)
                                .addBsClass("inputGroup")
                                .addBsClass("select2BootstrapAppend")
                                .addBsColClass({ xs: 12 });

            // 1. Render rows per page list control
            var rowsPerPageAddon = $("<span>")
                                        .addClass(CLASS_NAME.plugin.rowsPerPageAddon)
                                        .addBsClass("inputGroupPrepend")
                                        .append(this.rowsPerPageListContainer);

            inputGroup.append(rowsPerPageAddon);

            // 2. Render paging buttons control
            inputGroup.append(this.buttonGroup);

            container.append(inputGroup);

            controlContainer.append(container);
        };

        return PagingEdit;
    })(ns.PagingBaseEdit);
})();

(function () {
    this.Specto = this.Specto || {};
    this.Specto.ui = this.Specto.ui || {};

    var ns = this.Specto.ui;

/***************************************************************************************************/
/******************************************* Paging Edit *******************************************/

    /*
        options: { 
            clientSideFiltering: true/false(default),
            url:.., If clientSideFiltering = false.
            data: [{ Key(columnName): value }], If clientSideFiltering = true.
            pageSize: 5(default), 
            pageIndex: 1(default),
            pagesPerPartition: 8(default), 
            orderBy:.., 
            ascending: true/false(default),
            filters: [{ columnName:.., value:.., type:.. }], 
            searchColumns: [{ columnName:.., columnValue:.. }], 
            firstSearchResult: { rowsCount:.., data:.. }, 
            onPageChangeCallback:.., 
            param: [], 
            dir: "ltr"/"rtl", 
            localizer: { 
                FIRST: "First", 
                PREV: "Prev", 
                NEXT: "Next", 
                LAST: "Last",
                NUMBER_OF_ITEMS_PER_PAGE: "Number of items per page"
            },
        }

        - filters 'type' represents a FilterType enum and it's value should be one of f the following values:
            Equals = 1,
            Contains = 2,
            StartsWith = 3,
            EndsWidth = 4,
            GreaterThan = 5,
            LessThan = 6,
            GreaterThanOrEquals = 7,
            LessThanOrEquals = 8,

        OnPageChange this class will call the server method (options.url) to applyFilter, so the function "applyFilter" passes to the server the following data:
           The "paging" object that should consist of: 
              pageSize: selectedDropdownValue, pageIndex: clickedpageIndex, orderBy:.., ascending:..,  filters: (if there is extra filters passed by options or updated by the function ""), searchColumns:..,      
        
        IMPORTANT NOTE: (The following js files are required and must be imported before this class)
          jqueryExtensions.js
          UploadBaseEdit.js
    */
    ns.PagingEdit = (function (parent) {
        PagingEdit.prototype = new ns.PagingBaseEdit();
        PagingEdit.prototype.constructor = PagingEdit;

        //#region ______ CONST ______

        const CLASS_NAME = {
            plugin: {
                pagingEdit: "paging-edit",
                rowsPerPageListContainer: "paging-edit-rows-per-page-list-container",
                pager: "paging-edit-pager",
                pageNumberButton: "paging-page-number-btn",
                inputGroup: "paging-edit-input-group",
                rowsPerPageAddon: "paging-edit-rows-per-page-addon",
                activeButton: "active-button",
                //select2
                select2: "select2",
            }
        };

        //#endregion ___ CONST ______

        var defaults = {
            pagesPerPartition: 8
        };

        function PagingEdit(options) {
            // Initialize the PagingEdit
            init.call(this);

            // When use $.extend, if the second object contains null or 0, those two values override the default values from the first object, but the undefined does not. 
            // So, for this reason, we use our created $.customExtend instead of $.extend.
            parent.call(this, $.customExtend(true, {}, defaults, options));
        }
        //#region ___________________________ Private Methods ___________________________

        var init = function () {
            this.rowsPerPageListContainer = $("<div>")
                .addClass(CLASS_NAME.plugin.rowsPerPageListContainer);

            // Use bootstrap pagination
            //this.buttonGroup = $("<ui>")
            //                        .addClass(CLASS_NAME.plugin.pager)
            //                        .addClass("pagination");

            this.buttonGroup = $("<div>")
                                    .addClass(CLASS_NAME.plugin.pager)
                                    .addBsClass("buttonGroup");
        };

        //#endregion ________________________ Private Methods ___________________________

        //#region ___________________________ On Page Change ___________________________

        var disableLeftSideAndRightSideButtons = function () {
            this.firstPageBtn.attr("disabled", true);
            this.previousPageBtn.attr("disabled", true);
            this.nextPageBtn.attr("disabled", true);
            this.lastPageBtn.attr("disabled", true);
        };

        var changeLeftSideAndRightSideButtonsStatus = function (pageIndex) {
            this.firstPageBtn.removeAttr("disabled");
            this.previousPageBtn.removeAttr("disabled");
            this.nextPageBtn.removeAttr("disabled");
            this.lastPageBtn.removeAttr("disabled");

            if (pageIndex === 1) {
                this.firstPageBtn.attr("disabled", true);
                this.previousPageBtn.attr("disabled", true);
            }

            if (pageIndex === this.numberOfPages) {
                this.nextPageBtn.attr("disabled", true);
                this.lastPageBtn.attr("disabled", true);
            }
        };

        var onPageChange = function (pageIndex) {
            changeLeftSideAndRightSideButtonsStatus.call(this, pageIndex);

            this.paging.pageIndex = pageIndex;
            this.applyFilter(false, false, true);
        };

        var activeUiPageNumberButton = function (pageButton) {
            this.buttonGroup.find("." + CLASS_NAME.plugin.pageNumberButton)
                                        .removeBsClass("buttonPrimary")
                                        .addBsClass("buttonDefault")
                                        .removeClass(CLASS_NAME.plugin.activeButton);

            $(pageButton)
                .removeBsClass("buttonDefault")
                .addBsClass("buttonPrimary")
                .addClass(CLASS_NAME.plugin.activeButton);
        };

        var firePageNumberButtonClickEvent = function (pageIndex) {
            if (pageIndex > 0 && pageIndex <= this.numberOfPages) {
                this.buttonGroup.find("." + CLASS_NAME.plugin.pageNumberButton + "[pageIndex='" + pageIndex + "']").click();
            }
        };

        //#endregion ___________________________ On Page Change ___________________________


        //#region ___________________________ Pages Partition ___________________________

        var initializePartition = function () {
            this.firstPartitionPage = 1;
            this.lastPartitionPage = this.options.pagesPerPartition;

            if (this.numberOfPages > this.lastPartitionPage) {
                this.nextPartitionBtn.css("display", "inline-block");
            }
        };

        var displayPartitionPages = function () {
            var me = this;

            this.buttonGroup.find("." + CLASS_NAME.plugin.pageNumberButton)
                            .css("display", "none");

            this.buttonGroup.find("." + CLASS_NAME.plugin.pageNumberButton)
                            .filter(function () {
                                var currentPageIndex = parseInt($(this).attr("pageIndex"));
                                return currentPageIndex >= me.firstPartitionPage && currentPageIndex <= me.lastPartitionPage;
                            })
                            .css("display", "inline-block");

            if (this.firstPartitionPage === 1) {
                this.previousPartitionBtn.css("display", "none");
            }
            else {
                this.previousPartitionBtn.css("display", "inline-block");
            }

            if (this.numberOfPages <= this.lastPartitionPage) {
                this.nextPartitionBtn.css("display", "none");
            }
            else {
                this.nextPartitionBtn.css("display", "inline-block");
            }
        };

        var onPreviousPartitionClick = function () {
            this.firstPartitionPage = this.firstPartitionPage - this.options.pagesPerPartition;
            this.lastPartitionPage = this.lastPartitionPage - this.options.pagesPerPartition;

            displayPartitionPages.call(this);

            firePageNumberButtonClickEvent.call(this, this.lastPartitionPage);
        };

        var onNextPartitionClick = function () {
            this.firstPartitionPage = this.firstPartitionPage + this.options.pagesPerPartition;
            this.lastPartitionPage = this.lastPartitionPage + this.options.pagesPerPartition;

            displayPartitionPages.call(this);

            firePageNumberButtonClickEvent.call(this, this.firstPartitionPage);
        };

        //#endregion ___________________________ Pages Partition ___________________________


        //#region ___________________________ Page Navigation ___________________________

        var onFirstPageClick = function () {
            initializePartition.call(this);
            displayPartitionPages.call(this);

            firePageNumberButtonClickEvent.call(this, 1);
        };

        var onPreviousPageClick = function () {
            var previousPageIndex = this.paging.pageIndex - 1;

            if (previousPageIndex < this.firstPartitionPage) {
                onPreviousPartitionClick.call(this);
            }
            else {
                firePageNumberButtonClickEvent.call(this, previousPageIndex);
            }
        };

        var onNextPageClick = function (pageNumber) {
            var nextPageIndex = this.paging.pageIndex + 1;

            if (nextPageIndex > this.lastPartitionPage) {
                onNextPartitionClick.call(this);
            }
            else {
                firePageNumberButtonClickEvent.call(this, nextPageIndex);
            }
        };

        var onLastPageClick = function () {
            var numberOfPartitions = Math.ceil(this.numberOfPages / this.options.pagesPerPartition);
            var lastPageInPreviousPartition = (numberOfPartitions - 1) * this.options.pagesPerPartition;
            this.firstPartitionPage = lastPageInPreviousPartition + 1;
            this.lastPartitionPage = this.firstPartitionPage + this.options.pagesPerPartition - 1;

            displayPartitionPages.call(this);

            firePageNumberButtonClickEvent.call(this, this.numberOfPages);
        };

        //#endregion ___________________________ Page Navigation ___________________________


        //#region ___________________________ Control Creation ___________________________

        var createButton = function (content, onClickCallback) {
            // Use bootstrap pagination
            //var link = $("<a>")
            //                .addClass("page-link")
            //                .html(content);


            //return $("<li>")
            //            .addClass("page-item")
            //            .append(link).click(onClickCallback);

            return $("<button type='button'>")
                                    .addBsClass("button")
                                    .addBsClass("buttonDefault")
                                    .html(content)
                                    .click(onClickCallback);
        };

        var createLeftSideButtons = function () {
            var me = this;

            this.firstPageBtn = createButton(this.options.localizer["FIRST"], function () {
                onFirstPageClick.call(me);
            });

            this.previousPageBtn = createButton(this.options.localizer["PREV"], function () {
                onPreviousPageClick.call(me);
            });

            this.previousPartitionBtn = createButton("...", function () {
                onPreviousPartitionClick.call(me);
            }).css("display", "none");

            this.buttonGroup.append(this.firstPageBtn).append(this.previousPageBtn).append(this.previousPartitionBtn);
        };

        var createRigthSideButtons = function () {
            var me = this;

            this.nextPartitionBtn = createButton("...", function () {
                onNextPartitionClick.call(me);
            }).css("display", "none");

            this.nextPageBtn = createButton(this.options.localizer["NEXT"], function () {
                onNextPageClick.call(me);
            });


            this.lastPageBtn = createButton(this.options.localizer["LAST"], function () {
                onLastPageClick.call(me);
            });

            this.buttonGroup.append(this.nextPartitionBtn).append(this.nextPageBtn).append(this.lastPageBtn);
        };

        var createNumberingButtons = function () {
            var me = this;

            for (var pageIndex = 1; pageIndex <= this.numberOfPages; pageIndex++) {
                var pageBtn = createButton(pageIndex, function () {
                    var currentPagingButton = $(this);

                    // if the current button is not already active
                    if (!currentPagingButton.hasClass(CLASS_NAME.plugin.activeButton)) {
                        // a. Change the style of the button to show as active
                        activeUiPageNumberButton.call(me, this);

                        // b. Get server data based on the clicked page
                        var clickedPageIndex = parseInt(currentPagingButton.attr("pageIndex"));
                        onPageChange.call(me, clickedPageIndex);
                    }
                }).addClass(CLASS_NAME.plugin.pageNumberButton)
                              .attr("pageIndex", pageIndex);


                // Hide all paging buttons that is not in the first partition
                if (pageIndex > this.options.pagesPerPartition) {
                    pageBtn.css("display", "none");
                }

                this.buttonGroup.append(pageBtn);
            }
        };

        //#endregion ___________________________ Control Creation ___________________________


        //#region ___________________________ Overridden Methods - Control Creation ___________________________

        PagingEdit.prototype.createRowsPerPageListControl = function () {
            this.rowsPerPageListContainer.empty();

            var loopCount = 0;

            // 1. Calculate the number of loops
            if (this.rowsCount !== 0) {
                var maximumRowsPerPage = 50;
                loopCount = maximumRowsPerPage / this.numberOfItemsPerPage;

                if (this.rowsCount < maximumRowsPerPage) {
                    loopCount = Math.ceil(this.rowsCount / this.numberOfItemsPerPage);
                }
            }

            // 2. Create a list and fill it with numbers multiplicated by the pageSize value that is passed as parameter on the first time or get the default value
            var listItems = [];
            for (var i = 1; i <= loopCount; i++) {
                var rowsPerPage = i * this.numberOfItemsPerPage;
                listItems.push({ id: rowsPerPage, text: rowsPerPage });
            }

            // 3. Create select2
            var me = this;
            var select2Edit = new ns.Select2Edit({
                items: listItems,
                value: this.numberOfItemsPerPage, // (1 * this.numberOfItemsPerPage)
                width: "62px",
                dir: this.options.dir || "ltr",
                onChangeCallback: function (selectedValue) {
                    if (me.numberOfPages > 0) {
                        me.paging.pageSize = parseInt(selectedValue);
                        me.paging.pageIndex = 1;

                        me.applyFilter(true, false, false);
                    }
                }
            });

            select2Edit.renderOn(this.rowsPerPageListContainer);

            // 4. Apply select2 custom attributes
            var rowsPerPageSelect2 = this.rowsPerPageListContainer.find("." + CLASS_NAME.plugin.select2)
            // a. Override the select2 display style
            rowsPerPageSelect2.css("display", "inline-block");

            // b. Set select2 tooltip
            rowsPerPageSelect2.tooltip({
                title: this.options.localizer["NUMBER_OF_ITEMS_PER_PAGE"],
                placement: "bottom"
            });
        };

        PagingEdit.prototype.createPagingControl = function () {
            var me = this;

            this.buttonGroup.empty();

            // 1. Create left side buttons (First, Previous, PreviousPartition(...))
            createLeftSideButtons.call(this);

            // 2. Create paging buttons with numbers
            createNumberingButtons.call(this);

            // 3. Create left side buttons (NextPartition(...), Next, Last)
            createRigthSideButtons.call(this);

            // 4. Reflect the control ui for the first data result
            if (this.numberOfPages > 0) {
                // a. Active the first page
                var firstPageButton = this.buttonGroup.find("." + CLASS_NAME.plugin.pageNumberButton + "[pageIndex='1']");
                activeUiPageNumberButton.call(this, firstPageButton);

                // b. For the first time disabled the "First, Previous" buttons and enable "Next, Last" buttons
                changeLeftSideAndRightSideButtonsStatus.call(this, 1);

                // c. For the first time hide the "previous partition" button. Show the "next partition" button in case the last page is not in the first partition
                initializePartition.call(this);
            }
            else {
                disableLeftSideAndRightSideButtons.call(this);
            }
        };

        //#endregion ___________________________ Overridden Methods - Control Creation ___________________________


        //#region ___________________________ Overridden Methods - Show / Hide Spinner ___________________________

        PagingEdit.prototype.showSpinner = function () {
            $('body').jLoadingOverlay('');
        };

        PagingEdit.prototype.hideSpinner = function () {
            $('body').jLoadingOverlay('close');
        };

        //#endregion ___________________________ Overridden Methods - Show / Hide Spinner ___________________________


        PagingEdit.prototype.renderOn = function (controlContainer) {
            var container = $("<div>").addClass(CLASS_NAME.plugin.pagingEdit);

            if (this.options.dir === "rtl") {
                container.addClass("dir-rtl");
            }

            var inputGroup = $("<div>")
                                .addClass(CLASS_NAME.plugin.inputGroup)
                                .addBsClass("inputGroup")
                                .addBsClass("select2BootstrapAppend")
                                .addBsColClass({ xs: 12 });

            // 1. Render rows per page list control
            var rowsPerPageAddon = $("<span>")
                                        .addClass(CLASS_NAME.plugin.rowsPerPageAddon)
                                        .addBsClass("inputGroupPrepend")
                                        .append(this.rowsPerPageListContainer);

            inputGroup.append(rowsPerPageAddon);

            // 2. Render paging buttons control
            inputGroup.append(this.buttonGroup);

            container.append(inputGroup);

            controlContainer.append(container);
        };

        return PagingEdit;
    })(ns.PagingBaseEdit);
})();


(function () {
  this.Specto = this.Specto || {};
  this.Specto.ui = this.Specto.ui || {};
  Specto.ui.defaults = Specto.ui.defaults || {};
  var ns = this.Specto.ui;

  /***************************************************************************************************/
  /**************************************** Tree Card Viewer *****************************************/

  //#region *************************** Documentation ***************************//

  //#region ********** Required Files **********//
  /*
      Required the following Specto classes:
          - ElementQueries.js
          - NavigatorHelper.js
          - TooltipOnOverflow.js
          - ResponsiveCarousel.js

      Required plugins:
          - jQuery-ui: We need jquery "sortable" widget
              <script src="https://code.jquery.com/ui/1.12.1/jquery-ui.min.js"
                  integrity="sha256-VazP97ZCwtekAsvgPBSUwPFKdrwD3unUfSGVYrahUqU="
                  crossorigin="anonymous">
              </script>

          - jquery.contextMenu: Download the files from the following url: (https://swisnl.github.io/jQuery-contextMenu/)
              <link href="jquery.contextMenu/css/jquery.contextMenu.min.css" rel="stylesheet" />
              <script src="jquery.contextMenu/js/jquery.contextMenu.min.js"></script>
  */
  //#endregion ******* Required Files **********//

  //#region *********** jQuery Plugin **********//
  /*
      $(selector).treeCardViewer(options); Create plugin
      $(selector).treeCardViewer("instance"); Get the current plugin instance

      $(selector).treeCardViewer("showDetailsSlider"); // Show Details Slider
      $(selector).treeCardViewer("hideDetailsSlider"); // Hide Details Slider
      $(selector).treeCardViewer("refreshDetailsSlider"); // Refresh Details Slider responsive design

      $(selector).treeCardViewer("getNode", nodeId); Get node object
      $(selector).treeCardViewer("getParentNode", nodeId); Get parent node object
      $(selector).treeCardViewer("getChildrenNodes", nodeId); Get children nodes object
      $(selector).treeCardViewer("getAncestorNodes", nodeId); Get all ancestor nodes object
      $(selector).treeCardViewer("getDescendentNodes", nodeId); Get all descendent nodes object

      $(selector).treeCardViewer("appendNode", parentId, nodeId, node); // Append a new node
      $(selector).treeCardViewer("appendNodes", parentId, subTree); // Append array of nodes
      $(selector).treeCardViewer("updateNode", nodeId, { keys to update }); // Update node by id
      $(selector).treeCardViewer("deleteNode", nodeId); // Delete a node

      $(selector).treeCardViewer("activateNode", nodeId); // Activate a node
      $(selector).treeCardViewer("getActiveNode"); // Return active node object
      $(selector).treeCardViewer("getActivePathNodes"); // Return active path nodes
  
      $(selector).treeCardViewer("expandAll", nodeId); // Expand a sub tree
  */
  //#endregion ******** jQuery Plugin **********//

  //#region ************** Options *************//
  /* 

      param: {
          rootId:(required),

          options: {
              rtl: true/false(default),
              detailsSlider: {
                  resizable: true(default)/false,
                  toggable: true(default)/false,
                  width: 50%(default), // This value should be either a number or a percentage value between 1 and 100
              },
              textTooltipLinesNumber: 1,
              resizeIcon: "fa fa-bars",
              toggleIcon: "fa fa-bars",
              deleteIcon: "fa fa-times",
              onDelete: function (e, obj) {}, // The obj is a keyvalue pair object, consist of: 
                          { 
                              component: (current class context), context: (current node element),
                              parentId:.., nodeId:.., node: {}, $detailsContainer:.. 
                          }
              onActivate: function (e, obj) {}, // The obj is a keyvalue pair object, consist of: 
                          { 
                              component: (current class context), context: (current node element), 
                              parentId:.., nodeId:.., node: {}, $detailsContainer:.. 
                          },
              onSelect: function (e, obj) {}, // The obj is a keyvalue pair object, consist of: 
                          { 
                              component: (current class context), context: (current node element), 
                              parentId:.., nodeId:.., node: {}, $detailsContainer:.. 
                          },
              onSort: function (e, obj) {}, // The obj is a keyvalue pair object, consist of: 
                          { 
                              component: (current class context), context: (current node element),
                              parentId:.., movedNodeId:.., movedNode: {}, sortedNodes: {}, ancestorNodes: {}
                          },
              localizer: {
                  CLOSE_TOGGLE: "Close",
                  SHOW_DETAILS: "Show Details",
                  HIDE_DETAILS: "Hide Details",
                  RESIZE: "Resize",
                  DELETE: "Delete",
                  ALT_IMAGE: "The image is not loaded correctly",
              },
          },

          nodes: {
              nodeId(asKey): {
                  text:..,
                  image:..,
                  sortableChildren: true/false(default),
                  children: [nodeIds],
                  allowDelete: true/false(default),
                  actions: [
                      { 
                          iconClass: "string"/["classes"], 
                          text:.., 
                          callback: function (e, obj) {}, // The obj is a keyvalue pair object, consist of:  
                                      { 
                                          component: (current class context), context: (current node element),
                                          parentId:.., nodeId:.., node: {}, $detailsContainer:.. 
                                      }
                          showInBar: true/false(default), 
                          showInMenu: true/false(default) 
                      }
                  ],
              }
          }
      }
  */
  //#endregion *********** Options *************//

  //#region ************* TODO List ************//
  /*
      TODO_N:
       - Remove data-key attribute from cards (that is using for contextmenu).
       - jQuery resizable on tablet and mobile screens.
       - Read more about adaptive design, apply it on window.resize, on desktop screens.
       - Investigate how to break function execution between events in javascript.
       - Investigate how to use css element queries instead of media queries.
   */
  //#endregion ********** TODO List ************//

  //#endregion ************************ Documentation ***************************//


  //#region **************************** Entry Class ****************************//

  ns.TreeCardViewer = (function () {
      // Default options
      var defaults = $.extend({}, {
          rtl: false,
          detailsSlider: {
              resizable: true,
              toggable: true,
          },
          resizeIcon: "fa fa-bars",
          toggleIcon: "fa fa-bars",
          deleteIcon: "fa fa-times",
          localizer: {
              CLOSE_TOGGLE: "Close",
              SHOW_DETAILS: "Show Details",
              HIDE_DETAILS: "Hide Details",
              RESIZE: "Resize",
              DELETE: "Delete",
              ALT_IMAGE: "The image is not loaded correctly",
          },
          nodes: [],
          textTooltipLinesNumber: 1,
      }, Specto.ui.defaults.TreeCardViewer);

      var priv = new WeakMap();
      var _ = function (instance) { return priv.get(instance); };

      function TreeCardViewer(element, param) {
          this.options = $.extend(true, {}, defaults, param.options);

          if (!param.rootId) {
              throw new Error("Missing rootId in options object");
          }

          var privateMembers = {
              $element: $(element), // Original container
              $control: null,
              // Levels side and Data side
              $levelsSide: $("<div>")
                              .addClass("tcv-side")
                              .addClass("tcv-levels-side"),
              $dataSide: $("<div>")
                              .addClass("tcv-side")
                              .addClass("tcv-data-side"),
              // Create levels container, data container and navigation bar
              $levelsContainer: $("<div>").addClass("tcv-levels-container"),
              $navigationBar: $("<div>").addClass("tcv-navigation-bar"),
              $dataContainer: $("<div>").addClass("tcv-data-container"),
              // Create element queries monitor on data container
              dataContainerMonitor: null,
              // RootId
              rootId: param.rootId,
              // Prepare nodes iterator
              nodesIterator: new NodeDictionary(param.rootId, param.nodes),
              // TreeCard
              treeCardInstance: null,
              // Check if the current navigator is mobile and tablet
              isMobileAndTablet: Specto.utils.NavigatorHelper.userAgent.isMobileAndTablet(),
              //cardWidth: 125,
          };

          priv.set(this, privateMembers);

          // Initialize the TreeCardViewer
          init.call(this);
      }

      //#region ___________________________ Private Methods ___________________________

      var init = function () {
          if (!_(this).nodesIterator.exists(_(this).rootId)) {
              throw new Error("Root node does not exist in nodes object");
          }

          //new ResizeSensor(_(this).$dataContainer, function () {
          //    console.log('Changed to ' + element.clientWidth);
          //});

          // Create element queries monitor on data container
          _(this).dataContainerMonitor = new Specto.ui.ElementQueries(_(this).$dataContainer);

          // Create tree card viewer control, then render the control inside the $element(container)
          var $control = _(this).$control = createControl.call(this);
          _(this).$element.append($control);

          // Prepare levels and data side
          prepareLevelsSide.call(this);
          prepareDataSide.call(this);

          // Create TreeCard
          var treeCardInstance = _(this).treeCardInstance = createTreeCard.call(this);
          // Activate root card
          //treeCardInstance.activateCard(this.options.rootId);

          var me = this;

          // Bind window.resize event
          $(window).resize(function (e, element) {
              me.refreshDetailsSlider();
              //refreshTreeCards.call(me);
          });

          //// Refresh all tree cards on the first load
          //setTimeout(function () {
          //    refreshTreeCards.call(me);
          //}, 600);
      };


      //#region ______________ Control Creation _____________

      var createControl = function () {
          var $control = $("<div>").addClass("tcv");

          // Add control right to left
          if (this.options.rtl) {
              $control.addClass("tcv-rtl");
          }

          // Append the left and right side
          $control
              .append(_(this).$levelsSide)
              .append(_(this).$dataSide);

          if (_(this).isMobileAndTablet) {
              $control.addClass("mobile");
              _(this).$levelsSide.addClass("expand");
              _(this).$dataSide.addClass("shrink");
          }

          return $control;
      };

      //#endregion ___________ Control Creation _____________


      //#region ___________________ Sides ___________________

      var validatePercentageValue = function (value) {
          // Check if value is a percentage value or only number
          return /^\d+(\.\d+)?%$|^\d+(\.\d+)?$/.test(value);
      };

      var prepareLevelsSide = function () {
          var $levelsSide = _(this).$levelsSide;

          $levelsSide.append(_(this).$levelsContainer);

          if (this.options.detailsSlider.toggable) {
              var $toggleIcon = createToggleIcon.call(this);
              $levelsSide.append($toggleIcon);

              changeToggleIconText.call(this);
          }

          if (this.options.detailsSlider.width) {
              var detailsSideWidth = this.options.detailsSlider.width;

              if (validatePercentageValue.call(this, detailsSideWidth)) {
                  var floatWidth = parseFloat(detailsSideWidth);
                  if (floatWidth > 0 && floatWidth <= 100) {
                      var levelsSideWidth = 100 - floatWidth + "%";
                      $levelsSide.css("width", levelsSideWidth);
                  }
              }
          }
      };

      var prepareDataSide = function () {
          var $dataSide = _(this).$dataSide;

          if (_(this).isMobileAndTablet) {
              var $menuBar = $("<div>").addClass("tcv-action-bar").appendTo($dataSide);

              var $closeToggleBtn = createCloseTogglingBtn.call(this);
              $menuBar.append($closeToggleBtn);
          }
          else {
              $dataSide.append(_(this).$navigationBar);

              if (this.options.detailsSlider.resizable) {
                  applyResizableSlider.call(this);
              }
          }

          $dataSide.append(_(this).$dataContainer);
      };

      var refreshUiNodeDetails = function (data) {
          var $dataContainer = _(this).$dataContainer;
          $dataContainer.empty();

          if (data) {
              $dataContainer.html(data);
              this.refreshDetailsSlider();
          }
      };

      //#endregion ________________ Sides ___________________


      //#region ______________ Toggable Slider ______________

      var createCloseTogglingBtn = function () {
          var me = this;

          return $("<button type='button'>")
                      .addClass("tcv-close-toggle")
                      .addClass("btn btn-primary")
                      .text(this.options.localizer["CLOSE_TOGGLE"])
                      .click(function () {
                          toggleDetailsSlider.call(me, false);
                      });
      };

      var createToggleIcon = function () {
          var me = this;

          return $("<a href='javascript:;'>")
                      .addClass("tcv-nav-toggle-icon")
                      .append($("<i>").addClass(this.options.toggleIcon))
                      .attr({ "data-toggle": "tooltip" })
                      .click(function () {
                          var isClosed = _(me).$dataSide.hasClass("shrink");
                          toggleDetailsSlider.call(me, isClosed);
                      });
      };

      var toggleDetailsSlider = function (flag) {
          var $levelsSide = _(this).$levelsSide;
          var $dataSide = _(this).$dataSide;

          if (flag) {
              $levelsSide.removeClass("expand");
              $dataSide.removeClass("shrink");
          }
          else {
              $levelsSide.addClass("expand");
              $dataSide.addClass("shrink");
          }

          changeToggleIconText.call(this);

          // Add workaround
          var me = this;
          setTimeout(function () {
              refreshTreeCards.call(me);

              // Important Note: This time should be the same as the css transition time 
              //  (transition: width 0.7s ease-in-out;). Because we need to do some
              //  calculations after the navigation bar toggle finishes.
          }, 700);
      };

      var changeToggleIconText = function () {
          var $levelsSide = _(this).$levelsSide;

          var tooltipTitle = $levelsSide.hasClass("expand") ? this.options.localizer["SHOW_DETAILS"] :
                                  this.options.localizer["HIDE_DETAILS"];

          $levelsSide.find(".tcv-nav-toggle-icon").attr("title", tooltipTitle);
      };

      //#endregion ___________ Toggable Slider ______________


      //#region ______________ Resizable Slider _____________

      var applyResizableSlider = function () {
          //TODO_N: Set this class for $navigationBar instead of $control
          _(this).$control.addClass("tcv--resizable");

          var $navBarIcon = $("<i>")
                                  .addClass("tcv-nav-bar-icon")
                                  .addClass(this.options.resizeIcon)
                                  .attr({
                                      "data-toggle": "tooltip",
                                      "title": this.options.localizer["RESIZE"]
                                  });

          _(this).$navigationBar.append($navBarIcon);

          bindSidesResizableEvents.call(this);
      };

      var bindSidesResizableEvents = function () {
          var me = this;

          var $control = _(this).$control;
          var $levelsSide = _(this).$levelsSide;
          var $navigationBar = _(this).$navigationBar;
          var $dataContainer = _(this).$dataContainer;

          var leftPane = $levelsSide[0];
          var splitter = $navigationBar[0];

          function resizer(e) {
              $control.addClass("resizing");

              window.addEventListener('mousemove', mousemove);
              window.addEventListener('mouseup', mouseup);

              let prevX = e.x;
              const leftPanel = leftPane.getBoundingClientRect();
              //const leftPanel = 240;

              function mousemove(e) {
                  let newX = prevX - e.x;
                  leftPane.style.width = leftPanel.width - newX + "px";

                  resizeFinished();
              };

              function mouseup() {
                  window.removeEventListener('mousemove', mousemove);
                  window.removeEventListener('mouseup', mouseup);

                  $control.removeClass("resizing");

                  //refreshTreeCards.call(me);
              };

              function resizeFinished() {
                  //dataContainerMonitor.trigger();
                  me.refreshDetailsSlider();
              };
          }

          splitter.addEventListener('mousedown', resizer);
      };

      //#endregion ___________ Resizable Slider _____________


      //#region _________________ Tree Card _________________

      var createTreeCard = function () {
          var nodesIterator = _(this).nodesIterator;

          var rootId = _(this).rootId;
          var rootNode = nodesIterator.get(rootId);

          var me = this;
          return new TreeCard(rootId, rootNode, _(this).$levelsContainer, {
              resizeSensor: this.options.detailsSlider.resizable, //TODO_N: Check if navigator is not mobile or tablet
              textTooltipLinesNumber: this.options.textTooltipLinesNumber,
              deleteIcon: this.options.deleteIcon,
              onDelete: this.options.onDelete,
              onAfterActivate: onAfterActivate.bind(this),
              onAfterSelect: onAfterSelect.bind(this),
              onSort: function (e, obj) {
                  // 1. Re-order those nodes inside the node children array
                  nodesIterator.sortChildren(obj.parentId, obj.sortedNodesIds);

                  // 2. Callback the onSort function
                  if (me.options.onSort && $.isFunction(me.options.onSort)) {
                      me.options.onSort(e, {
                          component: me,
                          context: obj.context,
                          parentId: obj.parentId,
                          movedNodeId: obj.movedNodeId,
                          // Get the moved node
                          movedNode: nodesIterator.get(obj.movedNodeId),
                          // Get children nodes after re-order them
                          sortedNodes: nodesIterator.getChildren(obj.parentId),
                          // Get all ancestor nodes. Note: All sorted nodes have the same parent and ancestors
                          ancestorNodes: nodesIterator.getAncestors(obj.sortedNodesIds[0]),
                      });
                  }
              },
              onActionClick: function (e, action, obj) {
                  var node = _(me).nodesIterator.get(obj.nodeId);

                  // obj: Consists of: { context:.. , parentId:.. , nodeId:.. }
                  if (action.callback && $.isFunction(action.callback)) {
                      // Pass a param object to callback function
                      action.callback(e, $.extend(true, {}, obj, {
                          // obj: Consists of: { context:.. , parentId:.. , nodeId:.. }
                          component: me,
                          node: node,
                          $detailsContainer: _(me).$dataContainer
                      }));
                  }

              },
              localizer: this.options.localizer,
          });
      };

      var onAfterActivate = function (e, obj) {
          var node = _(this).nodesIterator.get(obj.nodeId);

          // Render node details
          refreshUiNodeDetails.call(this, node.details);

          // Callback onActivate
          if (this.options.onActivate && this.options.onActivate instanceof Function) {
              this.options.onActivate(e, $.extend(true, {}, obj, {
                  // obj: Consists of: { context:.. , parentId:.. , nodeId:.. }
                  component: this,
                  node: node,
                  $detailsContainer: _(this).$dataContainer
              }));
          }

          // Refresh the cards
          //refreshTreeCards.call(this);

          // Vertically scroll to activated card
          var $currentLevel = obj.context.closest(".tcv-level");
          verticallyScrollToLevel.call(this, $currentLevel);
      };

      var onAfterSelect = function (e, obj) {
          var nodesIterator = _(this).nodesIterator;
          var node = nodesIterator.get(obj.nodeId);
  
          // If this node has child nodes, draw it's childs
          if (nodesIterator.hasChildren(obj.nodeId)) {
              var treeCardInstance = _(this).treeCardInstance;

              var children = nodesIterator.getChildren(obj.nodeId);
              for (var i = 0; i < children.length; i++) {
                  var child = children[i];
                  treeCardInstance.addCard(obj.nodeId, child.id, child);
              }
          }

          // Callback onSelect
          if (this.options.onSelect && this.options.onSelect instanceof Function) {
              this.options.onSelect(e, $.extend(true, {}, obj, {
                  // obj: Consists of: { context:.. , parentId:.. , nodeId:.. }
                  component: this,
                  node: node,
                  $detailsContainer: _(this).$dataContainer
              }));
          }
      };

      var expandSubTree = function (nodeId) {
          var treeCardInstance = _(this).treeCardInstance;

          if (treeCardInstance.hasCard(nodeId)) {
              // Next selected node / next node to be selected
              var nextSelectableNodeId;

              var nodesIterator = _(this).nodesIterator;

              if (nodesIterator.hasChildren(nodeId)) {
                  var node = nodesIterator.get(nodeId);

                  // Get first child node. By default the next selectable node is the first child node
                  nextSelectableNodeId = node.children[0];
              }

              // 1. If the current node is not selected, select it
              if (!treeCardInstance.isCardSelected(nodeId)) {
                  treeCardInstance.selectCard(nodeId); // Select node
              }
              else {
                  /* 
                      If the node is already selected, in this case we should expand the selected children nodes
                  */

                  // Check if current node children are rendered (has next level)
                  if (treeCardInstance.hasChildren(nodeId)) {
                      var selectedChildId = treeCardInstance.getSelectedChildId(nodeId);
                      if (selectedChildId) {
                          nextSelectableNodeId = selectedChildId; // Override the default value
                      }
                  }
              }

              // 2. If the current node has a selected child or has a child to be selected
              if (nextSelectableNodeId) {
                  // Recall the expandSubTree recursively to activate the sub tree
                  expandSubTree.call(this, nextSelectableNodeId);
              }
          }
      };

      //var calculateTreeLevelCardsCount = function () {
      //    var carouselWidth = _(this).treeCardInstance.getCarouselWidth();
      //    return Math.floor(carouselWidth / _(this).cardWidth);
      //};

      //var refreshTreeCards = function () {
      //    var maxCardsAllowedPerLevel = calculateTreeLevelCardsCount.call(this);

      //    // Limit the number of showing cards inside each level carousel
      //    _(this).treeCardInstance.refreshLevelsCarousel(maxCardsAllowedPerLevel);
      //};

      var refreshTreeCards = function () {
          // Limit the number of showing cards inside each level carousel
          _(this).treeCardInstance.refreshLevelsCarousel();
      };

      var verticallyScrollToLevel = function ($level) {
          var $levelsContainer = _(this).$levelsContainer;

          var top = $levelsContainer.scrollTop() + $level.position().top - 15;
          $levelsContainer.scrollTop(top);
      };

      //#endregion ______________ Tree Card _________________


      //#endregion ________________________ Private Methods ___________________________

      TreeCardViewer.prototype.showDetailsSlider = function (includedMobile) {
          if (!_(this).isMobileAndTablet || includedMobile) {
              toggleDetailsSlider.call(this, true);
          }
      };

      TreeCardViewer.prototype.hideDetailsSlider = function () {
          toggleDetailsSlider.call(this, false);
      };

      TreeCardViewer.prototype.refreshDetailsSlider = function () {
          _(this).dataContainerMonitor.trigger();
      };

      TreeCardViewer.prototype.getNode = function (nodeId) {
          return _(this).nodesIterator.get(nodeId);
      };

      TreeCardViewer.prototype.getParentNode = function (nodeId) {
          return _(this).nodesIterator.getParent(nodeId);
      };

      TreeCardViewer.prototype.getChildrenNodes = function (nodeId) {
          return _(this).nodesIterator.getChildren(nodeId);
      };

      TreeCardViewer.prototype.getAncestorNodes = function (nodeId) {
          return _(this).nodesIterator.getAncestors(nodeId);
      };

      TreeCardViewer.prototype.getDescendentNodes = function (nodeId) {
          return _(this).nodesIterator.getDescendent(nodeId);
      };

      TreeCardViewer.prototype.appendNode = function (parentId, nodeId, node) {
          var treeCardInstance = _(this).treeCardInstance;

          // 1. Append node object to nodesIterator
          _(this).nodesIterator.add(parentId, nodeId, node);

          // 2. Create node card if it's parent is rendered on DOM, and this card is not rendered yet
          // Check if parent card is rendered on DOM
          if (treeCardInstance.hasCard(parentId)) {
              // Check if the card is not rendered yet
              if (!treeCardInstance.hasCard(nodeId)) {
                  // 1. Append card on ui
                  treeCardInstance.addCard(parentId, nodeId, node);

                  // 2. Refresh level
                  //var maxCardsAllowedPerLevel = calculateTreeLevelCardsCount.call(this);
                  //treeCardInstance.updateCarouselVisibleItems(parentId, maxCardsAllowedPerLevel);

                  // 3. Activate the card
                  //treeCardInstance.activateCard(nodeId);
              }
          }
      };

      TreeCardViewer.prototype.appendNodes = function (parentId, subTree) {
          var nodesIterator = _(this).nodesIterator;
          var treeCardInstance = _(this).treeCardInstance;

          // 1. Append many nodes objects to nodesIterator
          var normalizedSubTree = nodesIterator.addSubTree(parentId, subTree);

          // 2. Create nodes cards if it's parent is rendered on DOM, and the children cards are not rendered yet
          // Check if parent card is rendered on DOM
          if (treeCardInstance.hasCard(parentId)) {
              // Check if parent node has children
              if (nodesIterator.hasChildren(parentId)) {
                  var children = nodesIterator.getChildren(parentId);

                  // 1. Append only direct level children cards on ui
                  for (var i = 0; i < children.length; i++) {
                      var child = children[i];

                      //if (normalizedSubTree.hasOwnProperty(child.id))
                      // Check if the card is not rendered yet
                      if (!treeCardInstance.hasCard(child.id)) {
                          treeCardInstance.addCard(parentId, child.id, child);
                      }
                  }

                  // 2. Refresh level
                  //var maxCardsAllowedPerLevel = calculateTreeLevelCardsCount.call(this);
                  //treeCardInstance.updateCarouselVisibleItems(parentId, maxCardsAllowedPerLevel);
              }
          }
      };

      TreeCardViewer.prototype.updateNode = function (nodeId, obj) {
          var nodesIterator = _(this).nodesIterator;
          var treeCardInstance = _(this).treeCardInstance;

          // 1. Get node before update
          var node = _(this).nodesIterator.get(nodeId);

          // 2. If node text is changed, reflect the updated text on ui
          if (node.text !== obj.text) {
              treeCardInstance.updateText(nodeId, obj.text);
          }

          // 3. If node image is changed, reflect the updated image on ui
          if (node.image !== obj.image) {
              treeCardInstance.updateImage(nodeId, obj.image);
          }

          // 4. Update the node object
          nodesIterator.update(nodeId, obj);
      };

      TreeCardViewer.prototype.deleteNode = function (nodeId) {
          var nodesIterator = _(this).nodesIterator;

          if (nodesIterator.exists(nodeId)) {
              var node = nodesIterator.get(nodeId);
              var treeCardInstance = _(this).treeCardInstance;

              // 1. Remove node sub tree from nodes object
              nodesIterator.removeSubTree(nodeId);

              // 2. Remove node sub tree from DOM
              treeCardInstance.removeSubTree(nodeId);

              // 3. Refresh level
              //var maxCardsAllowedPerLevel = calculateTreeLevelCardsCount.call(this);
              //treeCardInstance.updateCarouselVisibleItems(node.parentId, maxCardsAllowedPerLevel);
          }
      };

      TreeCardViewer.prototype.activateNode = function (nodeId, expandAll) {
          var treeCardInstance = _(this).treeCardInstance;

          if (treeCardInstance.hasCard(nodeId)) {
              treeCardInstance.activateCard(nodeId);
          }

          if (expandAll) {
              this.expandAll(nodeId);
          }
      };

      TreeCardViewer.prototype.getActiveNode = function () {
          var activeNode;

          var activeNodeId = _(this).treeCardInstance.getActiveCardId();
          if (activeNodeId) {
              activeNode = _(this).nodesIterator.get(activeNodeId);
          }

          return activeNode;
      };

      TreeCardViewer.prototype.getActivePathNodes = function () {
          var pathNodes = [];

          var nodesIterator = _(this).nodesIterator;

          var activePathIds = _(this).treeCardInstance.getActivePath();
          for (var i = 0; i < activePathIds.length; i++) {
              var node = nodesIterator.get(activePathIds[i]);
              pathNodes.push(node);
          }

          return pathNodes;
      };

      TreeCardViewer.prototype.expandAll = function (nodeId) {
          expandSubTree.call(this, nodeId);
          refreshTreeCards.call(this);
      };

      return TreeCardViewer;
  })();

  //#endregion ************************* Entry Class ****************************//


  //#region ************************ NodeDictionary Class ***********************//

  /*
   * @param {Object} nodes dict with keys(nodeId)
   */
  var NodeDictionary = (function () {
      var priv = new WeakMap();
      var _ = function (instance) { return priv.get(instance); };

      function NodeDictionary(rootId, treeNodes) {
          var privateMembers = {
              rootId: rootId,
              nodes: {},
          };

          priv.set(this, privateMembers);

          // Initialize the NodeDictionary
          var normalizedTreeNodes = Array.isArray(treeNodes) ? normalizeNodesArray(treeNodes) : treeNodes;
          init.call(this, normalizedTreeNodes);
      }

      //#region ___________________________ Private Methods ___________________________

      /*
       * Initializes the NodeDictionary, adding the root node and it's sub tree
       * 
       * @param {Object} treeNodes
       */
      var init = function (treeNodes) {
          var rootId = _(this).rootId;
          var rootNode = treeNodes[rootId];

          if (!rootNode) {
              throw new Error("The root node \"" + rootId + "\" does not exist in the passed tree nodes");
          }

          // Append the root node into nodes object
          //_(this).nodes[rootId] = $.extend(true, {}, rootNode);
          generateNode.call(this, rootId, rootNode);

          // Append the tree nodes into nodes object
          this.addSubTree(rootId, treeNodes);
      };

      /*
       * Converts the nodes array to dictionary
       * 
       * @param {Array} nodesArray
       * @returns {Object} returns nodes object
       */
      var normalizeNodesArray = function (nodesArray) {
          var nodes = {};

          for (var i = 0; i < nodesArray.length; i++) {
              var node = nodesArray[i];
              nodes[node.id] = node;
          }

          return nodes;
      };

      /*
       * Filters the nodes object
       * 
       * @param {Object} nodesObj
       * @param {Integer|String} filterBy
       * @param {Integer|String|Boolean} filterValue
       * @returns {Array} returns filtered nodes array
       */
      var filter = function (nodesObj, filterBy, filterValue) {
          var filteredNodes = [];

          for (var nodeId in nodesObj) {
              var node = nodesObj[nodeId];

              if (node[filterBy] === filterValue) {
                  //filteredNodes[nodeId] = node;
                  filteredNodes.push(node);
              }
          }

          return filteredNodes;
      };

      /*
       * Adds the node to nodes dictionary, and generate some functions inside the
       *  node object, like getParent.. This method is shared between "init method", that 
       *  initialize the root node, and "add method", that adds a new node
       * 
       * @param {Integer|String} nodeId
       * @param {Object} node
       */
      var generateNode = function (nodeId, node) {
          // 1. Add the node to nodes object
          _(this).nodes[nodeId] = node;

          // 2. Workaround: Override children array, if there is a value coming from outside the control
          node.children = [];

          // 3. Create a function inside the node itself "getParent"
          var me = this;
          node.getParent = function () {
              return me.getParent(nodeId);
          };
      };

      /*
       * Creates an array of children ids to parent node, if the parent node
       *  does not have children array created before. Then, appends childId to this array
       * 
       * @param {Integer|String} parentId
       * @param {Integer|String} childId
       */
      var appendParentChild = function (parentId, childId) {
          var parentNode = this.get(parentId);

          if (!parentNode.children)
              parentNode.children = [];

          parentNode.children.push(childId);
      };

      /*
       * Removes the childId from children array in the parent node
       * 
       * @param {Integer|String} parentId
       * @param {Integer|String} childId
       */
      var removeParentChild = function (parentId, childId) {
          var parentNode = this.get(parentId);

          var childIndex = parentNode.children.indexOf(childId);
          if (childIndex !== -1) {
              parentNode.children.splice(childIndex, 1);
          }
      };

      //#endregion ________________________ Private Methods ___________________________

      /*
       * This method adds a new node to nodes dictionary, only if the parent node exists and
       *  the node itself does not exist
       * 
       * @param {Integer|String} parentId
       * @param {Integer|String} childId
       * @param {Object} node
       */
      NodeDictionary.prototype.add = function (parentId, nodeId, node) {
          if (!this.exists(parentId)) {
              throw new Error("The node \"" + nodeId + "\" does not have a parent node with id \"" + parentId + "\"");
          }

          if (this.exists(nodeId)) {
              return false;
              //throw new Error("The node \"" + nodeId + "\" is already exist");
          }

          //var extendedNode = $.extend(true, {}, node);

          // 1. Set parentId to node
          //extendedNode.parentId = parentId;            

          // 2. Add the nodeId to parent children list
          appendParentChild.call(this, parentId, nodeId);

          // 3. Add the node to nodes object
          //_(this).nodes[nodeId] = extendedNode;
          generateNode.call(this, nodeId, node);
      };

      NodeDictionary.prototype.addSubTree = function (parentId, subTree) {
          var normalizedSubTree = Array.isArray(subTree) ? normalizeNodesArray(subTree) : subTree;

          /*
          var parentNode = normalizedSubTree[parentId];
          if (parentNode) {
              var children = parentNode.children;

              if (children && children.length) {
                  for (var i = 0; i < children.length; i++) {
                      var childNodeId = children[i];

                      var childNode = subTree[childNodeId];
                      if (!childNode) {
                          throw new Error("The node \"" + parentId + "\" children list has the following child id \"" +
                                 childNodeId + "\", that does not exist in the passed sub tree");
                      }

                      // Append child node
                      this.add(parentId, childNodeId, childNode);

                      // Append child sub tree
                      this.addSubTree(childNodeId, subTree);
                  }
              }
          }
          */

          //var children = parentNode.children;
          var children = filter.call(this, normalizedSubTree, "parentId", parentId);

          if (children && children.length) {
              for (var i = 0; i < children.length; i++) {
                  var childNode = children[i];
                  var childNodeId = childNode.id;

                  // Append child node
                  this.add(parentId, childNodeId, childNode);

                  // Append child sub tree
                  this.addSubTree(childNodeId, normalizedSubTree);
              }
          }

          return normalizedSubTree;
      };

      NodeDictionary.prototype.removeSubTree = function (nodeId) {
          if (this.exists(nodeId)) {
              var node = this.get(nodeId);

              // 1. Remove all children recursively
              if (this.hasChildren(nodeId)) {
                  var children = node.children;

                  for (var i = 0; i < children.length; i++) {
                      this.removeSubTree(children[i]);
                  }
              }

              // 2. Delete the node itself from nodes object
              delete _(this).nodes[nodeId];

              // 3. Delete the nodeId from parent children list
              removeParentChild.call(this, node.parentId, nodeId);
          }
      };

      NodeDictionary.prototype.update = function (nodeId, obj) {
          if (this.exists(nodeId)) {
              var node = this.get(nodeId);

              for (var key in obj) {
                  if (key === "id" || key === "parentId") {
                      continue;
                  }

                  node[key] = obj[key];
              }
          }
      };

      NodeDictionary.prototype.exists = function (nodeId) {
          //return _(this).nodes.hasOwnProperty(nodeId);
          return !!_(this).nodes[nodeId];
      };

      NodeDictionary.prototype.get = function (nodeId) {
          return _(this).nodes[nodeId];
      };

      NodeDictionary.prototype.hasChildren = function (nodeId) {
          var hasChildren = false;

          if (this.exists(nodeId)) {
              var node = this.get(nodeId);
              hasChildren = node.children && node.children.length;
          }

          return hasChildren;
      };

      NodeDictionary.prototype.getParent = function (nodeId) {
          var parentNode;

          if (this.exists(nodeId)) {
              var node = this.get(nodeId);

              // Note: The only node that does not have a parent is the root node
              if (node.parentId) {
                  parentNode = this.get(node.parentId);
              }
          }

          return parentNode;
      };

      NodeDictionary.prototype.getChildren = function (nodeId) {
          var childrenNodes = [];

          if (this.exists(nodeId)) {
              var node = this.get(nodeId);

              var children = node.children;
              if (children && children.length) {
                  for (var i = 0; i < children.length; i++) {
                      var childId = children[i];
                      var childNode = this.get(childId);

                      //childrenNodes[childId] = childNode;
                      childrenNodes.push(childNode);
                  }
              }
          }

          return childrenNodes;
      };

      NodeDictionary.prototype.getAncestors = function (nodeId) {
          var ancestorsNodes = [];

          if (this.exists(nodeId)) {
              var node = this.get(nodeId);

              /*
              if (node.parentId) {
                  var parentNode = nodes[node.parentId];
              
                  // Add parent node to ancestorsNodes object
                  ancestorsNodes[node.parentId] = parentNode;
              
                  // Add parent node sub tree to ancestorsNodes object recursively
                  Object.assign(ancestorsNodes, this.getAncestors(node.parentId));
              }
              */

              var parentId = node.parentId;
              while (parentId) {
                  var parentNode = this.get(parentId);

                  // Add parent node to ancestorsNodes array
                  ancestorsNodes.push(parentNode);

                  // Change the parentId
                  parentId = parentNode.parentId;
              }
          }

          return ancestorsNodes;
      };

      NodeDictionary.prototype.getDescendent = function (nodeId) {
          var descendentNodes = {};

          if (this.exists(nodeId)) {
              var node = this.get(nodeId);

              var children = node.children;
              if (children && children.length) {
                  for (var i = 0; i < children.length; i++) {
                      var childId = children[i];
                      var childNode = this.get(childId);

                      // Add child node to descendentNodes object
                      descendentNodes[childId] = childNode;

                      // Add child node sub tree to descendentNodes object recursively
                      Object.assign(descendentNodes, this.getDescendent(childId));
                  }
              }
          }

          return descendentNodes;
      };

      NodeDictionary.prototype.sortChildren = function (nodeId, sortedChildren) {
          if (this.exists(nodeId)) {
              var node = this.get(nodeId);
              node.children = sortedChildren;
          }
      };

      return NodeDictionary;
  })();

  //#endregion ********************* NodeDictionary Class ***********************//


  //#region *************************** TreeCard Class **************************//

  var TreeCard = (function () {
      var priv = new WeakMap();
      var _ = function (instance) { return priv.get(instance); };

      function TreeCard(rootId, rootNode, container, options) {
          this.options = $.extend(true, {}, options);

          var privateMembers = {
              $container: container,
              rootId: rootId,
              levelsInstances: {},
              cardsInstances: {},
          };

          priv.set(this, privateMembers);

          // Initialize the TreeCard
          init.call(this, rootId, rootNode);
      }

      //#region ___________________________ Private Methods ___________________________

      var init = function (rootId, rootNode) {
          // Create root card
          // a. Create first level (root level)
          var rootLevelInstance = createLevel.call(this, -1, false);
          _(this).$container.append(rootLevelInstance.render());

          // b. Create root card class instance
          var rootCardInstance = createCard.call(this, -1, rootId, rootNode);

          // c. Append root card into level
          rootLevelInstance.appendCard(rootNode.id, rootCardInstance.render());
      };

      //#region _______________ Level Instance ______________

      var hasLevel = function (id) {
          return !!_(this).levelsInstances.hasOwnProperty(id);
      };

      var createLevel = function (id, sortableChildren) {
          var levelsInstances = _(this).levelsInstances;

          var levelInstance = new TreeLevel({
              rtl: this.options.rtl,
              resizeSensor: this.options.resizeSensor,
              id: id,
              levelNumber: Object.keys(levelsInstances).length + 1,
              sortableChildren: sortableChildren,
              onSort: this.options.onSort,
          });

          levelsInstances[id] = levelInstance;

          return levelInstance;
      };

      var removeLevel = function (id) {
          var levelsInstances = _(this).levelsInstances;
          var levelInstance = levelsInstances[id];

          // Destroy all children
          var cardIds = levelInstance.getLevelCardsIds();
          if (cardIds.length) {
              for (var i = 0; i < cardIds.length; i++) {
                  removeCard.call(this, cardIds[i]);
              }
          }

          // Destroy the level
          levelsInstances[id].destroy();
          delete levelsInstances[id];
      };

      var removeNextLevelsRecursively = function (parentId) {
          //$level = _(this).$level;
          //$level.nextAll('.tcv-level').remove();

          var levelInstance = getLevelInstance.call(this, parentId);
          if (levelInstance.hasNext()) {
              var nextLevelId = levelInstance.getNextLevelId();
              removeNextLevelsRecursively.call(this, nextLevelId);

              // Remove current level
              removeLevel.call(this, nextLevelId);
          }
      };

      var getLevelInstance = function (id) {
          return _(this).levelsInstances[id];
      };

      //#endregion ____________ Level Instance ______________


      //#region _______________ Card Instance _______________

      var hasCard = function (nodeId) {
          return !!_(this).cardsInstances.hasOwnProperty(nodeId);
      };

      var hasSortableChildren = function (nodeId) {
          return _(this).cardsInstances[nodeId].sortableChildren;
      };

      var createCard = function (parentId, nodeId, node) {
          var nodeOptions = $.extend(true, {}, {
              onBeforeActivate: onBeforeActivate.bind(this),
              onBeforeSelect: onBeforeSelect.bind(this),
              textTooltipLinesNumber: this.options.textTooltipLinesNumber,
          }, this.options);

          var cardInstance = new Card(parentId, nodeId, node, nodeOptions);
          _(this).cardsInstances[nodeId] = cardInstance;

          return cardInstance;
      };

      var removeCard = function (nodeId) {
          var cardsInstances = _(this).cardsInstances;

          //cardsInstances[nodeId].destroy();
          delete cardsInstances[nodeId];
      };

      var getCardInstance = function (nodeId) {
          return _(this).cardsInstances[nodeId];
      };

      var onBeforeActivate = function (e, obj) {
          var activeCardId = this.getActiveCardId();
          if (activeCardId) {
              getCardInstance.call(this, activeCardId).removeActivation();
          }
      };

      var onBeforeSelect = function (e, obj) {
          // Remove all levels
          removeNextLevelsRecursively.call(this, obj.parentId);


          // Get current level
          var levelInstance = getLevelInstance.call(this, obj.parentId);

          // Select card
          levelInstance.selectCard(obj.nodeId);

          // Remove the selected class from cards on the same level, and keep the selected 
          //  class for cards on the other levels.
          //var selectedLevelCardId = levelInstance.getSelectedCardId(); //TODO_NEMAH
          //if (selectedLevelCardId) {
          //    getCardInstance.call(this, selectedLevelCardId).removeSelection();
          //}
      };

      //#endregion ____________ Card Instance _______________


      //#endregion ________________________ Private Methods ___________________________


      TreeCard.prototype.addCard = function (parentId, nodeId, node) {
          // Check if the current node has parent node card
          if (hasCard.call(this, parentId)) {
              // Check if the current node does not rendered yet
              if (!hasCard.call(this, nodeId)) {
                  // Create level if not exist
                  var levelInstance;

                  // If the parent card is created and this card does not have children level, 
                  // so, we must first, create a level, then render the child node.
                  if (!hasLevel.call(this, parentId)) {
                      var sortableChildren = hasSortableChildren.call(this, parentId);

                      levelInstance = createLevel.call(this, parentId, sortableChildren);
                      _(this).$container.append(levelInstance.render());
                  }
                  else {
                      levelInstance = getLevelInstance.call(this, parentId);
                  }

                  // Create card class instance
                  var cardInstance = createCard.call(this, parentId, nodeId, node);

                  // Append card into level
                  levelInstance.appendCard(nodeId, cardInstance.render());
              }
          }
      };

      TreeCard.prototype.removeSubTree = function (nodeId) {
          if (hasCard.call(this, nodeId)) {
              var cardInstance = getCardInstance.call(this, nodeId);
              var levelInstance = getLevelInstance.call(this, cardInstance.parentId);

              // 1. If this card has children level remove it before removing the card itself
              if (cardInstance.isSelected && hasLevel.call(this, nodeId)) {
                  removeNextLevelsRecursively.call(this, cardInstance.parentId);
              }

              // 2. Workaround: We should destroy the level carousel before remove a card
              //levelInstance.destroyCarousel();

              // 3. Remove the card
              levelInstance.removeCard(nodeId);
              removeCard.call(this, nodeId);

              // 4. Check if level becomes empty after removing the card
              if (levelInstance.isEmpty) {
                  // If yes, remove the level
                  removeLevel.call(this, cardInstance.parentId);
              }
              else {
                  // Workaround: If no, reCreate the carousel, after destroy it and remove the card
                  levelInstance.refresh();
              }
          }
      };

      TreeCard.prototype.hasCard = function (nodeId) {
          return hasCard.call(this, nodeId);
      };

      TreeCard.prototype.updateText = function (nodeId, text) {
          if (hasCard.call(this, nodeId)) {
              getCardInstance.call(this, nodeId).updateText(text);
          }
      };

      TreeCard.prototype.updateImage = function (nodeId, image) {
          if (hasCard.call(this, nodeId)) {
              getCardInstance.call(this, nodeId).updateImage(image);
          }
      };

      TreeCard.prototype.isCardSelected = function (nodeId) {
          return getCardInstance.call(this, nodeId).isSelected;
      };

      TreeCard.prototype.selectCard = function (nodeId) {
          getCardInstance.call(this, nodeId).select();
      };

      TreeCard.prototype.activateCard = function (nodeId) {
          var cardInstance = getCardInstance.call(this, nodeId);
          var levelInstance = getLevelInstance.call(this, cardInstance.parentId);

          // Activate card
          cardInstance.activate();

          // Slide to activated card
          levelInstance.slideToCard(nodeId);
      };

      TreeCard.prototype.hasChildren = function (nodeId) {
          return hasLevel.call(this, nodeId);
      };

      TreeCard.prototype.getSelectedChildId = function (nodeId) {
          var selectedChildId;

          if (hasLevel.call(this, nodeId)) {
              selectedChildId = getLevelInstance.call(this, nodeId).getSelectedCardId();
          }

          return selectedChildId;
      };

      TreeCard.prototype.getActiveCardId = function () {
          var activeCardId;

          var cardsInstances = _(this).cardsInstances;
          for (var cardId in cardsInstances) {
              if (cardsInstances[cardId].isActive) {
                  activeCardId = cardId;
                  break;
              }
          }

          return activeCardId;
      };

      TreeCard.prototype.getActivePath = function () {
          // Note: We want to return active path ordered by "level number" from top to bottom
          var activePathIds = [];

          var levelsInstances = _(this).levelsInstances;

          // Save the active card id
          var activeCardId;

          // Save the level number and selected card id inside that level
          var levelNumberToSelectedCardId = {};

          for (var levelId in levelsInstances) {
              var levelInstance = levelsInstances[levelId];

              // Get selected card id inside a level
              var selectedCardId = levelInstance.getSelectedCardId();
              if (selectedCardId) {
                  // Save the level number and selected card id inside it
                  levelNumberToSelectedCardId[levelInstance.levelNumber] =
                      levelInstance.getSelectedCardId();

                  // Save the active card id
                  if (getCardInstance.call(this, selectedCardId).isActive) {
                      activeCardId = selectedCardId;
                  }
              }
          }


          var numberOfLevels = Object.keys(levelNumberToSelectedCardId).length;
          for (var i = 1; i <= numberOfLevels; i++) {
              // Get selected card id by level number from top to bottom
              var cardId = levelNumberToSelectedCardId[i];
              activePathIds.push(cardId);

              // If the card is active, break the loop
              if (cardId === activeCardId) {
                  break;
              }
          }

          return activePathIds;
      };

      //TreeCard.prototype.getCarouselWidth = function () {
      //    var levelInstance = getLevelInstance.call(this, -1);
      //    return levelInstance.getCarouselWidth();
      //};

      TreeCard.prototype.refreshLevelsCarousel = function () {
          var levelsInstances = _(this).levelsInstances;

          for (var levelId in levelsInstances) {
              var levelInstance = levelsInstances[levelId];
              levelInstance.refreshVisibleItems();
          }
      };

      //TreeCard.prototype.updateCarouselVisibleItems = function (id, itemsCount) {
      //    if (hasLevel.call(this, id)) {
      //        getLevelInstance.call(this, id).updateCarouselVisibleItems(itemsCount);
      //    }
      //};

      return TreeCard;
  })();

  //#endregion ************************ TreeCard Class **************************//


  //#region ************************** TreeLevel Class **************************//

  var TreeLevel = (function () {
      var priv = new WeakMap();
      var _ = function (instance) { return priv.get(instance); };

      function TreeLevel(options) {
          this.options = $.extend(true, {}, options);

          var privateMembers = {
              $level: null,
              carouselInstance: null,
          };

          priv.set(this, privateMembers);

          // Initialize the TreeLevel
          init.call(this);
      }

      //#region ___________________________ Private Methods ___________________________

      var init = function () {
          // Create level and carousel
          var $level = _(this).$level = createLevel.call(this);

          // Create carousel
          var $carouselWrap = $("<div>").addClass("tcv-level-carousel-wrap");
          // Append $carouselWrap inside level
          $level.append($carouselWrap);

          var me = this;
          var carouselInstance = _(this).carouselInstance = new Specto.ui.ResponsiveCarousel($carouselWrap, {
              rtl: this.options.rtl,
              resizeSensor: this.options.resizeSensor,
              carouselClass: "tcv-level-carousel",
              selectedCardClass: "tcv-card--selected",
              onAfterCreate: function ($carousel) {
                  // Mark level carousel stage as sortable, allowing the sorting of current level nodes
                  if (me.options.sortableChildren) {
                      var $owlStage = $carousel.find(".owl-stage");
                      applySortableCarousel.call(me, $owlStage);
                  }
              },
          });

          // Append $carousel inside level
          //$level.append(carouselInstance.render());
      };

      //#region _______________ Level Creation ______________

      var createLevel = function () {
          // Create level
          var $level = $("<div>")
                          .addClass("tcv-level")
                          .addClass("d-flex")
                          .data({
                              "level-num": this.options.levelNumber,
                              "parent-id": this.options.id
                          });

          if (this.options.sortableChildren) {
              $level.addClass("tcv-level--sortable");
          }

          return $level;
      };

      //#endregion ____________ Level Creation ______________


      //#region _______________ Sortable Cards ______________

      var applySortableCarousel = function ($owlStage) {
          var me = this;
          $owlStage.sortable({
              start: function (e, ui) {
                  ui.item.addClass("tcv-owl-item-sorting");
              },
              stop: function (e, ui) {
                  ui.item.removeClass("tcv-owl-item-sorting");
              },
              update: function (e, ui) {
                  // Get the sorted node ids
                  var sortedNodesIds = [];
                  $(this).sortable('refreshPositions').children().each(function () {
                      sortedNodesIds.push($(this).find("> .tcv-card").data("id"));
                  });

                  var $movedCard = ui.item.find("> .tcv-card");

                  // Callback the onSort function
                  me.options.onSort(e, {
                      context: $movedCard,
                      parentId: me.options.id,
                      movedNodeId: $movedCard.data("id"),
                      sortedNodesIds: sortedNodesIds,
                  });
              }
          });
      };

      //#endregion ____________ Sortable Cards ______________

      //#endregion ________________________ Private Methods ___________________________


      TreeLevel.prototype.render = function () {
          return _(this).$level;
      };

      TreeLevel.prototype.destroy = function () {
          _(this).carouselInstance.destroy();
          _(this).$level.remove();
      };

      TreeLevel.prototype.appendCard = function (id, $node) {
          _(this).carouselInstance.addCard(id, $node);
      };

      TreeLevel.prototype.removeCard = function (id) {
          _(this).carouselInstance.removeCard(id);
      };

      TreeLevel.prototype.selectCard = function (cardId) {
          _(this).carouselInstance.selectCard(cardId);
      };

      //TreeLevel.prototype.destroyCarousel = function () {
      //    _(this).carouselInstance.destroy();
      //};

      TreeLevel.prototype.refresh = function () {
          _(this).carouselInstance.refresh();
      };

      //TreeLevel.prototype.getCarouselWidth = function () {
      //    return _(this).carouselInstance.getCarouselWidth();
      //};

      //TreeLevel.prototype.updateCarouselVisibleItems = function (itemsCount) {
      //    _(this).carouselInstance.updateVisibleItems(itemsCount);
      //};

      TreeLevel.prototype.refreshVisibleItems = function () {
          _(this).carouselInstance.refreshVisibleItems();
      };

      TreeLevel.prototype.slideToCard = function (nodeId) {
          //var $level = _(this).$level;

          //// Find card
          //var $card = $level.find(".tcv-card").filter(function () {
          //    return $(this).data("id") === nodeId;
          //});

          //// Card slide/item index
          //var cardSlideIndex = $card.closest(".owl-item").index();
          //$level.find("> .tcv-level-carousel").trigger("to.owl.carousel", cardSlideIndex);

          _(this).carouselInstance.slideToCard(nodeId);
      };

      TreeLevel.prototype.getLevelCardsIds = function () {
          var cardIds = [];

          _(this).$level.find(".tcv-card").each(function () {
              cardIds.push($(this).data("id"));
          });

          return cardIds;
      };

      TreeLevel.prototype.getSelectedCardId = function () {
          return _(this).$level.find(".tcv-card.tcv-card--selected").data("id");
      };

      TreeLevel.prototype.hasNext = function () {
          return _(this).$level.next('.tcv-level').length > 0;
      };

      TreeLevel.prototype.getNextLevelId = function () {
          return _(this).$level.next('.tcv-level').data("parent-id");
      };

      TreeLevel.prototype.getCardsCount = function () {
          return _(this).$level.find(".tcv-card").length;
      };

      // Create a read-only property: isEmpty
      Object.defineProperty(TreeLevel.prototype, "isEmpty", {
          get: function () {
              return this.getCardsCount() === 0;
          }
      });

      // Create a read-only property: levelNumber
      Object.defineProperty(TreeLevel.prototype, "levelNumber", {
          get: function () {
              return this.options.levelNumber;
          }
      });

      return TreeLevel;
  })();

  //#endregion *********************** TreeLevel Class **************************//


  //#region ***************************** Card Class ****************************//

  var Card = (function () {
      var defaults = {

      };

      var priv = new WeakMap();
      var _ = function (instance) { return priv.get(instance); };

      function Card(parentId, nodeId, node, options) {
          this.options = $.extend(true, {}, options);

          var privateMembers = {
              parentId: parentId,
              nodeId: nodeId,
              $node: null,
              sortableChildren: node.sortableChildren
          };

          priv.set(this, privateMembers);

          // Initialize the Card
          init.call(this, nodeId, node);
      }

      //#region ___________________________ Private Methods ___________________________

      var init = function (nodeId, node) {
          _(this).$node = createCard.call(this, nodeId, node);
      };

      //#region _______________ Shared Methods ______________

      var onActionClick = function (e, action) {
          this.activate(e);

          if (this.options.onActionClick && $.isFunction(this.options.onActionClick)) {
              this.options.onActionClick(e, action, generateCallbackArguments.call(this));
          }
      };

      var generateDeleteActionObject = function () {
          return {
              iconClass: this.options.deleteIcon,
              text: this.options.localizer["DELETE"],
              callback: this.options.onDelete
          };
      };

      var generateCallbackArguments = function () {
          return {
              context: _(this).$node,
              parentId: _(this).parentId,
              nodeId: _(this).nodeId,
          }
      };

      //#endregion ____________ Shared Methods ______________


      //#region _______________ Card Creation _______________

      var createCard = function (nodeId, node) {
          var me = this;

          // Create node card
          var $node = $("<div>")
                          .addClass("tcv-card")
                          .addClass("card")
                          .data("id", nodeId)
                          .attr("data-key", nodeId)
                          .click(function (e) {
                              me.activate(e);
                          })
                          .contextmenu(function (e) {
                              me.activate(e);
                          });


          // a. Create node image
          renderCardImage.call(this, node.image, $node);

          // b. Create node text
          renderCardText.call(this, node.text, $node);

          // c. Create node toolbar
          var $toolbar = createCardToolbar.call(this, node);
          $node.append($toolbar);

          // d. Create node context menu
          createCardContextMenu.call(this, node);

          return $node;
      };

      var renderCardImage = function (image, $node) {
          var $imageWrap = $("<div>")
                              .addClass("tcv-card-img-wrap")
                              .appendTo($node);

          var $imageWrapInner = $("<div>")
                                  .addClass("tcv-card-img-wrap-inner")
                                  .appendTo($imageWrap);

          var $image = $("<img>")
                          .addClass("tcv-card-img")
                          .addClass("img-fluid")
                          .attr({ "src": image, alt: this.options.localizer["ALT_IMAGE"] })
                          .appendTo($imageWrapInner);
      };

      var renderCardText = function (text, $node) {
          var $textWrap = $("<div>")
                              .addClass("tcv-card-txt-wrap")
                              .appendTo($node);

          var $text = $("<span>")
                          .addClass("tcv-card-txt")
                          .addClass("fw-700 text-center")
                          .html(text)
                          .appendTo($textWrap);

          if (this.options.textTooltipLinesNumber) {
              $text.addClass("tcv-card-txt--ellipsis-line-" + this.options.textTooltipLinesNumber);
              $text.tooltipOnOverflow({ ellipsisLines: this.options.textTooltipLinesNumber });
          }
      };


      //#endregion ____________ Card Creation _______________


      //#region _______________ Toolbar Items _______________

      var createCardToolbar = function (node) {
          var $toolbar = $('<div>').addClass('tcv-tool-bar');

          var me = this;
          // 1. Render delete icon
          if (node.allowDelete) {
              var $deleteToolbarItem = createToolbarItem.call(this, generateDeleteActionObject.call(this), node);
              $deleteToolbarItem
                  .addClass("delete-icon")
                  .appendTo($toolbar);
          }

          // 2. Render toolbar actions
          if (node.actions && node.actions) {
              // Get only showInBar actions
              var barActions = node.actions.filter(a => a.showInBar);

              if (barActions && barActions.length) {
                  for (var i = 0; i < barActions.length; i++) {
                      $toolbar.append(createToolbarItem.call(this, barActions[i], node));
                  }
              }
          }

          return $toolbar;
      };

      var createToolbarItem = function (action, node) {
          var $outerIcon = $('<a href="javascript:void(0);">')
                              .addClass('tcv-tool-bar-icon')
                              .addClass('btn btn-primary btn-icon')
                              .addClass('rounded-circle waves-effect waves-themed mb-1')
                              .attr({
                                  "data-toggle": "tooltip",
                                  "title": action.text
                              });

          let isList = action.iconClass.constructor === Array;
          if (action.iconClass.constructor === Array) {
            for (let i = 0; i< action.iconClass.length; i++) {
                appendToolbarIcon.call(this, $outerIcon, action.iconClass[i]);
            }
          }
          else {
            appendToolbarIcon.call(this, $outerIcon, action.iconClass);
          }

          // Call action callback function
          var me = this;
          $outerIcon.click(function (e) {
              e.stopPropagation();
              onActionClick.call(me, e, action);
          });

          return $outerIcon;
      };

      var appendToolbarIcon = function ($container, iconClass) {
        var $innerIcon = $("<i>")
            .addClass(iconClass)
            .appendTo($container);
      };

      //#endregion ____________ Toolbar Items _______________


      //#region ________________ Context Menu _______________

      var createCardContextMenu = function (node) {
          var contextMenuItems = createContextMenuItems.call(this, node);

          if (contextMenuItems && Object.keys(contextMenuItems).length) {
              $.contextMenu({
                  // define which elements trigger this menu
                  selector: ".tcv-card[data-key='" + node.id + "']",
                  //appendTo: $node,
                  //delay: 500,
                  // define the elements of the menu
                  //items: contextMenuItems
                  build: function ($trigger, e) {
                      // this callback is executed every time the menu is to be shown
                      // its results are destroyed every time the menu is hidden
                      // e is the original contextmenu event, containing e.pageX and e.pageY (amongst other data)
                      return {
                          items: contextMenuItems
                      };
                  },
                  // there's more, have a look at the demos and docs...
              });
          }
      };

      var createContextMenuItems = function (node) {
          var contextMenuItems = {};

          var me = this;
          // 1. Render delete icon
          if (node.allowDelete) {
              var deleteContextMenuItem = createContextMenuItem.call(this,
                  generateDeleteActionObject.call(this), node);
              contextMenuItems[deleteContextMenuItem.name] = deleteContextMenuItem;
          }

          // 2. Render toolbar actions
          if (node.actions && node.actions) {
              // Get only showInBar actions
              var menuActions = node.actions.filter(a => a.showInMenu);

              if (menuActions && menuActions.length) {
                  for (var i = 0; i < menuActions.length; i++) {
                      var contextMenuItem = createContextMenuItem.call(this, menuActions[i], node);
                      contextMenuItems[contextMenuItem.name] = contextMenuItem;
                  }
              }
          }

          return contextMenuItems;
      };

      var createContextMenuItem = function (action, node) {
          var me = this;
          return {
              name: action.text,
              icon: function (opt, $itemElement, itemKey, item) {
                  // Set the content to the menu trigger selector and add an bootstrap icon to the item.
                  //$itemElement.html('<i class="tcv-context-menu-icon fa fa-edit"></i>' + item.name);
                  var $icon = $("<i>")
                                  .addClass("tcv-context-menu-icon")
                                  .addClass(action.iconClass);

                  $itemElement
                      .empty()
                      .append($icon)
                      .append(action.text);

                  // Add the context-menu-icon-updated class to the item
                  return 'tcv-context-menu';
              },
              callback: function (itemKey, opt, e) {
                  // Alert the key of the item and the trigger element's id.
                  //alert("Clicked on " + itemKey + " on element " + opt.$trigger.id);
                  onActionClick.call(me, e, action);

                  // Do not close the menu after clicking an item
                  //return false;
              }
          };
      };

      //#endregion _____________ Context Menu _______________

      //#endregion ________________________ Private Methods ___________________________


      Card.prototype.render = function () {
          return _(this).$node;
      };

      Card.prototype.destroy = function () {
          _(this).$node.remove();
      };

      Card.prototype.updateText = function (text) {
          _(this).$node.find(".tcv-card-txt").html(text);
      };

      Card.prototype.updateImage = function (image) {
          _(this).$node.find(".tcv-card-img").attr("src", image);
      };

      Card.prototype.select = function (e) {
          var callbackObject = generateCallbackArguments.call(this);

          this.options.onBeforeSelect(e, callbackObject);

          // Select the current card
          //_(this).$node.addClass("tcv-card--selected"); // TODO_NEMAH

          this.options.onAfterSelect(e, callbackObject);
      };

      Card.prototype.activate = function (e) {
          if (!this.isSelected) {
              this.select(e);
          }

          var callbackObject = generateCallbackArguments.call(this);

          this.options.onBeforeActivate(e, callbackObject);

          // Activate the current card
          _(this).$node.addClass("tcv-card--active");

          this.options.onAfterActivate(e, callbackObject);
      };

      //Card.prototype.removeSelection = function () { // TODO_NEMAH
      //    _(this).$node.removeClass("tcv-card--selected");
      //};

      Card.prototype.removeActivation = function () {
          _(this).$node.removeClass("tcv-card--active");
      };

      // Create a read-only property: parentId
      Object.defineProperty(Card.prototype, "parentId", {
          get: function () {
              return _(this).parentId;
          }
      });

      // Create a read-only property: isSelected
      Object.defineProperty(Card.prototype, "isSelected", {
          get: function () {
              return _(this).$node.hasClass("tcv-card--selected");
          }
      });

      // Create a read-only property: isActive
      Object.defineProperty(Card.prototype, "isActive", {
          get: function () {
              return _(this).$node.hasClass("tcv-card--active");
          }
      });

      Object.defineProperty(Card.prototype, "sortableChildren", {
          get: function () {
              return !!_(this).sortableChildren;
          }
      });

      return Card;
  })();

  //#endregion ************************** Card Class ****************************//


  //#region *************************** jQuery Plugin ***************************//

  var pluginName = "treeCardViewer";

  $.fn[pluginName] = function (param) {
      // All methods that should return the element
      var thisMethods = ['appendNode', 'appendNodes', 'updateNode', 'deleteNode', 'expandAll',
                          'activateNode', 'showDetailsSlider', 'hideDetailsSlider'];

      if (typeof param === 'object') {
          return this.each(function () {
              // Destroy created TreeCardViewer
              if ($.data(this, pluginName)) {
                  var instance = $(this).data(pluginName);
                  instance.destroy();
              }
              // Create a new instance of TreeCardViewer
              $.data(this, pluginName, new Specto.ui.TreeCardViewer(this, param));
          });
      }
      else if (typeof param === 'string') {
          // Get  main function argument values
          var args = Array.prototype.slice.call(arguments, 1);

          var returnValue;

          this.each(function () {
              var instance = $(this).data(pluginName);

              //if (instance == null && window.console && console.error) {
              if (instance === null) {
                  console.error('The ' + pluginName + '(\'' + param + '\') method was called on an '
                                  + 'element that is not using ' + pluginName + '.');
              }

              // Return current control instance
              if (param === 'instance') {
                  returnValue = instance;
              }
              else {

                  // Remove the instance from element data
                  if (param === 'destroy') {
                      $.data(this, pluginName, null);
                  }

                  // Call the method
                  returnValue = instance[param].apply(instance, args);
              }
          });

          // Check if we should be returning `this`
          if ($.inArray(param, thisMethods) > -1) {
              return this;
          }

          return returnValue;
      }
      else {
          throw new Error('Invalid arguments for ' + pluginName + ': ' + param);
      }
  };

  //#endregion ************************ jQuery Plugin ***************************//
})();

(function () {
    this.Specto = this.Specto || {};
    this.Specto.ui = this.Specto.ui || {};
    Specto.ui.defaults = Specto.ui.defaults || {};
    var ns = this.Specto.ui;

    /***************************************************************************************************/
    /******************************************* Table View ********************************************/

    /*
        options: {
            rtl: true/false(default),
            showRowNumber: true/false(default),
            showStickyHeader: true/false(default),
            scrollable: {
                enabled: true/false(default),
                height:..,
            },
            clientSideFiltering: true,
            columns: [{
                dataField: "ColumnKey",
                dataType: "date",
                caption: "",
                sortOrder: "asc",


                // ********** TODO_N ********** //
                //width: ..,
                //alignment: "left/right/center",
                //dataType: "",
                }
            ],
            dataSource: [
                { Key(columnName-"dataField"): value }
            ],
            masterDetail: {
                enabled: true/false(default),
                key: columnKey,
                template: function(container, options) { } // options is an object { data:.., key:.. }
            },
            paging: {
                enabled: true(default)/false,
                pageSize: 10,
                pageIndex: 1,
                pagesPerPartition: 8,
            },
            columnChooser: {
                enabled: true/false,
            },
            sorting: {
                mode: "single" // or "multiple" | "none"
            },
            



            // ********** TODO_N ********** //
            //columnsAutoWidth: true, //TODO
            //allowColumnReordering:false, //TODO
            //allowColumnResizing:false, //TODO
        }

        IMPORTANT NOTE: (The following js files are required and must be imported before this class)
          PagingEdit.js
          jquery.mCustomScrollbar.concat.min.js


    */
    ns.TableView = (function () {
        var defaults = $.extend({}, {
            localizer: {
                COLUMN_CHOOSER: "Column Chooser",
                OK: "Ok"
            },
            tableClassName: "table-bordered", //table-striped // bootstrap 4
            borderlessTableClassName: "table table-borderless",
            tableHoverClassName: "table-hover",
            thScopeClassName: "col", // bootstrap 4
            columnChooserClassName: "fa fa-server", // font-awesome-5
            triangleRightIcon: "fa fa-caret-right",
            triangleDownIcon: "fa fa-caret-down",
            sortingAscIcon: "fa fa-sort-alpha-up-alt", // font-awesome-5
            sortingDescIcon: "fa fa-sort-alpha-down-alt", // font-awesome-5
            rtl: false,
            showRowNumber: false,
            showStickyHeader: false,
            scrollable: {
                enabled: false,
            },
            clientSideFiltering: true,
            columns: [],
            dataSource: [],
            masterDetail: {
                enabled: false,
                template: null
            },
            paging: {
                enabled: true,
                pageSize: 10,
                pageIndex: 1,
                pagesPerPartition: 8,
                //TODO_N: Move this localizer to paging file
                localizer: {
                    FIRST: "First",
                    PREV: "Prev",
                    NEXT: "Next",
                    LAST: "Last",
                    NUMBER_OF_ITEMS_PER_PAGE: "Number of items per page"
                },
            },
            columnChooser: {
                enabled: false,
            },
            sorting: {
                mode: "none",
            },
        }, Specto.ui.defaults.TableView);

        var priv = new WeakMap();
        var _ = function (instance) { return priv.get(instance); };

        function TableView(gridContainer, options) {

            // When use $.extend, if the second object contains null or 0, those two values override the 
            //  default values from the first object, but the undefined does not. So, for this reason, 
            //  we use our created $.customExtend instead of $.extend.
            this.options = $.customExtend(true, {}, defaults, options);

            var privateMembers = {
                $gridContainer: $(gridContainer),
                $headersTable: null,
                $table: null,
                pagingInstance: null,
                columnChooserList: [], // This array contains all shown columns (by default all columns are shown)
            };

            priv.set(this, privateMembers);

            // Initialize the TableView
            init.call(this);
        }

        var init = function () {
            // Mark all columns as shown by default
            initColumnChooserList.call(this);

            //// Create main container
            //var $control = $("<div>")
            //                    .addClass("tblv")
            //                    .appendTo(_(this).$gridContainer);

            //if (this.options.rtl) {
            //    $control.addClass("tblv-rtl");
            //}

            // 1. Render table actions
            renderTableActions.call(this, _(this).$gridContainer);

            // 2. Render table (create 2 separates tables one for header and the other for content if scrollable option is true)
            //renderTable.call(this, $control);
            renderTable.call(this, _(this).$gridContainer);

            // 3. Create paging
            if (isPagingEnabled.call(this)) {
                var pagingInstance = _(this).pagingInstance = createPaging.call(this);
                //pagingInstance.renderOn($control);
                pagingInstance.renderOn(_(this).$gridContainer);
            }
            else {
                renderFilterRows.call(this, this.options.dataSource);
            }

            // _(this).$table.dataTable(
            //     {
            //         // responsive: true,
            //         // fixedHeader: true,
            //         paging: isPagingEnabled.call(this),
            //         // blurable: false,
            //         // keys: true,
            //         // stateSave: true,
            //         filter: false, //for demo purpose only
            //         lengthChange: false, //for demo purpose only
            //         scrollX: true
            //     });
        };

        //#region ___________________________ Private Methods ___________________________

        var allowDisplayColumn = function (column) {
            return column.display !== false;
        };

        var isPagingEnabled = function () {
            return this.options.paging && this.options.paging.enabled;
        };

        var isMasterDetailEnabled = function () {
            return this.options.masterDetail && this.options.masterDetail.enabled;
        };

        var isColumnChooserEnabled = function () {
            return this.options.columnChooser && this.options.columnChooser.enabled;
        };

        var isSortingEnabled = function () {
            return this.options.sorting && this.options.sorting.mode !== "none";
        };

        var isScrollbarEnabled = function () {
            //return this.options.scrollbar && this.options.scrollbar.enabled;
            return this.options.scrollable && this.options.scrollable.enabled;
        };

        var displayRowNumber = function () {
            return this.options.showRowNumber;
        };

        var showStickyHeader = function () {
            return this.options.showStickyHeader;
        };

        //#region _______________ Table Actions _______________

        var renderTableActions = function ($container) {
            var $actionsContainer = $("<div>")
                .addClass("tblv-tbl-actions")
                .appendTo($container);

            // Create column chooser button
            if (isColumnChooserEnabled.call(this)) {
                var $columnChooserBtn = createColumnChooserBtn.call(this);
                $actionsContainer.append($columnChooserBtn);
            }
        };

        //#endregion ____________ Table Actions _______________


        //#region _______________ Table Creation ______________

        var renderTable = function ($container) {
            // Create table wrapper
            var $tableWrapper = _(this).$table = $("<table>")
                .addClass("table table-responsive table-bordered table-hover table-striped w-100");
            $tableWrapper.appendTo($container);

            // a. Create headers
            var $headersWrapper = $("<thead>").addClass("thead-dark").appendTo($tableWrapper);
            var $headersTable = _(this).$headersTable = createHeadersTable.call(this);
            $headersWrapper.append($headersTable);

            // b. Create data source
            var $contentTableWrapper = $("<tbody>")
                .appendTo($tableWrapper);

            // // Create table wrapper
            // var $tableWrapper = $("<div>");
            // $tableWrapper.appendTo($container);

            // if (!isScrollbarEnabled.call(this)) {
            //     var $table = _(this).$table = createTable.call(this);
            //     $tableWrapper.append($table);

            //     //TODO_N: Remove this line, this is a dummy table only used dor seach elements inside it
            //     _(this).$headersTable = $("<div>");
            // }
            // else {
            //     // a. Create headers table
            //     var $headersTableWrapper = $("<div>").appendTo($tableWrapper);
            //     var $headersTable = _(this).$headersTable = createHeadersTable.call(this);
            //     $headersTableWrapper.append($headersTable);

            //     // b. Create data source table
            //     var $contentTableWrapper = $("<div>")
            //         .addClass("tblv-tbl-content-wrap")
            //         .addClass("dx-datagrid-rowsview dx-datagrid-nowrap dx-scrollable dx-scrollable-both dx-scrollable-simulated")
            //         .appendTo($tableWrapper);

            //     var $scrollableWrapper = $("<div>").addClass("dx-scrollable-wrapper").appendTo($contentTableWrapper);

            //     var $scrollable = $("<div>").addClass("dx-scrollable-container")
            //         //.addClass("scroll")
            //         .appendTo($scrollableWrapper);

            //     if (this.options.scrollable.height) {
            //         $scrollable.css("height", this.options.scrollable.height);
            //     }

            //     //$scrollable.mCustomScrollbar();
            //     //$(window).on("load", function () {
            //     //    $scrollable.mCustomScrollbar({ theme: "minimal-dark" });
            //     //});
            //     $(document).ready(function () {
            //         setTimeout(function () {
            //             $scrollable.mCustomScrollbar({ theme: "minimal-dark" });
            //         }, 100);
            //     $('.td').removeClass('m-auto');
            //     });

            //     var $scrollableContent = $("<div>").addClass("dx-scrollable-content").appendTo($scrollable);

            //     var $content = $("<div>").addClass("dx-datagrid-content").appendTo($scrollableContent);

            //     var $contentTable = _(this).$table = createContentTable.call(this);
            //     $content.append($contentTable);

            //     var scrollbarH = $('<div class="dx-scrollable-scrollbar dx-widget dx-scrollbar-horizontal dx-scrollbar-hoverable" style="display: none;"><div class="dx-scrollable-scroll dx-state-invisible" style="width: 1297px; transform: translate(0px, 0px);"><div class="dx-scrollable-scroll-content"></div></div></div>');
            //     var scollbarV = $('<div class="dx-scrollable-scrollbar dx-widget dx-scrollbar-vertical dx-scrollbar-hoverable" style=""><div class="dx-scrollable-scroll dx-state-invisible" style="height: 272px; transform: translate(0px, 130px);"><div class="dx-scrollable-scroll-content"></div></div></div>');

            //     $scrollable.append(scrollbarH).append(scollbarV);
            // }
        };

        var createTable = function () {
            // Create table
            var $table = $("<div>")
                .addClass("tblv-tbl-content")
                .addClass(this.options.tableClassName);
            //.addClass(this.options.borderlessTableClassName)
            //.addClass(this.options.tableHoverClassName);

            if (showStickyHeader.call(this)) {
                $table.addClass("tblv-sticky-tbl");

                window.onscroll = function () { myFunction() };

                var $thList;
                var sticky;

                $(document).ready(function () {
                    $thList = $table.find("> .thead > .tr > .th");
                    sticky = $thList.offset().top;
                });

                function myFunction() {
                    if (window.pageYOffset > sticky) {
                        $thList.addClass("tblv-sticky-tbl");
                    } else {
                        $thList.removeClass("tblv-sticky-tbl");
                    }
                }
            }

            // Create column group
            // var $columnGroup = createColumnGroup.call(this);
            // $columnGroup.appendTo($table);

            // 1. Create header
            var $thead = $("<div>").addClass('thead table-view-thead').appendTo($table);

            var $headTr = createHeaderRow.call(this);
            $thead.append($headTr);

            // 2. Create rows
            var $tbody = $("<div>").addClass('tbody').appendTo($table);

            return $table;
        };

        var createHeadersTable = function () {
            var $headTr = createHeaderRow.call(this);
            return $headTr;
            // // Create table
            // var $headersTable = $("<div>")
            //                         .addClass(this.options.tableClassName);

            // if (showStickyHeader.call(this)) {
            //     $headersTable.addClass("tblv-sticky-tbl");
            // }

            // // Create column group
            // // var $columnGroup = createColumnGroup.call(this);
            // // $columnGroup.appendTo($headersTable);

            // // Create header
            // var $thead = $("<div>").addClass('thead table-view-thead').appendTo($headersTable);

            // var $headTr = createHeaderRow.call(this);
            // $thead.append($headTr);

            // return $headersTable;
        };

        var createContentTable = function () {
            // Create table
            var $contentTable = $("<div>")
                .addClass("table tblv-tbl-content dx-datagrid-table dx-datagrid-table-fixed")
                .addClass(this.options.tableClassName);
            //.addClass(this.options.borderlessTableClassName);
            //.addClass(this.options.tableHoverClassName);

            // Create column group
            var $columnGroup = createColumnGroup.call(this);
            $columnGroup.appendTo($contentTable);

            // Create rows
            var $tbody = $("<div>").addClass('tbody').appendTo($contentTable);

            return $contentTable;
        };

        var createColumnGroup = function () {
            var $columnGroup = $("<colgroup>");

            var columns = this.options.columns;

            if (isMasterDetailEnabled.call(this)) {
                $columnGroup.append($("<col>").attr("style", "width: 40px;"));
            }

            if (displayRowNumber.call(this)) {
                $columnGroup.append($("<col>").attr("style", "width: 50px;"));
            }

            for (var c = 0; c < columns.length; c++) {
                if (allowDisplayColumn.call(this, columns[c])) {
                    var columnWidth = columns[c].width || "auto" + ";";
                    $("<col>")
                        .attr("style", "width: " + columnWidth)
                        .data("col-group-for", columns[c].dataField)
                        .appendTo($columnGroup);
                }
            }

            return $columnGroup;
        };

        //#region _______ Table Header _______

        var createHeaderCell = function (data, dataField) {
            var $th = $("<th>")
                .addClass('align-top text-center')
                .html(data);

            if (dataField) {
                $th.data("data-field", dataField);
            }
            return $th;
            // var $th = $("<div>")
            //             .addClass('col-lg td table-td text-center px-2')
            //             .attr("scope", this.options.thScopeClassName)
            //             .html(data);

            // if (dataField) {
            //     $th.data("data-field", dataField);
            // }

            // return $th;
        };

        var createHeaderRow = function () {
            var $headTr = $("<tr>");
            // Create columns from options
            var columns = this.options.columns;
            for (var c = 0; c < columns.length; c++) {
                if (allowDisplayColumn.call(this, columns[c])) {
                    var $cell = createHeaderCell.call(this, columns[c].caption, columns[c].dataField);

                    // Create sort icon only if the current column has sortOrder option 
                    //  and the sorting is enabled on the general options
                    if (columns[c].sortOrder && allowSorting) {
                        var $sortIcon = createSortingIcon.call(this, columns[c].sortOrder);
                        $cell.append($sortIcon);
                    }

                    $headTr.append($cell);
                }
            }

            return $headTr;
            // var $headTr = $("<div>")
            //   .css({
            //     'line-height': '14px',
            //     'background': '#f2f2f2',
            //     'padding': '10px',
            //     'border-bottom': '2px solid #dee2e6'
            //   })
            //   .addClass('row no-gutters');

            // // Create an empty expand command header cell
            // if (isMasterDetailEnabled.call(this)) {
            //     var $masterDetailHeaderCell = createHeaderCell.call(this);
            //     $masterDetailHeaderCell
            //         .addClass("tblv-command-expand")
            //         .appendTo($headTr);
            // }

            // // Create row number header cell
            // if (displayRowNumber.call(this)) {
            //     var $rowNumberCell = createHeaderCell.call(this, "#");
            //     $rowNumberCell
            //         .addClass("tblv-row-number")
            //         .appendTo($headTr);
            // }

            // var allowSorting = isSortingEnabled.call(this);

            // // Create columns from options
            // var columns = this.options.columns;
            // for (var c = 0; c < columns.length; c++) {
            //     if (allowDisplayColumn.call(this, columns[c])) {
            //         var $cell = createHeaderCell.call(this, columns[c].caption, columns[c].dataField);

            //         // Create sort icon only if the current column has sortOrder option 
            //         //  and the sorting is enabled on the general options
            //         if (columns[c].sortOrder && allowSorting) {
            //             var $sortIcon = createSortingIcon.call(this, columns[c].sortOrder);
            //             $cell.append($sortIcon);
            //         }

            //         $headTr.append($cell);
            //     }
            // }

            // return $headTr;
        };

        var getHeaderCell = function (dataField) {
            var $headerCell;

            // Note: The following code returns all cells that are belong to this table and all nested tables
            // var $headerCells = _(this).$table.find("th"); 

            // Get only header cells that are belong to this table
            var $tables = $([_(this).$table, _(this).$headersTable]);
            $tables.each(function () {
                var $headerCells = $tables.find("> .thead > .tr > .th");

                var isFound = false;
                $headerCells.each(function () {
                    if ($(this).data("data-field") === dataField) {
                        $headerCell = $(this);
                        isFound = true;
                        return false;
                    }
                });

                if (isFound) {
                    return false;
                }
            });


            return $headerCell;
        };

        //#endregion ____ Table Header _______


        //#region ________ Table Body ________

        var createCell = function (data, dataField) {
            // var $td = $("<div>")
            //             .addClass('col-lg td table-td text-wrap text-center p-2')
            //             .css('border-left', '1px solid #e9e9e9')
            //             .html(data);
            var $td = $("<td>")
                .addClass('col-lg td table-td text-center p-2')
                // .addClass('col-lg td table-td text-wrap text-center p-2')
                .css('border-left', '1px solid #e9e9e9')
                .html(data);

            if (dataField) {
                $td.data("data-field", dataField);
            }

            return $td;
        };

        var renderFilterRows = function (filteredData) {
            var columns = this.options.columns;
            //var dataSource = this.options.dataSource;

            var $tbody = _(this).$table.find("tbody");

            // Clear table body
            $tbody.empty();

            // Has master detail
            var hasMasterDetail = isMasterDetailEnabled.call(this);

            // Render filter rows
            if (filteredData && filteredData.length) {
                for (var i = 0; i < filteredData.length; i++) { // Rows
                    var $tr = $("<tr>").appendTo($tbody);
                    // var $tr = $("<div>").addClass('row tr no-gutters').css('border-bottom', '1px solid #e9e9e9').appendTo($tbody);
                    // Create expand command, if it has an option to enable master detail
                    // if (hasMasterDetail) {
                    //     var $masterDetailCell = createCell.call(this, createMasterDetailIcon.call(this, filteredData[i]));
                    //     $masterDetailCell
                    //         .addClass("tblv-command-expand")
                    //         .appendTo($tr);
                    // }

                    // // Create row number cell
                    // if (displayRowNumber.call(this)) {
                    //     var $rowNumberCell = createCell.call(this, i + 1);
                    //     $rowNumberCell.addClass("tblv-row-number").appendTo($tr);
                    // }

                    // Create cells from options
                    for (var j = 0; j < columns.length; j++) { // Columns
                        if (allowDisplayColumn.call(this, columns[j])) {
                            var column = columns[j];
                            var row = filteredData[i];
                            var cellValue = row[column.dataField] || column.default;
                            var $td = createCell.call(this, cellValue, column.dataField);
                            // razan  
                            var cell = {
                                cellElement: $td,
                                row: { data: row },
                                column: column,
                                rowIndex: i,
                                columIndex: j,
                                value: cellValue
                            };

                            if (column.type != 'buttons') {
                                if (this.options.onCellClicked) {
                                    (function (cell) {
                                        $td.click(function () {
                                            this.options.onCellClicked(cell);
                                        }.bind(this));
                                    }.bind(this))(cell);
                                }

                                if (this.options.onCellPrepared) {
                                    this.options.onCellPrepared(cell);
                                }
                            }
                            else {
                                column.buttons.forEach(b => {
                                    var $button = $("<a>").appendTo($td);
                                    if (b.iconClass) {
                                        $button.append($("<i>").addClass(b.iconClass));
                                    }
                                    else {
                                        $button.text(b.text);
                                    }

                                    // if(b.hint){
                                    //     $button.tooltip({'title': $button.hint});
                                    // }
                                    if (b.onClick) {
                                        var options = {
                                            component: this,
                                            row: {
                                                element: $tr,
                                                data: row
                                            },
                                            button: {
                                                element: $button,
                                                data: b
                                            }
                                        };
                                        (function (b, e) {
                                            $button.click(function () {
                                                b.onClick(e);
                                            });
                                        })(b, options);
                                    }
                                });
                            }
                            if (cellValue) {
                                $td.prepend($(`<span class="table-view-td-span d-block">${column.caption}: </span>`)
                                    .css('background', 'whitesmoke'));
                                // $td.find('.table-view-td-span').addClass('d-block');
                            } else {
                                // Since if there is an empty cell (td), 
                                // the another cells will be shiffted to empty one,
                                // and caused a conflict between matching header cell and cell value
                                // so to prevent that we add an empty span
                                $td.append($('<span>'));
                            }
                            $tr.append($td); // Render data based on column key
                            // the second child of any cell($td)
                            // represents the field value which maybe a long text
                            // so we truncate it
                            $td.children().eq(1)
                                .addClass('text-truncate text-truncate-md')
                                .removeClass('no-gutters');

                        }
                    }

                    var onRowClicked = this.options.onRowClicked;
                    var options = {
                        component: this,
                        row: {
                            element: $tr,
                            data: row
                        }
                    };
                    if ($.isFunction(onRowClicked)) {
                        (function (e) {
                            $tr.click(function () {
                                onRowClicked(e);
                            });
                        })(options);
                    }
                }
            }
        };

        //#endregion _____ Table Body ________

        //#endregion ____________ Table Creation ______________


        //#region _______________ Pager Creation ______________

        var createPaging = function () {
            var me = this;

            return new ns.PagingEdit($.extend(true, {}, this.options.paging, {
                clientSideFiltering: this.options.clientSideFiltering,
                firstSearchResult: { rowsCount: this.options.dataSource.length, data: this.options.dataSource },
                onPageChangeCallback: function (result) {
                    renderFilterRows.call(me, result);
                },
            }));
        };

        var resetPager = function (data) {
            _(this).pagingInstance.resetPagerData({ rowsCount: data.length, data: data });
        };

        //#endregion ____________ Pager Creation ______________


        //#region _______________ Master Detail _______________

        var createMasterDetailIcon = function (rowData) {
            var me = this;
            var $masterDetailIcon = $("<div>")
                .addClass(this.options.triangleRightIcon)
                .addClass("tblv-command-expand-icon")
                .click(function (e) {
                    e.stopPropagation();
                    $(this).toggleClass("expanded");

                    // Get the current row
                    var $currentTr = $(this).closest("tr");

                    // Get master detail row if it exist
                    var $masterDetailTr = $currentTr.next(".tblv-master-detail-row");

                    if ($(this).hasClass("expanded")) {
                        $(this)
                            .removeClass(me.options.triangleRightIcon)
                            .addClass(me.options.triangleDownIcon);

                        // If the current row has master detail rendered before, display it, otherwise create a new one
                        if ($masterDetailTr.length) {
                            // Show master detail row
                            $masterDetailTr.show();
                        }
                        else {
                            // Create master detail row after the main row
                            //$masterDetailTr = createMasterDetailRow.call(me, $currentTr.children().length);
                            var shownColumnsCount = getShownColumnsCount.call(me);
                            $masterDetailTr = createMasterDetailRow.call(me, shownColumnsCount);
                            $masterDetailTr.insertAfter($currentTr);

                            // Render master detail for the current row
                            var $masterDetailTd = $masterDetailTr.children().first(); // Get master detail td
                            initializeMasterDetail.call(me, $masterDetailTd, rowData);
                        }
                    }
                    else {
                        $(this)
                            .removeClass(me.options.triangleDownIcon)
                            .addClass(me.options.triangleRightIcon);

                        // Hide the master detail row
                        $masterDetailTr.hide();
                    }
                });

            return $masterDetailIcon;
        };

        var createMasterDetailRow = function (columnsCount) {
            var $masterDetailTr = $("<div>").addClass("row tr no-gutters tblv-master-detail-row").css('border', '1px solid #e9e9e9');

            var $masterDetailTd = $("<div>")
                .addClass('col-lg td table-td text-center p-2')
                .attr("colspan", columnsCount)
                .appendTo($masterDetailTr);

            return $masterDetailTr;
        };

        var initializeMasterDetail = function ($masterDetailTd, rowData) {
            var rowOptions = {
                key: rowData[this.options.masterDetail.key],
                data: rowData
            };

            this.options.masterDetail.template($masterDetailTd, rowOptions);
        };

        //#endregion ____________ Master Detail _______________


        //#region _______________ Column Chooser ______________

        var initColumnChooserList = function () {
            var columnChooserList = _(this).columnChooserList;

            var columns = this.options.columns.filter(c => c.type != "buttons");
            for (var i = 0; i < columns.length; i++) {
                if (allowDisplayColumn.call(this, columns[i])) {
                    columnChooserList.push(columns[i].dataField);
                }
            }
        };

        var createColumnChooserBtn = function () {
            return $("<button>")
                .addClass("tblv-col-chsr-btn")
                .append($("<i>").addClass(this.options.columnChooserClassName))
                .click(showColumnChooserPopup.bind(this));
        };

        var showColumnChooserPopup = function () {
            var me = this;

            var $columnChooser = createColumnChooser.call(this);
            Specto.ui.Modal.showModal($columnChooser, this.options.localizer["COLUMN_CHOOSER"], [{
                label: this.options.localizer["OK"], color: "btn-primary", onClick: function (modal) {
                    // Get all checked columns from ui (from column chooser popup)
                    var checkedColumns = $.map($columnChooser.find(":input[type='checkbox']:checked"), function (el) {
                        return $(el).data("key");
                    });
                    // Show only the checked columns on the current grid
                    applyColumnChooser.call(me, checkedColumns);
                    modal.close();
                }
            }], { expandButton: false, width: "300px" });
        };

        var createColumnChooser = function () {
            var $columnChooser = $("<div>").addClass("tblv-col-chsr");

            var columnChooserList = _(this).columnChooserList;

            var columns = this.options.columns.filter(c => c.type != 'buttons');
            for (var i = 0; i < columns.length; i++) {
                if (allowDisplayColumn.call(this, columns[i])) {
                    // Create checkbox label
                    var $label = $("<label>")
                        .addClass("tblv-col-chsr-chk-lbl")
                        .appendTo($columnChooser);

                    // Check if the current column is already exist on column chooser list (checked before)
                    var isChecked = columnChooserList.indexOf(columns[i].dataField) !== -1;

                    // Create checkbox input
                    var $checkbox = $("<input type='checkbox'>")
                        .attr("name", "col-chsr-chk")
                        .data("key", columns[i].dataField)
                        .prop("checked", isChecked)
                        .appendTo($label);

                    // Create checkbox text
                    var $text = $("<span>")
                        .text(columns[i].caption)
                        .appendTo($label);
                }
            }

            return $columnChooser;
        };

        var applyColumnChooser = function (checkedColumns) {
            // Reset the columnChooserList based on selected columns
            _(this).columnChooserList = checkedColumns;

            // Note: The following code returns all cells that are belong to this table and all nested tables
            // var $tableCells = _(this).$table.find("td");

            // Get only cells that are belong to this table
            var $tables = $([_(this).$table, _(this).$headersTable]);
            //var $tableCells = $tables.find("> thead > tr > th, > tbody > tr > td");

            $tables.each(function () {
                var $table = $(this);
                $tableCells = $table.find("> .thead > .tr > .th, > .tbody > .tr > .td");

                var $tableCells = $tableCells.filter(function () {
                    return !!$(this).data("data-field"); // Get only cells that have data-field
                }).hide(); // Hide all cells

                // Hide column group
                var $columnsGroup = $table.find("> colgroup > col").filter(function () {
                    return !!$(this).data("col-group-for"); // Get only mapped group columns
                }).hide();


                // Show cells based on checked columns
                for (var i = 0; i < checkedColumns.length; i++) {
                    $tableCells.filter(function () {
                        return $(this).data("data-field") === checkedColumns[i];
                    }).show(); // Show current column

                    $columnsGroup.filter(function () {
                        return $(this).data("col-group-for") === checkedColumns[i];
                    }).show(); // Show current group column
                }

                // Change colspan for master detail cell based on current shown columns
                //var shownColumnsCount = getShownColumnsCount.call(this);
                //var x = _(this).$table.find("colgroup > col:visible").length;
                //$el.css('display') !== 'none'
                //var shownColumnsCount = $table.find("colgroup > col:not(:hidden)").length;
                var shownColumnsCount = $columnsGroup.filter(function () {
                    return $(this).css("display") !== "none";
                }).length;
                $table.find("> .tbody > .tr.tblv-master-detail-row > .td").each(function () {
                    $(this).attr("colspan", shownColumnsCount);
                });
            });
        };

        var getShownColumnsCount = function () {
            //var x = _(this).$table.find("> colgroup > col:visible").length;
            //$el.css('display') !== 'none'
            //var numberOfColumns = _(this).$table.find("colgroup > col:not(:hidden)").length;

            //var count = 0;
            //_(this).$table.find("> colgroup > col").each(function () {
            //    if ($(this).css("display") !== "none") {
            //        ++count;
            //    }
            //});

            var count = _(this).$table.find("> colgroup > col").filter(function () {
                return $(this).css("display") !== "none";
            }).length;

            return count;
        };

        //#endregion ____________ Column Chooser ______________


        //#region __________________ Sorting __________________

        var createSortingIcon = function (sortOrder) {
            var me = this;
            var $sortingIcon = $("<i>")
                .addClass("tblv-sorting-ico")
                .addClass(sortOrder === "asc" ? this.options.sortingAscIcon : this.options.sortingDescIcon)
                .click(function () {
                    var currentSortOrder = $(this).data("sort-order") || sortOrder;

                    // Call apply sorting method
                    sortData.call(me, $(this).closest("th").data("data-field"), currentSortOrder);

                    // Reverse current sort order
                    $(this).data("sort-order", currentSortOrder === "asc" ? "desc" : "asc");
                });

            return $sortingIcon;
        };

        var sortData = function (dataField, sortOrder) {
            var sortingMode = this.options.sorting.mode;

            var dataSource = $.extend(true, [], this.options.dataSource);
            if (sortingMode === "single") {
                sortBy.call(this, dataSource, dataField, sortOrder);
            }
            else if (sortingMode === "multiple") { //TODO
                var sortableColumns = this.options.columns.filter(c => !!c.sortOrder);

                for (var i = 0; i < sortableColumns.length; i++) {
                    var $headerCell = getHeaderCell.call(this, sortableColumns[i].dataField);
                    // This is the original sortOrder
                    //var sortOrder = sortableColumns[i].sortOrder;

                    // This is the updated sortOrder
                    var updatedSortOrder = $headerCell.find(".tblv-sorting-ico").data("sort-order");
                    if (updatedSortOrder) {
                        sortBy.call(this, dataSource, sortableColumns[i].dataField, updatedSortOrder);
                    }
                }
            }

            resetPager.call(this, dataSource);
        };

        var sortBy = function (dataSource, key, sortOrder) {
            dataSource.sort(function (a, b) {
                if (!a.hasOwnProperty(key) || !b.hasOwnProperty(key)) {
                    // property doesn't exist on either object
                    return 0;
                }

                const varA = (typeof a[key] === "string")
                    ? a[key].toUpperCase() : a[key];
                const varB = (typeof b[key] === "string")
                    ? b[key].toUpperCase() : b[key];

                let comparison = 0;
                if (varA > varB) {
                    comparison = 1;
                } else if (varA < varB) {
                    comparison = -1;
                }
                return sortOrder === "desc" ? (comparison * -1) : comparison;
            });
        };

        //#endregion _______________ Sorting __________________

        //#endregion ________________________ Private Methods ___________________________

        TableView.prototype.destroy = function () {
            _(this).$table.remove();
            //TODO_N: Create a destroy method for paging edit
            //_(this).$pager.remove();
        };

        TableView.prototype.showColumnChooser = function () {
            showColumnChooser.call(this);
        };

        TableView.prototype.clearSort = function () {

        };

        TableView.prototype.toggleMasterDetailsView = function (row) {

            var $row = row.element;
            var rowData = row.data;

            $row.toggleClass("expanded");

            // Get master detail row if it exist
            var $masterDetailTr = $row.next(".tblv-master-detail-row");

            if ($row.hasClass("expanded")) {
                // If the current row has master detail rendered before, display it, otherwise create a new one
                if ($masterDetailTr.length) {
                    // Show master detail row
                    $masterDetailTr.show();
                }
                else {
                    // Create master detail row after the main row
                    var shownColumnsCount = getShownColumnsCount.call(this);
                    $masterDetailTr = createMasterDetailRow.call(this, shownColumnsCount);
                    $masterDetailTr.insertAfter($row);
                }

                //TODO: Try to optimize this
                // Render master detail for the current row
                var $masterDetailTd = $masterDetailTr.children().first(); // Get master detail td
                initializeMasterDetail.call(this, $masterDetailTd, rowData);
            }
            else {

                // Hide the master detail row
                $masterDetailTr.hide();
            }

        };

        TableView.prototype.setMasterDetialsViewTemplate = function (template) {
            this.options.masterDetail.template = template;
        }

        return TableView;
    })();

    //*****************************************************************************//
    //******************************* jQuery Plugin *******************************//

    /*
        $(selector).tableView(options);
        $(selector).tableView("instance"); // Return the control instance
        $(selector).tableView("destroy"); // Destroy tableView created
    */

    var pluginName = "tableView";

    $.fn[pluginName] = function (param) {
        // All methods that should return the element
        var thisMethods = ['destroy'];

        if (typeof param === 'object') {
            return this.each(function () {
                // Destroy created combo edit
                if ($.data(this, pluginName)) {
                    var instance = $(this).data(pluginName);
                    instance.destroy();
                }
                // Create a new instance of TableView
                $.data(this, pluginName, new Specto.ui.TableView(this, param));
            });
        }
        else if (typeof param === 'string') {
            // Get  main function argument values
            var args = Array.prototype.slice.call(arguments, 1);

            var returnValue;

            this.each(function () {
                var instance = $(this).data(pluginName);

                //if (instance == null && window.console && console.error) {
                if (instance === null) {
                    console.error('The ' + pluginName + '(\'' + param + '\') method was called on an '
                        + 'element that is not using ' + pluginName + '.');
                }

                // Return current control instance
                if (param === 'instance') {
                    returnValue = instance;
                }
                else {

                    // Remove the instance from element data
                    if (param === 'destroy') {
                        $.data(this, pluginName, null);
                    }

                    // Call the method
                    returnValue = instance[param].apply(instance, args);
                }
            });

            // Check if we should be returning `this`
            if ($.inArray(param, thisMethods) > -1) {
                return this;
            }

            return returnValue;
        }
        else {
            throw new Error('Invalid arguments for ' + pluginName + ': ' + param);
        }
    };

    //*****************************************************************************//
})();

(function () {
    this.Specto = this.Specto || {};
    this.Specto.ui = this.Specto.ui || {};
    Specto.ui.defaults = Specto.ui.defaults || {};
    var ns = this.Specto.ui;

    /***************************************************************************************************/
    /**************************************** Diagram Designer *****************************************/

    //#region *************************** Documentation ***************************//

    //#region ********** Required Files **********//
    /*
        Required plugins:
            - fontAwesome v4.7.0

            - Bootstrap v4.0.0

            - jQuery
                <script src="https://code.jquery.com/jquery-3.1.1.js"></script>

            - D3.js v6.5.0
                <script src="d3.min.js"></script>

            - LeaderLine v1.0.5 (c) anseki https://anseki.github.io/leader-line/
                <script src="leader-line.min.js"></script>

            - jquery.contextMenu: Download the files from the following url: (https://swisnl.github.io/jQuery-contextMenu/)
                <link href="jquery.contextMenu/css/jquery.contextMenu.min.css" rel="stylesheet" />
                <script src="jquery.contextMenu/js/jquery.contextMenu.min.js"></script>

        Required specto plugins:
            <link rel="stylesheet" href="Modal.css" />
            <script src="Modal.js"></script>
    */
    //#endregion ******* Required Files **********//

    //#region ************** Options *************//
    /* 
      options: {
          rtl: true/false(default),
          readOnly: true/false(default),
          onImport: function (component) {}, // component: (current class context)
          onExport: function (component) {}, // component: (current class context)
          designer: {
            width: "950px(default)",
            height: "950px(default)"
          },
          items: [
            { 
                type:.., 
                text:.., 
                fill:.., 
                border:..,
                attributes: [ // Design Mode: After creating an item shape, 
                                                the user allowed to add a set of quieres from this list
                    { 
                        id:..,
                        text:..,
                        type: "intRange"/"bool"/"oneOf"/"manyOf",
                        choices: Optional (In case the type is "oneOf"/"manyOf", the data: [...])
                    }
                ],
                connectsWith: [itemType,...], // Design Mode: The list of connected items
            }
          ],
          shapes: [
            {
                id:..,
                itemType:..,
                edgePoints: [],
                midPoints: [],
                queries: [
                    id:..,
                    edgePoints: [],
                    type: "exactCount"/"pieChart"/"barChart",
                    data: [{ attributeId:.., value:.. }]
                ]
            }
          ],
          connectors: [{ id:.., connectorId:.. }]
      }
    */
    //#endregion *********** Options *************//

    //#region ************* TODO List ************//
    /* 
     */
    //#endregion ********** TODO List ************//

    //#endregion ************************ Documentation ***************************//


    //#region ******************************* Enums *******************************//

    const ActionEnum = Object.freeze({
        ADD_SHAPE: "addShape",
        REMOVE_SHAPE: "removeShape",
        UPDATE_SHAPE: "updateShape",
        CONNECT_SHAPES: "connectShapes",
        DISCONNECT_SHAPES: "disconnectShapes"
    });

    const QueryTypeEnum = Object.freeze({
        EXACT_COUNT: "exactCount",
        PIE_CHART: "pieChart",
        BAR_CHART: "barChart"
    });

    const FieldTypeEnum = Object.freeze({
        INT_RANGE: "intRange",
        BOOLEAN: "bool",
        ONE_OF: "oneOf",
        MANY_OF: "manyOf"
    });

    //#endregion **************************** Enums *******************************//


    //#region ***************** ContextMenu Manager (Static Class) ****************//
    
    /*
     * selector
     * actions = [{ text:.., iconClass:.., callback: function ($selector) {} }]
     */
    var ContextMenuManager = {
        _createContextMenuItem: function (action) {
            return {
                name: action.text,
                icon: function (opt, $itemElement, itemKey, item) {
                    var $icon = $("<i>").addClass("dd-context-menu-icon").addClass(action.iconClass);

                    $itemElement
                        .empty()
                        .append($icon)
                        .append(action.text);

                    return 'dd-context-menu';
                },
                callback: function (itemKey, opt, e) {
                    //var selectorId = $(opt.selector).attr("data-id");
                    if (action.callback instanceof Function) {
                        action.callback($(opt.selector));
                    }

                    //return false; // Do not close the menu after clicking an item
                }
            };
        },
        create: function (selector, actions) {
            if (actions && actions.length) {
                var me = this;

                $.contextMenu({
                    selector: selector, // define which elements trigger this menu
                    build: function ($trigger, e) {
                        // This callback is executed every time the menu is to be shown
                        // Its results are destroyed every time the menu is hidden
                        // e is the original contextmenu event, containing e.pageX and e.pageY (amongst other data)

                        var contextMenuItems = {};
                        for (var i = 0; i < actions.length; i++) {
                            var contextMenuItem = me._createContextMenuItem(actions[i]);
                            contextMenuItems[contextMenuItem.name] = contextMenuItem;
                        }

                        return {
                            items: contextMenuItems
                        };
                    },
                    // there's more, have a look at the demos and docs...
                });
            }
        }
    };

    //#endregion ************** ContextMenu Manager (Static Class) ****************//


    //#region ************************* Entry(Main) Class *************************//

    ns.DiagramDesigner = (function () {
        // Default options
        var defaults = $.extend({}, {
            removeIcon: "fa fa-trash",
            undoIcon: "fa fa-undo",
            redoIcon: "fa fa-repeat",
            sidebarIcon: "fa fa-window-maximize",
            rtl: false,
            readOnly: false,
            designer: {
                width: "950px",
                height: "950px"
            },
            items: [],
            shapes: [],
            connectors: [],
        }, Specto.ui.defaults.DiagramDesigner);

        var priv = new WeakMap();
        var _ = function (instance) { return priv.get(instance); };

        function DiagramDesigner(element, options) {
            this.options = $.extend(true, {}, defaults, options);

            var privateMembers = {
                $element: $(element), // Original container
                menubarInstance: null,
                toolbarInstance: null,
                sidebarInstance: null,
                diagramInstance: null,
                formatPanelInstance: null,
            };

            priv.set(this, privateMembers);

            // Initialization
            init.call(this);
        }

        //#region ___________________________ Private Methods ___________________________

        var init = function () {
            var $container = $("<div>")
                                .addClass("dd-container")
                                .appendTo(_(this).$element);

            if (!this.options.readOnly) {
                // 1. Create menubar
                var menubarInstance = _(this).menubarInstance = createMenubarComponent.call(this);
                $container.append(menubarInstance.render());

                // 2. Create toolbar
                var toolbarInstance = _(this).toolbarInstance = createToolbarComponent.call(this);
                $container.append(toolbarInstance.render());
            }

            // 3. Create designer container
            var $designerContainer = $("<div>")
                                        .addClass("dd-designer-container")
                                        .appendTo($container);

            if (!this.options.readOnly) {
                // 3. a. Create sidebar
                var sidebarInstance = _(this).sidebarInstance = createSidebarComponent.call(this);
                $designerContainer.append(sidebarInstance.render());
            }

            // 3. b. Create diagram area
            var diagramInstance = _(this).diagramInstance = createDiagramComponent.call(this);
            $designerContainer.append(diagramInstance.render());

            if (!this.options.readOnly) {
                // 3. c. Create format panel
                var formatPanelInstance = _(this).formatPanelInstance = createFormatPanelComponent.call(this);
                $designerContainer.append(formatPanelInstance.render());

                // Assign the format panel to FormatProxy class
                FormatProxy.setFormatPanel(formatPanelInstance.panel());

                if (isMobile.call(this)) {
                    formatPanelInstance.hide();
                }

                $(window).resize(function (e) {
                    if (window.innerWidth <= 575) {
                        formatPanelInstance.hide();
                    }
                    else {
                        formatPanelInstance.show();
                    }
                });
            }

            // 4. Draw shapes
            if (this.options.shapes && this.options.shapes.length) {
                diagramInstance.addShapes(this.options.shapes);
            }

            // 5. Connect the shapes
            if (this.options.connectors && this.options.connectors.length) {
                var connectors = this.options.connectors;

                for (var i = 0; i < connectors.length; i++) {
                    this.connectShapes(connectors[i].id, connectors[i].connectorId);
                }
            }
        };

        var isMobile = function () {
            let check = false;
            (function (a) { if (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(a) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a.substr(0, 4))) check = true; })(navigator.userAgent || navigator.vendor || window.opera);
            return check;
        };

        //#region ____________ Designer Components ____________

        var createMenubarComponent = function () {
            var me = this;

            return new Menubar({
                import: function () {
                    if (me.options.onImport instanceof Function) {
                        me.options.onImport(me);
                    }
                },
                export: function () {
                    if (me.options.onExport instanceof Function) {
                        me.options.onExport(me);
                    }
                }
            });
        };

        var createToolbarComponent = function () {
            var me = this;

            return new Toolbar({
                undoIcon: this.options.undoIcon,
                redoIcon: this.options.redoIcon,
                removeIcon: this.options.removeIcon,
                sidebarIcon: this.options.sidebarIcon,
                actionsWidth: this.options.designer.width,
                removeShape: function () {
                    _(me).diagramInstance.removeSelectedShapeOrLine();
                },
                undo: function () {
                    _(me).diagramInstance.undo();
                },
                redo: function () {
                    _(me).diagramInstance.redo();
                },
                toggleFormatPanel: function () {
                    _(me).formatPanelInstance.toggle();
                    _(me).diagramInstance.refreshConnectors();
                },
            });
        };

        var createSidebarComponent = function () {
            var me = this;

            return new Sidebar({
                items: this.options.items,
                onItemClick: function (activeItemType) {
                    if (activeItemType) {
                        _(me).diagramInstance.drawable = true;
                    }
                    else {
                        _(me).diagramInstance.drawable = false;
                    }
                },
            });
        };

        var createDiagramComponent = function () {
            return new Diagram({
                readOnly: this.options.readOnly,
                width: this.options.designer.width,
                height: this.options.designer.height,
                populateItem: (type) => this.options.items.find(i => i.type === type),
                populateActiveItem: () => this.options.items.find(i => i.type === _(this).sidebarInstance.getActiveItemType()),
                toolbarActions: _(this).toolbarInstance && _(this).toolbarInstance.getActions(),
            });
        };

        var createFormatPanelComponent = function () {
            return new FormatPanel();
        };

        //#endregion _________ Designer Components ____________

        //#endregion ________________________ Private Methods ___________________________

        /*
         * retruns {
         *  shapes: [],
         *  connectors: [{ id:.., connectorId:.. }]
         * }
         */
        DiagramDesigner.prototype.getData = function () {
            return _(this).diagramInstance.getData();
        };

        /*
         * options has two keys { 
         *  shapes: [], 
         *  connectors: [{ id:.., connectorId:.. }] 
         * }
         */
        DiagramDesigner.prototype.addData = function (options) {
            _(this).diagramInstance.addData(options);
        };

        DiagramDesigner.prototype.addShape = function (shape) {
            _(this).diagramInstance.addShape(shape);
        };

        DiagramDesigner.prototype.addShapes = function (shapes) {
            _(this).diagramInstance.addShapes(shapes);
        };

        DiagramDesigner.prototype.removeShape = function (id) {
            _(this).diagramInstance.removeShape(id);
        };

        DiagramDesigner.prototype.connectShapes = function (id, connectorId) {
            _(this).diagramInstance.connectShapes(id, connectorId);
        };

        DiagramDesigner.prototype.empty = function () {
            _(this).diagramInstance.empty();
        };

        return DiagramDesigner;
    })();

    //#endregion ********************** Entry(Main) Class *************************//


    //#region *************************** Menubar Class ***************************//

    var Menubar = (function () {
        var defaults = {

        };

        var priv = new WeakMap();
        var _ = function (instance) { return priv.get(instance); }

        var Menubar = function (options) {
            this.options = $.extend(true, {}, options);

            var privateMembers = {
                $element: $("<div>").addClass("dd-menubar"),
            };

            priv.set(this, privateMembers);

            // Initialization
            init.call(this);
        };

        //#region ___________________________ Private Methods ___________________________

        var init = function () {
            var $element = _(this).$element;

            var $importButton = createButton.call(this, "Import", this.options.import);
            $element.append($importButton);

            var $exportButton = createButton.call(this, "Export", this.options.export);
            $element.append($exportButton);
        };

        var createButton = function (text, callback) {
            return $("<button type='button'>")
                    .addClass("dd-menubar-btn")
                    .text(text)
                    .click(callback);
        };

        //#endregion ________________________ Private Methods ___________________________

        Menubar.prototype.render = function () {
            return _(this).$element;
        };

        return Menubar;
    })();

	//#endregion ************************ Menubar Class ***************************//


    //#region *************************** Toolbar Class ***************************//

    /**
     * options: {
     *  undoIcon:..,
     *  redoIcon:..,
     *  removeIcon:..,
     *  sidebarIcon:..,
     *  removeShape:..,
     *  toggleFormatPanel:..,
     * }
     */
    var Toolbar = (function () {
        var defaults = {

        };

        var priv = new WeakMap();
        var _ = function (instance) { return priv.get(instance); }

        var Toolbar = function (options) {
            this.options = $.extend(true, {}, options);

            var privateMembers = {
                $element: $("<div>").addClass("dd-toolbar"),
                buttonsActions: {},
            };

            priv.set(this, privateMembers);

            // Initialization
            init.call(this);
        };

        //#region ___________________________ Private Methods ___________________________

        var init = function () {
            var $element = _(this).$element;

            var $shapeActions = $("<div>")
                                    .addClass("dd-toolbar-actions")
                                    .css("width", this.options.actionsWidth)
                                    .appendTo($element);

            // Create undo icon
            var $undo = createIcon.call(this, "undoButton", "dd-undo-icon", this.options.undoIcon, "Undo", this.options.undo, true);
            $shapeActions.append($undo);

            // Create redo icon
            var $redo = createIcon.call(this, "redoButton", "dd-redo-icon", this.options.redoIcon, "Redo", this.options.redo, true);
            $shapeActions.append($redo);

            appendSeparator.call(this, $shapeActions);

            // Create remove icon
            var $remove = createIcon.call(this, "removeButton", "dd-remove-icon", this.options.removeIcon, "Delete", this.options.removeShape, true);
            $shapeActions.append($remove);

            // Create sidebar icon
            var $sidebar = createIcon.call(this, "formatPanelButton", "dd-format-panel-icon", this.options.sidebarIcon, "Format Panel", this.options.toggleFormatPanel);
            $element.append($sidebar);
        };

        var createIcon = function (actionKey, mainClass, iconClass, tooltipText, callback, isDisabled) {
            var $abbr = $("<abbr>")
                            .attr({ "title": tooltipText })
                            .append($('<i aria-hidden="true">').addClass(iconClass));

            var me = this;
            var $icon = $("<div>")
                            .append($abbr)
                            .addClass("dd-icon")
                            .addClass(mainClass)
                            .click(function () {
                                if (callback instanceof Function) {
                                    disableRemoveIcon.call(me);
                                    callback();
                                }
                            });

            if (isDisabled) {
                $icon.addClass("disabled");
            }

            _(this).buttonsActions[actionKey] = {
                enable: function () {
                    $icon.removeClass("disabled");
                },
                disable: function () {
                    $icon.addClass("disabled");
                }
            };

            return $icon;
        };

        var appendSeparator = function ($container) {
            $("<div>").addClass("dd-separator").appendTo($container);
        };

        var disableRemoveIcon = function () {
            $(".dd-icon.dd-remove-icon").addClass("disabled");
        };

        //#endregion ________________________ Private Methods ___________________________

        Toolbar.prototype.render = function () {
            return _(this).$element;
        };

        Toolbar.prototype.getActions = function () {
            return _(this).buttonsActions;
        };

        return Toolbar;
    })();

	//#endregion ************************ Toolbar Class ***************************//


    //#region *************************** Sidebar Class ***************************//

    /*
     * options = {
     *  items: [],
     *  onItemClick: function (item) {}
     * }
     */
    var Sidebar = (function () {
        var priv = new WeakMap();
        var _ = function (instance) { return priv.get(instance); }

        var Sidebar = function (options) {
            this.options = $.extend(true, {}, options);

            var privateMembers = {
                $element: $("<div>").addClass("dd-sidebar"),
                activeItemType: null,
            };

            priv.set(this, privateMembers);

            // Initialization
            init.call(this);
        };

        //#region ___________________________ Private Methods ___________________________

        var init = function () {
            appendSidebarItems.call(this);
        };

        var appendSidebarItems = function () {
            var $sidebar = _(this).$element;

            var $sidebarItems = $("<div>")
                                    .addClass("dd-sidebar-items")
                                    .appendTo($sidebar);

            var items = this.options.items;
            for (var i = 0; i < items.length; i++) {
                let $sidebarItem = createSidebarItem.call(this, items[i]);
                $sidebarItems.append($sidebarItem);
            }

            return $sidebar;
        };

        var createSidebarItem = function (item) {
            var me = this;

            var $item = $("<div>")
                .addClass("dd-sidebar-item")
                .text(item.text)
                .data("item-type", item.type)
                .click(function () {
                    if (me.options.onItemClick instanceof Function) {
                        var currentItemType = $(this).data("item-type");
                        var activeItemType = _(me).activeItemType;

                        $(".dd-sidebar-item--active").removeClass("dd-sidebar-item--active");

                        if (currentItemType === activeItemType) {
                            _(me).activeItemType = null;
                        }
                        else {
                            $(this).addClass("dd-sidebar-item--active");
                            _(me).activeItemType = currentItemType;
                        }

                        me.options.onItemClick(_(me).activeItemType);
                    }
                });

            return $item;
        };

        //#endregion ________________________ Private Methods ___________________________

        Sidebar.prototype.render = function () {
            return _(this).$element;
        };

        Sidebar.prototype.getActiveItemType = function () {
            return _(this).activeItemType;
        };

        return Sidebar;
    })();

    //#endregion ************************ Sidebar Class ***************************//


    //#region ************************* Format Panel Class ************************//

    var FormatPanel = (function () {
        var defaults = {

        };

        var priv = new WeakMap();
        var _ = function (instance) { return priv.get(instance); }

        var FormatPanel = function () {
            var privateMembers = {
                $element: $("<div>").addClass("dd-format-panel"),
            };

            priv.set(this, privateMembers);

            // Initialization
            init.call(this);
        };

        //#region ___________________________ Private Methods ___________________________

        var init = function () {

        };

        //#endregion ________________________ Private Methods ___________________________

        FormatPanel.prototype.render = function () {
            return _(this).$element;
        };
        
        FormatPanel.prototype.panel = function () {
            return _(this).$element;
        };

        FormatPanel.prototype.toggle = function () {
            _(this).$element.toggleClass("hidden");
        };

        FormatPanel.prototype.show = function () {
            _(this).$element.removeClass("hidden");
        };

        FormatPanel.prototype.hide = function () {
            _(this).$element.addClass("hidden");
        };

        return FormatPanel;
    })();

    /*
    * Static Class
    */
    var FormatProxy = {
        _$panel: null,
        setFormatPanel: function ($panel) {
            this._$panel = $panel;

            this._generateTitleArea();
            this._generateBodyArea();
        },
        empty: function () {
            //this._$panel.empty();

            // 1. Empty the title field
            this._$panel.find(".dd-format-title")
                .empty()
                .hide();

            // 2. Empty the body field
            this._$panel.find(".dd-format-body")
                .empty()
                .hide();
        },
        setTitle: function (title) {
            this._$panel.find(".dd-format-title")
                .text(title)
                .show();
        },
        append: function ($elment) {
            var $body = this._$panel.find(".dd-format-body").show();
            $body.append($elment);
        },
        _generateTitleArea: function () {
            $("<h6>")
                .addClass("dd-format-title")
                .addClass("dd-format-separator")
                .appendTo(this._$panel);
        },
        _generateBodyArea: function () {
            $("<div>")
                .addClass("dd-format-body")
                .appendTo(this._$panel);
        },
    }

    //#endregion ********************** Format Panel Class ************************//


    //#region *************************** Diagram Class ***************************//

    /*
     * options = {
     *  readOnly: true/false(default),
     *  width:..,
     *  hegiht:..,
     *  populateItem: function (itemType) {},
     *  populateActiveItem: function () {},
     *  toolbarActions: {
     *      actionButton: { 
     *          enable: function () {}, 
     *          disable: function() {} 
     *      }, ....
     *  },
     *  $formatPanel:..,
     * }
     */
    var Diagram = (function () {
        var defaults = {
            readOnly: false,
            connectors: [],
            toolbarActions: {}
        };

        var priv = new WeakMap();
        var _ = function (instance) { return priv.get(instance); }

        var Diagram = function (options) {
            this.options = $.extend(true, {}, defaults, options);

            var privateMembers = {
                $diagram: null,
                svgSelection: null, // D3.js selection
                shapesInstances: {},
                activeStartConnectorId: null,
                initialImportedData: {},
                actionsState: [],
                redoActionsState: [],
            };

            priv.set(this, privateMembers);

            // Initialization
            init.call(this);
        };

        //#region ___________________________ Private Methods ___________________________

        var init = function () {
            _(this).$diagram = createDiagram.call(this);
        };

        var isEditable = function () {
            return !this.options.readOnly;
        };

        //#region __________________ Diagram __________________

        var createDiagram = function () {
            var me = this;

            var $diagram = $("<div>")
                                .addClass("dd-diagram")
                                .addClass("scrollable")
                                .scroll(function () {
                                    refreshConnectorLines.call(me);
                                });

            var $diagramWrapper = $("<div>")
                                        .addClass("dd-diagram-wrapper")
                                        .css({
                                            width: this.options.width,
                                            height: this.options.height
                                        })
                                        .appendTo($diagram);

            $("<div>")
                .addClass("dd-bg-page")
                .appendTo($diagramWrapper);

            appendSvg.call(this, $diagramWrapper);

            return $diagram;
        };

        var appendDefs = function (selection) {
            selection
                .append('defs')
                .append('marker')
                .attr('id', 'triangle')
                .attr('viewBox', [0, 0, 40, 40])
                .attr('refX', 5)
                .attr('refY', 5)
                .attr('markerWidth', 11)
                .attr('markerHeight', 11)
                .attr('orient', 'auto-start-reverse')
                .append('path')
                .attr('d', d3.line()([[0, 0], [0, 10], [10, 5]]));
        };

        //#endregion _______________ Diagram __________________


        //#region ____________________ SVG ____________________

        var appendSvg = function ($diagram) {
            var me = this;

            _(this).svgSelection = d3.select($diagram[0])
                                        .append("svg")
                                        .attr('class', 'dd-svg');

            appendDefs.call(this, _(this).svgSelection);

            // Note: Creating main-group directly inside the svg, to apply zooming correctly 
            //  without affecting the svg position.
            _(this).svgSelection
                    .append('g')
                    .attr('class', 'main-group');

            if (!isEditable.call(this)) {
                makeSvgZoomable.call(this);
            }
            else {
                registerSelectionEvents.call(this);

                $(document).on('keyup', function (e) {
                    if (e.keyCode === 46) {
                        me.removeSelectedShapeOrLine();
                    }
                });
            }
        };

        var makeSvgZoomable = function () {
            var me = this;
            _(this).svgSelection
                //.attr("viewBox", [0, 0, width, height])
                .call(d3.drag()
                    .on('drag', function (e) {
                        var diagram = $(".dd-diagram")[0];

                        diagram.scrollLeft += -e.dx;
                        diagram.scrollTop += -e.dy;
                    })
                )
                .call(d3.zoom()
                    //.translateExtent
                    //.scaleExtent([0.4, 3])
                    .scaleExtent([0.1, 10])
                    .on("zoom", function (e) {
                        //_(me).svgSelection.attr("transform", e.transform);
                        _(me).svgSelection
                            .select('.main-group') // Note: Apply zoom to main-group instead of applying it on the svg
                            //.attr('transform', 'translate(' + e.transform.x + ', ' + e.transform.y + ') scale(' + e.transform.k + ')');
                            .attr('transform', 'scale(' + e.transform.k + ')');

                        refreshConnectorLines.call(me);
                    })
                );
        };

        var deselectAll = function () {
            deselectAllSelectedShapes.call(this);
            deselectSelectedConnectorLine.call(this);

            deactiveShapesConnectionMode.call(this);
        };

        var deselectAllSelectedShapes = function () {
            d3.selectAll(".shape--selected").classed("shape--selected", false);

            FormatProxy.empty();

            this.options.toolbarActions.removeButton.disable();
        };

        var deactiveShapesConnectionMode = function () {
            _(this).svgSelection.select('.shape-group.active')
                                .classed('active', false);

            _(this).svgSelection.select('.connector-arrow--active')
                .classed('connector-arrow--active', false);

            _(this).svgSelection.classed('connection-mode-on', false);
            _(this).activeStartConnectorId = null;
        };

        var isShapeSelected = function (shapeId) {
            var isSelected = false;

            $selectedShapes = $(".shape--selected");

            // If selected object is a shape
            if ($selectedShapes.length) {
                $selectedShapes.each(function () {
                    let selectedShapeId = $(this).parent().attr("data-id");
                    if (selectedShapeId.toString() === shapeId.toString()) {
                        isSelected = true;
                        return false;
                    }
                });
            }

            return isSelected;
        };

        //#endregion _________________ SVG ____________________


        //#region ______________ Shape Selection ______________

        var registerSelectionEvents = function () {
            var svg = _(this).svgSelection;

            // Create the selection element
            ShapeSelectionManager.element = svg.append("path")
                                                .attr("class", "selection")
                                                .attr("visibility", "hidden");

            var me = this;
            var onMouseUp = function (startPoint, endPosition) {
                // Deselect all selected shapes
                deselectAll.call(me);

                // Select the selected shapes by user
                selectShapesInRange.call(me, startPoint, endPosition);
            };

            // Desktop version
            svg.on("mousedown", function (e) {
                var startPoint = { x: e.offsetX, y: e.offsetY };
                ShapeSelectionManager.mousedown(startPoint, onMouseUp);
            });

            // Mobile version
            svg.on("touchstart", function (e) {
                var subject = d3.select(this);
                var offset = $(this).offset();

                var startPoint = {
                    x: e.changedTouches[0].clientX - offset.left,
                    y: e.changedTouches[0].clientY - offset.top
                };//d3.touch(parent, id),

                ShapeSelectionManager.touchstart(e, subject, offset, startPoint, onMouseUp);
            });
        };

        var unbindSelectionEvents = function () {
            _(this).svgSelection
                    .on("mousedown", null)
                    .on("touchstart", null);

            ShapeSelectionManager.remove();
        };

        var selectShapesInRange = function (startPoint, endPoint) {
            var x1, x2, y1, y2;

            if (startPoint.x <= endPoint.x) {
                x1 = startPoint.x;
                x2 = endPoint.x;
            }
            else {
                x1 = endPoint.x;
                x2 = startPoint.x;
            }

            if (startPoint.y <= endPoint.y) {
                y1 = startPoint.y;
                y2 = endPoint.y;
            }
            else {
                y1 = endPoint.y;
                y2 = startPoint.y;
            }

            var shapesInstances = _(this).shapesInstances;

            var hasSelectedShapes = false;
            for (var id in shapesInstances) {
                let shapeInstance = shapesInstances[id];

                if (shapeInstance.isInRange(x1, x2, y1, y2)) {
                    shapeInstance.select();
                    hasSelectedShapes = true;
                }
            }

            if (hasSelectedShapes) {
                this.options.toolbarActions.removeButton.enable();
            }
        };

        //#endregion ___________ Shape Selection ______________


        //#region __________________ Drawing __________________

        var isDrawingEnabled = function () {
            return !!_(this).svgSelection.classed("dd-svg--drawable");
        };

        var createMouseDrawingShape = function (e, id) {
            return drawShape.call(this, {
                itemType: this.options.populateActiveItem().type,
                edgePoints: [{ x: e.offsetX, y: e.offsetY }, { x: e.offsetX, y: e.offsetY }],
                id: id
            });
        };

        var registerDrawingEvents = function () {
            var isDrawing = false;
            var shapeId;
            var drawableShapeInstance;

            var me = this;
            _(this).svgSelection
                .on('mousedown', function (e) {
                    if (e.button === 0) { // Only left mouse click allowed
                        if (isDrawingEnabled.call(me)) {
                            isDrawing = true;
                        }
                    }
                })
                .on('mousemove', function (e) {
                    if (isDrawing) {
                        if (!drawableShapeInstance) {
                            shapeId = generateUniqueShapeId.call(me);
                            drawableShapeInstance = createMouseDrawingShape.call(me, e, shapeId);
                        }
                        drawableShapeInstance.updateEndPoint({ x: e.offsetX, y: e.offsetY });
                        drawableShapeInstance.classed("drawing", true);
                    }
                })
                .on('mouseup', function (e) {
                    if (isDrawing) {
                        if (drawableShapeInstance) {
                            var dimensions = drawableShapeInstance.getDimensions();
                            if (dimensions.width < 30 || dimensions.height < 30) {
                                me.removeShape(shapeId);
                            }
                            else {
                                drawableShapeInstance.classed("drawing", false);
                                saveActionState.call(me, ActionEnum.ADD_SHAPE, drawableShapeInstance.getValue());
                            }

                            drawableShapeInstance = null;
                        }

                        isDrawing = false;
                    }
                })
                .on('click', function () {
                    deselectAll.call(me);
                });
        };

        var unbindDrawingEvents = function () {
            _(this).svgSelection
                .on("mousedown", null)
                .on("mousemove", null)
                .on("mouseup", null)
                .on("click", null);
        };

        //#endregion _______________ Drawing __________________


        //#region ______________ Connector Lines ______________

        var createConnectorLine = function (id, connectorId) {
            var shapesInstances = _(this).shapesInstances;

            var firstShape = shapesInstances[id].shape;
            var secondShape = shapesInstances[connectorId].shape;

            //var pathLabel = LeaderLine.pathLabel('Queries');
            var captionLabel = LeaderLine.captionLabel('Queries');

            var line = new LeaderLine(firstShape, secondShape, {
                size: 6,
                color: 'black',
                startPlug: 'behind',
                endPlug: 'behind',
                //path: 'grid'
                middleLabel: captionLabel,
                //hide: true,
                //duration: 500,
                //timing: [0.58, 0, 0.42, 1]
            });

            //line.show('draw', { duration: 500, timing: [0.58, 0, 0.42, 1] });

            return line;
        };

        var refreshConnectorLines = function () {
            var connectors = this.options.connectors;
            
            for (var i = 0; i < connectors.length; i++) {
                var connector = connectors[i];
                connector.line.position();
            }
        };

        var refreshShapeConnectorLines = function (id) {
            var connectors = this.options.connectors;

            for (var i = 0; i < connectors.length; i++) {
                var connector = connectors[i];

                if (connector.id.toString() === id.toString() || connector.connectorId.toString() === id.toString()) {
                    connector.line.position();
                }
            }
        };

        var getConnector = function (fromShapeId, toShapeId) {
            return this.options.connectors.find(c =>
                (c.id.toString() === fromShapeId.toString() && c.connectorId.toString() === toShapeId.toString()) ||
                (c.id.toString() === toShapeId.toString() && c.connectorId.toString() === fromShapeId.toString()));
        };

        var isShapeConnected = function (id) {
            return this.options.connectors.some(c =>
                c.id.toString() === id.toString() ||
                c.connectorId.toString() === id.toString());
        };

        var hasConnectionBetween = function (fromShapeId, toShapeId) {
            //return this.options.connectors.some(c =>
            //    (c.id.toString() === fromShapeId.toString() && c.connectorId.toString() === toShapeId.toString()) ||
            //    (c.id.toString() === toShapeId.toString() && c.connectorId.toString() === fromShapeId.toString()));
            return !!getConnector.call(this, fromShapeId, toShapeId);
        };

        var selectConnectorLine = function (id, connectorId) {
            var connector = getConnector.call(this, id, connectorId);

            connector.$line.addClass("dd-line--selected");

            connector.line.outline = true;
            connector.line.setOptions({
                //{ dash: { animation: false } }
                //{ dropShadow: true, dash: true, opacity: 0.1 }

                //color: 'rgb(248, 205, 30)',
                //outlineColor: 'rgb(30, 130, 250)'
                //color: 'rgb(100, 100, 100)',
                //dropShadow: { dx: 0, dy: 3 }
                //dropShadow: true
                outlineColor: 'rgb(0, 0, 0)',
                color: 'black',
                dropShadow: { color: '2196f3', dx: 0, dy: 0 },
                size: 7
            });
        };

        var deselectSelectedConnectorLine = function () {
            var $selectedLine = $(".dd-line--selected");

            if ($selectedLine.length) {
                var fromShapeId = $selectedLine.attr("data-from-id");
                var toShapeId = $selectedLine.attr("data-to-id");

                var connector = getConnector.call(this, fromShapeId, toShapeId);
                connector.line.outline = false;
                connector.line.setOptions({ dropShadow: false, size: 6 });

                $selectedLine.removeClass("dd-line--selected");
            }
        };

        var createConnectorLineContextMenu = function (fromShapeId, toShapeId) {
            var me = this;

            //var selector = ".dd-line";
            //var selector = ".leader-line > g";
            var selector = ".dd-line[data-from-id='" + fromShapeId + "'][data-to-id='" + toShapeId + "']";
            var actions = [{
                iconClass: this.options.removeIcon, text: "Delete", callback: function ($selector) {
                    onUserRemoveLine.call(me, $selector.attr("data-from-id"), $selector.attr("data-to-id"));
                }
            }];

            ContextMenuManager.create(selector, actions);
        };

        /*
         * On user tries to remove a shape (User Action)
         */
        var onUserRemoveLine = function (fromShapeId, toShapeId) {
            // a. Remove the connection line between the following two shapes
            this.disconnectShapes(fromShapeId, toShapeId);

            // b. Save DISCONNECT_SHAPES action, after removing the line
            saveActionState.call(this, ActionEnum.DISCONNECT_SHAPES, { id: fromShapeId, connectorId: toShapeId });

            this.options.toolbarActions.removeButton.disable();
        };

        //#endregion ___________ Connector Lines ______________


        //#region ___________________ Shape ___________________

        var generateUniqueShapeId = function () {
            var shapesInstances = _(this).shapesInstances;

            var id;
            do {
                id = Math.floor(Math.random() * 1000000);
            }
            while (shapesInstances.hasOwnProperty(id));

            return id;
        };

        var drawShape = function (shapeOptions) {
            //var item = this.options.items.find(i => i.type === shapeOptions.itemType);
            var item = this.options.populateItem(shapeOptions.itemType);

            var me = this;

            // Append the shape inside the main-group
            var mainGroup = d3.select('svg.dd-svg').select('.main-group');
            var shapeInstance = new ItemShape(mainGroup, $.extend(true, {}, shapeOptions, {
                //fill: item.fill,
                //border: item.border,
                item: item,
                readOnly: this.options.readOnly,
                allowAdd: true,
                onChange: function (id) {
                    if (isShapeConnected.call(me, id)) {
                        refreshShapeConnectorLines.call(me, id);
                    }

                    deselectSelectedConnectorLine.call(me);
                },
                onSelect: function (itemShape) {
                    onUserSelectShape.call(me, itemShape.id);
                },
                onQuerySelect: function (query) {
                    onUserSelectShape.call(me, query.id);
                },
                onConnectorArrowClicked: function (id) {
                    _(me).svgSelection.classed('connection-mode-on', true);
                    _(me).activeStartConnectorId = id;
                },
                onRemoveShapeClicked: function (id) {
                    onUserRemoveShape.call(me, id);
                },
                onAfterUpdate: function (id) {
                    // Save UPDATE_SHAPE action state
                    saveActionState.call(me, ActionEnum.UPDATE_SHAPE, getShapeOptions.call(me, id));
                },
            }));

            _(this).shapesInstances[shapeOptions.id] = shapeInstance;

            return shapeInstance;
        };

        var getShapeOptions = function (id) {
            var shapeInstance = _(this).shapesInstances[id];
            return shapeInstance.getValue();
        };

        var hasShape = function (id) {
            return _(this).shapesInstances.hasOwnProperty(id);
        };

        /*
         * Here the shape id maybe the itemShapeId or queryShapeId
         */
        var onUserSelectShape = function (id) {
            if (_(this).svgSelection.classed('connection-mode-on')) {
                onUserConnectShapes.call(this, id);
            }

            this.options.toolbarActions.removeButton.enable();
            deselectSelectedConnectorLine.call(this);
        };

        /*
         * On user tries to remove a shape (User Action)
         */
        var onUserRemoveShape = function (id) {
            if (hasShape.call(this, id)) {
                let options = {
                    shapeOptions: getShapeOptions.call(this, id),
                    connectors: isShapeConnected.call(this, id) ? this.getShapeConnectors(id) : []
                };

                // a. Save REMOVE_SHAPE action for actual shape (save the options before removing it)
                saveActionState.call(this, ActionEnum.REMOVE_SHAPE, options);

                // b. Deselect shape if it selected
                //if (isShapeSelected.call(this, id)) {
                //}

                // c. Remove the shape
                this.removeShape(id);
            }
            else {
                var shapesInstances = _(this).shapesInstances;

                for (var shapeId in shapesInstances) {
                    // Check if deleted shape is a child shape
                    if (shapesInstances[shapeId].hasChild(id)) {
                        // a. Deselect shape if it selected
                        //if (isShapeSelected.call(this, id)) {
                        //}

                        // b. Remove the child shape
                        this.removeShape(id);

                        // c. Save UPDATE_SHAPE action for the actual parent shape, after removing it's child
                        saveActionState.call(this, ActionEnum.UPDATE_SHAPE, getShapeOptions.call(this, shapeId));

                        break;
                    }
                }
            }

            this.options.toolbarActions.removeButton.disable();
        };

        var onUserConnectShapes = function (id) {
            var activeStartConnectorId = _(this).activeStartConnectorId;

            if (id.toString() !== activeStartConnectorId.toString()) {
                // a. Connect the shapes
                this.connectShapes(activeStartConnectorId, id);

                // b. Save CONNECT_SHAPES action state
                saveActionState.call(this, ActionEnum.CONNECT_SHAPES, {
                    id: activeStartConnectorId,
                    connectorId: id
                });
            }

            deactiveShapesConnectionMode.call(this);
        };

        //#endregion ________________ Shape ___________________


        //#region __________________ Actions __________________

        var saveActionState = function (actionName, options) {
            // Save actions state
            _(this).actionsState.unshift({ name: actionName, data: options });

            // Reset redo actions state list
            _(this).redoActionsState = [];

            this.options.toolbarActions.undoButton.enable();
            this.options.toolbarActions.redoButton.disable();
        };

        var applyUndoActionState = function (action, previousData) {
            switch (action.name) {
                case ActionEnum.ADD_SHAPE:
                    // Undo by removing the added shape
                    this.removeShape(action.data.id);
                    break;

                case ActionEnum.REMOVE_SHAPE:
                    // Undo by adding the removed shape
                    this.addShape(action.data.shapeOptions);
                    if (action.data.connectors.length) {
                        // Undo by adding removed shape connector lines
                        this.addShapesConnectors(action.data.connectors);
                    }
                    break;

                case ActionEnum.UPDATE_SHAPE:
                    // Undo by getting back the previous options before update
                    this.updateShape(previousData);
                    break;

                case ActionEnum.CONNECT_SHAPES:
                    // Undo by removing the added connector line
                    this.disconnectShapes(action.data.id, action.data.connectorId);
                    break;

                case ActionEnum.DISCONNECT_SHAPES:
                    // Undo by adding the removed connector line
                    this.connectShapes(action.data.id, action.data.connectorId);
                    break;
            }
        };

        var applyRedoActionState = function (action) {
            switch (action.name) {
                case ActionEnum.ADD_SHAPE:
                    this.addShape(action.data);
                    break;

                case ActionEnum.REMOVE_SHAPE:
                    this.removeShape(action.data.shapeOptions.id);
                    break;

                case ActionEnum.UPDATE_SHAPE:
                    this.updateShape(action.data);
                    break;

                case ActionEnum.CONNECT_SHAPES:
                    this.connectShapes(action.data.id, action.data.connectorId);
                    break;

                case ActionEnum.DISCONNECT_SHAPES:
                    this.disconnectShapes(action.data.id, action.data.connectorId);
                    break;
            }
        };

        var resetActionsState = function () {
            _(this).actionsState = [];
            _(this).redoActionsState = [];

            this.options.toolbarActions.undoButton.disable();
            this.options.toolbarActions.redoButton.disable();
        };

        var getPreviousShapeDataFromInitialImportedDate = function (id) {
            var shape;

            var importedShapes = _(this).initialImportedData.shapes;
            if (importedShapes && importedShapes.length) {
                shape = importedShapes.find(s => s.id.toString() === id.toString());
            }

            return shape;
        };

        //#endregion _______________ Actions __________________

        //#endregion ________________________ Private Methods ___________________________

        Diagram.prototype.render = function () {
            return _(this).$diagram;
        };

        /*
         * This method returns an object { shapes: [], connectors: [] }
         */
        Diagram.prototype.getData = function () {
            var shapes = [];

            var shapesInstances = _(this).shapesInstances;
            for (var id in shapesInstances) {
                var shapeInstance = shapesInstances[id];
                shapes.push(shapeInstance.getValue());
            }

            return {
                shapes: shapes,
                connectors: this.options.connectors.map(function (c) {
                    return { id: c.id, connectorId: c.connectorId };
                })
            };
        };

        /*
         * options has two keys { shapes: [], connectors: [{ id:.., connectorId:.. }] }
         */ 
        Diagram.prototype.addData = function (dataOptions) {
            // Add shapes
            this.addShapes(dataOptions.shapes);

            // Connect shapes
            var connectors = dataOptions.connectors;
            for (var i = 0; i < connectors.length; i++) {
                this.connectShapes(connectors[i].id, connectors[i].connectorId);
            }

            // Save added data
            if (isEditable.call(this)) {
                _(this).initialImportedData = dataOptions;
                resetActionsState.call(this);
            }
        };

        Diagram.prototype.addShape = function (shape) {
            if (!hasShape.call(this, shape.id)) {
                drawShape.call(this, shape);
            }
        };

        Diagram.prototype.addShapes = function (shapes) {
            for (var i = 0; i < shapes.length; i++) {
                this.addShape(shapes[i]);
            }
        };

        Diagram.prototype.updateShape = function (shape) {
            if (hasShape.call(this, shape.id)) {
                var shapeInstance = _(this).shapesInstances[shape.id];
                shapeInstance.update(shape);
            }
        };

        Diagram.prototype.removeShape = function (id) {
            var shapesInstances = _(this).shapesInstances;

            // Check if user is attempting to delete an outer shape
            if (shapesInstances.hasOwnProperty(id)) {
                // Check if this shape is connected, then remove connected lines
                if (isShapeConnected.call(this, id)) {
                    this.removeShapeConnectors(id);
                }

                // Remove the shape
                shapesInstances[id].remove(id);
                delete shapesInstances[id];
            }
            else {
                // Remove inner shape(query shape)
                for (var shapeId in shapesInstances) {
                    // Check if user is attempting to delete an inner shape(query shape)
                    if (shapesInstances[shapeId].hasChild(id)) {
                        shapesInstances[shapeId].removeChild(id);
                        break;
                    }
                }
            }
        };

        Diagram.prototype.removeSelectedShapeOrLine = function () {
            var me = this;
            $selectedShapes = $(".shape--selected");

            // If selected object is a shape
            if ($selectedShapes.length) {
                $selectedShapes.each(function () {
                    let shapeId = $(this).parent().attr("data-id");

                    // Remove selected shape
                    onUserRemoveShape.call(me, shapeId);
                });
            }
            else {
                $selectedLines = $(".dd-line--selected");

                // If selected object is a line
                if ($selectedLines.length) {
                    $selectedLines.each(function () {
                        let fromShapeId = $(this).attr("data-from-id");
                        let toShapeId = $(this).attr("data-to-id");

                        // Remove selected line
                        onUserRemoveLine.call(me, fromShapeId, toShapeId);
                    });
                }
            }
        };

        Diagram.prototype.connectShapes = function (id, connectorId) {
            if (hasConnectionBetween.call(this, id, connectorId)) {
                return;
            }

            // Create leader-line
            var line = createConnectorLine.call(this, id, connectorId);

            var connectorObject = {
                id: id,
                connectorId: connectorId,
                line: line
            }

            // Adding a workaround to get the "leader-line svg" from ui
            var $lineSvg = $("body").children("svg").last();

            // Bind text click event
            var $text = $lineSvg.children("text");
            $text.click(function () {
                alert('Queries');
            });

            if (isEditable.call(this)) {
                // Make the line selectable
                var $line = $lineSvg.find("> g > use:first")
                                    .addClass("dd-line")
                                    .attr({ "data-from-id": id, "data-to-id": connectorId });

                connectorObject.$line = $line;

                var me = this;
                $line.click(function () {
                    deselectAllSelectedShapes.call(me);
                    selectConnectorLine.call(me, id, connectorId);
                    me.options.toolbarActions.removeButton.enable();
                });

                // Create line contextMenu
                createConnectorLineContextMenu.call(this, id, connectorId);
            }

            // Save added connector
            this.options.connectors.push(connectorObject);

            // Add a workaround to reposition the line
            line.position();
        };

        Diagram.prototype.disconnectShapes = function (id, connectorId) {
            var connectors = this.options.connectors;

            var index = connectors.findIndex(c => c.id.toString() === id.toString() && 
                                c.connectorId.toString() === connectorId.toString());

            if (index >= 0) {
                connectors[index].line.remove();
                connectors.splice(index, 1);
            }
        };

        Diagram.prototype.addShapesConnectors = function (connectors) {
            for (var i = 0; i < connectors.length; i++) {
                let connector = connectors[i];
                this.connectShapes(connector.id, connector.connectorId);
            }
        };

        Diagram.prototype.removeShapeConnectors = function (id) {
            var connectors = this.options.connectors;

            for (var i = connectors.length - 1; i >= 0; i--) {
                let connector = connectors[i];

                if (connector.id.toString() === id.toString() ||
                    connector.connectorId.toString() === id.toString()) {
                    connector.line.remove();
                    connectors.splice(i, 1);
                }
            }
        };

        Diagram.prototype.refreshConnectors = function () {
            refreshConnectorLines.call(this);
        };

        Diagram.prototype.getShapeConnectors = function (id) {
            var connectors = this.options.connectors;

            var shapeConnectors = [];
            for (var i = 0; i < connectors.length; i++) {
                let connector = connectors[i];

                if (connector.id.toString() === id.toString() ||
                    connector.connectorId.toString() === id.toString()) {
                    shapeConnectors.push(connector);
                }
            }

            return shapeConnectors;
        };

        Diagram.prototype.undo = function () {
            var actionsState = _(this).actionsState;

            // Move the last action from undo list to redo list
            var lastAction = actionsState.shift();
            _(this).redoActionsState.unshift(lastAction);

            var previousShapeActionData;
            if (lastAction.name === ActionEnum.UPDATE_SHAPE) {
                // Find the previous action state before update
                var previousShapeActionState = actionsState.find(action => {
                    var isAddOrUpdate = action.name === ActionEnum.ADD_SHAPE ||
                                            action.name === ActionEnum.UPDATE_SHAPE;

                    return isAddOrUpdate && action.data.id.toString() === lastAction.data.id.toString();
                });

                // If the is no previous action state, get previous action state from inital imported data
                previousShapeActionData = previousShapeActionState ? previousShapeActionState.data :
                    getPreviousShapeDataFromInitialImportedDate.call(this, lastAction.data.id);
            }

            // Apply the undo action on UI
            applyUndoActionState.call(this, lastAction, previousShapeActionData);

            // If undo list is empty, disable redo button
            if (_(this).actionsState.length === 0) {
                this.options.toolbarActions.undoButton.disable();
            }

            // Enable redo button
            this.options.toolbarActions.redoButton.enable();
        };

        Diagram.prototype.redo = function () {
            // Move the last action from redo list to undo list
            var lastAction = _(this).redoActionsState.shift();
            _(this).actionsState.unshift(lastAction);

            // Apply the redo action on UI
            applyRedoActionState.call(this, lastAction);

            // If redo list is empty, disable redo button
            if (_(this).redoActionsState.length === 0) {
                this.options.toolbarActions.redoButton.disable();
            }

            // Enable undo button
            this.options.toolbarActions.undoButton.enable();
        };

        Diagram.prototype.empty = function () {
            this.options.connectors.forEach(c => this.disconnectShapes(c.id, c.connectorId));

            // Unbind contextMenu
            //$(".shape-group").each(function () {
            //    $(this).unbind();
            //});

            //TODO_N: Remove all shapes
        };

        // Create a set property: drawable of type boolean
        Object.defineProperty(Diagram.prototype, "drawable", {
            set: function (value) {
                var isDrawingAlreadyEnabled = isDrawingEnabled.call(this);

                // If the drawing mode changed, toggle the value
                if (isDrawingAlreadyEnabled !== value) {
                    if (value === true) {
                        // Drawing Mode
                        _(this).svgSelection.classed("dd-svg--drawable", true);
                        unbindSelectionEvents.call(this);
                        registerDrawingEvents.call(this);
                    }
                    else {
                        // Selection Mode
                        _(this).svgSelection.classed("dd-svg--drawable", false);
                        unbindDrawingEvents.call(this);
                        registerSelectionEvents.call(this);
                    }
                }
            }
        });

        return Diagram;
    })();

    //#endregion ************************ Diagram Class ***************************//


    //#region ************ Shape Selection Manager Class (Static Class) ***********//

    var ShapeSelectionManager = {
        element: null,
        _rect: function (x, y, w, h) {
            return "M" + [x, y] + " l" + [w, 0] + " l" + [0, h] + " l" + [-w, 0] + "z";
        },
        mousedown: function (startPoint, onStopFn) {
            var me = this;

            this.start(startPoint);

            var subject = d3.select(window);
            subject
                .on("mousemove.selection", function (e) {
                    me.move(startPoint, { x: e.offsetX, y: e.offsetY });

                    e.stopPropagation();
                    e.preventDefault();
                })
                .on("mouseup.selection", function (e) {
                    var position = { x: e.offsetX, y: e.offsetY };
                    me.end(startPoint, position);

                    subject
                        .on("mousemove.selection", null)
                        .on("mouseup.selection", null);

                    onStopFn(startPoint, position);
                })
        },
        touchstart: function (e, subject, offset, startPoint, onStopFn) {
            var me = this;

            this.start(startPoint);

            var id = e.changedTouches[0].identifier;
            var position;

            subject
                .on("touchmove." + id, function (e) {
                    position = {
                        x: e.changedTouches[0].clientX - offset.left,
                        y: e.changedTouches[0].clientY - offset.top
                    }

                    me.move(startPoint, position);
                })
                .on("touchend." + id, function (e) {
                    position = {
                        x: e.changedTouches[0].clientX - offset.left,
                        y: e.changedTouches[0].clientY - offset.top
                    }

                    me.end(startPoint, position);

                    subject
                        .on("touchmove." + id, null)
                        .on("touchend." + id, null);

                    onStopFn(startPoint, position);
                });
        },
        start: function (start) {
            this.element
                .attr("d", this._rect(start.x, start.y, 0, 0))
                .attr("visibility", "visible");
        },
        move: function (start, moved) {
            this.element.attr("d", this._rect(start.x, start.y, moved.x - start.x, moved.y - start.y));
        },
        end: function (start, end) {
            this.element.attr("visibility", "hidden");
        },
        remove: function () {
            this.element.remove();
        }
    };

    //#endregion ********* Shape Selection Manager Class (Static Class) ***********//


    //#region ************************** Item Shape Class *************************//

    /*
     * options: {
     *  item:..,
     *  readOnly: true/false(default),
     *  allowAdd: true/false(default),
     *  id:..,
     *  edgePoints: [{ x:.., y:.. }, {..}], // Two points(startEdgePoint and endEdgePoint)
     *  midPoints: [{ x:.., y:.. }, {..}, {..}, {..}], // Four points(topMidPoint, rightMidpoint, bottomMidpoint, leftMidpoint)
     *  queries: [],
     *  onChange: function () {},
     *  onSelect: function () {},
     *  onQuerySelect: function () {},
     *  onConnectorArrowClicked: function () {},
     *  onRemoveShapeClicked: function () {},
     *  onAfterUpdate: function () {},
     * }
     */
    var ItemShape = (function () {
        var defaults = {
            readOnly: false,
            item: {},
            edgePoints: [],
            midPoints: [],
            allowAdd: false,
            shapes: [],
        };

        var priv = new WeakMap();
        var _ = function (instance) { return priv.get(instance); };

        function ItemShape(selection, options) {
            this.options = $.extend(true, {}, defaults, options);

            var privateMembers = {
                shapeGroup: selection.append('g') // D3 selection
                                        .attr('data-id', this.options.id)
                                        .attr('transform', 'translate(0.5,0.5)')
                                        .classed('shape-group', true),
                rectPolyShapeInstance: null, // D3 selection
                queriesSvgSelection: null, // D3 selection
                queryShapesInstances: {},
            };

            priv.set(this, privateMembers);

            // Initialization
            init.call(this);
        }

        //#region ___________________________ Private Methods ___________________________

        var init = function () {
            if (!this.options.readOnly) {
                // Create shape context menu
                createShapeContextMenu.call(this, this.options.id);
            }

            // Create shape
            createItemShape.call(this);
        };

        /*
         * This method creates shape from options
         */
        var createItemShape = function () {
            // Append RectPolygon shape
            appendRectPolygonShape.call(this);

            // Append queries svg
            appendQueriesSvg.call(this);

            if (this.options.queries && this.options.queries.length) {
                appendQueries.call(this, this.options.queries);
            }

            if (!this.options.readOnly) {
                appendArrows.call(this);
            }

            _(this).rectPolyShapeInstance.reDraw();
        };

        var appendQueries = function (queries) {
            for (var i = 0; i < queries.length; i++) {
                appendQueryShape.call(this, queries[i]);
            }
        };

        //#region ____________ RectPolygon Creation ___________

        var appendRectPolygonShape = function () {
            var isEditable = !this.options.readOnly;

            // Append RectPolygon shape
            var me = this;
            _(this).rectPolyShapeInstance = new RectanglePolygonShape(_(this).shapeGroup, {
                id: this.options.id,
                edgePoints: this.options.edgePoints,
                midPoints: this.options.midPoints,
                fill: this.options.item.fill,
                border: this.options.item.border,
                selectable: isEditable,
                resizable: isEditable,
                movable: isEditable,
                onSelect: function (id) {
                    var shape = me.getValue(id);
                    me.options.onSelect(shape);

                    showShapeFormat.call(me, shape);
                },
                onUpdate: function (edgePoints, midPoints) {
                    me.options.edgePoints = edgePoints;
                    me.options.midPoints = midPoints;

                    if (isEditable && me.options.allowAdd) {
                        updateQueriesSvg.call(me, edgePoints, midPoints);
                    }

                    updateArrows.call(me, midPoints);

                    if (me.options.onChange instanceof Function) {
                        me.options.onChange(me.options.id);
                    }
                },
                onAfterUpdate: this.options.onAfterUpdate,
            });
        };

        var showShapeFormat = function (shape) {
            var item = this.options.item;

            // 1. Empty the panel
            FormatProxy.empty();

            // 2. Append query type title
            FormatProxy.setTitle(item.text);

            // 3. Append format shape elements
            //FormatProxy.append();
        };

        //#endregion _________ RectPolygon Creation ___________


        //#region ________________ Queries Svg ________________

        var appendQueriesSvg = function () {
            var points = _(this).rectPolyShapeInstance.getEdgePoints();
            var dimensions = this.getDimensions();

            _(this).queriesSvgSelection = _(this).shapeGroup.append('svg')
                                                            .attr('class', 'shape-queries-svg')
                                                            .attr('x', points[0].x - 4)
                                                            .attr('y', points[0].y - 4)
                                                            .attr('width', dimensions.width)
                                                            .attr('height', dimensions.height)
                                                            .on('mousedown', function (e) {
                                                                e.stopPropagation();
                                                            });

            var isEditable = !this.options.readOnly;
            if (isEditable && this.options.allowAdd) {
                appendAddQueryButton.call(this);
            }
        };

        var updateQueriesSvg = function (points, midPoints) {
            var dimensions = this.getDimensions();

            _(this).queriesSvgSelection
                .attr('x', points[0].x - 4)
                .attr('y', points[0].y - 4)
                .attr('width', dimensions.width)
                .attr('height', dimensions.height);
        };

        var appendAddQueryButton = function () {
            var me = this;

            var buttonGroupInstance = new CircleButton({
                className: "add-shape-btn-grp",
                x: 20, y: 24, r: 12, cx: 20, cy: 20,
                text: "+",
                onClick: function () {
                    showQueryBuilder.call(me, "Create", function (query) {
                        onUserCreateQuery.call(me, query.type, query.data);
                    });
                }
            });

            _(this).queriesSvgSelection.node().append(buttonGroupInstance.render());
        };

        var showQueryBuilder = function (btnTitle, btnSuccessFn, optQuery) {
            var queryBuilderInstance = new QueryBuilder({
                attributes: this.options.item.attributes,
                query: optQuery
            });

            var $queryBuilderWrap = $("<div>")
                                        .append(queryBuilderInstance.render());

            var me = this;
            Specto.ui.Modal.showModal($queryBuilderWrap, "Query",
                [
                    {
                        label: btnTitle, color: "btn-primary", onClick: function (modal) {
                            if (!queryBuilderInstance.isEmpty()) {
                                var query = queryBuilderInstance.getQuery();

                                btnSuccessFn(query);
                                modal.close();
                            }
                        }
                    },
                    { label: "Cancel", color: "btn-primary" }
                ]
            );
        };

        var onUserCreateQuery = function (type, data) {
            appendQueryShape.call(this, {
                id: generateUniqueShapeId.call(this),
                edgePoints: [{ x: 50, y: 50 }, { x: 150, y: 150 }],
                type: type,
                data: data
            });

            if (this.options.onAfterUpdate instanceof Function) {
                this.options.onAfterUpdate(this.options.id);
            }
        };

        var generateUniqueShapeId = function () {
            var queryShapesInstances = _(this).queryShapesInstances;

            var id;
            do {
                id = Math.floor(Math.random() * 1000000);
            }
            while (queryShapesInstances.hasOwnProperty(id));

            return id;
        };

        var appendQueryShape = function (query) {
            var isEditable = !this.options.readOnly;

            var queryShapeGroup = _(this).queriesSvgSelection.append('g')
                                        .attr('data-id', query.id)
                                        .attr('class', 'shape-group');

            if (isEditable) {
                // Create sub shape context menu
                createShapeContextMenu.call(this, query.id);
            }

            var me = this;
            var queryShapeInstance = new RectangleShape(queryShapeGroup, $.extend(true, {}, query, {
                selectable: isEditable,
                resizable: isEditable,
                movable: isEditable,
                onSelect: function (id) {
                    var query = getQueryValue.call(me, id);

                    me.options.onQuerySelect(query);
                    showQueryFormat.call(me, query);
                },
                onUpdate: function (edgePoints) {
                    queryShapeInstance.data.queryInstance.update(edgePoints); //TODO_N
                },
                onAfterUpdate: function (childId) {
                    var mainShapeId = me.options.id;
                    me.options.onAfterUpdate(mainShapeId);
                },
            }));

            _(this).queryShapesInstances[query.id] = queryShapeInstance;


            if (query.type) {
                appedQueryByType.call(this, query.type, query);
            }

            queryShapeInstance.reDraw();
        };

        var appedQueryByType = function (type, query) {
            var queryShapeInstance = _(this).queryShapesInstances[query.id];
            var queryShapeGroup = d3.select(queryShapeInstance.parentNode);

            //var mappedQueryUiData = QueryDataMapper.mapUiData(this.options.item, query.data);
            let mappedQueryUiData = FieldFactory.mapUiQueryData(query.data, this.options.item.attributes);

            let queryText = QueryFactory.getQueryText(query.type);

            //queryShapeGroup.append("text").text(queryText)
            //    .attr("transform", "translate(" + (query.edgePoints[0].x + 3) + "," + (query.edgePoints[0].y + 20) + ")");

            let queryInstance = QueryFactory.createQuery(type, queryShapeGroup, {
                data: mappedQueryUiData,
                edgePoints: query.edgePoints
            });

            queryShapeInstance.data = {
                queryInstance: queryInstance,
                query: query // Original Data
            };
        };

        var getQueryValue = function (queryShapeId) {
            let queryShapeInstance = _(this).queryShapesInstances[queryShapeId];

            return {
                id: queryShapeId,
                edgePoints: queryShapeInstance.getEdgePoints(),
                type: queryShapeInstance.data.query.type,
                data: queryShapeInstance.data.query.data
            };
        };

        var showQueryFormat = function (query) {
            var me = this;
            var queryId = query.id;

            // 1. Empty the panel
            FormatProxy.empty();

            // 2. Append query type title
            FormatProxy.setTitle(QueryFactory.getQueryText(query.type));

            // 3. Append format query elements
            // a. Edit query
            var $editBtn = $("<button type='button'>")
                .addClass("btn btn-default")
                .text("Edit")
                .click(function () {
                    showQueryBuilder.call(me, "Edit", function (updatedQuery) {
                        // Destroy the loaded/rendered query
                        var queryShapeInstance = _(me).queryShapesInstances[query.id];
                        var queryInstance = queryShapeInstance.data.queryInstance;
                        queryInstance.destroy();
                        delete queryShapeInstance.data.queryInstance;
                        delete queryShapeInstance.data.query;

                        // Edit query
                        // Important Note: On extend, set first argument to false, to replace the query data
                        //  instead of merging them
                        appedQueryByType.call(me, updatedQuery.type, $.extend(false, {}, query, updatedQuery));
                    }, query);
                });

            FormatProxy.append($editBtn);
        };

        //#endregion _____________ Queries Svg ________________


        //#region ______________ Connetor Arrows ______________

        var appendArrows = function () {
            var connectorLines = _(this).shapeGroup.append("g")
                .attr("class", "connector-arrows");

            var me = this;
            for (var i = 1; i <= 4; i++) {
                let group = connectorLines.append("g")
                    .attr("class", "connector-arrow");

                group.append("line")
                    .attr("marker-end", "url(#triangle)")
                    .on("mousedown", function (e) {
                        e.stopPropagation();

                        group.classed("connector-arrow--active", true);
                        _(me).shapeGroup.classed('active', true);

                        if (me.options.onConnectorArrowClicked instanceof Function) {
                            me.options.onConnectorArrowClicked(me.options.id);
                        }
                    })
                    .on("click", function (e) {
                        e.stopPropagation();
                    });
            }
        };

        updateArrows = function (midPoints) {
            var degrees = [270, 0, 90, 180];

            _(this).shapeGroup.selectAll(".connector-arrow line").data(midPoints)
                .attr("x1", data => data.x)
                .attr("y1", data => data.y)
                .attr("x2", data => data.x + 20)
                .attr("y2", data => data.y)
                .attr("transform", function (data, index) {
                    return "rotate(" + degrees[index] + " " + data.x + " " + data.y + ")";
                });
        };

        //#endregion ___________ Connetor Arrows ______________


        //#region ________________ Context Menu _______________

        var createShapeContextMenu = function (id, actions) {
            var me = this;

            var selector = ".shape-group[data-id='" + id + "']";

            var removeAction = {
                iconClass: this.options.removeIcon, text: "Delete", callback: function ($selector) {
                    me.options.onRemoveShapeClicked($selector.attr("data-id"));
                }
            };

            var menuActions = actions && actions.length ? actions.concat([removeAction]) : [removeAction];

            //ContextMenuManager.create(selector, menuActions);
        };

        //#endregion _____________ Context Menu _______________

        //#endregion ________________________ Private Methods ___________________________

        ItemShape.prototype.updateEndPoint = function (endPoint) {
            _(this).rectPolyShapeInstance.updateEndPoint(endPoint);
        };

        ItemShape.prototype.getDimensions = function () {
            return _(this).rectPolyShapeInstance.getDimensions();
        };

        ItemShape.prototype.remove = function () {
            _(this).shapeGroup.remove();
        };

        ItemShape.prototype.hasChild = function (id) {
            return _(this).queryShapesInstances.hasOwnProperty(id);
        };

        ItemShape.prototype.removeChild = function (id) {
            delete _(this).queryShapesInstances[id];

            var queryShapeGroup = _(this).queriesSvgSelection.select(".shape-group[data-id='" + id + "']");
            queryShapeGroup.remove();
        };

        ItemShape.prototype.getValue = function () {
            var queries = [];
            var queryShapesInstances = _(this).queryShapesInstances;
            if (queryShapesInstances && Object.keys(queryShapesInstances).length) {
                for (var queryShapeId in queryShapesInstances) {
                    queries.push(getQueryValue.call(this, queryShapeId));
                }
            }

            var rectPolyShapeInstance = _(this).rectPolyShapeInstance;
            return {
                id: this.options.id,
                itemType: this.options.item.type,
                edgePoints: rectPolyShapeInstance.getEdgePoints(),
                midPoints: rectPolyShapeInstance.getMidPoints(),
                queries: queries
            };
        };

        ItemShape.prototype.update = function (options) {
            // Here we should set false instead of true
            this.options = $.extend(false, this.options, options);
            //empty.call(this);
            //createItemShape.call(this);

            // Remove all sub shapes(queries' shapes)
            _(this).queriesSvgSelection.selectAll(".shape-group").remove();
            _(this).queryShapesInstances = {};

            // Update the shapes and resizable points
            _(this).rectPolyShapeInstance.update(this.options.edgePoints, this.options.midPoints);

            // Insert new sub shapes(queries' shapes)
            if (this.options.queries && this.options.queries.length) {
                appendQueries.call(this, this.options.queries);
            }
        };

        ItemShape.prototype.classed = function (className, value) {
            _(this).shapeGroup.classed(className, value);
        };

        ItemShape.prototype.isInRange = function (x1, x2, y1, y2) {
            var points = this.options.edgePoints;

            return (points[0].x >= x1 && points[0].y >= y1) &&
                (points[1].x <= x2 && points[1].y <= y2);
        };

        ItemShape.prototype.select = function () {
            _(this).rectPolyShapeInstance.select();
        };

        // Create a read-only property: shape
        Object.defineProperty(ItemShape.prototype, "shape", {
            get: function () {
                return _(this).shapeGroup.select('polygon').node();
                //return _(this).shapeGroup.select('polygon')._groups[0][0];
                //return _(this).shapeGroup._groups[0][0];
            }
        });

        return ItemShape;
    })();

    //#endregion *********************** Item Shape Class *************************//


    //#region ************************ Circle Button Class ************************//

    /*
     * options = {
     *  x:..,
     *  y:..,
     *  r:..,
     *  rx:..,
     *  ry:..,
     *  className:..,
     *  onClick: function () {}
     * }
     */
    var CircleButton = (function () {
        var priv = new WeakMap();
        var _ = function (instance) { return priv.get(instance); };

        var CircleButton = function (options) {
            if (options) {
                this.options = $.extend(true, {}, options);

                var privateMembers = {
                    buttonGroup: createButton.call(this), // D3 selection
                };

                priv.set(this, privateMembers);

                // Initialization
                init.call(this);
            }
        }

        //#region ___________________________ Private Methods ___________________________

        var init = function () {
        };

        var createButton = function () {
            var me = this;

            var buttonGroup = d3.create("svg").append('g')
                .attr('class', "dd-circle-btn")
                .on('click', function () {
                    if (me.options.onClick instanceof Function) {
                        me.options.onClick();
                    }
                });

            if (this.options.className) {
                buttonGroup.classed(this.options.className, true);
            }

            buttonGroup
                .append('circle')
                .attr('r', this.options.r)
                .attr('cx', this.options.cx)
                .attr('cy', this.options.cy);

            buttonGroup
                .append('text')
                .attr('x', this.options.x)
                .attr('y', this.options.y)
                .text(this.options.text);

            return buttonGroup;
        };

        //#endregion ________________________ Private Methods ___________________________

        CircleButton.prototype.render = function () {
            //selection.node().appendChild(buttonGroup.node());
            return _(this).buttonGroup.node();
        };

        return CircleButton;
    })();

    //#endregion ********************* Circle Button Class ************************//


    //#region *************************** Shapes Classes **************************//

    var ShapeBase = (function () {
        var defaults = {
            fill: 'white',
            border: 'black',
            selectable: false,
            resizable: false,
            movable: false
        };

        var priv = new WeakMap();
        var _ = function (instance) { return priv.get(instance); };

        var ShapeBase = function (selection, options) {
            if (options) {
                this.options = $.extend(true, {}, defaults, options);

                var privateMembers = {
                    shapeSelection: this._appendShape(selection), // D3 selection
                    data: null,
                };

                priv.set(this, privateMembers);

                // Initialization
                init.call(this, selection);
            }
        }

        //#region ___________________________ Private Methods ___________________________

        var init = function (selection) {
            if (this.options.selectable) {
                makeShapeSelectable.call(this);
            }

            if (this.options.movable) {
                makeShapeMovable.call(this);
            }

            if (this.options.resizable) {
                this._appendResizablePoints(selection);
            }
        };

        var makeShapeSelectable = function () {
            var me = this;

            _(this).shapeSelection.on('click', function (e) {
                e.stopPropagation();
                onUserSelectShape.call(me);
            });
        };

        var makeShapeMovable = function () {
            var me = this;

            let isMoving = false;

            _(this).shapeSelection
                //.attr('data-id', this.options.id)
                .classed('movable', true)
                .call(d3.drag()
                    .on('drag', function (e) {
                        isMoving = true;
                        onShapeDragging.call(me, e);
                    })
                    .on('start', function () {
                        $(this).addClass('dragging');
                    })
                    .on('end', function () {
                        $(this).removeClass('dragging');
                        onUserSelectShape.call(me);

                        if (isMoving) {
                            isMoving = false;

                            if (me.options.onAfterUpdate instanceof Function) {
                                me.options.onAfterUpdate(me.options.id);
                            }
                        }
                    })
                );
        };

        var onShapeDragging = function (e) {
            // Deselect the current shape
            _(this).shapeSelection.classed("shape--selected", false);

            this._updateResizablePoints(e);
            this._updateShape();
        };

        var onUserSelectShape = function () {
            // Deselect all selected shapes
            d3.selectAll(".shape--selected").classed("shape--selected", false);
            this.select();

            if (this.options.onSelect instanceof Function) {
                this.options.onSelect(this.options.id);
            }
        };

        //#endregion ________________________ Private Methods ___________________________

        ShapeBase.prototype._appendShape = function (selection) {
            throw "You must override the abstract method \'_appendShape\' in " + this.constructor.name + " child class";
        };

        ShapeBase.prototype._updateShape = function () {
            throw "You must override the abstract method \'_updateShape\' in " + this.constructor.name + " child class";
        };

        ShapeBase.prototype._appendResizablePoints = function (selection) {
            throw "You must override the abstract method \'_appendResizablePoints\' in " + this.constructor.name + " child class";
        };

        ShapeBase.prototype._updateResizablePoints = function (e) {
            throw "You must override the abstract method \'_updateResizablePoints\' in " + this.constructor.name + " child class";
        };

        ShapeBase.prototype.getDimensions = function () {
            throw "You must override the abstract method \'getDimensions\' in " + this.constructor.name + " child class";
        };

        ShapeBase.prototype._getShapeSelection = function () {
            return _(this).shapeSelection;
        };

        ShapeBase.prototype.reDraw = function () {
            this._updateShape();
        };

        ShapeBase.prototype.select = function () {
            _(this).shapeSelection.classed("shape--selected", true);
        };

        // Create a property: data
        Object.defineProperty(ShapeBase.prototype, "data", {
            set: function (value) {
                _(this).data = value;
            },
            get: function () {
                return _(this).data;
            }
        });

        //TODO_N: Remove this code (This code is a workaround to get the parent)
        Object.defineProperty(ShapeBase.prototype, "parentNode", {
            get: function () {
                return _(this).shapeSelection.node().parentNode;
            }
        });

        return ShapeBase;
    })();

    /*
    * options = {
    *  selectable: true/false(default),
    *  resizable: true/false(default),
    *  movable: true/false(default),
    *  onSelect: function (id) {},
    *  onUpdate: function (id) {},
    *  onAfterUpdate: function(id) {},
    *  id:..,
    *  edgePoints: [],
    *  fill:..,
    *  border:..,
    * }
    */
    var RectangleShape = (function (parent) {
        var priv = new WeakMap();
        var _ = function (instance) { return priv.get(instance); };

        var RectangleShape = function (selection, options) {
            //this.options = $.extend(true, {}, defaults, options);

            var privateMembers = {
                //shapeSelection: null, // D3 selection
                edgePointsGroupInstance: null,
            };

            priv.set(this, privateMembers);

            parent.call(this, selection, options);

            // Initialization
            init.call(this);
        }

        RectangleShape.prototype = new parent();
        RectangleShape.prototype.constructor = RectangleShape;

        //#region ___________________________ Private Methods ___________________________

        var init = function () {

        };

        //#endregion ________________________ Private Methods ___________________________

        /* Overrided protected method */
        RectangleShape.prototype._appendShape = function (selection) {
            return selection
                    .append('rect')
                    .attr('class', 'shape rect')
                    .attr('fill', this.options.fill);
        };

        /* Overrided protected method */
        RectangleShape.prototype._updateShape = function () {
            var points = this.options.edgePoints;
            var dimensions = this.getDimensions();

            this._getShapeSelection()
                .attr('x', points[0].x)
                .attr('y', points[0].y)
                .attr('width', dimensions.width)
                .attr('height', dimensions.height);

            if (this.options.onUpdate instanceof Function) {
                this.options.onUpdate(this.options.edgePoints);
            }
        };

        /* Overrided protected method */
        RectangleShape.prototype._appendResizablePoints = function (selection) {
            var me = this;

            _(this).edgePointsGroupInstance = new ResizableEdgePointsGroup(selection, {
                points: this.options.edgePoints,
                onResizing: function (e, newPoints) {
                    me.options.edgePoints = newPoints;
                    me._updateShape();
                },
                onResized: function (newPoints) {
                    me.options.edgePoints = newPoints;

                    if (me.options.onAfterUpdate instanceof Function) {
                        me.options.onAfterUpdate(me.options.id);
                    }
                },
            });
        };

        /* Overrided protected method */
        RectangleShape.prototype._updateResizablePoints = function (e) {
            var points = this.options.edgePoints;

            for (let i = 0; i < points.length; i++) {
                points[i].x += e.dx;
                points[i].y += e.dy;
            }

            _(this).edgePointsGroupInstance.updatePoints($.extend(true, [], points));
        };

        /* Overrided public method */
        RectangleShape.prototype.getDimensions = function () {
            var points = this.options.edgePoints;

            return {
                width: points[1].x - points[0].x,
                height: points[1].y - points[0].y
            };
        };

        RectangleShape.prototype.getEdgePoints = function () {
            return $.extend(true, [], this.options.edgePoints);
        };

        return RectangleShape;
    })(ShapeBase);

    /*
     * options = {
     *  selectable: true/false(default),
     *  resizable: true/false(default),
     *  movable: true/false(default),
     *  onSelect: function (id) {},
     *  onUpdate: function (id) {},
     *  onAfterUpdate: function(id) {},
     *  id:..,
     *  edgePoints: [],
     *  midPoints: [],
     *  fill:..,
     *  border:..,
     * }
     */
    var RectanglePolygonShape = (function (parent) {
        var priv = new WeakMap();
        var _ = function (instance) { return priv.get(instance); };

        var RectanglePolygonShape = function (selection, options) {
            //this.options = $.extend(true, {}, defaults, options);

            var privateMembers = {
                shapeSelection: null, // D3 selection
                midPoints: null, // Object (Get midPoints from options midPoints array or generate a new object)
                edgePointsGroupInstance: null,
                midPointsGroupInstance: null,
            };

            priv.set(this, privateMembers);

            parent.call(this, selection, options);

            // Initialization
            init.call(this);
        }

        RectanglePolygonShape.prototype = new parent();
        RectanglePolygonShape.prototype.constructor = RectanglePolygonShape;

        //#region ___________________________ Private Methods ___________________________

        var init = function () {
            //if (!(this.options.midPoints && this.options.midPoints.length)) {
            //    this.options.midPoints = generateMidPoints.call(this);
            //}
            //_(this).midPoints = getMidPointsFromOptions.call(this);
        };

        //#region _______________ Shared Methods ______________

        var getPolygonPoints = function () {
            var points = this.options.edgePoints;
            var midPoints = _(this).midPoints;

            var polygonPoints = [
                { x: points[0].x, y: points[0].y },
                midPoints.xTop,
                { x: points[1].x, y: points[0].y },
                midPoints.yRight,
                { x: points[1].x, y: points[1].y },
                midPoints.xBottom,
                { x: points[0].x, y: points[1].y },
                midPoints.yLeft
            ];

            return polygonPoints.map(p => p.x + ',' + p.y).join(' ');
        };

        //#endregion ____________ Shared Methods ______________


        //#region _________________ Midpoints _________________

        var generateMidPoints = function () {
            var points = this.options.edgePoints;

            var dimensions = this.getDimensions();

            var xAxisMidPoint = (dimensions.width / 2) + points[0].x;
            var yAxisMidPoint = (dimensions.height / 2) + points[0].y;

            return [
                { x: xAxisMidPoint, y: points[0].y },
                { x: points[1].x, y: yAxisMidPoint },
                { x: xAxisMidPoint, y: points[1].y },
                { x: points[0].x, y: yAxisMidPoint }
            ];
        };

        var getMidPointsFromOptions = function () {
            var midPointsArray = this.options.midPoints;

            // Note: The order is very important (clockwise)
            return {
                xTop: midPointsArray[0],
                yRight: midPointsArray[1],
                xBottom: midPointsArray[2],
                yLeft: midPointsArray[3]
            };
        };

        var resetAffectedMidpoints = function (e, changedEdgePointPosition) {
            var midPoints = _(this).midPoints;

            midPoints.xTop.x += e.dx / 2;
            midPoints.xBottom.x += e.dx / 2;

            midPoints.yLeft.y += e.dy / 2;
            midPoints.yRight.y += e.dy / 2;

            switch (changedEdgePointPosition) {
                case 0:
                    midPoints.xTop.y += e.dy;
                    midPoints.yLeft.x += e.dx;
                    break;

                case 1:
                    midPoints.xTop.y += e.dy;
                    midPoints.yRight.x += e.dx;
                    break;

                case 2:
                    midPoints.xBottom.y += e.dy;
                    midPoints.yRight.x += e.dx;
                    break;

                case 3:
                    midPoints.xBottom.y += e.dy;
                    midPoints.yLeft.x += e.dx;
                    break;
            }

            this.options.midPoints = [midPoints.xTop, midPoints.yRight, midPoints.xBottom, midPoints.yLeft];
        };

        //#endregion ______________ Midpoints _________________

        //#endregion ________________________ Private Methods ___________________________
        
        /* Overrided protected method */
        RectanglePolygonShape.prototype._appendShape = function (selection) {
            if (!(this.options.midPoints && this.options.midPoints.length)) {
                this.options.midPoints = generateMidPoints.call(this);
            }
            _(this).midPoints = getMidPointsFromOptions.call(this);

            var polygonPointsString = getPolygonPoints.call(this);

            return selection
                    .append('polygon')
                    .attr('points', polygonPointsString)
                    .attr('class', 'shape rect-polygon')
                    .attr('fill', this.options.fill)
                    .attr('stroke', this.options.border);
        };

        /* Overrided protected method */
        RectanglePolygonShape.prototype._appendResizablePoints = function (selection) {
            var me = this;

            _(this).edgePointsGroupInstance = new ResizableEdgePointsGroup(selection, {
                points: this.options.edgePoints,
                onResizing: function (e, newPoints, pointPosition) {
                    me.options.edgePoints = newPoints;
                    resetAffectedMidpoints.call(me, e, pointPosition);

                    _(me).midPointsGroupInstance.updatePoints($.extend(true, [], me.options.midPoints));
                    me._updateShape();
                },
                onResized: function (newPoints) {
                    me.options.edgePoints = newPoints;

                    if (me.options.onAfterUpdate instanceof Function) {
                        me.options.onAfterUpdate(me.options.id);
                    }
                },
            });

            _(this).midPointsGroupInstance = new ResizableMidPointsGroup(selection, {
                points: this.options.midPoints,
                onResizing: function (e, newPoints, pointPosition) {
                    me.options.midPoints = newPoints;
                    _(me).midPoints = getMidPointsFromOptions.call(me);
                    me._updateShape();
                },
                onResized: function (newPoints) {
                    me.options.midPoints = newPoints;

                    if (me.options.onAfterUpdate instanceof Function) {
                        me.options.onAfterUpdate(me.options.id);
                    }
                },
            });
        };

        /* Overrided protected method */
        RectanglePolygonShape.prototype._updateShape = function () {
            var polygonPointsString = getPolygonPoints.call(this);

            this._getShapeSelection()
                .attr('points', polygonPointsString);

            if (this.options.onUpdate instanceof Function) {
                this.options.onUpdate(this.options.edgePoints, this.options.midPoints);
            }
        };

        /* Overrided protected method */
        RectanglePolygonShape.prototype._updateResizablePoints = function (e) {
            var points = this.options.edgePoints;
            var midPoints = this.options.midPoints;

            for (let i = 0; i < points.length; i++) {
                points[i].x += e.dx;
                points[i].y += e.dy;
            }

            // Move the midPoints
            for (let i = 0; i < midPoints.length; i++) {
                midPoints[i].x += e.dx;
                midPoints[i].y += e.dy;
            }
            _(this).midPoints = getMidPointsFromOptions.call(this);

            _(this).edgePointsGroupInstance.updatePoints($.extend(true, [], points));
            _(this).midPointsGroupInstance.updatePoints($.extend(true, [], midPoints));
        };

        /* Overrided public method */
        RectanglePolygonShape.prototype.getDimensions = function () {
            var points = this.options.edgePoints;

            return {
                width: points[1].x - points[0].x,
                height: points[1].y - points[0].y
            };
        };

        RectanglePolygonShape.prototype.update = function (edgePoints, midPoints) {
            this.options.edgePoints = $.extend(true, [], edgePoints);
            this.options.midPoints = $.extend(true, [], midPoints);

            _(this).midPoints = getMidPointsFromOptions.call(this);

            _(this).edgePointsGroupInstance.updatePoints($.extend(true, [], this.options.edgePoints));
            _(this).midPointsGroupInstance.updatePoints($.extend(true, [], this.options.midPoints));

            this._updateShape();
        };

        RectanglePolygonShape.prototype.updateEndPoint = function (endPoint) {
            var points = this.options.edgePoints;
            if (endPoint.x < points[0].x || endPoint.y < points[0].y) {
                points[0] = endPoint;
            }
            else {
                points[1] = endPoint;
            }

            this.options.midPoints = generateMidPoints.call(this);
            _(this).midPoints = getMidPointsFromOptions.call(this);

            _(this).midPointsGroupInstance.updatePoints($.extend(true, [], this.options.midPoints));
            _(this).edgePointsGroupInstance.updateEndPoint(endPoint);

            this._updateShape();
        };

        RectanglePolygonShape.prototype.getEdgePoints = function () {
            return $.extend(true, [], this.options.edgePoints);
        };

        RectanglePolygonShape.prototype.getMidPoints = function () {
            return $.extend(true, [], this.options.midPoints);
        };

        return RectanglePolygonShape;
    })(ShapeBase);

    //#endregion ************************ Shapes Classes **************************//


    //#region ********************** Resizable Points Classes *********************//

    /*
    * options: {
    *   size: 9(default),
    *   points: [{ x:.., y:.. }, { x:.., y:.. }], // [{ startPoint }, { endPoint }],
    *   onResizing: function (e, newPoints) {},
    *   onResized: function (newPoints) {}
    * }
    */
    var ResizableEdgePointsGroup = (function () {
        var defaults = {
            size: 9
        };

        var priv = new WeakMap();
        var _ = function (instance) { return priv.get(instance); };

        function ResizableEdgePointsGroup(selection, options) {
            this.options = $.extend(true, {}, defaults, options);

            var privateMembers = {
                group: selection
                            .append('g')
                            .classed('resizable-points', true),
                pointsSelections: [], // Contains a list of d3 selection (resizable corner points)
            };

            priv.set(this, privateMembers);

            // Initialization
            init.call(this);
        }

        //#region ___________________________ Private Methods ___________________________

        var init = function () {
            appendPoints.call(this);
            updateUiPoints.call(this);
        };

        var appendPoints = function () {
            var me = this;

            // Append edges points (The order is important 'clockwise')
            appendPoint.call(this, 'top-left-point', function (e) {
                me.options.points[0].x += e.dx;
                me.options.points[0].y += e.dy;
                onPointDragging.call(me, e, 0);
            });
            appendPoint.call(this, 'top-right-point', function (e) {
                me.options.points[1].x += e.dx;
                me.options.points[0].y += e.dy;
                onPointDragging.call(me, e, 1);
            });
            appendPoint.call(this, 'bottom-right-point', function (e) {
                me.options.points[1].x += e.dx;
                me.options.points[1].y += e.dy;
                onPointDragging.call(me, e, 2);
            });
            appendPoint.call(this, 'bottom-left-point', function (e) {
                me.options.points[0].x += e.dx;
                me.options.points[1].y += e.dy;
                onPointDragging.call(me, e, 3);
            });
        };

        var appendPoint = function (className, onDragfn) {
            var me = this;

            let isMoving = false;

            var size = this.options.size;
            var pointSelection = _(this).group
                                        .append('rect')
                                        .attr('class', 'resizable-point edge-point')
                                        .attr('width', size)
                                        .attr('height', size)
                                        .classed(className, true)
                                        .call(d3.drag()
                                            .on('drag', function (e) {
                                                isMoving = true;
                                                onDragfn.call(me, e);
                                            })
                                            .on('end', function () {
                                                if (isMoving) {
                                                    isMoving = false;

                                                    if (me.options.onResized instanceof Function) {
                                                        me.options.onResized($.extend(true, [], me.options.points));
                                                    }
                                                }
                                            })
                                        );

            _(this).pointsSelections.push(pointSelection);
        };

        var onPointDragging = function (e, pointPosition) {
            updateUiPoints.call(this);

            if (this.options.onResizing instanceof Function) {
                this.options.onResizing(e, $.extend(true, [], this.options.points), pointPosition);
            }
        };

        var updateUiPoints = function () {
            var points = this.options.points;

            var data = [
                { x: points[0].x, y: points[0].y },
                { x: points[1].x, y: points[0].y },
                { x: points[1].x, y: points[1].y },
                { x: points[0].x, y: points[1].y }
            ];

            var pointsSelections = _(this).pointsSelections;
            for (var i = 0; i < pointsSelections.length; i++) {
                var pointData = data[i];

                var margin = this.options.size / 2;
                pointsSelections[i]
                    .attr('x', pointData.x - margin)
                    .attr('y', pointData.y - margin);
            }
        };

        //#endregion ________________________ Private Methods ___________________________

        ResizableEdgePointsGroup.prototype.updateEndPoint = function (endPoint) {
            this.options.points[1] = endPoint;
            updateUiPoints.call(this);
        };

        ResizableEdgePointsGroup.prototype.updatePoints = function (points) {
            this.options.points = points;
            updateUiPoints.call(this);
        };

        return ResizableEdgePointsGroup;
    })();

    /*
    * options: {
    *   radius: 5(default),
    *   points: [{ x:.., y:.. }, { x:.., y:.. }], // [{ startPoint }, { endPoint }],
    *   onResizing: function (e, newPoints) {},
    *   onResized: function (newPoints) {}
    * }
    */
    var ResizableMidPointsGroup = (function () {
        var defaults = {
            radius: 5
        };

        var priv = new WeakMap();
        var _ = function (instance) { return priv.get(instance); };

        function ResizableMidPointsGroup(selection, options) {
            this.options = $.extend(true, {}, defaults, options);

            var privateMembers = {
                group: selection
                            .append('g')
                            .classed('resizable-points', true),
                pointsSelections: [], // Contains a list of d3 selection (resizable corner points)
            };

            priv.set(this, privateMembers);

            // Initialization
            init.call(this);
        }

        //#region ___________________________ Private Methods ___________________________

        var init = function () {
            appendPoints.call(this);
            updateUiPoints.call(this);
        };

        var appendPoints = function () {
            // Append midPoints (The order is important 'clockwise')
            appendPoint.call(this, 'x-midpoint top-midpoint', 0);
            appendPoint.call(this, 'y-midpoint right-midpoint', 1);
            appendPoint.call(this, 'x-midpoint bottom-midpoint', 2);
            appendPoint.call(this, 'y-midpoint left-midpoint', 3);
        };

        var appendPoint = function (className, pointPosition) {
            var me = this;

            let isMoving = false;

            var pointSelection = _(this).group
                                        .append('circle')
                                        .attr('class', 'resizable-point midpoint')
                                        .classed(className, true)
                                        .call(d3.drag()
                                            .on('drag', function (e) {
                                                isMoving = true;
                                                onPointDragging.call(me, e, pointPosition);
                                            })
                                            .on('end', function () {
                                                if (isMoving) {
                                                    isMoving = false;

                                                    if (me.options.onResized instanceof Function) {
                                                        me.options.onResized($.extend(true, [], me.options.points));
                                                    }
                                                }
                                            })
                                        );

            _(this).pointsSelections.push(pointSelection);
        };

        var onPointDragging = function (e, pointPosition) {
            var point = this.options.points[pointPosition];
            point.x += e.dx;
            point.y += e.dy;

            updateUiPoint.call(this, pointPosition);

            if (this.options.onResizing instanceof Function) {
                this.options.onResizing(e, $.extend(true, [], this.options.points), pointPosition);
            }
        };

        var updateUiPoints = function () {
            var pointsSelections = _(this).pointsSelections;
            for (var i = 0; i < pointsSelections.length; i++) {
                updateUiPoint.call(this, i);
            }
        };

        var updateUiPoint = function (pointPosition) {
            var point = this.options.points[pointPosition];

            _(this).pointsSelections[pointPosition]
                .attr('r', this.options.radius)
                .attr('cx', point.x)
                .attr('cy', point.y);
        };

        //#endregion ________________________ Private Methods ___________________________

        ResizableMidPointsGroup.prototype.updatePoints = function (points) {
            this.options.points = points;
            updateUiPoints.call(this);
        };

        return ResizableMidPointsGroup;
    })();

    //#endregion ******************* Resizable Points Classes *********************//


    //#region *************************** Query Classes ***************************//

    /*
     * Static Class
     */
    var QueryFactory = {
        createQuery: function (queryType, selection, options) {
            var queryClass;

            switch (queryType) {
                case QueryTypeEnum.EXACT_COUNT:
                    queryClass = ExactCountQuery;
                    break;

                case QueryTypeEnum.PIE_CHART:
                    queryClass = PieChartQuery;
                    break;

                case QueryTypeEnum.BAR_CHART:
                    queryClass = BarChartQuery;
                    break;
            }

            return new queryClass(selection, options);
        },
        getQueryText: function (queryType) {
            var text;

            switch (queryType) {
                case QueryTypeEnum.EXACT_COUNT:
                    text = "Exact Count";
                    break;

                case QueryTypeEnum.PIE_CHART:
                    text = "Pie Chart";
                    break;

                case QueryTypeEnum.BAR_CHART:
                    text = "Bar Chart";
                    break;
            }

            return text;
        }
    };

    
    var QueryBase = (function () {
        var defaults = {

        };

        var priv = new WeakMap();
        var _ = function (instance) { return priv.get(instance); }

        function QueryBase(selection, options) {
            if (options) {
                this.options = $.extend(true, {}, defaults, options);

                var privateMembers = {
                    //group: selection.append("g"), // D3 selection
                };

                priv.set(this, privateMembers);

                init.call(this);
            }
        }

        //#region ___________________________ Private Methods ___________________________

        var init = function () {

        };

        //#endregion ________________________ Private Methods ___________________________

        QueryBase.prototype.update = function (edgePoints) {
            throw "You must override the abstract method \'update\' in " + this.constructor.name + " child class";
        };

        QueryBase.prototype.destroy = function () {
            throw "You must override the abstract method \'destroy\' in " + this.constructor.name + " child class";
        };

        return QueryBase;
    })();

    /*
     * options: {
     *  data: [{ text:.., value:.. }]
     * }
     */
    var ExactCountQuery = (function (parent) {
        var defaults = {
            
        };

        var priv = new WeakMap();
        var _ = function (instance) { return priv.get(instance); }

        function ExactCountQuery(selection, options) {
            //this.options = $.extend(true, {}, defaults, options);

            var privateMembers = {
                group: selection.append("g"), // D3 selection
            };

            priv.set(this, privateMembers);

            parent.call(this, selection, options);

            init.call(this);
        }

        ExactCountQuery.prototype = new parent();
        ExactCountQuery.prototype.constructor = ExactCountQuery;

        //#region ___________________________ Private Methods ___________________________

        var init = function () {
            updatePosition.call(this);

            var data = this.options.data;
            if (data && data.length) {
                for (var i = 0; i < data.length; i++) {
                    appendDataItem.call(this, data[i], i * 25);
                }
            }
        };

        var appendDataItem = function (item, top) {
            _(this).group.append("text")
                        .text(item.name + ": " + item.value)
                        .attr("y", top);
        };

        var updatePosition = function () {
            var points = this.options.edgePoints;

            _(this).group
                .attr("transform", "translate(" + (points[0].x + 8) + "," + (points[0].y + 20) + ")");
        };

        //#endregion ________________________ Private Methods ___________________________

        ExactCountQuery.prototype.update = function (edgePoints) {
            this.options.edgePoints = $.extend(true, [], edgePoints);

            updatePosition.call(this);
        };

        ExactCountQuery.prototype.destroy = function () {
            _(this).group.remove();
        };

        return ExactCountQuery;
    })(QueryBase);

    var PieChartQuery = (function (parent) {
        var defaults = {
            edgePoints: [],
            data: [],
            margin: 10
        };

        var priv = new WeakMap();
        var _ = function (instance) { return priv.get(instance); }

        function PieChartQuery(selection, options) {
            this.options = $.extend(true, {}, defaults, options);

            var privateMembers = {
                chartGroup: null, // D3 selection
            };

            priv.set(this, privateMembers);

            parent.call(this, selection, options);

            init.call(this, selection);
        }

        PieChartQuery.prototype = new parent();
        PieChartQuery.prototype.constructor = PieChartQuery;

        //#region ___________________________ Private Methods ___________________________

        var init = function (selection) {
            var chartGroup = _(this).chartGroup = createChart.call(this);
            selection.node().appendChild(chartGroup.node());
        };

        var createChart = function () {
            var data = this.options.data;
            var data = [
                { name: "TV", value: 10 },
                { name: "Couch", value: 4 },
            ];

            var points = this.options.edgePoints;
            var dimensions = getDimensions.call(this);

            // Set the dimensions and margins of the graph
            var width = dimensions.width;
            var height = dimensions.height;
            var margin = this.options.margin;

            // The radius of the pieplot is half the width or half the height (smallest one). I subtract a bit of margin.
            var radius = Math.min(width, height) / 2 - margin;

            // Create an svg on the fly
            var chartGroup = d3.create("svg")
                                .attr("width", width)
                                .attr("height", height)
                                .append("g")
                                    .attr("transform", "translate(" + (points[0].x + width / 2) + "," + (points[0].y + height / 2) + ")");

            // Set the color scale
            var color = d3.scaleOrdinal()
                //.domain(data)
                .domain(data.map(d => d.name))
                .range(d3.schemeSet2);

            // Compute the position of each group on the pie:
            var pie = d3.pie()
                .value(function (d) {
                    //return d.value;
                    //return d[1];
                    return d.value;
                });

            var data_ready = pie(data);
            // Now I know that group A goes from 0 degrees to x degrees and so on.

            // Shape helper to build arcs:
            var arcGenerator = d3.arc()
                .innerRadius(0)
                .outerRadius(radius);

            // Build the pie chart: Basically, each part of the pie is a path that we build using the arc function.
            chartGroup
                .selectAll('mySlices')
                .data(data_ready)
                .enter()
                .append('path')
                .attr('d', arcGenerator)
                .attr('fill', function (d) {
                    //return (color(d.data.key))
                    //return (color(d.data[0]))
                    return (color(d.data.name));
                })
                .attr("stroke", "black")
                .style("stroke-width", "2px")
                .style("opacity", 0.7);

            // Now add the annotation. Use the centroid method to get the best coordinates
            chartGroup
                .selectAll('mySlices')
                .data(data_ready)
                .enter()
                .append('text')
                .text(function (d) {
                    //return "grp " + d.data.key
                    //return "grp " + d.data[0]
                    return d.data.value;
                })
                .attr("transform", function (d) {
                    return "translate(" + arcGenerator.centroid(d) + ")";
                })
                .style("text-anchor", "middle")
                .style("font-size", 14);

            return chartGroup;
        };

        var getDimensions = function () {
            var points = this.options.edgePoints;

            return {
                width: points[1].x - points[0].x,
                height: points[1].y - points[0].y
            };
        };

        //#endregion ________________________ Private Methods ___________________________

        PieChartQuery.prototype.update = function (edgePoints) {
            this.options.edgePoints = $.extend(true, [], edgePoints);

            var parentNode = _(this).chartGroup.node().parentNode;
            _(this).chartGroup.remove();

            var chartGroup = _(this).chartGroup = createChart.call(this);
            parentNode.appendChild(chartGroup.node());
        };

        PieChartQuery.prototype.destroy = function () {
            _(this).chartGroup.remove();
        };

        return PieChartQuery;
    })(QueryBase);
    
    var BarChartQuery = (function (parent) {
        var defaults = {
            edgePoints: [],
            data: [],
            margin: 10
        };

        var priv = new WeakMap();
        var _ = function (instance) { return priv.get(instance); }

        function BarChartQuery(selection, options) {
            this.options = $.extend(true, {}, defaults, options);

            var privateMembers = {
                chartGroup: null, // D3 selection
            };

            priv.set(this, privateMembers);

            parent.call(this, selection, options);

            init.call(this, selection);
        }

        BarChartQuery.prototype = new parent();
        BarChartQuery.prototype.constructor = BarChartQuery;

        //#region ___________________________ Private Methods ___________________________

        var init = function (selection) {
            var chartGroup = _(this).chartGroup = createChart.call(this);
            selection.node().appendChild(chartGroup.node());
        };


        var createChart = function () {
            //var data = [
            //    { name: "Bob", value: 33 },
            //    { name: "Robin", value: 12 },
            //    { name: "Anne", value: 41 },
            //    { name: "Mark", value: 16 },
            //    { name: "Joe", value: 59 },
            //    { name: "Eve", value: 38 },
            //    { name: "Karen", value: 21 },
            //];

            var data = [
                { name: "TV", value: 10 },
                { name: "Couch", value: 4 },
            ];

            var points = this.options.edgePoints;
            var dimensions = getDimensions.call(this);

            // Set the dimensions and margins of the graph
            var width = dimensions.width;
            var height = dimensions.height;
            var margin = this.options.margin;

            var margin = { top: 30, right: 0, bottom: 30, left: 40 };
            var color = "steelblue";

            var x = d3.scaleBand()
                .domain(d3.range(data.length))
                .range([margin.left, width - margin.right])
                .padding(0.1);

            var y = d3.scaleLinear()
                .domain([0, d3.max(data, d => d.value)]).nice()
                .range([height - margin.bottom, margin.top]);

            var xAxis = g => g
                .attr("transform", `translate(0,${height - margin.bottom})`)
                .call(d3.axisBottom(x).tickFormat(i => data[i].name).tickSizeOuter(0));

            var yAxis = g => g
                .attr("transform", `translate(${margin.left},0)`)
                .call(d3.axisLeft(y).ticks(null, data.format))
                .call(g => g.select(".domain").remove())
                .call(g => g.append("text")
                    .attr("x", -margin.left)
                    .attr("y", 10)
                    .attr("fill", "currentColor")
                    .attr("text-anchor", "start")
                    .text(data.y));


            const svg = d3.create("svg")
                //.attr("viewBox", [0, 0, width, height]);
                .attr("width", width)
                .attr("height", height)
                .append("g")
                .attr("transform", "translate(" + (points[0].x - 10) + "," + (points[0].y) + ")");
                

            svg.append("g")
                .attr("fill", color)
                .selectAll("rect")
                .data(data)
                .join("rect")
                .attr("x", (d, i) => x(i))
                .attr("y", d => y(d.value))
                .attr("height", d => y(0) - y(d.value))
                .attr("width", x.bandwidth());

            svg.append("g")
                .call(xAxis);

            svg.append("g")
                .call(yAxis);

            return svg;
        };

        var createChart2 = function () {
            var data = [
                { name: "Bob", value: 33 },
                { name: "Robin", value: 12 },
                { name: "Anne", value: 41 },
                { name: "Mark", value: 16 },
                { name: "Joe", value: 59 },
                { name: "Eve", value: 38 },
                { name: "Karen", value: 21 },
            ];

            var points = this.options.edgePoints;
            var dimensions = getDimensions.call(this);

            // Set the dimensions and margins of the graph
            var width = dimensions.width;
            var height = dimensions.height;
            var margin = this.options.margin;

            var margin = ({ top: 20, right: 0, bottom: 30, left: 40 });

            var x = d3.scaleBand()
                .domain(data.map(d => d.name))
                .range([margin.left, width - margin.right])
                .padding(0.1);

            var y = d3.scaleLinear()
                .domain([0, d3.max(data, d => d.value)]).nice()
                .range([height - margin.bottom, margin.top]);

            var xAxis = g => g
                .attr("transform", `translate(0,${height - margin.bottom})`)
                .call(d3.axisBottom(x).tickSizeOuter(0));

            var yAxis = g => g
                .attr("transform", `translate(${margin.left},0)`)
                .call(d3.axisLeft(y))
                .call(g => g.select(".domain").remove());

            const svg = d3.create("svg")
                .attr("viewBox", [0, 0, width, height]);

            const bar = svg.append("g")
                .attr("fill", "steelblue")
                .selectAll("rect")
                .data(data)
                .join("rect")
                .style("mix-blend-mode", "multiply")
                .attr("x", d => x(d.name))
                .attr("y", d => y(d.value))
                .attr("height", d => y(0) - y(d.value))
                .attr("width", x.bandwidth());

            const gx = svg.append("g")
                .call(xAxis);

            const gy = svg.append("g")
                .call(yAxis);

            Object.assign(svg.node(), {
                update(order) {
                    x.domain(data.sort(order).map(d => d.name));

                    const t = svg.transition()
                        .duration(750);

                    bar.data(data, d => d.name)
                        .order()
                        .transition(t)
                        .delay((d, i) => i * 20)
                        .attr("x", d => x(d.name));

                    gx.transition(t)
                        .call(xAxis)
                        .selectAll(".tick")
                        .delay((d, i) => i * 20);
                }
            });

            return svg;
        };

        var createChart1 = function () {
            var data = [
                { salesperson: "Bob", sales: 33 },
                { salesperson: "Robin", sales: 12 },
                { salesperson: "Anne", sales: 41 },
                { salesperson: "Mark", sales: 16 },
                { salesperson: "Joe", sales: 59 },
                { salesperson: "Eve", sales: 38 },
                { salesperson: "Karen", sales: 21 },
            ];

            var points = this.options.edgePoints;
            var dimensions = getDimensions.call(this);

            // Set the dimensions and margins of the graph
            var width = dimensions.width;
            var height = dimensions.height;
            var margin = this.options.margin;

            // set the dimensions and margins of the graph
            var margin = { top: 20, right: 20, bottom: 30, left: 40 },
                width = width - margin.left - margin.right,
                height = height - margin.top - margin.bottom;
            
            // set the ranges
            var x = d3.scaleBand()
                .range([0, width])
                .padding(0.1);
            var y = d3.scaleLinear()
                .range([height, 0]);

            // append the svg object to the body of the page
            // append a 'group' element to 'svg'
            // moves the 'group' element to the top left margin
            var chartGroup = d3.create("svg")
                                //.attr("width", width + margin.left + margin.right)
                                //.attr("height", height + margin.top + margin.bottom)
                                .attr("width", width)
                                .attr("height", height)
                                .append("g")
                                    //.attr("transform", "translate(" + margin.left + "," + margin.top + ")");
                                .attr("transform", "translate(" + (points[0].x + 30) + "," + (points[0].y + 10) + ")");

            // format the data
            data.forEach(function (d) {
                d.sales = +d.sales;
            });

            // Scale the range of the data in the domains
            x.domain(data.map(function (d) { return d.salesperson; }));
            y.domain([0, d3.max(data, function (d) { return d.sales; })]);

            // append the rectangles for the bar chart
            chartGroup.selectAll(".bar")
                .data(data)
                .enter().append("rect")
                .attr("class", "bar")
                .attr("x", function (d) { return x(d.salesperson); })
                .attr("width", x.bandwidth())
                .attr("y", function (d) { return y(d.sales); })
                .attr("height", function (d) { return height - y(d.sales); });

            // add the x Axis
            chartGroup.append("g")
                .attr("transform", "translate(0," + height + ")")
                .call(d3.axisBottom(x));

            // add the y Axis
            chartGroup.append("g")
                .call(d3.axisLeft(y));

            return chartGroup;
        };

        var getDimensions = function () {
            var points = this.options.edgePoints;

            return {
                width: points[1].x - points[0].x,
                height: points[1].y - points[0].y
            };
        };

        //#endregion ________________________ Private Methods ___________________________

        BarChartQuery.prototype.update = function (edgePoints) {
            this.options.edgePoints = $.extend(true, [], edgePoints);

            var parentNode = _(this).chartGroup.node().parentNode;
            _(this).chartGroup.remove();

            var chartGroup = _(this).chartGroup = createChart.call(this);
            parentNode.appendChild(chartGroup.node());
        };

        BarChartQuery.prototype.destroy = function () {
            _(this).chartGroup.remove();
        };

        return BarChartQuery;
    })(QueryBase);

    //#endregion ************************ Query Classes ***************************//


    //#region ************************ Query Builder Class ************************//

    /*
     * options: {
     *  attributes: [{ id:.., text:.., type: "intRange"/"boolean"/"oneOf"/"manyOf", choices: Optional }],
     *  query: {
     *      type:..,
     *      data: [{ attributeId: .., value:.. }],
     *      breakBy: attributeId
     *  }
     * }
     */
    var QueryBuilder = (function () {
        var defaults = {
            attributes: []
        };

        var priv = new WeakMap();
        var _ = function (instance) { return priv.get(instance); }

        function QueryBuilder(options) {
            this.options = $.extend(true, {}, defaults, options);

            var privateMembers = {
                $control: $("<div>").addClass("dd-qry-bldr"),
                $attributesWrap: $("<div>").addClass("dd-attrs-wrap"),
                queryTypeFieldInstance: null,
                $breakDownByList: null,
            };

            priv.set(this, privateMembers);

            init.call(this);
        }

        //#region ___________________________ Private Methods ___________________________

        var init = function () {
            var $control = _(this).$control;

            // 1. Render query type
            renderQueryType.call(this, $control);

            $control.append("<hr>");

            // 2. Render add new attribute button
            renderAddAttributeBtn.call(this, $control);

            // 3. Render attributes container
            $control.append(_(this).$attributesWrap);

            // 4. Render break by
            renderBreakDownBy.call(this, $control);

            // 5. Set query (Update Mode)
            var query = this.options.query;
            if (query) {
                setQuery.call(this, query);
            }
        };

        var setQuery = function (query) {
            if (query.type) {
                setQueryType.call(this, query.type);
            }

            var data = query.data;
            if (data && data.length) {
                for (let i = 0; i < data.length; i++) {
                    appendAttribute.call(this, data[i]);
                }
            }

            if (query.breakBy) {
                _(this).$breakByList.val(query.breakBy);
            }
        };

        //#region _________________ Query Type ________________

        var renderQueryType = function ($container) {
            var choices = [
                { id: QueryTypeEnum.EXACT_COUNT, text: QueryFactory.getQueryText(QueryTypeEnum.EXACT_COUNT) },
                { id: QueryTypeEnum.PIE_CHART, text: QueryFactory.getQueryText(QueryTypeEnum.PIE_CHART) },
                { id: QueryTypeEnum.BAR_CHART, text: QueryFactory.getQueryText(QueryTypeEnum.BAR_CHART) }
            ];
            
            var $queryTypeWrap = $("<div>")
                                    .addClass("dd-flex")
                                    .appendTo($container);

            var $label = createFieldLabel.call(this, "Query Type:");
            $queryTypeWrap.append($label);

            var me = this;
            var queryTypeFieldInstance = _(this).queryTypeFieldInstance =
                FieldFactory.createField(FieldTypeEnum.ONE_OF, {
                    id: "queryType",
                    choices: choices,
                    onChange: function (value) {
                        value === QueryTypeEnum.EXACT_COUNT ? hideBreakDownByField.call(me) :
                            showBreakDownByField.call(me)
                    }
                });

            $queryTypeWrap.append(queryTypeFieldInstance.render());
        };

        var setQueryType = function (type) {
            _(this).queryTypeFieldInstance.setValue(type);
        };

        //#endregion ______________ Query Type ________________


        //#region _________________ Attribute _________________

        var renderAddAttributeBtn = function ($container) {
            var me = this;

            $("<button type='button'>")
                .addClass("dd-add-attr-btn")
                .addClass("btn btn-primary")
                .text("+")
                .appendTo($container)
                .click(function () {
                    appendAttribute.call(me);
                });
        };

        var createRemoveIcon = function () {
            return $("<span>")
                .addClass("dd-remove-attr")
                .addClass("fa fa-times"); //TODO_N: Get from defaults
        };

        var appendAttribute = function (optQueryValue) {
            var me = this;

            var $attributeWrap = $("<div>")
                                    .addClass("dd-attr-wrap")
                                    .addClass("dd-flex")
                                    .appendTo(_(this).$attributesWrap);

            // 1. Render remove icon
            var $removeAttributeIcon = createRemoveIcon.call(this);
            $attributeWrap.append($removeAttributeIcon);

            // 2. Render attributes list
            $attributeList = createListField.call(this, { id: "attributeId", choices: this.options.attributes });
            $attributeWrap.append($attributeList);

            // 3. Render field area
            $("<div>")
                    .addClass("dd-field-area")
                    .appendTo($attributeWrap);

            // 4. Register attribute dropdown change event
            $attributeList.change(function () {
                onAttributeListChange.call(me, $(this));
            });

            // 5. Register remove attribute event
            $removeAttributeIcon.click(function () {
                var fieldInstance = $attributeList.data("fieldInstance");
                if (fieldInstance) { delete fieldInstance; }

                $attributeWrap.remove();
            });

            // 6. Set value
            if (optQueryValue) {
                // a. Set attribute list value
                $attributeList.val(optQueryValue.attributeId);

                $attributeList.change();

                // b. Set field value
                var fieldInstance = $attributeList.data("fieldInstance");
                fieldInstance.setValue(optQueryValue.value);
            }
        };

        var onAttributeListChange = function ($attributeList) {
            var $fieldArea = $attributeList.next(".dd-field-area");

            // Remove old field
            var fieldInstance = $attributeList.data("fieldInstance");
            if (fieldInstance) { delete fieldInstance; }

            $fieldArea.empty();

            // Create a new field based on selected attribute
            var selectedAttributeId = $attributeList.val();
            if (selectedAttributeId) {
                let fieldInstance = createFieldByAttributeId.call(this, selectedAttributeId);
                $fieldArea.append(fieldInstance.render());

                // Save current field instance
                $attributeList.data("fieldInstance", fieldInstance);
            }
        };

        var createFieldByAttributeId = function (attributeId) {
            var attribute = this.options.attributes.find(a => a.id.toString() === attributeId.toString());
            return FieldFactory.createField(attribute.type, attribute);
        };

        //#endregion ______________ Attribute _________________


        //#region __________________ Break By _________________

        var showBreakDownByField = function () {
            _(this).$breakDownByList.parent().removeClass("dd-hidden");
        };

        var hideBreakDownByField = function () {
            _(this).$breakDownByList.parent().addClass("dd-hidden");
        };

        var renderBreakDownBy = function ($container) {
            var $breakDownByWrap = $("<div>")
                                    .addClass("dd-hidden")
                                    .appendTo($container);

            var choices = [];
            var attributes = this.options.attributes;
            for (var i = 0; i < attributes.length; i++) {
                choices.push({ id: attributes[i].id.toString(), text: attributes[i].text });
            }

            var $label = createFieldLabel.call(this, "Break Down By: ");
            var $breakDownByList = _(this).$breakDownByList = createListField.call(this, { id: "breakBy", choices: choices });

            $breakDownByWrap
                .append("<hr>")
                .append($label)
                .append($breakDownByList);
        };

        //#endregion _______________ Break By _________________


        //#region ___________________ Fields __________________

        var createFieldLabel = function (text) {
            return $("<span>")
                .addClass("dd-lbl")
                .text(text);
        };

        var createListField = function (field) {
            var $select = $("<select>").attr("name", field.id);

            // Append empty option
            $select.append($("<option>"));

            for (let i = 0; i < field.choices.length; i++) {
                var choice = field.choices[i];

                $("<option>")
                    .attr("value", choice.id)
                    .text(choice.text)
                    .appendTo($select);
            }

            return $select;
        };

        //#endregion ________________ Fields __________________


        //#endregion ________________________ Private Methods ___________________________

        QueryBuilder.prototype.render = function () {
            return _(this).$control;
        };

        QueryBuilder.prototype.isEmpty = function () {
            if (_(this).queryTypeFieldInstance.isEmpty()) return true;

            var $attributesDropdowns = _(this).$attributesWrap.find("select[name='attributeId']");

            if ($attributesDropdowns.length === 0) return true;

            var hasEmptyField = false;
            $attributesDropdowns.each(function () {
                var selectedAttributeId = $(this).val();
                var fieldInstance = $(this).data("fieldInstance");

                if (!selectedAttributeId || fieldInstance.isEmpty()) {
                    hasEmptyField = true;
                    return false;
                }
            });

            if (hasEmptyField) return true;

            return false;
        };

        QueryBuilder.prototype.getQuery = function () {
            var $attributesDropdowns = _(this).$attributesWrap.find("select[name='attributeId']");

            var data = [];
            $attributesDropdowns.each(function () {
                var fieldInstance = $(this).data("fieldInstance");
                data.push({ attributeId: $(this).val(), value: fieldInstance.getValue() });
            });

            return {
                type: _(this).queryTypeFieldInstance.getValue(),
                data: data
            };
        };

        return QueryBuilder;
    })();

    //#endregion ********************* Query Builder Class ************************//


    //#region ************************** Fields Classes ***************************//

    /*
    * Static Class
    */
    var FieldFactory = {
        createField: function (type, field) {
            var fieldClass;
            
            switch (type) {
                case FieldTypeEnum.INT_RANGE:
                    fieldClass = IntRangeField;
                    break;

                case FieldTypeEnum.BOOLEAN:
                    fieldClass = BooleanField;
                    break;

                case FieldTypeEnum.ONE_OF:
                    fieldClass = RadioListField;
                    break;

                case FieldTypeEnum.MANY_OF:
                    fieldClass = CheckboxListField;
                    break;
            }

            return new fieldClass(field);
        },
        mapUiQueryData: function (queryData, attributes) {
            var mappedUiQueryData = [];

            for (var i = 0; i < queryData.length; i++) {
                let attributeId = queryData[i].attributeId;
                let value = queryData[i].value;

                let attribute = attributes.find(a => a.id.toString() === attributeId.toString());

                var mappedUiValue;
                switch (attribute.type) {
                    case FieldTypeEnum.INT_RANGE:
                        mappedUiValue = value.from + "-" + value.to;
                        break;

                    case FieldTypeEnum.BOOLEAN:
                        mappedUiValue = value === "yes" ? "Yes" : "No";
                        break;

                    case FieldTypeEnum.ONE_OF:
                        mappedUiValue = attribute.choices.find(c => c.id.toString() === value.toString()).text;
                        break;

                    case FieldTypeEnum.MANY_OF:
                        mappedUiValue = value.map(function (v) {
                            return attribute.choices.find(c => c.id.toString() === v.toString()).text;
                        });
                        break;
                }

                mappedUiQueryData.push({
                    name: attribute.text,
                    value: mappedUiValue
                });
            }

            return mappedUiQueryData;
        },
    };

    /*
     * options = {
     *  id:..,
     *  text:..,
     *  choices:..,
     *  value:..,
     *  onChange: function () {}
     * }
     */ 
    var FieldBase = (function () {
        var defaults = {
        };

        function FieldBase(options) {
            if (options) {
                this.options = $.extend(true, {}, defaults, options);
                init.call(this);
            }
        }

        //#region ___________________________ Private Methods ___________________________

        var init = function () {
        };

        //#endregion ________________________ Private Methods ___________________________

        FieldBase.prototype.render = function () {
            throw "You must override the abstract method \'render\' in " + this.constructor.name + " child class";
        };

        FieldBase.prototype.isEmpty = function () {
            throw "You must override the abstract method \'isEmpty\' in " + this.constructor.name + " child class";
        };

        FieldBase.prototype.getValue = function () {
            throw "You must override the abstract method \'getValue\' in " + this.constructor.name + " child class";
        };

        FieldBase.prototype.setValue = function (value) {
            throw "You must override the abstract method \'setValue\' in " + this.constructor.name + " child class";
        };

        return FieldBase;
    })();

    var IntRangeField = (function (parent) {
        var defaults = {
        };

        var priv = new WeakMap();
        var _ = function (instance) { return priv.get(instance); }

        function IntRangeField(options) {
            var privateMembers = {
                $control: $("<div>")
            };

            priv.set(this, privateMembers);

            parent.call(this, options);

            init.call(this);
        }

        IntRangeField.prototype = new parent();
        IntRangeField.prototype.constructor = IntRangeField;

        //#region ___________________________ Private Methods ___________________________

        var init = function () {
            var $control = _(this).$control;

            var value = this.options.value || {};

            var $fromField = createIntField.call(this, { id: this.options.id + "_from", value: value.from });
            var $toField = createIntField.call(this, { id: this.options.id + "_to", value: value.to });

            $control
                .append($fromField)
                .append(" : ")
                .append($toField);
        };

        var createIntField = function (field) {
            return $("<input type='text'>")
                .attr({
                    "name": field.id,
                    value: field.value
                });
        };

        //#endregion ________________________ Private Methods ___________________________

        IntRangeField.prototype.render = function () {
            return _(this).$control;
        };

        IntRangeField.prototype.isEmpty = function () {
            var rangeValue = this.getValue();
            return !rangeValue || !rangeValue.from || !rangeValue.to;
        };

        IntRangeField.prototype.getValue = function () {
            var $rangeInputs = _(this).$control.find("> input");

            return {
                from: $($rangeInputs[0]).val(),
                to: $($rangeInputs[1]).val()
            }
        };

        IntRangeField.prototype.setValue = function (value) {
            var $rangeInputs = _(this).$control.find("> input");

            $($rangeInputs[0]).val(value.from);
            $($rangeInputs[1]).val(value.to);
        };

        return IntRangeField;
    })(FieldBase);

    var RadioListField = (function (parent) {
        var defaults = {
        };

        var priv = new WeakMap();
        var _ = function (instance) { return priv.get(instance); }

        function RadioListField(options) {
            if (options) {
                var privateMembers = {
                    $control: $("<div>").addClass("dd-radio-list")
                };

                priv.set(this, privateMembers);

                parent.call(this, options);

                init.call(this);
            }
        }

        RadioListField.prototype = new parent();
        RadioListField.prototype.constructor = RadioListField;

        //#region ___________________________ Private Methods ___________________________

        var init = function () {
            var $control = _(this).$control;

            for (var i = 0; i < this.options.choices.length; i++) {
                var choice = this.options.choices[i];

                let $radioWrap = createRadioButton.call(this, { name: this.options.id, value: choice.id, text: choice.text });
                $control.append($radioWrap);
            }

            if (this.options.onChange instanceof Function) {
                let me = this;

                _(this).$control.find(":radio")
                                .change(function () {
                                    var value = $(this).val();
                                    me.options.onChange(value);
                                });
            }

            if (this.options.value) {
                setValue.call(this, this.options.value);
            }
        };

        var createRadioButton = function (choice) {
            var $radioWrap = $("<span>");

            $("<input type='radio'>")
                .attr({
                    name: choice.name,
                    value: choice.value
                })
                .appendTo($radioWrap);

            $("<span>")
                .text(choice.text)
                .appendTo($radioWrap);

            return $radioWrap;
        };

        var setValue = function (value) {
            _(this).$control.find(":radio[value='" + value + "']").prop("checked", true);
        }

        //#endregion ________________________ Private Methods ___________________________

        RadioListField.prototype.render = function () {
            return _(this).$control;
        };

        RadioListField.prototype.isEmpty = function () {
            return !this.getValue();
        };

        RadioListField.prototype.getValue = function () {
            //value = $input.filter(":checked").val();
            return _(this).$control.find("input[type='radio']:checked").val();
        };

        RadioListField.prototype.setValue = function (value) {
            _(this).$control.find("input[type='radio'][value='" + value + "']").prop("checked", true);
        };

        return RadioListField;
    })(FieldBase);

    var CheckboxListField = (function (parent) {
        var defaults = {
        };

        var priv = new WeakMap();
        var _ = function (instance) { return priv.get(instance); }

        function CheckboxListField(options) {
            var privateMembers = {
                $control: $("<div>").addClass("dd-checkbox-list")
            };

            priv.set(this, privateMembers);

            parent.call(this, options);

            init.call(this);
        }

        CheckboxListField.prototype = new parent();
        CheckboxListField.prototype.constructor = CheckboxListField;

        //#region ___________________________ Private Methods ___________________________

        var init = function () {
            var $control = _(this).$control;

            for (var i = 0; i < this.options.choices.length; i++) {
                var choice = this.options.choices[i];

                let $checkboxWrap = createCheckbox.call(this, { name: this.options.id, value: choice.id, text: choice.text });
                $control.append($checkboxWrap);
            }

            if (this.options.value) {
                setValues.call(this, this.options.value);
            }
        };

        var createCheckbox = function (choice) {
            var $checkboxWrap = $("<span>");

            $("<input type='checkbox'>")
                .attr({
                    name: choice.name,
                    value: choice.value
                })
                .appendTo($checkboxWrap);

            $("<span>")
                .text(choice.text)
                .appendTo($checkboxWrap);

            return $checkboxWrap;
        };

        var setValues = function (values) {
            values.forEach(function (value) {
                _(this).$control.find(":checkbox[value='" + value + "']").prop("checked", true);
            });
        }

        //#endregion ________________________ Private Methods ___________________________

        CheckboxListField.prototype.render = function () {
            return _(this).$control;
        };

        CheckboxListField.prototype.isEmpty = function () {
            var selectedCheckboxes = this.getValue();
            return !selectedCheckboxes || selectedCheckboxes.length === 0;
        };

        CheckboxListField.prototype.getValue = function () {
            return _(this).$control.find("input[type='checkbox']:checked").map(function () {
                return $(this).val();
            }).get(); // Call .get() to convert the jQuery object to an array
        };

        CheckboxListField.prototype.setValue = function (values) {
            var $checkboxes = _(this).$control.find("input[type='checkbox']");

            values.forEach(function (value) {
                $checkboxes.filter("[value='" + value + "']").prop("checked", true);
            });
        };

        return CheckboxListField;
    })(FieldBase);

    var BooleanField = (function (parent) {
        var defaults = {
        };

        function BooleanField(options) {
            var chocices = [{ id: "yes", text: "Yes" }, { id: "no", text: "No" }];

            this.options = $.extend(true, {}, defaults, { choices: chocices }, options);

            parent.call(this, this.options);

            init.call(this);
        }

        BooleanField.prototype = new parent();
        BooleanField.prototype.constructor = BooleanField;

        //#region ___________________________ Private Methods ___________________________

        var init = function () {
        };
        
        //#endregion ________________________ Private Methods ___________________________

        return BooleanField;
    })(RadioListField);

    //#endregion *********************** Fields Classes ***************************//
})();

/*!
FullCalendar Core Package v4.3.1
Docs & License: https://fullcalendar.io/
(c) 2019 Adam Shaw
*/

(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define(['exports'], factory) :
    (global = global || self, factory(global.FullCalendar = {}));
}(this, function (exports) { 'use strict';

    // Creating
    // ----------------------------------------------------------------------------------------------------------------
    var elementPropHash = {
        className: true,
        colSpan: true,
        rowSpan: true
    };
    var containerTagHash = {
        '<tr': 'tbody',
        '<td': 'tr'
    };
    function createElement(tagName, attrs, content) {
        var el = document.createElement(tagName);
        if (attrs) {
            for (var attrName in attrs) {
                if (attrName === 'style') {
                    applyStyle(el, attrs[attrName]);
                }
                else if (elementPropHash[attrName]) {
                    el[attrName] = attrs[attrName];
                }
                else {
                    el.setAttribute(attrName, attrs[attrName]);
                }
            }
        }
        if (typeof content === 'string') {
            el.innerHTML = content; // shortcut. no need to process HTML in any way
        }
        else if (content != null) {
            appendToElement(el, content);
        }
        return el;
    }
    function htmlToElement(html) {
        html = html.trim();
        var container = document.createElement(computeContainerTag(html));
        container.innerHTML = html;
        return container.firstChild;
    }
    function htmlToElements(html) {
        return Array.prototype.slice.call(htmlToNodeList(html));
    }
    function htmlToNodeList(html) {
        html = html.trim();
        var container = document.createElement(computeContainerTag(html));
        container.innerHTML = html;
        return container.childNodes;
    }
    // assumes html already trimmed and tag names are lowercase
    function computeContainerTag(html) {
        return containerTagHash[html.substr(0, 3) // faster than using regex
        ] || 'div';
    }
    function appendToElement(el, content) {
        var childNodes = normalizeContent(content);
        for (var i = 0; i < childNodes.length; i++) {
            el.appendChild(childNodes[i]);
        }
    }
    function prependToElement(parent, content) {
        var newEls = normalizeContent(content);
        var afterEl = parent.firstChild || null; // if no firstChild, will append to end, but that's okay, b/c there were no children
        for (var i = 0; i < newEls.length; i++) {
            parent.insertBefore(newEls[i], afterEl);
        }
    }
    function insertAfterElement(refEl, content) {
        var newEls = normalizeContent(content);
        var afterEl = refEl.nextSibling || null;
        for (var i = 0; i < newEls.length; i++) {
            refEl.parentNode.insertBefore(newEls[i], afterEl);
        }
    }
    function normalizeContent(content) {
        var els;
        if (typeof content === 'string') {
            els = htmlToElements(content);
        }
        else if (content instanceof Node) {
            els = [content];
        }
        else { // Node[] or NodeList
            els = Array.prototype.slice.call(content);
        }
        return els;
    }
    function removeElement(el) {
        if (el.parentNode) {
            el.parentNode.removeChild(el);
        }
    }
    // Querying
    // ----------------------------------------------------------------------------------------------------------------
    // from https://developer.mozilla.org/en-US/docs/Web/API/Element/closest
    var matchesMethod = Element.prototype.matches ||
        Element.prototype.matchesSelector ||
        Element.prototype.msMatchesSelector;
    var closestMethod = Element.prototype.closest || function (selector) {
        // polyfill
        var el = this;
        if (!document.documentElement.contains(el)) {
            return null;
        }
        do {
            if (elementMatches(el, selector)) {
                return el;
            }
            el = el.parentElement || el.parentNode;
        } while (el !== null && el.nodeType === 1);
        return null;
    };
    function elementClosest(el, selector) {
        return closestMethod.call(el, selector);
    }
    function elementMatches(el, selector) {
        return matchesMethod.call(el, selector);
    }
    // accepts multiple subject els
    // returns a real array. good for methods like forEach
    function findElements(container, selector) {
        var containers = container instanceof HTMLElement ? [container] : container;
        var allMatches = [];
        for (var i = 0; i < containers.length; i++) {
            var matches = containers[i].querySelectorAll(selector);
            for (var j = 0; j < matches.length; j++) {
                allMatches.push(matches[j]);
            }
        }
        return allMatches;
    }
    // accepts multiple subject els
    // only queries direct child elements
    function findChildren(parent, selector) {
        var parents = parent instanceof HTMLElement ? [parent] : parent;
        var allMatches = [];
        for (var i = 0; i < parents.length; i++) {
            var childNodes = parents[i].children; // only ever elements
            for (var j = 0; j < childNodes.length; j++) {
                var childNode = childNodes[j];
                if (!selector || elementMatches(childNode, selector)) {
                    allMatches.push(childNode);
                }
            }
        }
        return allMatches;
    }
    // Attributes
    // ----------------------------------------------------------------------------------------------------------------
    function forceClassName(el, className, bool) {
        if (bool) {
            el.classList.add(className);
        }
        else {
            el.classList.remove(className);
        }
    }
    // Style
    // ----------------------------------------------------------------------------------------------------------------
    var PIXEL_PROP_RE = /(top|left|right|bottom|width|height)$/i;
    function applyStyle(el, props) {
        for (var propName in props) {
            applyStyleProp(el, propName, props[propName]);
        }
    }
    function applyStyleProp(el, name, val) {
        if (val == null) {
            el.style[name] = '';
        }
        else if (typeof val === 'number' && PIXEL_PROP_RE.test(name)) {
            el.style[name] = val + 'px';
        }
        else {
            el.style[name] = val;
        }
    }

    function pointInsideRect(point, rect) {
        return point.left >= rect.left &&
            point.left < rect.right &&
            point.top >= rect.top &&
            point.top < rect.bottom;
    }
    // Returns a new rectangle that is the intersection of the two rectangles. If they don't intersect, returns false
    function intersectRects(rect1, rect2) {
        var res = {
            left: Math.max(rect1.left, rect2.left),
            right: Math.min(rect1.right, rect2.right),
            top: Math.max(rect1.top, rect2.top),
            bottom: Math.min(rect1.bottom, rect2.bottom)
        };
        if (res.left < res.right && res.top < res.bottom) {
            return res;
        }
        return false;
    }
    function translateRect(rect, deltaX, deltaY) {
        return {
            left: rect.left + deltaX,
            right: rect.right + deltaX,
            top: rect.top + deltaY,
            bottom: rect.bottom + deltaY
        };
    }
    // Returns a new point that will have been moved to reside within the given rectangle
    function constrainPoint(point, rect) {
        return {
            left: Math.min(Math.max(point.left, rect.left), rect.right),
            top: Math.min(Math.max(point.top, rect.top), rect.bottom)
        };
    }
    // Returns a point that is the center of the given rectangle
    function getRectCenter(rect) {
        return {
            left: (rect.left + rect.right) / 2,
            top: (rect.top + rect.bottom) / 2
        };
    }
    // Subtracts point2's coordinates from point1's coordinates, returning a delta
    function diffPoints(point1, point2) {
        return {
            left: point1.left - point2.left,
            top: point1.top - point2.top
        };
    }

    // Logic for determining if, when the element is right-to-left, the scrollbar appears on the left side
    var isRtlScrollbarOnLeft = null;
    function getIsRtlScrollbarOnLeft() {
        if (isRtlScrollbarOnLeft === null) {
            isRtlScrollbarOnLeft = computeIsRtlScrollbarOnLeft();
        }
        return isRtlScrollbarOnLeft;
    }
    function computeIsRtlScrollbarOnLeft() {
        var outerEl = createElement('div', {
            style: {
                position: 'absolute',
                top: -1000,
                left: 0,
                border: 0,
                padding: 0,
                overflow: 'scroll',
                direction: 'rtl'
            }
        }, '<div></div>');
        document.body.appendChild(outerEl);
        var innerEl = outerEl.firstChild;
        var res = innerEl.getBoundingClientRect().left > outerEl.getBoundingClientRect().left;
        removeElement(outerEl);
        return res;
    }
    // The scrollbar width computations in computeEdges are sometimes flawed when it comes to
    // retina displays, rounding, and IE11. Massage them into a usable value.
    function sanitizeScrollbarWidth(width) {
        width = Math.max(0, width); // no negatives
        width = Math.round(width);
        return width;
    }

    function computeEdges(el, getPadding) {
        if (getPadding === void 0) { getPadding = false; }
        var computedStyle = window.getComputedStyle(el);
        var borderLeft = parseInt(computedStyle.borderLeftWidth, 10) || 0;
        var borderRight = parseInt(computedStyle.borderRightWidth, 10) || 0;
        var borderTop = parseInt(computedStyle.borderTopWidth, 10) || 0;
        var borderBottom = parseInt(computedStyle.borderBottomWidth, 10) || 0;
        // must use offset(Width|Height) because compatible with client(Width|Height)
        var scrollbarLeftRight = sanitizeScrollbarWidth(el.offsetWidth - el.clientWidth - borderLeft - borderRight);
        var scrollbarBottom = sanitizeScrollbarWidth(el.offsetHeight - el.clientHeight - borderTop - borderBottom);
        var res = {
            borderLeft: borderLeft,
            borderRight: borderRight,
            borderTop: borderTop,
            borderBottom: borderBottom,
            scrollbarBottom: scrollbarBottom,
            scrollbarLeft: 0,
            scrollbarRight: 0
        };
        if (getIsRtlScrollbarOnLeft() && computedStyle.direction === 'rtl') { // is the scrollbar on the left side?
            res.scrollbarLeft = scrollbarLeftRight;
        }
        else {
            res.scrollbarRight = scrollbarLeftRight;
        }
        if (getPadding) {
            res.paddingLeft = parseInt(computedStyle.paddingLeft, 10) || 0;
            res.paddingRight = parseInt(computedStyle.paddingRight, 10) || 0;
            res.paddingTop = parseInt(computedStyle.paddingTop, 10) || 0;
            res.paddingBottom = parseInt(computedStyle.paddingBottom, 10) || 0;
        }
        return res;
    }
    function computeInnerRect(el, goWithinPadding) {
        if (goWithinPadding === void 0) { goWithinPadding = false; }
        var outerRect = computeRect(el);
        var edges = computeEdges(el, goWithinPadding);
        var res = {
            left: outerRect.left + edges.borderLeft + edges.scrollbarLeft,
            right: outerRect.right - edges.borderRight - edges.scrollbarRight,
            top: outerRect.top + edges.borderTop,
            bottom: outerRect.bottom - edges.borderBottom - edges.scrollbarBottom
        };
        if (goWithinPadding) {
            res.left += edges.paddingLeft;
            res.right -= edges.paddingRight;
            res.top += edges.paddingTop;
            res.bottom -= edges.paddingBottom;
        }
        return res;
    }
    function computeRect(el) {
        var rect = el.getBoundingClientRect();
        return {
            left: rect.left + window.pageXOffset,
            top: rect.top + window.pageYOffset,
            right: rect.right + window.pageXOffset,
            bottom: rect.bottom + window.pageYOffset
        };
    }
    function computeViewportRect() {
        return {
            left: window.pageXOffset,
            right: window.pageXOffset + document.documentElement.clientWidth,
            top: window.pageYOffset,
            bottom: window.pageYOffset + document.documentElement.clientHeight
        };
    }
    function computeHeightAndMargins(el) {
        return el.getBoundingClientRect().height + computeVMargins(el);
    }
    function computeVMargins(el) {
        var computed = window.getComputedStyle(el);
        return parseInt(computed.marginTop, 10) +
            parseInt(computed.marginBottom, 10);
    }
    // does not return window
    function getClippingParents(el) {
        var parents = [];
        while (el instanceof HTMLElement) { // will stop when gets to document or null
            var computedStyle = window.getComputedStyle(el);
            if (computedStyle.position === 'fixed') {
                break;
            }
            if ((/(auto|scroll)/).test(computedStyle.overflow + computedStyle.overflowY + computedStyle.overflowX)) {
                parents.push(el);
            }
            el = el.parentNode;
        }
        return parents;
    }
    function computeClippingRect(el) {
        return getClippingParents(el)
            .map(function (el) {
            return computeInnerRect(el);
        })
            .concat(computeViewportRect())
            .reduce(function (rect0, rect1) {
            return intersectRects(rect0, rect1) || rect1; // should always intersect
        });
    }

    // Stops a mouse/touch event from doing it's native browser action
    function preventDefault(ev) {
        ev.preventDefault();
    }
    // Event Delegation
    // ----------------------------------------------------------------------------------------------------------------
    function listenBySelector(container, eventType, selector, handler) {
        function realHandler(ev) {
            var matchedChild = elementClosest(ev.target, selector);
            if (matchedChild) {
                handler.call(matchedChild, ev, matchedChild);
            }
        }
        container.addEventListener(eventType, realHandler);
        return function () {
            container.removeEventListener(eventType, realHandler);
        };
    }
    function listenToHoverBySelector(container, selector, onMouseEnter, onMouseLeave) {
        var currentMatchedChild;
        return listenBySelector(container, 'mouseover', selector, function (ev, matchedChild) {
            if (matchedChild !== currentMatchedChild) {
                currentMatchedChild = matchedChild;
                onMouseEnter(ev, matchedChild);
                var realOnMouseLeave_1 = function (ev) {
                    currentMatchedChild = null;
                    onMouseLeave(ev, matchedChild);
                    matchedChild.removeEventListener('mouseleave', realOnMouseLeave_1);
                };
                // listen to the next mouseleave, and then unattach
                matchedChild.addEventListener('mouseleave', realOnMouseLeave_1);
            }
        });
    }
    // Animation
    // ----------------------------------------------------------------------------------------------------------------
    var transitionEventNames = [
        'webkitTransitionEnd',
        'otransitionend',
        'oTransitionEnd',
        'msTransitionEnd',
        'transitionend'
    ];
    // triggered only when the next single subsequent transition finishes
    function whenTransitionDone(el, callback) {
        var realCallback = function (ev) {
            callback(ev);
            transitionEventNames.forEach(function (eventName) {
                el.removeEventListener(eventName, realCallback);
            });
        };
        transitionEventNames.forEach(function (eventName) {
            el.addEventListener(eventName, realCallback); // cross-browser way to determine when the transition finishes
        });
    }

    var DAY_IDS = ['sun', 'mon', 'tue', 'wed', 'thu', 'fri', 'sat'];
    // Adding
    function addWeeks(m, n) {
        var a = dateToUtcArray(m);
        a[2] += n * 7;
        return arrayToUtcDate(a);
    }
    function addDays(m, n) {
        var a = dateToUtcArray(m);
        a[2] += n;
        return arrayToUtcDate(a);
    }
    function addMs(m, n) {
        var a = dateToUtcArray(m);
        a[6] += n;
        return arrayToUtcDate(a);
    }
    // Diffing (all return floats)
    function diffWeeks(m0, m1) {
        return diffDays(m0, m1) / 7;
    }
    function diffDays(m0, m1) {
        return (m1.valueOf() - m0.valueOf()) / (1000 * 60 * 60 * 24);
    }
    function diffHours(m0, m1) {
        return (m1.valueOf() - m0.valueOf()) / (1000 * 60 * 60);
    }
    function diffMinutes(m0, m1) {
        return (m1.valueOf() - m0.valueOf()) / (1000 * 60);
    }
    function diffSeconds(m0, m1) {
        return (m1.valueOf() - m0.valueOf()) / 1000;
    }
    function diffDayAndTime(m0, m1) {
        var m0day = startOfDay(m0);
        var m1day = startOfDay(m1);
        return {
            years: 0,
            months: 0,
            days: Math.round(diffDays(m0day, m1day)),
            milliseconds: (m1.valueOf() - m1day.valueOf()) - (m0.valueOf() - m0day.valueOf())
        };
    }
    // Diffing Whole Units
    function diffWholeWeeks(m0, m1) {
        var d = diffWholeDays(m0, m1);
        if (d !== null && d % 7 === 0) {
            return d / 7;
        }
        return null;
    }
    function diffWholeDays(m0, m1) {
        if (timeAsMs(m0) === timeAsMs(m1)) {
            return Math.round(diffDays(m0, m1));
        }
        return null;
    }
    // Start-Of
    function startOfDay(m) {
        return arrayToUtcDate([
            m.getUTCFullYear(),
            m.getUTCMonth(),
            m.getUTCDate()
        ]);
    }
    function startOfHour(m) {
        return arrayToUtcDate([
            m.getUTCFullYear(),
            m.getUTCMonth(),
            m.getUTCDate(),
            m.getUTCHours()
        ]);
    }
    function startOfMinute(m) {
        return arrayToUtcDate([
            m.getUTCFullYear(),
            m.getUTCMonth(),
            m.getUTCDate(),
            m.getUTCHours(),
            m.getUTCMinutes()
        ]);
    }
    function startOfSecond(m) {
        return arrayToUtcDate([
            m.getUTCFullYear(),
            m.getUTCMonth(),
            m.getUTCDate(),
            m.getUTCHours(),
            m.getUTCMinutes(),
            m.getUTCSeconds()
        ]);
    }
    // Week Computation
    function weekOfYear(marker, dow, doy) {
        var y = marker.getUTCFullYear();
        var w = weekOfGivenYear(marker, y, dow, doy);
        if (w < 1) {
            return weekOfGivenYear(marker, y - 1, dow, doy);
        }
        var nextW = weekOfGivenYear(marker, y + 1, dow, doy);
        if (nextW >= 1) {
            return Math.min(w, nextW);
        }
        return w;
    }
    function weekOfGivenYear(marker, year, dow, doy) {
        var firstWeekStart = arrayToUtcDate([year, 0, 1 + firstWeekOffset(year, dow, doy)]);
        var dayStart = startOfDay(marker);
        var days = Math.round(diffDays(firstWeekStart, dayStart));
        return Math.floor(days / 7) + 1; // zero-indexed
    }
    // start-of-first-week - start-of-year
    function firstWeekOffset(year, dow, doy) {
        // first-week day -- which january is always in the first week (4 for iso, 1 for other)
        var fwd = 7 + dow - doy;
        // first-week day local weekday -- which local weekday is fwd
        var fwdlw = (7 + arrayToUtcDate([year, 0, fwd]).getUTCDay() - dow) % 7;
        return -fwdlw + fwd - 1;
    }
    // Array Conversion
    function dateToLocalArray(date) {
        return [
            date.getFullYear(),
            date.getMonth(),
            date.getDate(),
            date.getHours(),
            date.getMinutes(),
            date.getSeconds(),
            date.getMilliseconds()
        ];
    }
    function arrayToLocalDate(a) {
        return new Date(a[0], a[1] || 0, a[2] == null ? 1 : a[2], // day of month
        a[3] || 0, a[4] || 0, a[5] || 0);
    }
    function dateToUtcArray(date) {
        return [
            date.getUTCFullYear(),
            date.getUTCMonth(),
            date.getUTCDate(),
            date.getUTCHours(),
            date.getUTCMinutes(),
            date.getUTCSeconds(),
            date.getUTCMilliseconds()
        ];
    }
    function arrayToUtcDate(a) {
        // according to web standards (and Safari), a month index is required.
        // massage if only given a year.
        if (a.length === 1) {
            a = a.concat([0]);
        }
        return new Date(Date.UTC.apply(Date, a));
    }
    // Other Utils
    function isValidDate(m) {
        return !isNaN(m.valueOf());
    }
    function timeAsMs(m) {
        return m.getUTCHours() * 1000 * 60 * 60 +
            m.getUTCMinutes() * 1000 * 60 +
            m.getUTCSeconds() * 1000 +
            m.getUTCMilliseconds();
    }

    var INTERNAL_UNITS = ['years', 'months', 'days', 'milliseconds'];
    var PARSE_RE = /^(-?)(?:(\d+)\.)?(\d+):(\d\d)(?::(\d\d)(?:\.(\d\d\d))?)?/;
    // Parsing and Creation
    function createDuration(input, unit) {
        var _a;
        if (typeof input === 'string') {
            return parseString(input);
        }
        else if (typeof input === 'object' && input) { // non-null object
            return normalizeObject(input);
        }
        else if (typeof input === 'number') {
            return normalizeObject((_a = {}, _a[unit || 'milliseconds'] = input, _a));
        }
        else {
            return null;
        }
    }
    function parseString(s) {
        var m = PARSE_RE.exec(s);
        if (m) {
            var sign = m[1] ? -1 : 1;
            return {
                years: 0,
                months: 0,
                days: sign * (m[2] ? parseInt(m[2], 10) : 0),
                milliseconds: sign * ((m[3] ? parseInt(m[3], 10) : 0) * 60 * 60 * 1000 + // hours
                    (m[4] ? parseInt(m[4], 10) : 0) * 60 * 1000 + // minutes
                    (m[5] ? parseInt(m[5], 10) : 0) * 1000 + // seconds
                    (m[6] ? parseInt(m[6], 10) : 0) // ms
                )
            };
        }
        return null;
    }
    function normalizeObject(obj) {
        return {
            years: obj.years || obj.year || 0,
            months: obj.months || obj.month || 0,
            days: (obj.days || obj.day || 0) +
                getWeeksFromInput(obj) * 7,
            milliseconds: (obj.hours || obj.hour || 0) * 60 * 60 * 1000 + // hours
                (obj.minutes || obj.minute || 0) * 60 * 1000 + // minutes
                (obj.seconds || obj.second || 0) * 1000 + // seconds
                (obj.milliseconds || obj.millisecond || obj.ms || 0) // ms
        };
    }
    function getWeeksFromInput(obj) {
        return obj.weeks || obj.week || 0;
    }
    // Equality
    function durationsEqual(d0, d1) {
        return d0.years === d1.years &&
            d0.months === d1.months &&
            d0.days === d1.days &&
            d0.milliseconds === d1.milliseconds;
    }
    function isSingleDay(dur) {
        return dur.years === 0 && dur.months === 0 && dur.days === 1 && dur.milliseconds === 0;
    }
    // Simple Math
    function addDurations(d0, d1) {
        return {
            years: d0.years + d1.years,
            months: d0.months + d1.months,
            days: d0.days + d1.days,
            milliseconds: d0.milliseconds + d1.milliseconds
        };
    }
    function subtractDurations(d1, d0) {
        return {
            years: d1.years - d0.years,
            months: d1.months - d0.months,
            days: d1.days - d0.days,
            milliseconds: d1.milliseconds - d0.milliseconds
        };
    }
    function multiplyDuration(d, n) {
        return {
            years: d.years * n,
            months: d.months * n,
            days: d.days * n,
            milliseconds: d.milliseconds * n
        };
    }
    // Conversions
    // "Rough" because they are based on average-case Gregorian months/years
    function asRoughYears(dur) {
        return asRoughDays(dur) / 365;
    }
    function asRoughMonths(dur) {
        return asRoughDays(dur) / 30;
    }
    function asRoughDays(dur) {
        return asRoughMs(dur) / 864e5;
    }
    function asRoughMinutes(dur) {
        return asRoughMs(dur) / (1000 * 60);
    }
    function asRoughSeconds(dur) {
        return asRoughMs(dur) / 1000;
    }
    function asRoughMs(dur) {
        return dur.years * (365 * 864e5) +
            dur.months * (30 * 864e5) +
            dur.days * 864e5 +
            dur.milliseconds;
    }
    // Advanced Math
    function wholeDivideDurations(numerator, denominator) {
        var res = null;
        for (var i = 0; i < INTERNAL_UNITS.length; i++) {
            var unit = INTERNAL_UNITS[i];
            if (denominator[unit]) {
                var localRes = numerator[unit] / denominator[unit];
                if (!isInt(localRes) || (res !== null && res !== localRes)) {
                    return null;
                }
                res = localRes;
            }
            else if (numerator[unit]) {
                // needs to divide by something but can't!
                return null;
            }
        }
        return res;
    }
    function greatestDurationDenominator(dur, dontReturnWeeks) {
        var ms = dur.milliseconds;
        if (ms) {
            if (ms % 1000 !== 0) {
                return { unit: 'millisecond', value: ms };
            }
            if (ms % (1000 * 60) !== 0) {
                return { unit: 'second', value: ms / 1000 };
            }
            if (ms % (1000 * 60 * 60) !== 0) {
                return { unit: 'minute', value: ms / (1000 * 60) };
            }
            if (ms) {
                return { unit: 'hour', value: ms / (1000 * 60 * 60) };
            }
        }
        if (dur.days) {
            if (!dontReturnWeeks && dur.days % 7 === 0) {
                return { unit: 'week', value: dur.days / 7 };
            }
            return { unit: 'day', value: dur.days };
        }
        if (dur.months) {
            return { unit: 'month', value: dur.months };
        }
        if (dur.years) {
            return { unit: 'year', value: dur.years };
        }
        return { unit: 'millisecond', value: 0 };
    }

    /* FullCalendar-specific DOM Utilities
    ----------------------------------------------------------------------------------------------------------------------*/
    // Given the scrollbar widths of some other container, create borders/margins on rowEls in order to match the left
    // and right space that was offset by the scrollbars. A 1-pixel border first, then margin beyond that.
    function compensateScroll(rowEl, scrollbarWidths) {
        if (scrollbarWidths.left) {
            applyStyle(rowEl, {
                borderLeftWidth: 1,
                marginLeft: scrollbarWidths.left - 1
            });
        }
        if (scrollbarWidths.right) {
            applyStyle(rowEl, {
                borderRightWidth: 1,
                marginRight: scrollbarWidths.right - 1
            });
        }
    }
    // Undoes compensateScroll and restores all borders/margins
    function uncompensateScroll(rowEl) {
        applyStyle(rowEl, {
            marginLeft: '',
            marginRight: '',
            borderLeftWidth: '',
            borderRightWidth: ''
        });
    }
    // Make the mouse cursor express that an event is not allowed in the current area
    function disableCursor() {
        document.body.classList.add('fc-not-allowed');
    }
    // Returns the mouse cursor to its original look
    function enableCursor() {
        document.body.classList.remove('fc-not-allowed');
    }
    // Given a total available height to fill, have `els` (essentially child rows) expand to accomodate.
    // By default, all elements that are shorter than the recommended height are expanded uniformly, not considering
    // any other els that are already too tall. if `shouldRedistribute` is on, it considers these tall rows and
    // reduces the available height.
    function distributeHeight(els, availableHeight, shouldRedistribute) {
        // *FLOORING NOTE*: we floor in certain places because zoom can give inaccurate floating-point dimensions,
        // and it is better to be shorter than taller, to avoid creating unnecessary scrollbars.
        var minOffset1 = Math.floor(availableHeight / els.length); // for non-last element
        var minOffset2 = Math.floor(availableHeight - minOffset1 * (els.length - 1)); // for last element *FLOORING NOTE*
        var flexEls = []; // elements that are allowed to expand. array of DOM nodes
        var flexOffsets = []; // amount of vertical space it takes up
        var flexHeights = []; // actual css height
        var usedHeight = 0;
        undistributeHeight(els); // give all elements their natural height
        // find elements that are below the recommended height (expandable).
        // important to query for heights in a single first pass (to avoid reflow oscillation).
        els.forEach(function (el, i) {
            var minOffset = i === els.length - 1 ? minOffset2 : minOffset1;
            var naturalHeight = el.getBoundingClientRect().height;
            var naturalOffset = naturalHeight + computeVMargins(el);
            if (naturalOffset < minOffset) {
                flexEls.push(el);
                flexOffsets.push(naturalOffset);
                flexHeights.push(naturalHeight);
            }
            else {
                // this element stretches past recommended height (non-expandable). mark the space as occupied.
                usedHeight += naturalOffset;
            }
        });
        // readjust the recommended height to only consider the height available to non-maxed-out rows.
        if (shouldRedistribute) {
            availableHeight -= usedHeight;
            minOffset1 = Math.floor(availableHeight / flexEls.length);
            minOffset2 = Math.floor(availableHeight - minOffset1 * (flexEls.length - 1)); // *FLOORING NOTE*
        }
        // assign heights to all expandable elements
        flexEls.forEach(function (el, i) {
            var minOffset = i === flexEls.length - 1 ? minOffset2 : minOffset1;
            var naturalOffset = flexOffsets[i];
            var naturalHeight = flexHeights[i];
            var newHeight = minOffset - (naturalOffset - naturalHeight); // subtract the margin/padding
            if (naturalOffset < minOffset) { // we check this again because redistribution might have changed things
                el.style.height = newHeight + 'px';
            }
        });
    }
    // Undoes distrubuteHeight, restoring all els to their natural height
    function undistributeHeight(els) {
        els.forEach(function (el) {
            el.style.height = '';
        });
    }
    // Given `els`, a set of <td> cells, find the cell with the largest natural width and set the widths of all the
    // cells to be that width.
    // PREREQUISITE: if you want a cell to take up width, it needs to have a single inner element w/ display:inline
    function matchCellWidths(els) {
        var maxInnerWidth = 0;
        els.forEach(function (el) {
            var innerEl = el.firstChild; // hopefully an element
            if (innerEl instanceof HTMLElement) {
                var innerWidth_1 = innerEl.getBoundingClientRect().width;
                if (innerWidth_1 > maxInnerWidth) {
                    maxInnerWidth = innerWidth_1;
                }
            }
        });
        maxInnerWidth++; // sometimes not accurate of width the text needs to stay on one line. insurance
        els.forEach(function (el) {
            el.style.width = maxInnerWidth + 'px';
        });
        return maxInnerWidth;
    }
    // Given one element that resides inside another,
    // Subtracts the height of the inner element from the outer element.
    function subtractInnerElHeight(outerEl, innerEl) {
        // effin' IE8/9/10/11 sometimes returns 0 for dimensions. this weird hack was the only thing that worked
        var reflowStyleProps = {
            position: 'relative',
            left: -1 // ensure reflow in case the el was already relative. negative is less likely to cause new scroll
        };
        applyStyle(outerEl, reflowStyleProps);
        applyStyle(innerEl, reflowStyleProps);
        var diff = // grab the dimensions
         outerEl.getBoundingClientRect().height -
            innerEl.getBoundingClientRect().height;
        // undo hack
        var resetStyleProps = { position: '', left: '' };
        applyStyle(outerEl, resetStyleProps);
        applyStyle(innerEl, resetStyleProps);
        return diff;
    }
    /* Selection
    ----------------------------------------------------------------------------------------------------------------------*/
    function preventSelection(el) {
        el.classList.add('fc-unselectable');
        el.addEventListener('selectstart', preventDefault);
    }
    function allowSelection(el) {
        el.classList.remove('fc-unselectable');
        el.removeEventListener('selectstart', preventDefault);
    }
    /* Context Menu
    ----------------------------------------------------------------------------------------------------------------------*/
    function preventContextMenu(el) {
        el.addEventListener('contextmenu', preventDefault);
    }
    function allowContextMenu(el) {
        el.removeEventListener('contextmenu', preventDefault);
    }
    /* Object Ordering by Field
    ----------------------------------------------------------------------------------------------------------------------*/
    function parseFieldSpecs(input) {
        var specs = [];
        var tokens = [];
        var i;
        var token;
        if (typeof input === 'string') {
            tokens = input.split(/\s*,\s*/);
        }
        else if (typeof input === 'function') {
            tokens = [input];
        }
        else if (Array.isArray(input)) {
            tokens = input;
        }
        for (i = 0; i < tokens.length; i++) {
            token = tokens[i];
            if (typeof token === 'string') {
                specs.push(token.charAt(0) === '-' ?
                    { field: token.substring(1), order: -1 } :
                    { field: token, order: 1 });
            }
            else if (typeof token === 'function') {
                specs.push({ func: token });
            }
        }
        return specs;
    }
    function compareByFieldSpecs(obj0, obj1, fieldSpecs) {
        var i;
        var cmp;
        for (i = 0; i < fieldSpecs.length; i++) {
            cmp = compareByFieldSpec(obj0, obj1, fieldSpecs[i]);
            if (cmp) {
                return cmp;
            }
        }
        return 0;
    }
    function compareByFieldSpec(obj0, obj1, fieldSpec) {
        if (fieldSpec.func) {
            return fieldSpec.func(obj0, obj1);
        }
        return flexibleCompare(obj0[fieldSpec.field], obj1[fieldSpec.field])
            * (fieldSpec.order || 1);
    }
    function flexibleCompare(a, b) {
        if (!a && !b) {
            return 0;
        }
        if (b == null) {
            return -1;
        }
        if (a == null) {
            return 1;
        }
        if (typeof a === 'string' || typeof b === 'string') {
            return String(a).localeCompare(String(b));
        }
        return a - b;
    }
    /* String Utilities
    ----------------------------------------------------------------------------------------------------------------------*/
    function capitaliseFirstLetter(str) {
        return str.charAt(0).toUpperCase() + str.slice(1);
    }
    function padStart(val, len) {
        var s = String(val);
        return '000'.substr(0, len - s.length) + s;
    }
    /* Number Utilities
    ----------------------------------------------------------------------------------------------------------------------*/
    function compareNumbers(a, b) {
        return a - b;
    }
    function isInt(n) {
        return n % 1 === 0;
    }
    /* Weird Utilities
    ----------------------------------------------------------------------------------------------------------------------*/
    function applyAll(functions, thisObj, args) {
        if (typeof functions === 'function') { // supplied a single function
            functions = [functions];
        }
        if (functions) {
            var i = void 0;
            var ret = void 0;
            for (i = 0; i < functions.length; i++) {
                ret = functions[i].apply(thisObj, args) || ret;
            }
            return ret;
        }
    }
    function firstDefined() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        for (var i = 0; i < args.length; i++) {
            if (args[i] !== undefined) {
                return args[i];
            }
        }
    }
    // Returns a function, that, as long as it continues to be invoked, will not
    // be triggered. The function will be called after it stops being called for
    // N milliseconds. If `immediate` is passed, trigger the function on the
    // leading edge, instead of the trailing.
    // https://github.com/jashkenas/underscore/blob/1.6.0/underscore.js#L714
    function debounce(func, wait) {
        var timeout;
        var args;
        var context;
        var timestamp;
        var result;
        var later = function () {
            var last = new Date().valueOf() - timestamp;
            if (last < wait) {
                timeout = setTimeout(later, wait - last);
            }
            else {
                timeout = null;
                result = func.apply(context, args);
                context = args = null;
            }
        };
        return function () {
            context = this;
            args = arguments;
            timestamp = new Date().valueOf();
            if (!timeout) {
                timeout = setTimeout(later, wait);
            }
            return result;
        };
    }
    // Number and Boolean are only types that defaults or not computed for
    // TODO: write more comments
    function refineProps(rawProps, processors, defaults, leftoverProps) {
        if (defaults === void 0) { defaults = {}; }
        var refined = {};
        for (var key in processors) {
            var processor = processors[key];
            if (rawProps[key] !== undefined) {
                // found
                if (processor === Function) {
                    refined[key] = typeof rawProps[key] === 'function' ? rawProps[key] : null;
                }
                else if (processor) { // a refining function?
                    refined[key] = processor(rawProps[key]);
                }
                else {
                    refined[key] = rawProps[key];
                }
            }
            else if (defaults[key] !== undefined) {
                // there's an explicit default
                refined[key] = defaults[key];
            }
            else {
                // must compute a default
                if (processor === String) {
                    refined[key] = ''; // empty string is default for String
                }
                else if (!processor || processor === Number || processor === Boolean || processor === Function) {
                    refined[key] = null; // assign null for other non-custom processor funcs
                }
                else {
                    refined[key] = processor(null); // run the custom processor func
                }
            }
        }
        if (leftoverProps) {
            for (var key in rawProps) {
                if (processors[key] === undefined) {
                    leftoverProps[key] = rawProps[key];
                }
            }
        }
        return refined;
    }
    /* Date stuff that doesn't belong in datelib core
    ----------------------------------------------------------------------------------------------------------------------*/
    // given a timed range, computes an all-day range that has the same exact duration,
    // but whose start time is aligned with the start of the day.
    function computeAlignedDayRange(timedRange) {
        var dayCnt = Math.floor(diffDays(timedRange.start, timedRange.end)) || 1;
        var start = startOfDay(timedRange.start);
        var end = addDays(start, dayCnt);
        return { start: start, end: end };
    }
    // given a timed range, computes an all-day range based on how for the end date bleeds into the next day
    // TODO: give nextDayThreshold a default arg
    function computeVisibleDayRange(timedRange, nextDayThreshold) {
        if (nextDayThreshold === void 0) { nextDayThreshold = createDuration(0); }
        var startDay = null;
        var endDay = null;
        if (timedRange.end) {
            endDay = startOfDay(timedRange.end);
            var endTimeMS = timedRange.end.valueOf() - endDay.valueOf(); // # of milliseconds into `endDay`
            // If the end time is actually inclusively part of the next day and is equal to or
            // beyond the next day threshold, adjust the end to be the exclusive end of `endDay`.
            // Otherwise, leaving it as inclusive will cause it to exclude `endDay`.
            if (endTimeMS && endTimeMS >= asRoughMs(nextDayThreshold)) {
                endDay = addDays(endDay, 1);
            }
        }
        if (timedRange.start) {
            startDay = startOfDay(timedRange.start); // the beginning of the day the range starts
            // If end is within `startDay` but not past nextDayThreshold, assign the default duration of one day.
            if (endDay && endDay <= startDay) {
                endDay = addDays(startDay, 1);
            }
        }
        return { start: startDay, end: endDay };
    }
    // spans from one day into another?
    function isMultiDayRange(range) {
        var visibleRange = computeVisibleDayRange(range);
        return diffDays(visibleRange.start, visibleRange.end) > 1;
    }
    function diffDates(date0, date1, dateEnv, largeUnit) {
        if (largeUnit === 'year') {
            return createDuration(dateEnv.diffWholeYears(date0, date1), 'year');
        }
        else if (largeUnit === 'month') {
            return createDuration(dateEnv.diffWholeMonths(date0, date1), 'month');
        }
        else {
            return diffDayAndTime(date0, date1); // returns a duration
        }
    }

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    /* global Reflect, Promise */

    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };

    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    var __assign = function() {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };

    function parseRecurring(eventInput, allDayDefault, dateEnv, recurringTypes, leftovers) {
        for (var i = 0; i < recurringTypes.length; i++) {
            var localLeftovers = {};
            var parsed = recurringTypes[i].parse(eventInput, localLeftovers, dateEnv);
            if (parsed) {
                var allDay = localLeftovers.allDay;
                delete localLeftovers.allDay; // remove from leftovers
                if (allDay == null) {
                    allDay = allDayDefault;
                    if (allDay == null) {
                        allDay = parsed.allDayGuess;
                        if (allDay == null) {
                            allDay = false;
                        }
                    }
                }
                __assign(leftovers, localLeftovers);
                return {
                    allDay: allDay,
                    duration: parsed.duration,
                    typeData: parsed.typeData,
                    typeId: i
                };
            }
        }
        return null;
    }
    /*
    Event MUST have a recurringDef
    */
    function expandRecurringRanges(eventDef, duration, framingRange, dateEnv, recurringTypes) {
        var typeDef = recurringTypes[eventDef.recurringDef.typeId];
        var markers = typeDef.expand(eventDef.recurringDef.typeData, {
            start: dateEnv.subtract(framingRange.start, duration),
            end: framingRange.end
        }, dateEnv);
        // the recurrence plugins don't guarantee that all-day events are start-of-day, so we have to
        if (eventDef.allDay) {
            markers = markers.map(startOfDay);
        }
        return markers;
    }

    var hasOwnProperty = Object.prototype.hasOwnProperty;
    // Merges an array of objects into a single object.
    // The second argument allows for an array of property names who's object values will be merged together.
    function mergeProps(propObjs, complexProps) {
        var dest = {};
        var i;
        var name;
        var complexObjs;
        var j;
        var val;
        var props;
        if (complexProps) {
            for (i = 0; i < complexProps.length; i++) {
                name = complexProps[i];
                complexObjs = [];
                // collect the trailing object values, stopping when a non-object is discovered
                for (j = propObjs.length - 1; j >= 0; j--) {
                    val = propObjs[j][name];
                    if (typeof val === 'object' && val) { // non-null object
                        complexObjs.unshift(val);
                    }
                    else if (val !== undefined) {
                        dest[name] = val; // if there were no objects, this value will be used
                        break;
                    }
                }
                // if the trailing values were objects, use the merged value
                if (complexObjs.length) {
                    dest[name] = mergeProps(complexObjs);
                }
            }
        }
        // copy values into the destination, going from last to first
        for (i = propObjs.length - 1; i >= 0; i--) {
            props = propObjs[i];
            for (name in props) {
                if (!(name in dest)) { // if already assigned by previous props or complex props, don't reassign
                    dest[name] = props[name];
                }
            }
        }
        return dest;
    }
    function filterHash(hash, func) {
        var filtered = {};
        for (var key in hash) {
            if (func(hash[key], key)) {
                filtered[key] = hash[key];
            }
        }
        return filtered;
    }
    function mapHash(hash, func) {
        var newHash = {};
        for (var key in hash) {
            newHash[key] = func(hash[key], key);
        }
        return newHash;
    }
    function arrayToHash(a) {
        var hash = {};
        for (var _i = 0, a_1 = a; _i < a_1.length; _i++) {
            var item = a_1[_i];
            hash[item] = true;
        }
        return hash;
    }
    function hashValuesToArray(obj) {
        var a = [];
        for (var key in obj) {
            a.push(obj[key]);
        }
        return a;
    }
    function isPropsEqual(obj0, obj1) {
        for (var key in obj0) {
            if (hasOwnProperty.call(obj0, key)) {
                if (!(key in obj1)) {
                    return false;
                }
            }
        }
        for (var key in obj1) {
            if (hasOwnProperty.call(obj1, key)) {
                if (obj0[key] !== obj1[key]) {
                    return false;
                }
            }
        }
        return true;
    }

    function parseEvents(rawEvents, sourceId, calendar, allowOpenRange) {
        var eventStore = createEmptyEventStore();
        for (var _i = 0, rawEvents_1 = rawEvents; _i < rawEvents_1.length; _i++) {
            var rawEvent = rawEvents_1[_i];
            var tuple = parseEvent(rawEvent, sourceId, calendar, allowOpenRange);
            if (tuple) {
                eventTupleToStore(tuple, eventStore);
            }
        }
        return eventStore;
    }
    function eventTupleToStore(tuple, eventStore) {
        if (eventStore === void 0) { eventStore = createEmptyEventStore(); }
        eventStore.defs[tuple.def.defId] = tuple.def;
        if (tuple.instance) {
            eventStore.instances[tuple.instance.instanceId] = tuple.instance;
        }
        return eventStore;
    }
    function expandRecurring(eventStore, framingRange, calendar) {
        var dateEnv = calendar.dateEnv;
        var defs = eventStore.defs, instances = eventStore.instances;
        // remove existing recurring instances
        instances = filterHash(instances, function (instance) {
            return !defs[instance.defId].recurringDef;
        });
        for (var defId in defs) {
            var def = defs[defId];
            if (def.recurringDef) {
                var duration = def.recurringDef.duration;
                if (!duration) {
                    duration = def.allDay ?
                        calendar.defaultAllDayEventDuration :
                        calendar.defaultTimedEventDuration;
                }
                var starts = expandRecurringRanges(def, duration, framingRange, calendar.dateEnv, calendar.pluginSystem.hooks.recurringTypes);
                for (var _i = 0, starts_1 = starts; _i < starts_1.length; _i++) {
                    var start = starts_1[_i];
                    var instance = createEventInstance(defId, {
                        start: start,
                        end: dateEnv.add(start, duration)
                    });
                    instances[instance.instanceId] = instance;
                }
            }
        }
        return { defs: defs, instances: instances };
    }
    // retrieves events that have the same groupId as the instance specified by `instanceId`
    // or they are the same as the instance.
    // why might instanceId not be in the store? an event from another calendar?
    function getRelevantEvents(eventStore, instanceId) {
        var instance = eventStore.instances[instanceId];
        if (instance) {
            var def_1 = eventStore.defs[instance.defId];
            // get events/instances with same group
            var newStore = filterEventStoreDefs(eventStore, function (lookDef) {
                return isEventDefsGrouped(def_1, lookDef);
            });
            // add the original
            // TODO: wish we could use eventTupleToStore or something like it
            newStore.defs[def_1.defId] = def_1;
            newStore.instances[instance.instanceId] = instance;
            return newStore;
        }
        return createEmptyEventStore();
    }
    function isEventDefsGrouped(def0, def1) {
        return Boolean(def0.groupId && def0.groupId === def1.groupId);
    }
    function transformRawEvents(rawEvents, eventSource, calendar) {
        var calEachTransform = calendar.opt('eventDataTransform');
        var sourceEachTransform = eventSource ? eventSource.eventDataTransform : null;
        if (sourceEachTransform) {
            rawEvents = transformEachRawEvent(rawEvents, sourceEachTransform);
        }
        if (calEachTransform) {
            rawEvents = transformEachRawEvent(rawEvents, calEachTransform);
        }
        return rawEvents;
    }
    function transformEachRawEvent(rawEvents, func) {
        var refinedEvents;
        if (!func) {
            refinedEvents = rawEvents;
        }
        else {
            refinedEvents = [];
            for (var _i = 0, rawEvents_2 = rawEvents; _i < rawEvents_2.length; _i++) {
                var rawEvent = rawEvents_2[_i];
                var refinedEvent = func(rawEvent);
                if (refinedEvent) {
                    refinedEvents.push(refinedEvent);
                }
                else if (refinedEvent == null) {
                    refinedEvents.push(rawEvent);
                } // if a different falsy value, do nothing
            }
        }
        return refinedEvents;
    }
    function createEmptyEventStore() {
        return { defs: {}, instances: {} };
    }
    function mergeEventStores(store0, store1) {
        return {
            defs: __assign({}, store0.defs, store1.defs),
            instances: __assign({}, store0.instances, store1.instances)
        };
    }
    function filterEventStoreDefs(eventStore, filterFunc) {
        var defs = filterHash(eventStore.defs, filterFunc);
        var instances = filterHash(eventStore.instances, function (instance) {
            return defs[instance.defId]; // still exists?
        });
        return { defs: defs, instances: instances };
    }

    function parseRange(input, dateEnv) {
        var start = null;
        var end = null;
        if (input.start) {
            start = dateEnv.createMarker(input.start);
        }
        if (input.end) {
            end = dateEnv.createMarker(input.end);
        }
        if (!start && !end) {
            return null;
        }
        if (start && end && end < start) {
            return null;
        }
        return { start: start, end: end };
    }
    // SIDE-EFFECT: will mutate ranges.
    // Will return a new array result.
    function invertRanges(ranges, constraintRange) {
        var invertedRanges = [];
        var start = constraintRange.start; // the end of the previous range. the start of the new range
        var i;
        var dateRange;
        // ranges need to be in order. required for our date-walking algorithm
        ranges.sort(compareRanges);
        for (i = 0; i < ranges.length; i++) {
            dateRange = ranges[i];
            // add the span of time before the event (if there is any)
            if (dateRange.start > start) { // compare millisecond time (skip any ambig logic)
                invertedRanges.push({ start: start, end: dateRange.start });
            }
            if (dateRange.end > start) {
                start = dateRange.end;
            }
        }
        // add the span of time after the last event (if there is any)
        if (start < constraintRange.end) { // compare millisecond time (skip any ambig logic)
            invertedRanges.push({ start: start, end: constraintRange.end });
        }
        return invertedRanges;
    }
    function compareRanges(range0, range1) {
        return range0.start.valueOf() - range1.start.valueOf(); // earlier ranges go first
    }
    function intersectRanges(range0, range1) {
        var start = range0.start;
        var end = range0.end;
        var newRange = null;
        if (range1.start !== null) {
            if (start === null) {
                start = range1.start;
            }
            else {
                start = new Date(Math.max(start.valueOf(), range1.start.valueOf()));
            }
        }
        if (range1.end != null) {
            if (end === null) {
                end = range1.end;
            }
            else {
                end = new Date(Math.min(end.valueOf(), range1.end.valueOf()));
            }
        }
        if (start === null || end === null || start < end) {
            newRange = { start: start, end: end };
        }
        return newRange;
    }
    function rangesEqual(range0, range1) {
        return (range0.start === null ? null : range0.start.valueOf()) === (range1.start === null ? null : range1.start.valueOf()) &&
            (range0.end === null ? null : range0.end.valueOf()) === (range1.end === null ? null : range1.end.valueOf());
    }
    function rangesIntersect(range0, range1) {
        return (range0.end === null || range1.start === null || range0.end > range1.start) &&
            (range0.start === null || range1.end === null || range0.start < range1.end);
    }
    function rangeContainsRange(outerRange, innerRange) {
        return (outerRange.start === null || (innerRange.start !== null && innerRange.start >= outerRange.start)) &&
            (outerRange.end === null || (innerRange.end !== null && innerRange.end <= outerRange.end));
    }
    function rangeContainsMarker(range, date) {
        return (range.start === null || date >= range.start) &&
            (range.end === null || date < range.end);
    }
    // If the given date is not within the given range, move it inside.
    // (If it's past the end, make it one millisecond before the end).
    function constrainMarkerToRange(date, range) {
        if (range.start != null && date < range.start) {
            return range.start;
        }
        if (range.end != null && date >= range.end) {
            return new Date(range.end.valueOf() - 1);
        }
        return date;
    }

    function removeExact(array, exactVal) {
        var removeCnt = 0;
        var i = 0;
        while (i < array.length) {
            if (array[i] === exactVal) {
                array.splice(i, 1);
                removeCnt++;
            }
            else {
                i++;
            }
        }
        return removeCnt;
    }
    function isArraysEqual(a0, a1) {
        var len = a0.length;
        var i;
        if (len !== a1.length) { // not array? or not same length?
            return false;
        }
        for (i = 0; i < len; i++) {
            if (a0[i] !== a1[i]) {
                return false;
            }
        }
        return true;
    }

    function memoize(workerFunc) {
        var args;
        var res;
        return function () {
            if (!args || !isArraysEqual(args, arguments)) {
                args = arguments;
                res = workerFunc.apply(this, arguments);
            }
            return res;
        };
    }
    /*
    always executes the workerFunc, but if the result is equal to the previous result,
    return the previous result instead.
    */
    function memoizeOutput(workerFunc, equalityFunc) {
        var cachedRes = null;
        return function () {
            var newRes = workerFunc.apply(this, arguments);
            if (cachedRes === null || !(cachedRes === newRes || equalityFunc(cachedRes, newRes))) {
                cachedRes = newRes;
            }
            return cachedRes;
        };
    }

    var EXTENDED_SETTINGS_AND_SEVERITIES = {
        week: 3,
        separator: 0,
        omitZeroMinute: 0,
        meridiem: 0,
        omitCommas: 0
    };
    var STANDARD_DATE_PROP_SEVERITIES = {
        timeZoneName: 7,
        era: 6,
        year: 5,
        month: 4,
        day: 2,
        weekday: 2,
        hour: 1,
        minute: 1,
        second: 1
    };
    var MERIDIEM_RE = /\s*([ap])\.?m\.?/i; // eats up leading spaces too
    var COMMA_RE = /,/g; // we need re for globalness
    var MULTI_SPACE_RE = /\s+/g;
    var LTR_RE = /\u200e/g; // control character
    var UTC_RE = /UTC|GMT/;
    var NativeFormatter = /** @class */ (function () {
        function NativeFormatter(formatSettings) {
            var standardDateProps = {};
            var extendedSettings = {};
            var severity = 0;
            for (var name_1 in formatSettings) {
                if (name_1 in EXTENDED_SETTINGS_AND_SEVERITIES) {
                    extendedSettings[name_1] = formatSettings[name_1];
                    severity = Math.max(EXTENDED_SETTINGS_AND_SEVERITIES[name_1], severity);
                }
                else {
                    standardDateProps[name_1] = formatSettings[name_1];
                    if (name_1 in STANDARD_DATE_PROP_SEVERITIES) {
                        severity = Math.max(STANDARD_DATE_PROP_SEVERITIES[name_1], severity);
                    }
                }
            }
            this.standardDateProps = standardDateProps;
            this.extendedSettings = extendedSettings;
            this.severity = severity;
            this.buildFormattingFunc = memoize(buildFormattingFunc);
        }
        NativeFormatter.prototype.format = function (date, context) {
            return this.buildFormattingFunc(this.standardDateProps, this.extendedSettings, context)(date);
        };
        NativeFormatter.prototype.formatRange = function (start, end, context) {
            var _a = this, standardDateProps = _a.standardDateProps, extendedSettings = _a.extendedSettings;
            var diffSeverity = computeMarkerDiffSeverity(start.marker, end.marker, context.calendarSystem);
            if (!diffSeverity) {
                return this.format(start, context);
            }
            var biggestUnitForPartial = diffSeverity;
            if (biggestUnitForPartial > 1 && // the two dates are different in a way that's larger scale than time
                (standardDateProps.year === 'numeric' || standardDateProps.year === '2-digit') &&
                (standardDateProps.month === 'numeric' || standardDateProps.month === '2-digit') &&
                (standardDateProps.day === 'numeric' || standardDateProps.day === '2-digit')) {
                biggestUnitForPartial = 1; // make it look like the dates are only different in terms of time
            }
            var full0 = this.format(start, context);
            var full1 = this.format(end, context);
            if (full0 === full1) {
                return full0;
            }
            var partialDateProps = computePartialFormattingOptions(standardDateProps, biggestUnitForPartial);
            var partialFormattingFunc = buildFormattingFunc(partialDateProps, extendedSettings, context);
            var partial0 = partialFormattingFunc(start);
            var partial1 = partialFormattingFunc(end);
            var insertion = findCommonInsertion(full0, partial0, full1, partial1);
            var separator = extendedSettings.separator || '';
            if (insertion) {
                return insertion.before + partial0 + separator + partial1 + insertion.after;
            }
            return full0 + separator + full1;
        };
        NativeFormatter.prototype.getLargestUnit = function () {
            switch (this.severity) {
                case 7:
                case 6:
                case 5:
                    return 'year';
                case 4:
                    return 'month';
                case 3:
                    return 'week';
                default:
                    return 'day';
            }
        };
        return NativeFormatter;
    }());
    function buildFormattingFunc(standardDateProps, extendedSettings, context) {
        var standardDatePropCnt = Object.keys(standardDateProps).length;
        if (standardDatePropCnt === 1 && standardDateProps.timeZoneName === 'short') {
            return function (date) {
                return formatTimeZoneOffset(date.timeZoneOffset);
            };
        }
        if (standardDatePropCnt === 0 && extendedSettings.week) {
            return function (date) {
                return formatWeekNumber(context.computeWeekNumber(date.marker), context.weekLabel, context.locale, extendedSettings.week);
            };
        }
        return buildNativeFormattingFunc(standardDateProps, extendedSettings, context);
    }
    function buildNativeFormattingFunc(standardDateProps, extendedSettings, context) {
        standardDateProps = __assign({}, standardDateProps); // copy
        extendedSettings = __assign({}, extendedSettings); // copy
        sanitizeSettings(standardDateProps, extendedSettings);
        standardDateProps.timeZone = 'UTC'; // we leverage the only guaranteed timeZone for our UTC markers
        var normalFormat = new Intl.DateTimeFormat(context.locale.codes, standardDateProps);
        var zeroFormat; // needed?
        if (extendedSettings.omitZeroMinute) {
            var zeroProps = __assign({}, standardDateProps);
            delete zeroProps.minute; // seconds and ms were already considered in sanitizeSettings
            zeroFormat = new Intl.DateTimeFormat(context.locale.codes, zeroProps);
        }
        return function (date) {
            var marker = date.marker;
            var format;
            if (zeroFormat && !marker.getUTCMinutes()) {
                format = zeroFormat;
            }
            else {
                format = normalFormat;
            }
            var s = format.format(marker);
            return postProcess(s, date, standardDateProps, extendedSettings, context);
        };
    }
    function sanitizeSettings(standardDateProps, extendedSettings) {
        // deal with a browser inconsistency where formatting the timezone
        // requires that the hour/minute be present.
        if (standardDateProps.timeZoneName) {
            if (!standardDateProps.hour) {
                standardDateProps.hour = '2-digit';
            }
            if (!standardDateProps.minute) {
                standardDateProps.minute = '2-digit';
            }
        }
        // only support short timezone names
        if (standardDateProps.timeZoneName === 'long') {
            standardDateProps.timeZoneName = 'short';
        }
        // if requesting to display seconds, MUST display minutes
        if (extendedSettings.omitZeroMinute && (standardDateProps.second || standardDateProps.millisecond)) {
            delete extendedSettings.omitZeroMinute;
        }
    }
    function postProcess(s, date, standardDateProps, extendedSettings, context) {
        s = s.replace(LTR_RE, ''); // remove left-to-right control chars. do first. good for other regexes
        if (standardDateProps.timeZoneName === 'short') {
            s = injectTzoStr(s, (context.timeZone === 'UTC' || date.timeZoneOffset == null) ?
                'UTC' : // important to normalize for IE, which does "GMT"
                formatTimeZoneOffset(date.timeZoneOffset));
        }
        if (extendedSettings.omitCommas) {
            s = s.replace(COMMA_RE, '').trim();
        }
        if (extendedSettings.omitZeroMinute) {
            s = s.replace(':00', ''); // zeroFormat doesn't always achieve this
        }
        // ^ do anything that might create adjacent spaces before this point,
        // because MERIDIEM_RE likes to eat up loading spaces
        if (extendedSettings.meridiem === false) {
            s = s.replace(MERIDIEM_RE, '').trim();
        }
        else if (extendedSettings.meridiem === 'narrow') { // a/p
            s = s.replace(MERIDIEM_RE, function (m0, m1) {
                return m1.toLocaleLowerCase();
            });
        }
        else if (extendedSettings.meridiem === 'short') { // am/pm
            s = s.replace(MERIDIEM_RE, function (m0, m1) {
                return m1.toLocaleLowerCase() + 'm';
            });
        }
        else if (extendedSettings.meridiem === 'lowercase') { // other meridiem transformers already converted to lowercase
            s = s.replace(MERIDIEM_RE, function (m0) {
                return m0.toLocaleLowerCase();
            });
        }
        s = s.replace(MULTI_SPACE_RE, ' ');
        s = s.trim();
        return s;
    }
    function injectTzoStr(s, tzoStr) {
        var replaced = false;
        s = s.replace(UTC_RE, function () {
            replaced = true;
            return tzoStr;
        });
        // IE11 doesn't include UTC/GMT in the original string, so append to end
        if (!replaced) {
            s += ' ' + tzoStr;
        }
        return s;
    }
    function formatWeekNumber(num, weekLabel, locale, display) {
        var parts = [];
        if (display === 'narrow') {
            parts.push(weekLabel);
        }
        else if (display === 'short') {
            parts.push(weekLabel, ' ');
        }
        // otherwise, considered 'numeric'
        parts.push(locale.simpleNumberFormat.format(num));
        if (locale.options.isRtl) { // TODO: use control characters instead?
            parts.reverse();
        }
        return parts.join('');
    }
    // Range Formatting Utils
    // 0 = exactly the same
    // 1 = different by time
    // and bigger
    function computeMarkerDiffSeverity(d0, d1, ca) {
        if (ca.getMarkerYear(d0) !== ca.getMarkerYear(d1)) {
            return 5;
        }
        if (ca.getMarkerMonth(d0) !== ca.getMarkerMonth(d1)) {
            return 4;
        }
        if (ca.getMarkerDay(d0) !== ca.getMarkerDay(d1)) {
            return 2;
        }
        if (timeAsMs(d0) !== timeAsMs(d1)) {
            return 1;
        }
        return 0;
    }
    function computePartialFormattingOptions(options, biggestUnit) {
        var partialOptions = {};
        for (var name_2 in options) {
            if (!(name_2 in STANDARD_DATE_PROP_SEVERITIES) || // not a date part prop (like timeZone)
                STANDARD_DATE_PROP_SEVERITIES[name_2] <= biggestUnit) {
                partialOptions[name_2] = options[name_2];
            }
        }
        return partialOptions;
    }
    function findCommonInsertion(full0, partial0, full1, partial1) {
        var i0 = 0;
        while (i0 < full0.length) {
            var found0 = full0.indexOf(partial0, i0);
            if (found0 === -1) {
                break;
            }
            var before0 = full0.substr(0, found0);
            i0 = found0 + partial0.length;
            var after0 = full0.substr(i0);
            var i1 = 0;
            while (i1 < full1.length) {
                var found1 = full1.indexOf(partial1, i1);
                if (found1 === -1) {
                    break;
                }
                var before1 = full1.substr(0, found1);
                i1 = found1 + partial1.length;
                var after1 = full1.substr(i1);
                if (before0 === before1 && after0 === after1) {
                    return {
                        before: before0,
                        after: after0
                    };
                }
            }
        }
        return null;
    }

    /*
    TODO: fix the terminology of "formatter" vs "formatting func"
    */
    /*
    At the time of instantiation, this object does not know which cmd-formatting system it will use.
    It receives this at the time of formatting, as a setting.
    */
    var CmdFormatter = /** @class */ (function () {
        function CmdFormatter(cmdStr, separator) {
            this.cmdStr = cmdStr;
            this.separator = separator;
        }
        CmdFormatter.prototype.format = function (date, context) {
            return context.cmdFormatter(this.cmdStr, createVerboseFormattingArg(date, null, context, this.separator));
        };
        CmdFormatter.prototype.formatRange = function (start, end, context) {
            return context.cmdFormatter(this.cmdStr, createVerboseFormattingArg(start, end, context, this.separator));
        };
        return CmdFormatter;
    }());

    var FuncFormatter = /** @class */ (function () {
        function FuncFormatter(func) {
            this.func = func;
        }
        FuncFormatter.prototype.format = function (date, context) {
            return this.func(createVerboseFormattingArg(date, null, context));
        };
        FuncFormatter.prototype.formatRange = function (start, end, context) {
            return this.func(createVerboseFormattingArg(start, end, context));
        };
        return FuncFormatter;
    }());

    // Formatter Object Creation
    function createFormatter(input, defaultSeparator) {
        if (typeof input === 'object' && input) { // non-null object
            if (typeof defaultSeparator === 'string') {
                input = __assign({ separator: defaultSeparator }, input);
            }
            return new NativeFormatter(input);
        }
        else if (typeof input === 'string') {
            return new CmdFormatter(input, defaultSeparator);
        }
        else if (typeof input === 'function') {
            return new FuncFormatter(input);
        }
    }
    // String Utils
    // timeZoneOffset is in minutes
    function buildIsoString(marker, timeZoneOffset, stripZeroTime) {
        if (stripZeroTime === void 0) { stripZeroTime = false; }
        var s = marker.toISOString();
        s = s.replace('.000', '');
        if (stripZeroTime) {
            s = s.replace('T00:00:00Z', '');
        }
        if (s.length > 10) { // time part wasn't stripped, can add timezone info
            if (timeZoneOffset == null) {
                s = s.replace('Z', '');
            }
            else if (timeZoneOffset !== 0) {
                s = s.replace('Z', formatTimeZoneOffset(timeZoneOffset, true));
            }
            // otherwise, its UTC-0 and we want to keep the Z
        }
        return s;
    }
    function formatIsoTimeString(marker) {
        return padStart(marker.getUTCHours(), 2) + ':' +
            padStart(marker.getUTCMinutes(), 2) + ':' +
            padStart(marker.getUTCSeconds(), 2);
    }
    function formatTimeZoneOffset(minutes, doIso) {
        if (doIso === void 0) { doIso = false; }
        var sign = minutes < 0 ? '-' : '+';
        var abs = Math.abs(minutes);
        var hours = Math.floor(abs / 60);
        var mins = Math.round(abs % 60);
        if (doIso) {
            return sign + padStart(hours, 2) + ':' + padStart(mins, 2);
        }
        else {
            return 'GMT' + sign + hours + (mins ? ':' + padStart(mins, 2) : '');
        }
    }
    // Arg Utils
    function createVerboseFormattingArg(start, end, context, separator) {
        var startInfo = expandZonedMarker(start, context.calendarSystem);
        var endInfo = end ? expandZonedMarker(end, context.calendarSystem) : null;
        return {
            date: startInfo,
            start: startInfo,
            end: endInfo,
            timeZone: context.timeZone,
            localeCodes: context.locale.codes,
            separator: separator
        };
    }
    function expandZonedMarker(dateInfo, calendarSystem) {
        var a = calendarSystem.markerToArray(dateInfo.marker);
        return {
            marker: dateInfo.marker,
            timeZoneOffset: dateInfo.timeZoneOffset,
            array: a,
            year: a[0],
            month: a[1],
            day: a[2],
            hour: a[3],
            minute: a[4],
            second: a[5],
            millisecond: a[6]
        };
    }

    var EventSourceApi = /** @class */ (function () {
        function EventSourceApi(calendar, internalEventSource) {
            this.calendar = calendar;
            this.internalEventSource = internalEventSource;
        }
        EventSourceApi.prototype.remove = function () {
            this.calendar.dispatch({
                type: 'REMOVE_EVENT_SOURCE',
                sourceId: this.internalEventSource.sourceId
            });
        };
        EventSourceApi.prototype.refetch = function () {
            this.calendar.dispatch({
                type: 'FETCH_EVENT_SOURCES',
                sourceIds: [this.internalEventSource.sourceId]
            });
        };
        Object.defineProperty(EventSourceApi.prototype, "id", {
            get: function () {
                return this.internalEventSource.publicId;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EventSourceApi.prototype, "url", {
            // only relevant to json-feed event sources
            get: function () {
                return this.internalEventSource.meta.url;
            },
            enumerable: true,
            configurable: true
        });
        return EventSourceApi;
    }());

    var EventApi = /** @class */ (function () {
        function EventApi(calendar, def, instance) {
            this._calendar = calendar;
            this._def = def;
            this._instance = instance || null;
        }
        /*
        TODO: make event struct more responsible for this
        */
        EventApi.prototype.setProp = function (name, val) {
            var _a, _b;
            if (name in DATE_PROPS) ;
            else if (name in NON_DATE_PROPS) {
                if (typeof NON_DATE_PROPS[name] === 'function') {
                    val = NON_DATE_PROPS[name](val);
                }
                this.mutate({
                    standardProps: (_a = {}, _a[name] = val, _a)
                });
            }
            else if (name in UNSCOPED_EVENT_UI_PROPS) {
                var ui = void 0;
                if (typeof UNSCOPED_EVENT_UI_PROPS[name] === 'function') {
                    val = UNSCOPED_EVENT_UI_PROPS[name](val);
                }
                if (name === 'color') {
                    ui = { backgroundColor: val, borderColor: val };
                }
                else if (name === 'editable') {
                    ui = { startEditable: val, durationEditable: val };
                }
                else {
                    ui = (_b = {}, _b[name] = val, _b);
                }
                this.mutate({
                    standardProps: { ui: ui }
                });
            }
        };
        EventApi.prototype.setExtendedProp = function (name, val) {
            var _a;
            this.mutate({
                extendedProps: (_a = {}, _a[name] = val, _a)
            });
        };
        EventApi.prototype.setStart = function (startInput, options) {
            if (options === void 0) { options = {}; }
            var dateEnv = this._calendar.dateEnv;
            var start = dateEnv.createMarker(startInput);
            if (start && this._instance) { // TODO: warning if parsed bad
                var instanceRange = this._instance.range;
                var startDelta = diffDates(instanceRange.start, start, dateEnv, options.granularity); // what if parsed bad!?
                if (options.maintainDuration) {
                    this.mutate({ datesDelta: startDelta });
                }
                else {
                    this.mutate({ startDelta: startDelta });
                }
            }
        };
        EventApi.prototype.setEnd = function (endInput, options) {
            if (options === void 0) { options = {}; }
            var dateEnv = this._calendar.dateEnv;
            var end;
            if (endInput != null) {
                end = dateEnv.createMarker(endInput);
                if (!end) {
                    return; // TODO: warning if parsed bad
                }
            }
            if (this._instance) {
                if (end) {
                    var endDelta = diffDates(this._instance.range.end, end, dateEnv, options.granularity);
                    this.mutate({ endDelta: endDelta });
                }
                else {
                    this.mutate({ standardProps: { hasEnd: false } });
                }
            }
        };
        EventApi.prototype.setDates = function (startInput, endInput, options) {
            if (options === void 0) { options = {}; }
            var dateEnv = this._calendar.dateEnv;
            var standardProps = { allDay: options.allDay };
            var start = dateEnv.createMarker(startInput);
            var end;
            if (!start) {
                return; // TODO: warning if parsed bad
            }
            if (endInput != null) {
                end = dateEnv.createMarker(endInput);
                if (!end) { // TODO: warning if parsed bad
                    return;
                }
            }
            if (this._instance) {
                var instanceRange = this._instance.range;
                // when computing the diff for an event being converted to all-day,
                // compute diff off of the all-day values the way event-mutation does.
                if (options.allDay === true) {
                    instanceRange = computeAlignedDayRange(instanceRange);
                }
                var startDelta = diffDates(instanceRange.start, start, dateEnv, options.granularity);
                if (end) {
                    var endDelta = diffDates(instanceRange.end, end, dateEnv, options.granularity);
                    if (durationsEqual(startDelta, endDelta)) {
                        this.mutate({ datesDelta: startDelta, standardProps: standardProps });
                    }
                    else {
                        this.mutate({ startDelta: startDelta, endDelta: endDelta, standardProps: standardProps });
                    }
                }
                else { // means "clear the end"
                    standardProps.hasEnd = false;
                    this.mutate({ datesDelta: startDelta, standardProps: standardProps });
                }
            }
        };
        EventApi.prototype.moveStart = function (deltaInput) {
            var delta = createDuration(deltaInput);
            if (delta) { // TODO: warning if parsed bad
                this.mutate({ startDelta: delta });
            }
        };
        EventApi.prototype.moveEnd = function (deltaInput) {
            var delta = createDuration(deltaInput);
            if (delta) { // TODO: warning if parsed bad
                this.mutate({ endDelta: delta });
            }
        };
        EventApi.prototype.moveDates = function (deltaInput) {
            var delta = createDuration(deltaInput);
            if (delta) { // TODO: warning if parsed bad
                this.mutate({ datesDelta: delta });
            }
        };
        EventApi.prototype.setAllDay = function (allDay, options) {
            if (options === void 0) { options = {}; }
            var standardProps = { allDay: allDay };
            var maintainDuration = options.maintainDuration;
            if (maintainDuration == null) {
                maintainDuration = this._calendar.opt('allDayMaintainDuration');
            }
            if (this._def.allDay !== allDay) {
                standardProps.hasEnd = maintainDuration;
            }
            this.mutate({ standardProps: standardProps });
        };
        EventApi.prototype.formatRange = function (formatInput) {
            var dateEnv = this._calendar.dateEnv;
            var instance = this._instance;
            var formatter = createFormatter(formatInput, this._calendar.opt('defaultRangeSeparator'));
            if (this._def.hasEnd) {
                return dateEnv.formatRange(instance.range.start, instance.range.end, formatter, {
                    forcedStartTzo: instance.forcedStartTzo,
                    forcedEndTzo: instance.forcedEndTzo
                });
            }
            else {
                return dateEnv.format(instance.range.start, formatter, {
                    forcedTzo: instance.forcedStartTzo
                });
            }
        };
        EventApi.prototype.mutate = function (mutation) {
            var def = this._def;
            var instance = this._instance;
            if (instance) {
                this._calendar.dispatch({
                    type: 'MUTATE_EVENTS',
                    instanceId: instance.instanceId,
                    mutation: mutation,
                    fromApi: true
                });
                var eventStore = this._calendar.state.eventStore;
                this._def = eventStore.defs[def.defId];
                this._instance = eventStore.instances[instance.instanceId];
            }
        };
        EventApi.prototype.remove = function () {
            this._calendar.dispatch({
                type: 'REMOVE_EVENT_DEF',
                defId: this._def.defId
            });
        };
        Object.defineProperty(EventApi.prototype, "source", {
            get: function () {
                var sourceId = this._def.sourceId;
                if (sourceId) {
                    return new EventSourceApi(this._calendar, this._calendar.state.eventSources[sourceId]);
                }
                return null;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EventApi.prototype, "start", {
            get: function () {
                return this._instance ?
                    this._calendar.dateEnv.toDate(this._instance.range.start) :
                    null;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EventApi.prototype, "end", {
            get: function () {
                return (this._instance && this._def.hasEnd) ?
                    this._calendar.dateEnv.toDate(this._instance.range.end) :
                    null;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EventApi.prototype, "id", {
            // computable props that all access the def
            // TODO: find a TypeScript-compatible way to do this at scale
            get: function () { return this._def.publicId; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EventApi.prototype, "groupId", {
            get: function () { return this._def.groupId; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EventApi.prototype, "allDay", {
            get: function () { return this._def.allDay; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EventApi.prototype, "title", {
            get: function () { return this._def.title; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EventApi.prototype, "url", {
            get: function () { return this._def.url; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EventApi.prototype, "rendering", {
            get: function () { return this._def.rendering; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EventApi.prototype, "startEditable", {
            get: function () { return this._def.ui.startEditable; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EventApi.prototype, "durationEditable", {
            get: function () { return this._def.ui.durationEditable; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EventApi.prototype, "constraint", {
            get: function () { return this._def.ui.constraints[0] || null; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EventApi.prototype, "overlap", {
            get: function () { return this._def.ui.overlap; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EventApi.prototype, "allow", {
            get: function () { return this._def.ui.allows[0] || null; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EventApi.prototype, "backgroundColor", {
            get: function () { return this._def.ui.backgroundColor; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EventApi.prototype, "borderColor", {
            get: function () { return this._def.ui.borderColor; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EventApi.prototype, "textColor", {
            get: function () { return this._def.ui.textColor; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EventApi.prototype, "classNames", {
            // NOTE: user can't modify these because Object.freeze was called in event-def parsing
            get: function () { return this._def.ui.classNames; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EventApi.prototype, "extendedProps", {
            get: function () { return this._def.extendedProps; },
            enumerable: true,
            configurable: true
        });
        return EventApi;
    }());

    /*
    Specifying nextDayThreshold signals that all-day ranges should be sliced.
    */
    function sliceEventStore(eventStore, eventUiBases, framingRange, nextDayThreshold) {
        var inverseBgByGroupId = {};
        var inverseBgByDefId = {};
        var defByGroupId = {};
        var bgRanges = [];
        var fgRanges = [];
        var eventUis = compileEventUis(eventStore.defs, eventUiBases);
        for (var defId in eventStore.defs) {
            var def = eventStore.defs[defId];
            if (def.rendering === 'inverse-background') {
                if (def.groupId) {
                    inverseBgByGroupId[def.groupId] = [];
                    if (!defByGroupId[def.groupId]) {
                        defByGroupId[def.groupId] = def;
                    }
                }
                else {
                    inverseBgByDefId[defId] = [];
                }
            }
        }
        for (var instanceId in eventStore.instances) {
            var instance = eventStore.instances[instanceId];
            var def = eventStore.defs[instance.defId];
            var ui = eventUis[def.defId];
            var origRange = instance.range;
            var normalRange = (!def.allDay && nextDayThreshold) ?
                computeVisibleDayRange(origRange, nextDayThreshold) :
                origRange;
            var slicedRange = intersectRanges(normalRange, framingRange);
            if (slicedRange) {
                if (def.rendering === 'inverse-background') {
                    if (def.groupId) {
                        inverseBgByGroupId[def.groupId].push(slicedRange);
                    }
                    else {
                        inverseBgByDefId[instance.defId].push(slicedRange);
                    }
                }
                else {
                    (def.rendering === 'background' ? bgRanges : fgRanges).push({
                        def: def,
                        ui: ui,
                        instance: instance,
                        range: slicedRange,
                        isStart: normalRange.start && normalRange.start.valueOf() === slicedRange.start.valueOf(),
                        isEnd: normalRange.end && normalRange.end.valueOf() === slicedRange.end.valueOf()
                    });
                }
            }
        }
        for (var groupId in inverseBgByGroupId) { // BY GROUP
            var ranges = inverseBgByGroupId[groupId];
            var invertedRanges = invertRanges(ranges, framingRange);
            for (var _i = 0, invertedRanges_1 = invertedRanges; _i < invertedRanges_1.length; _i++) {
                var invertedRange = invertedRanges_1[_i];
                var def = defByGroupId[groupId];
                var ui = eventUis[def.defId];
                bgRanges.push({
                    def: def,
                    ui: ui,
                    instance: null,
                    range: invertedRange,
                    isStart: false,
                    isEnd: false
                });
            }
        }
        for (var defId in inverseBgByDefId) {
            var ranges = inverseBgByDefId[defId];
            var invertedRanges = invertRanges(ranges, framingRange);
            for (var _a = 0, invertedRanges_2 = invertedRanges; _a < invertedRanges_2.length; _a++) {
                var invertedRange = invertedRanges_2[_a];
                bgRanges.push({
                    def: eventStore.defs[defId],
                    ui: eventUis[defId],
                    instance: null,
                    range: invertedRange,
                    isStart: false,
                    isEnd: false
                });
            }
        }
        return { bg: bgRanges, fg: fgRanges };
    }
    function hasBgRendering(def) {
        return def.rendering === 'background' || def.rendering === 'inverse-background';
    }
    function filterSegsViaEls(view, segs, isMirror) {
        if (view.hasPublicHandlers('eventRender')) {
            segs = segs.filter(function (seg) {
                var custom = view.publiclyTrigger('eventRender', [
                    {
                        event: new EventApi(view.calendar, seg.eventRange.def, seg.eventRange.instance),
                        isMirror: isMirror,
                        isStart: seg.isStart,
                        isEnd: seg.isEnd,
                        // TODO: include seg.range once all components consistently generate it
                        el: seg.el,
                        view: view
                    }
                ]);
                if (custom === false) { // means don't render at all
                    return false;
                }
                else if (custom && custom !== true) {
                    seg.el = custom;
                }
                return true;
            });
        }
        for (var _i = 0, segs_1 = segs; _i < segs_1.length; _i++) {
            var seg = segs_1[_i];
            setElSeg(seg.el, seg);
        }
        return segs;
    }
    function setElSeg(el, seg) {
        el.fcSeg = seg;
    }
    function getElSeg(el) {
        return el.fcSeg || null;
    }
    // event ui computation
    function compileEventUis(eventDefs, eventUiBases) {
        return mapHash(eventDefs, function (eventDef) {
            return compileEventUi(eventDef, eventUiBases);
        });
    }
    function compileEventUi(eventDef, eventUiBases) {
        var uis = [];
        if (eventUiBases['']) {
            uis.push(eventUiBases['']);
        }
        if (eventUiBases[eventDef.defId]) {
            uis.push(eventUiBases[eventDef.defId]);
        }
        uis.push(eventDef.ui);
        return combineEventUis(uis);
    }

    // applies the mutation to ALL defs/instances within the event store
    function applyMutationToEventStore(eventStore, eventConfigBase, mutation, calendar) {
        var eventConfigs = compileEventUis(eventStore.defs, eventConfigBase);
        var dest = createEmptyEventStore();
        for (var defId in eventStore.defs) {
            var def = eventStore.defs[defId];
            dest.defs[defId] = applyMutationToEventDef(def, eventConfigs[defId], mutation, calendar.pluginSystem.hooks.eventDefMutationAppliers, calendar);
        }
        for (var instanceId in eventStore.instances) {
            var instance = eventStore.instances[instanceId];
            var def = dest.defs[instance.defId]; // important to grab the newly modified def
            dest.instances[instanceId] = applyMutationToEventInstance(instance, def, eventConfigs[instance.defId], mutation, calendar);
        }
        return dest;
    }
    function applyMutationToEventDef(eventDef, eventConfig, mutation, appliers, calendar) {
        var standardProps = mutation.standardProps || {};
        // if hasEnd has not been specified, guess a good value based on deltas.
        // if duration will change, there's no way the default duration will persist,
        // and thus, we need to mark the event as having a real end
        if (standardProps.hasEnd == null &&
            eventConfig.durationEditable &&
            (mutation.startDelta || mutation.endDelta)) {
            standardProps.hasEnd = true; // TODO: is this mutation okay?
        }
        var copy = __assign({}, eventDef, standardProps, { ui: __assign({}, eventDef.ui, standardProps.ui) });
        if (mutation.extendedProps) {
            copy.extendedProps = __assign({}, copy.extendedProps, mutation.extendedProps);
        }
        for (var _i = 0, appliers_1 = appliers; _i < appliers_1.length; _i++) {
            var applier = appliers_1[_i];
            applier(copy, mutation, calendar);
        }
        if (!copy.hasEnd && calendar.opt('forceEventDuration')) {
            copy.hasEnd = true;
        }
        return copy;
    }
    function applyMutationToEventInstance(eventInstance, eventDef, // must first be modified by applyMutationToEventDef
    eventConfig, mutation, calendar) {
        var dateEnv = calendar.dateEnv;
        var forceAllDay = mutation.standardProps && mutation.standardProps.allDay === true;
        var clearEnd = mutation.standardProps && mutation.standardProps.hasEnd === false;
        var copy = __assign({}, eventInstance);
        if (forceAllDay) {
            copy.range = computeAlignedDayRange(copy.range);
        }
        if (mutation.datesDelta && eventConfig.startEditable) {
            copy.range = {
                start: dateEnv.add(copy.range.start, mutation.datesDelta),
                end: dateEnv.add(copy.range.end, mutation.datesDelta)
            };
        }
        if (mutation.startDelta && eventConfig.durationEditable) {
            copy.range = {
                start: dateEnv.add(copy.range.start, mutation.startDelta),
                end: copy.range.end
            };
        }
        if (mutation.endDelta && eventConfig.durationEditable) {
            copy.range = {
                start: copy.range.start,
                end: dateEnv.add(copy.range.end, mutation.endDelta)
            };
        }
        if (clearEnd) {
            copy.range = {
                start: copy.range.start,
                end: calendar.getDefaultEventEnd(eventDef.allDay, copy.range.start)
            };
        }
        // in case event was all-day but the supplied deltas were not
        // better util for this?
        if (eventDef.allDay) {
            copy.range = {
                start: startOfDay(copy.range.start),
                end: startOfDay(copy.range.end)
            };
        }
        // handle invalid durations
        if (copy.range.end < copy.range.start) {
            copy.range.end = calendar.getDefaultEventEnd(eventDef.allDay, copy.range.start);
        }
        return copy;
    }

    function reduceEventStore (eventStore, action, eventSources, dateProfile, calendar) {
        switch (action.type) {
            case 'RECEIVE_EVENTS': // raw
                return receiveRawEvents(eventStore, eventSources[action.sourceId], action.fetchId, action.fetchRange, action.rawEvents, calendar);
            case 'ADD_EVENTS': // already parsed, but not expanded
                return addEvent(eventStore, action.eventStore, // new ones
                dateProfile ? dateProfile.activeRange : null, calendar);
            case 'MERGE_EVENTS': // already parsed and expanded
                return mergeEventStores(eventStore, action.eventStore);
            case 'PREV': // TODO: how do we track all actions that affect dateProfile :(
            case 'NEXT':
            case 'SET_DATE':
            case 'SET_VIEW_TYPE':
                if (dateProfile) {
                    return expandRecurring(eventStore, dateProfile.activeRange, calendar);
                }
                else {
                    return eventStore;
                }
            case 'CHANGE_TIMEZONE':
                return rezoneDates(eventStore, action.oldDateEnv, calendar.dateEnv);
            case 'MUTATE_EVENTS':
                return applyMutationToRelated(eventStore, action.instanceId, action.mutation, action.fromApi, calendar);
            case 'REMOVE_EVENT_INSTANCES':
                return excludeInstances(eventStore, action.instances);
            case 'REMOVE_EVENT_DEF':
                return filterEventStoreDefs(eventStore, function (eventDef) {
                    return eventDef.defId !== action.defId;
                });
            case 'REMOVE_EVENT_SOURCE':
                return excludeEventsBySourceId(eventStore, action.sourceId);
            case 'REMOVE_ALL_EVENT_SOURCES':
                return filterEventStoreDefs(eventStore, function (eventDef) {
                    return !eventDef.sourceId; // only keep events with no source id
                });
            case 'REMOVE_ALL_EVENTS':
                return createEmptyEventStore();
            case 'RESET_EVENTS':
                return {
                    defs: eventStore.defs,
                    instances: eventStore.instances
                };
            default:
                return eventStore;
        }
    }
    function receiveRawEvents(eventStore, eventSource, fetchId, fetchRange, rawEvents, calendar) {
        if (eventSource && // not already removed
            fetchId === eventSource.latestFetchId // TODO: wish this logic was always in event-sources
        ) {
            var subset = parseEvents(transformRawEvents(rawEvents, eventSource, calendar), eventSource.sourceId, calendar);
            if (fetchRange) {
                subset = expandRecurring(subset, fetchRange, calendar);
            }
            return mergeEventStores(excludeEventsBySourceId(eventStore, eventSource.sourceId), subset);
        }
        return eventStore;
    }
    function addEvent(eventStore, subset, expandRange, calendar) {
        if (expandRange) {
            subset = expandRecurring(subset, expandRange, calendar);
        }
        return mergeEventStores(eventStore, subset);
    }
    function rezoneDates(eventStore, oldDateEnv, newDateEnv) {
        var defs = eventStore.defs;
        var instances = mapHash(eventStore.instances, function (instance) {
            var def = defs[instance.defId];
            if (def.allDay || def.recurringDef) {
                return instance; // isn't dependent on timezone
            }
            else {
                return __assign({}, instance, { range: {
                        start: newDateEnv.createMarker(oldDateEnv.toDate(instance.range.start, instance.forcedStartTzo)),
                        end: newDateEnv.createMarker(oldDateEnv.toDate(instance.range.end, instance.forcedEndTzo))
                    }, forcedStartTzo: newDateEnv.canComputeOffset ? null : instance.forcedStartTzo, forcedEndTzo: newDateEnv.canComputeOffset ? null : instance.forcedEndTzo });
            }
        });
        return { defs: defs, instances: instances };
    }
    function applyMutationToRelated(eventStore, instanceId, mutation, fromApi, calendar) {
        var relevant = getRelevantEvents(eventStore, instanceId);
        var eventConfigBase = fromApi ?
            { '': {
                    startEditable: true,
                    durationEditable: true,
                    constraints: [],
                    overlap: null,
                    allows: [],
                    backgroundColor: '',
                    borderColor: '',
                    textColor: '',
                    classNames: []
                } } :
            calendar.eventUiBases;
        relevant = applyMutationToEventStore(relevant, eventConfigBase, mutation, calendar);
        return mergeEventStores(eventStore, relevant);
    }
    function excludeEventsBySourceId(eventStore, sourceId) {
        return filterEventStoreDefs(eventStore, function (eventDef) {
            return eventDef.sourceId !== sourceId;
        });
    }
    // QUESTION: why not just return instances? do a general object-property-exclusion util
    function excludeInstances(eventStore, removals) {
        return {
            defs: eventStore.defs,
            instances: filterHash(eventStore.instances, function (instance) {
                return !removals[instance.instanceId];
            })
        };
    }

    // high-level segmenting-aware tester functions
    // ------------------------------------------------------------------------------------------------------------------------
    function isInteractionValid(interaction, calendar) {
        return isNewPropsValid({ eventDrag: interaction }, calendar); // HACK: the eventDrag props is used for ALL interactions
    }
    function isDateSelectionValid(dateSelection, calendar) {
        return isNewPropsValid({ dateSelection: dateSelection }, calendar);
    }
    function isNewPropsValid(newProps, calendar) {
        var view = calendar.view;
        var props = __assign({ businessHours: view ? view.props.businessHours : createEmptyEventStore(), dateSelection: '', eventStore: calendar.state.eventStore, eventUiBases: calendar.eventUiBases, eventSelection: '', eventDrag: null, eventResize: null }, newProps);
        return (calendar.pluginSystem.hooks.isPropsValid || isPropsValid)(props, calendar);
    }
    function isPropsValid(state, calendar, dateSpanMeta, filterConfig) {
        if (dateSpanMeta === void 0) { dateSpanMeta = {}; }
        if (state.eventDrag && !isInteractionPropsValid(state, calendar, dateSpanMeta, filterConfig)) {
            return false;
        }
        if (state.dateSelection && !isDateSelectionPropsValid(state, calendar, dateSpanMeta, filterConfig)) {
            return false;
        }
        return true;
    }
    // Moving Event Validation
    // ------------------------------------------------------------------------------------------------------------------------
    function isInteractionPropsValid(state, calendar, dateSpanMeta, filterConfig) {
        var interaction = state.eventDrag; // HACK: the eventDrag props is used for ALL interactions
        var subjectEventStore = interaction.mutatedEvents;
        var subjectDefs = subjectEventStore.defs;
        var subjectInstances = subjectEventStore.instances;
        var subjectConfigs = compileEventUis(subjectDefs, interaction.isEvent ?
            state.eventUiBases :
            { '': calendar.selectionConfig } // if not a real event, validate as a selection
        );
        if (filterConfig) {
            subjectConfigs = mapHash(subjectConfigs, filterConfig);
        }
        var otherEventStore = excludeInstances(state.eventStore, interaction.affectedEvents.instances); // exclude the subject events. TODO: exclude defs too?
        var otherDefs = otherEventStore.defs;
        var otherInstances = otherEventStore.instances;
        var otherConfigs = compileEventUis(otherDefs, state.eventUiBases);
        for (var subjectInstanceId in subjectInstances) {
            var subjectInstance = subjectInstances[subjectInstanceId];
            var subjectRange = subjectInstance.range;
            var subjectConfig = subjectConfigs[subjectInstance.defId];
            var subjectDef = subjectDefs[subjectInstance.defId];
            // constraint
            if (!allConstraintsPass(subjectConfig.constraints, subjectRange, otherEventStore, state.businessHours, calendar)) {
                return false;
            }
            // overlap
            var overlapFunc = calendar.opt('eventOverlap');
            if (typeof overlapFunc !== 'function') {
                overlapFunc = null;
            }
            for (var otherInstanceId in otherInstances) {
                var otherInstance = otherInstances[otherInstanceId];
                // intersect! evaluate
                if (rangesIntersect(subjectRange, otherInstance.range)) {
                    var otherOverlap = otherConfigs[otherInstance.defId].overlap;
                    // consider the other event's overlap. only do this if the subject event is a "real" event
                    if (otherOverlap === false && interaction.isEvent) {
                        return false;
                    }
                    if (subjectConfig.overlap === false) {
                        return false;
                    }
                    if (overlapFunc && !overlapFunc(new EventApi(calendar, otherDefs[otherInstance.defId], otherInstance), // still event
                    new EventApi(calendar, subjectDef, subjectInstance) // moving event
                    )) {
                        return false;
                    }
                }
            }
            // allow (a function)
            var calendarEventStore = calendar.state.eventStore; // need global-to-calendar, not local to component (splittable)state
            for (var _i = 0, _a = subjectConfig.allows; _i < _a.length; _i++) {
                var subjectAllow = _a[_i];
                var subjectDateSpan = __assign({}, dateSpanMeta, { range: subjectInstance.range, allDay: subjectDef.allDay });
                var origDef = calendarEventStore.defs[subjectDef.defId];
                var origInstance = calendarEventStore.instances[subjectInstanceId];
                var eventApi = void 0;
                if (origDef) { // was previously in the calendar
                    eventApi = new EventApi(calendar, origDef, origInstance);
                }
                else { // was an external event
                    eventApi = new EventApi(calendar, subjectDef); // no instance, because had no dates
                }
                if (!subjectAllow(calendar.buildDateSpanApi(subjectDateSpan), eventApi)) {
                    return false;
                }
            }
        }
        return true;
    }
    // Date Selection Validation
    // ------------------------------------------------------------------------------------------------------------------------
    function isDateSelectionPropsValid(state, calendar, dateSpanMeta, filterConfig) {
        var relevantEventStore = state.eventStore;
        var relevantDefs = relevantEventStore.defs;
        var relevantInstances = relevantEventStore.instances;
        var selection = state.dateSelection;
        var selectionRange = selection.range;
        var selectionConfig = calendar.selectionConfig;
        if (filterConfig) {
            selectionConfig = filterConfig(selectionConfig);
        }
        // constraint
        if (!allConstraintsPass(selectionConfig.constraints, selectionRange, relevantEventStore, state.businessHours, calendar)) {
            return false;
        }
        // overlap
        var overlapFunc = calendar.opt('selectOverlap');
        if (typeof overlapFunc !== 'function') {
            overlapFunc = null;
        }
        for (var relevantInstanceId in relevantInstances) {
            var relevantInstance = relevantInstances[relevantInstanceId];
            // intersect! evaluate
            if (rangesIntersect(selectionRange, relevantInstance.range)) {
                if (selectionConfig.overlap === false) {
                    return false;
                }
                if (overlapFunc && !overlapFunc(new EventApi(calendar, relevantDefs[relevantInstance.defId], relevantInstance))) {
                    return false;
                }
            }
        }
        // allow (a function)
        for (var _i = 0, _a = selectionConfig.allows; _i < _a.length; _i++) {
            var selectionAllow = _a[_i];
            var fullDateSpan = __assign({}, dateSpanMeta, selection);
            if (!selectionAllow(calendar.buildDateSpanApi(fullDateSpan), null)) {
                return false;
            }
        }
        return true;
    }
    // Constraint Utils
    // ------------------------------------------------------------------------------------------------------------------------
    function allConstraintsPass(constraints, subjectRange, otherEventStore, businessHoursUnexpanded, calendar) {
        for (var _i = 0, constraints_1 = constraints; _i < constraints_1.length; _i++) {
            var constraint = constraints_1[_i];
            if (!anyRangesContainRange(constraintToRanges(constraint, subjectRange, otherEventStore, businessHoursUnexpanded, calendar), subjectRange)) {
                return false;
            }
        }
        return true;
    }
    function constraintToRanges(constraint, subjectRange, // for expanding a recurring constraint, or expanding business hours
    otherEventStore, // for if constraint is an even group ID
    businessHoursUnexpanded, // for if constraint is 'businessHours'
    calendar // for expanding businesshours
    ) {
        if (constraint === 'businessHours') {
            return eventStoreToRanges(expandRecurring(businessHoursUnexpanded, subjectRange, calendar));
        }
        else if (typeof constraint === 'string') { // an group ID
            return eventStoreToRanges(filterEventStoreDefs(otherEventStore, function (eventDef) {
                return eventDef.groupId === constraint;
            }));
        }
        else if (typeof constraint === 'object' && constraint) { // non-null object
            return eventStoreToRanges(expandRecurring(constraint, subjectRange, calendar));
        }
        return []; // if it's false
    }
    // TODO: move to event-store file?
    function eventStoreToRanges(eventStore) {
        var instances = eventStore.instances;
        var ranges = [];
        for (var instanceId in instances) {
            ranges.push(instances[instanceId].range);
        }
        return ranges;
    }
    // TODO: move to geom file?
    function anyRangesContainRange(outerRanges, innerRange) {
        for (var _i = 0, outerRanges_1 = outerRanges; _i < outerRanges_1.length; _i++) {
            var outerRange = outerRanges_1[_i];
            if (rangeContainsRange(outerRange, innerRange)) {
                return true;
            }
        }
        return false;
    }
    // Parsing
    // ------------------------------------------------------------------------------------------------------------------------
    function normalizeConstraint(input, calendar) {
        if (Array.isArray(input)) {
            return parseEvents(input, '', calendar, true); // allowOpenRange=true
        }
        else if (typeof input === 'object' && input) { // non-null object
            return parseEvents([input], '', calendar, true); // allowOpenRange=true
        }
        else if (input != null) {
            return String(input);
        }
        else {
            return null;
        }
    }

    function htmlEscape(s) {
        return (s + '').replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .replace(/'/g, '&#039;')
            .replace(/"/g, '&quot;')
            .replace(/\n/g, '<br />');
    }
    // Given a hash of CSS properties, returns a string of CSS.
    // Uses property names as-is (no camel-case conversion). Will not make statements for null/undefined values.
    function cssToStr(cssProps) {
        var statements = [];
        for (var name_1 in cssProps) {
            var val = cssProps[name_1];
            if (val != null && val !== '') {
                statements.push(name_1 + ':' + val);
            }
        }
        return statements.join(';');
    }
    // Given an object hash of HTML attribute names to values,
    // generates a string that can be injected between < > in HTML
    function attrsToStr(attrs) {
        var parts = [];
        for (var name_2 in attrs) {
            var val = attrs[name_2];
            if (val != null) {
                parts.push(name_2 + '="' + htmlEscape(val) + '"');
            }
        }
        return parts.join(' ');
    }
    function parseClassName(raw) {
        if (Array.isArray(raw)) {
            return raw;
        }
        else if (typeof raw === 'string') {
            return raw.split(/\s+/);
        }
        else {
            return [];
        }
    }

    var UNSCOPED_EVENT_UI_PROPS = {
        editable: Boolean,
        startEditable: Boolean,
        durationEditable: Boolean,
        constraint: null,
        overlap: null,
        allow: null,
        className: parseClassName,
        classNames: parseClassName,
        color: String,
        backgroundColor: String,
        borderColor: String,
        textColor: String
    };
    function processUnscopedUiProps(rawProps, calendar, leftovers) {
        var props = refineProps(rawProps, UNSCOPED_EVENT_UI_PROPS, {}, leftovers);
        var constraint = normalizeConstraint(props.constraint, calendar);
        return {
            startEditable: props.startEditable != null ? props.startEditable : props.editable,
            durationEditable: props.durationEditable != null ? props.durationEditable : props.editable,
            constraints: constraint != null ? [constraint] : [],
            overlap: props.overlap,
            allows: props.allow != null ? [props.allow] : [],
            backgroundColor: props.backgroundColor || props.color,
            borderColor: props.borderColor || props.color,
            textColor: props.textColor,
            classNames: props.classNames.concat(props.className)
        };
    }
    function processScopedUiProps(prefix, rawScoped, calendar, leftovers) {
        var rawUnscoped = {};
        var wasFound = {};
        for (var key in UNSCOPED_EVENT_UI_PROPS) {
            var scopedKey = prefix + capitaliseFirstLetter(key);
            rawUnscoped[key] = rawScoped[scopedKey];
            wasFound[scopedKey] = true;
        }
        if (prefix === 'event') {
            rawUnscoped.editable = rawScoped.editable; // special case. there is no 'eventEditable', just 'editable'
        }
        if (leftovers) {
            for (var key in rawScoped) {
                if (!wasFound[key]) {
                    leftovers[key] = rawScoped[key];
                }
            }
        }
        return processUnscopedUiProps(rawUnscoped, calendar);
    }
    var EMPTY_EVENT_UI = {
        startEditable: null,
        durationEditable: null,
        constraints: [],
        overlap: null,
        allows: [],
        backgroundColor: '',
        borderColor: '',
        textColor: '',
        classNames: []
    };
    // prevent against problems with <2 args!
    function combineEventUis(uis) {
        return uis.reduce(combineTwoEventUis, EMPTY_EVENT_UI);
    }
    function combineTwoEventUis(item0, item1) {
        return {
            startEditable: item1.startEditable != null ? item1.startEditable : item0.startEditable,
            durationEditable: item1.durationEditable != null ? item1.durationEditable : item0.durationEditable,
            constraints: item0.constraints.concat(item1.constraints),
            overlap: typeof item1.overlap === 'boolean' ? item1.overlap : item0.overlap,
            allows: item0.allows.concat(item1.allows),
            backgroundColor: item1.backgroundColor || item0.backgroundColor,
            borderColor: item1.borderColor || item0.borderColor,
            textColor: item1.textColor || item0.textColor,
            classNames: item0.classNames.concat(item1.classNames)
        };
    }

    var NON_DATE_PROPS = {
        id: String,
        groupId: String,
        title: String,
        url: String,
        rendering: String,
        extendedProps: null
    };
    var DATE_PROPS = {
        start: null,
        date: null,
        end: null,
        allDay: null
    };
    var uid = 0;
    function parseEvent(raw, sourceId, calendar, allowOpenRange) {
        var allDayDefault = computeIsAllDayDefault(sourceId, calendar);
        var leftovers0 = {};
        var recurringRes = parseRecurring(raw, // raw, but with single-event stuff stripped out
        allDayDefault, calendar.dateEnv, calendar.pluginSystem.hooks.recurringTypes, leftovers0 // will populate with non-recurring props
        );
        if (recurringRes) {
            var def = parseEventDef(leftovers0, sourceId, recurringRes.allDay, Boolean(recurringRes.duration), calendar);
            def.recurringDef = {
                typeId: recurringRes.typeId,
                typeData: recurringRes.typeData,
                duration: recurringRes.duration
            };
            return { def: def, instance: null };
        }
        else {
            var leftovers1 = {};
            var singleRes = parseSingle(raw, allDayDefault, calendar, leftovers1, allowOpenRange);
            if (singleRes) {
                var def = parseEventDef(leftovers1, sourceId, singleRes.allDay, singleRes.hasEnd, calendar);
                var instance = createEventInstance(def.defId, singleRes.range, singleRes.forcedStartTzo, singleRes.forcedEndTzo);
                return { def: def, instance: instance };
            }
        }
        return null;
    }
    /*
    Will NOT populate extendedProps with the leftover properties.
    Will NOT populate date-related props.
    The EventNonDateInput has been normalized (id => publicId, etc).
    */
    function parseEventDef(raw, sourceId, allDay, hasEnd, calendar) {
        var leftovers = {};
        var def = pluckNonDateProps(raw, calendar, leftovers);
        def.defId = String(uid++);
        def.sourceId = sourceId;
        def.allDay = allDay;
        def.hasEnd = hasEnd;
        for (var _i = 0, _a = calendar.pluginSystem.hooks.eventDefParsers; _i < _a.length; _i++) {
            var eventDefParser = _a[_i];
            var newLeftovers = {};
            eventDefParser(def, leftovers, newLeftovers);
            leftovers = newLeftovers;
        }
        def.extendedProps = __assign(leftovers, def.extendedProps || {});
        // help out EventApi from having user modify props
        Object.freeze(def.ui.classNames);
        Object.freeze(def.extendedProps);
        return def;
    }
    function createEventInstance(defId, range, forcedStartTzo, forcedEndTzo) {
        return {
            instanceId: String(uid++),
            defId: defId,
            range: range,
            forcedStartTzo: forcedStartTzo == null ? null : forcedStartTzo,
            forcedEndTzo: forcedEndTzo == null ? null : forcedEndTzo
        };
    }
    function parseSingle(raw, allDayDefault, calendar, leftovers, allowOpenRange) {
        var props = pluckDateProps(raw, leftovers);
        var allDay = props.allDay;
        var startMeta;
        var startMarker = null;
        var hasEnd = false;
        var endMeta;
        var endMarker = null;
        startMeta = calendar.dateEnv.createMarkerMeta(props.start);
        if (startMeta) {
            startMarker = startMeta.marker;
        }
        else if (!allowOpenRange) {
            return null;
        }
        if (props.end != null) {
            endMeta = calendar.dateEnv.createMarkerMeta(props.end);
        }
        if (allDay == null) {
            if (allDayDefault != null) {
                allDay = allDayDefault;
            }
            else {
                // fall back to the date props LAST
                allDay = (!startMeta || startMeta.isTimeUnspecified) &&
                    (!endMeta || endMeta.isTimeUnspecified);
            }
        }
        if (allDay && startMarker) {
            startMarker = startOfDay(startMarker);
        }
        if (endMeta) {
            endMarker = endMeta.marker;
            if (allDay) {
                endMarker = startOfDay(endMarker);
            }
            if (startMarker && endMarker <= startMarker) {
                endMarker = null;
            }
        }
        if (endMarker) {
            hasEnd = true;
        }
        else if (!allowOpenRange) {
            hasEnd = calendar.opt('forceEventDuration') || false;
            endMarker = calendar.dateEnv.add(startMarker, allDay ?
                calendar.defaultAllDayEventDuration :
                calendar.defaultTimedEventDuration);
        }
        return {
            allDay: allDay,
            hasEnd: hasEnd,
            range: { start: startMarker, end: endMarker },
            forcedStartTzo: startMeta ? startMeta.forcedTzo : null,
            forcedEndTzo: endMeta ? endMeta.forcedTzo : null
        };
    }
    function pluckDateProps(raw, leftovers) {
        var props = refineProps(raw, DATE_PROPS, {}, leftovers);
        props.start = (props.start !== null) ? props.start : props.date;
        delete props.date;
        return props;
    }
    function pluckNonDateProps(raw, calendar, leftovers) {
        var preLeftovers = {};
        var props = refineProps(raw, NON_DATE_PROPS, {}, preLeftovers);
        var ui = processUnscopedUiProps(preLeftovers, calendar, leftovers);
        props.publicId = props.id;
        delete props.id;
        props.ui = ui;
        return props;
    }
    function computeIsAllDayDefault(sourceId, calendar) {
        var res = null;
        if (sourceId) {
            var source = calendar.state.eventSources[sourceId];
            res = source.allDayDefault;
        }
        if (res == null) {
            res = calendar.opt('allDayDefault');
        }
        return res;
    }

    var DEF_DEFAULTS = {
        startTime: '09:00',
        endTime: '17:00',
        daysOfWeek: [1, 2, 3, 4, 5],
        rendering: 'inverse-background',
        classNames: 'fc-nonbusiness',
        groupId: '_businessHours' // so multiple defs get grouped
    };
    /*
    TODO: pass around as EventDefHash!!!
    */
    function parseBusinessHours(input, calendar) {
        return parseEvents(refineInputs(input), '', calendar);
    }
    function refineInputs(input) {
        var rawDefs;
        if (input === true) {
            rawDefs = [{}]; // will get DEF_DEFAULTS verbatim
        }
        else if (Array.isArray(input)) {
            // if specifying an array, every sub-definition NEEDS a day-of-week
            rawDefs = input.filter(function (rawDef) {
                return rawDef.daysOfWeek;
            });
        }
        else if (typeof input === 'object' && input) { // non-null object
            rawDefs = [input];
        }
        else { // is probably false
            rawDefs = [];
        }
        rawDefs = rawDefs.map(function (rawDef) {
            return __assign({}, DEF_DEFAULTS, rawDef);
        });
        return rawDefs;
    }

    function memoizeRendering(renderFunc, unrenderFunc, dependencies) {
        if (dependencies === void 0) { dependencies = []; }
        var dependents = [];
        var thisContext;
        var prevArgs;
        function unrender() {
            if (prevArgs) {
                for (var _i = 0, dependents_1 = dependents; _i < dependents_1.length; _i++) {
                    var dependent = dependents_1[_i];
                    dependent.unrender();
                }
                if (unrenderFunc) {
                    unrenderFunc.apply(thisContext, prevArgs);
                }
                prevArgs = null;
            }
        }
        function res() {
            if (!prevArgs || !isArraysEqual(prevArgs, arguments)) {
                unrender();
                thisContext = this;
                prevArgs = arguments;
                renderFunc.apply(this, arguments);
            }
        }
        res.dependents = dependents;
        res.unrender = unrender;
        for (var _i = 0, dependencies_1 = dependencies; _i < dependencies_1.length; _i++) {
            var dependency = dependencies_1[_i];
            dependency.dependents.push(res);
        }
        return res;
    }

    var EMPTY_EVENT_STORE = createEmptyEventStore(); // for purecomponents. TODO: keep elsewhere
    var Splitter = /** @class */ (function () {
        function Splitter() {
            this.getKeysForEventDefs = memoize(this._getKeysForEventDefs);
            this.splitDateSelection = memoize(this._splitDateSpan);
            this.splitEventStore = memoize(this._splitEventStore);
            this.splitIndividualUi = memoize(this._splitIndividualUi);
            this.splitEventDrag = memoize(this._splitInteraction);
            this.splitEventResize = memoize(this._splitInteraction);
            this.eventUiBuilders = {}; // TODO: typescript protection
        }
        Splitter.prototype.splitProps = function (props) {
            var _this = this;
            var keyInfos = this.getKeyInfo(props);
            var defKeys = this.getKeysForEventDefs(props.eventStore);
            var dateSelections = this.splitDateSelection(props.dateSelection);
            var individualUi = this.splitIndividualUi(props.eventUiBases, defKeys); // the individual *bases*
            var eventStores = this.splitEventStore(props.eventStore, defKeys);
            var eventDrags = this.splitEventDrag(props.eventDrag);
            var eventResizes = this.splitEventResize(props.eventResize);
            var splitProps = {};
            this.eventUiBuilders = mapHash(keyInfos, function (info, key) {
                return _this.eventUiBuilders[key] || memoize(buildEventUiForKey);
            });
            for (var key in keyInfos) {
                var keyInfo = keyInfos[key];
                var eventStore = eventStores[key] || EMPTY_EVENT_STORE;
                var buildEventUi = this.eventUiBuilders[key];
                splitProps[key] = {
                    businessHours: keyInfo.businessHours || props.businessHours,
                    dateSelection: dateSelections[key] || null,
                    eventStore: eventStore,
                    eventUiBases: buildEventUi(props.eventUiBases[''], keyInfo.ui, individualUi[key]),
                    eventSelection: eventStore.instances[props.eventSelection] ? props.eventSelection : '',
                    eventDrag: eventDrags[key] || null,
                    eventResize: eventResizes[key] || null
                };
            }
            return splitProps;
        };
        Splitter.prototype._splitDateSpan = function (dateSpan) {
            var dateSpans = {};
            if (dateSpan) {
                var keys = this.getKeysForDateSpan(dateSpan);
                for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
                    var key = keys_1[_i];
                    dateSpans[key] = dateSpan;
                }
            }
            return dateSpans;
        };
        Splitter.prototype._getKeysForEventDefs = function (eventStore) {
            var _this = this;
            return mapHash(eventStore.defs, function (eventDef) {
                return _this.getKeysForEventDef(eventDef);
            });
        };
        Splitter.prototype._splitEventStore = function (eventStore, defKeys) {
            var defs = eventStore.defs, instances = eventStore.instances;
            var splitStores = {};
            for (var defId in defs) {
                for (var _i = 0, _a = defKeys[defId]; _i < _a.length; _i++) {
                    var key = _a[_i];
                    if (!splitStores[key]) {
                        splitStores[key] = createEmptyEventStore();
                    }
                    splitStores[key].defs[defId] = defs[defId];
                }
            }
            for (var instanceId in instances) {
                var instance = instances[instanceId];
                for (var _b = 0, _c = defKeys[instance.defId]; _b < _c.length; _b++) {
                    var key = _c[_b];
                    if (splitStores[key]) { // must have already been created
                        splitStores[key].instances[instanceId] = instance;
                    }
                }
            }
            return splitStores;
        };
        Splitter.prototype._splitIndividualUi = function (eventUiBases, defKeys) {
            var splitHashes = {};
            for (var defId in eventUiBases) {
                if (defId) { // not the '' key
                    for (var _i = 0, _a = defKeys[defId]; _i < _a.length; _i++) {
                        var key = _a[_i];
                        if (!splitHashes[key]) {
                            splitHashes[key] = {};
                        }
                        splitHashes[key][defId] = eventUiBases[defId];
                    }
                }
            }
            return splitHashes;
        };
        Splitter.prototype._splitInteraction = function (interaction) {
            var splitStates = {};
            if (interaction) {
                var affectedStores_1 = this._splitEventStore(interaction.affectedEvents, this._getKeysForEventDefs(interaction.affectedEvents) // can't use cached. might be events from other calendar
                );
                // can't rely on defKeys because event data is mutated
                var mutatedKeysByDefId = this._getKeysForEventDefs(interaction.mutatedEvents);
                var mutatedStores_1 = this._splitEventStore(interaction.mutatedEvents, mutatedKeysByDefId);
                var populate = function (key) {
                    if (!splitStates[key]) {
                        splitStates[key] = {
                            affectedEvents: affectedStores_1[key] || EMPTY_EVENT_STORE,
                            mutatedEvents: mutatedStores_1[key] || EMPTY_EVENT_STORE,
                            isEvent: interaction.isEvent,
                            origSeg: interaction.origSeg
                        };
                    }
                };
                for (var key in affectedStores_1) {
                    populate(key);
                }
                for (var key in mutatedStores_1) {
                    populate(key);
                }
            }
            return splitStates;
        };
        return Splitter;
    }());
    function buildEventUiForKey(allUi, eventUiForKey, individualUi) {
        var baseParts = [];
        if (allUi) {
            baseParts.push(allUi);
        }
        if (eventUiForKey) {
            baseParts.push(eventUiForKey);
        }
        var stuff = {
            '': combineEventUis(baseParts)
        };
        if (individualUi) {
            __assign(stuff, individualUi);
        }
        return stuff;
    }

    // Generates HTML for an anchor to another view into the calendar.
    // Will either generate an <a> tag or a non-clickable <span> tag, depending on enabled settings.
    // `gotoOptions` can either be a DateMarker, or an object with the form:
    // { date, type, forceOff }
    // `type` is a view-type like "day" or "week". default value is "day".
    // `attrs` and `innerHtml` are use to generate the rest of the HTML tag.
    function buildGotoAnchorHtml(component, gotoOptions, attrs, innerHtml) {
        var dateEnv = component.dateEnv;
        var date;
        var type;
        var forceOff;
        var finalOptions;
        if (gotoOptions instanceof Date) {
            date = gotoOptions; // a single date-like input
        }
        else {
            date = gotoOptions.date;
            type = gotoOptions.type;
            forceOff = gotoOptions.forceOff;
        }
        finalOptions = {
            date: dateEnv.formatIso(date, { omitTime: true }),
            type: type || 'day'
        };
        if (typeof attrs === 'string') {
            innerHtml = attrs;
            attrs = null;
        }
        attrs = attrs ? ' ' + attrsToStr(attrs) : ''; // will have a leading space
        innerHtml = innerHtml || '';
        if (!forceOff && component.opt('navLinks')) {
            return '<a' + attrs +
                ' data-goto="' + htmlEscape(JSON.stringify(finalOptions)) + '">' +
                innerHtml +
                '</a>';
        }
        else {
            return '<span' + attrs + '>' +
                innerHtml +
                '</span>';
        }
    }
    function getAllDayHtml(component) {
        return component.opt('allDayHtml') || htmlEscape(component.opt('allDayText'));
    }
    // Computes HTML classNames for a single-day element
    function getDayClasses(date, dateProfile, context, noThemeHighlight) {
        var calendar = context.calendar, view = context.view, theme = context.theme, dateEnv = context.dateEnv;
        var classes = [];
        var todayStart;
        var todayEnd;
        if (!rangeContainsMarker(dateProfile.activeRange, date)) {
            classes.push('fc-disabled-day');
        }
        else {
            classes.push('fc-' + DAY_IDS[date.getUTCDay()]);
            if (view.opt('monthMode') &&
                dateEnv.getMonth(date) !== dateEnv.getMonth(dateProfile.currentRange.start)) {
                classes.push('fc-other-month');
            }
            todayStart = startOfDay(calendar.getNow());
            todayEnd = addDays(todayStart, 1);
            if (date < todayStart) {
                classes.push('fc-past');
            }
            else if (date >= todayEnd) {
                classes.push('fc-future');
            }
            else {
                classes.push('fc-today');
                if (noThemeHighlight !== true) {
                    classes.push(theme.getClass('today'));
                }
            }
        }
        return classes;
    }

    // given a function that resolves a result asynchronously.
    // the function can either call passed-in success and failure callbacks,
    // or it can return a promise.
    // if you need to pass additional params to func, bind them first.
    function unpromisify(func, success, failure) {
        // guard against success/failure callbacks being called more than once
        // and guard against a promise AND callback being used together.
        var isResolved = false;
        var wrappedSuccess = function () {
            if (!isResolved) {
                isResolved = true;
                success.apply(this, arguments);
            }
        };
        var wrappedFailure = function () {
            if (!isResolved) {
                isResolved = true;
                if (failure) {
                    failure.apply(this, arguments);
                }
            }
        };
        var res = func(wrappedSuccess, wrappedFailure);
        if (res && typeof res.then === 'function') {
            res.then(wrappedSuccess, wrappedFailure);
        }
    }

    var Mixin = /** @class */ (function () {
        function Mixin() {
        }
        // mix into a CLASS
        Mixin.mixInto = function (destClass) {
            this.mixIntoObj(destClass.prototype);
        };
        // mix into ANY object
        Mixin.mixIntoObj = function (destObj) {
            var _this = this;
            Object.getOwnPropertyNames(this.prototype).forEach(function (name) {
                if (!destObj[name]) { // if destination doesn't already define it
                    destObj[name] = _this.prototype[name];
                }
            });
        };
        /*
        will override existing methods
        TODO: remove! not used anymore
        */
        Mixin.mixOver = function (destClass) {
            var _this = this;
            Object.getOwnPropertyNames(this.prototype).forEach(function (name) {
                destClass.prototype[name] = _this.prototype[name];
            });
        };
        return Mixin;
    }());

    /*
    USAGE:
      import { default as EmitterMixin, EmitterInterface } from './EmitterMixin'
    in class:
      on: EmitterInterface['on']
      one: EmitterInterface['one']
      off: EmitterInterface['off']
      trigger: EmitterInterface['trigger']
      triggerWith: EmitterInterface['triggerWith']
      hasHandlers: EmitterInterface['hasHandlers']
    after class:
      EmitterMixin.mixInto(TheClass)
    */
    var EmitterMixin = /** @class */ (function (_super) {
        __extends(EmitterMixin, _super);
        function EmitterMixin() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        EmitterMixin.prototype.on = function (type, handler) {
            addToHash(this._handlers || (this._handlers = {}), type, handler);
            return this; // for chaining
        };
        // todo: add comments
        EmitterMixin.prototype.one = function (type, handler) {
            addToHash(this._oneHandlers || (this._oneHandlers = {}), type, handler);
            return this; // for chaining
        };
        EmitterMixin.prototype.off = function (type, handler) {
            if (this._handlers) {
                removeFromHash(this._handlers, type, handler);
            }
            if (this._oneHandlers) {
                removeFromHash(this._oneHandlers, type, handler);
            }
            return this; // for chaining
        };
        EmitterMixin.prototype.trigger = function (type) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            this.triggerWith(type, this, args);
            return this; // for chaining
        };
        EmitterMixin.prototype.triggerWith = function (type, context, args) {
            if (this._handlers) {
                applyAll(this._handlers[type], context, args);
            }
            if (this._oneHandlers) {
                applyAll(this._oneHandlers[type], context, args);
                delete this._oneHandlers[type]; // will never fire again
            }
            return this; // for chaining
        };
        EmitterMixin.prototype.hasHandlers = function (type) {
            return (this._handlers && this._handlers[type] && this._handlers[type].length) ||
                (this._oneHandlers && this._oneHandlers[type] && this._oneHandlers[type].length);
        };
        return EmitterMixin;
    }(Mixin));
    function addToHash(hash, type, handler) {
        (hash[type] || (hash[type] = []))
            .push(handler);
    }
    function removeFromHash(hash, type, handler) {
        if (handler) {
            if (hash[type]) {
                hash[type] = hash[type].filter(function (func) {
                    return func !== handler;
                });
            }
        }
        else {
            delete hash[type]; // remove all handler funcs for this type
        }
    }

    /*
    Records offset information for a set of elements, relative to an origin element.
    Can record the left/right OR the top/bottom OR both.
    Provides methods for querying the cache by position.
    */
    var PositionCache = /** @class */ (function () {
        function PositionCache(originEl, els, isHorizontal, isVertical) {
            this.originEl = originEl;
            this.els = els;
            this.isHorizontal = isHorizontal;
            this.isVertical = isVertical;
        }
        // Queries the els for coordinates and stores them.
        // Call this method before using and of the get* methods below.
        PositionCache.prototype.build = function () {
            var originEl = this.originEl;
            var originClientRect = this.originClientRect =
                originEl.getBoundingClientRect(); // relative to viewport top-left
            if (this.isHorizontal) {
                this.buildElHorizontals(originClientRect.left);
            }
            if (this.isVertical) {
                this.buildElVerticals(originClientRect.top);
            }
        };
        // Populates the left/right internal coordinate arrays
        PositionCache.prototype.buildElHorizontals = function (originClientLeft) {
            var lefts = [];
            var rights = [];
            for (var _i = 0, _a = this.els; _i < _a.length; _i++) {
                var el = _a[_i];
                var rect = el.getBoundingClientRect();
                lefts.push(rect.left - originClientLeft);
                rights.push(rect.right - originClientLeft);
            }
            this.lefts = lefts;
            this.rights = rights;
        };
        // Populates the top/bottom internal coordinate arrays
        PositionCache.prototype.buildElVerticals = function (originClientTop) {
            var tops = [];
            var bottoms = [];
            for (var _i = 0, _a = this.els; _i < _a.length; _i++) {
                var el = _a[_i];
                var rect = el.getBoundingClientRect();
                tops.push(rect.top - originClientTop);
                bottoms.push(rect.bottom - originClientTop);
            }
            this.tops = tops;
            this.bottoms = bottoms;
        };
        // Given a left offset (from document left), returns the index of the el that it horizontally intersects.
        // If no intersection is made, returns undefined.
        PositionCache.prototype.leftToIndex = function (leftPosition) {
            var lefts = this.lefts;
            var rights = this.rights;
            var len = lefts.length;
            var i;
            for (i = 0; i < len; i++) {
                if (leftPosition >= lefts[i] && leftPosition < rights[i]) {
                    return i;
                }
            }
        };
        // Given a top offset (from document top), returns the index of the el that it vertically intersects.
        // If no intersection is made, returns undefined.
        PositionCache.prototype.topToIndex = function (topPosition) {
            var tops = this.tops;
            var bottoms = this.bottoms;
            var len = tops.length;
            var i;
            for (i = 0; i < len; i++) {
                if (topPosition >= tops[i] && topPosition < bottoms[i]) {
                    return i;
                }
            }
        };
        // Gets the width of the element at the given index
        PositionCache.prototype.getWidth = function (leftIndex) {
            return this.rights[leftIndex] - this.lefts[leftIndex];
        };
        // Gets the height of the element at the given index
        PositionCache.prototype.getHeight = function (topIndex) {
            return this.bottoms[topIndex] - this.tops[topIndex];
        };
        return PositionCache;
    }());

    /*
    An object for getting/setting scroll-related information for an element.
    Internally, this is done very differently for window versus DOM element,
    so this object serves as a common interface.
    */
    var ScrollController = /** @class */ (function () {
        function ScrollController() {
        }
        ScrollController.prototype.getMaxScrollTop = function () {
            return this.getScrollHeight() - this.getClientHeight();
        };
        ScrollController.prototype.getMaxScrollLeft = function () {
            return this.getScrollWidth() - this.getClientWidth();
        };
        ScrollController.prototype.canScrollVertically = function () {
            return this.getMaxScrollTop() > 0;
        };
        ScrollController.prototype.canScrollHorizontally = function () {
            return this.getMaxScrollLeft() > 0;
        };
        ScrollController.prototype.canScrollUp = function () {
            return this.getScrollTop() > 0;
        };
        ScrollController.prototype.canScrollDown = function () {
            return this.getScrollTop() < this.getMaxScrollTop();
        };
        ScrollController.prototype.canScrollLeft = function () {
            return this.getScrollLeft() > 0;
        };
        ScrollController.prototype.canScrollRight = function () {
            return this.getScrollLeft() < this.getMaxScrollLeft();
        };
        return ScrollController;
    }());
    var ElementScrollController = /** @class */ (function (_super) {
        __extends(ElementScrollController, _super);
        function ElementScrollController(el) {
            var _this = _super.call(this) || this;
            _this.el = el;
            return _this;
        }
        ElementScrollController.prototype.getScrollTop = function () {
            return this.el.scrollTop;
        };
        ElementScrollController.prototype.getScrollLeft = function () {
            return this.el.scrollLeft;
        };
        ElementScrollController.prototype.setScrollTop = function (top) {
            this.el.scrollTop = top;
        };
        ElementScrollController.prototype.setScrollLeft = function (left) {
            this.el.scrollLeft = left;
        };
        ElementScrollController.prototype.getScrollWidth = function () {
            return this.el.scrollWidth;
        };
        ElementScrollController.prototype.getScrollHeight = function () {
            return this.el.scrollHeight;
        };
        ElementScrollController.prototype.getClientHeight = function () {
            return this.el.clientHeight;
        };
        ElementScrollController.prototype.getClientWidth = function () {
            return this.el.clientWidth;
        };
        return ElementScrollController;
    }(ScrollController));
    var WindowScrollController = /** @class */ (function (_super) {
        __extends(WindowScrollController, _super);
        function WindowScrollController() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        WindowScrollController.prototype.getScrollTop = function () {
            return window.pageYOffset;
        };
        WindowScrollController.prototype.getScrollLeft = function () {
            return window.pageXOffset;
        };
        WindowScrollController.prototype.setScrollTop = function (n) {
            window.scroll(window.pageXOffset, n);
        };
        WindowScrollController.prototype.setScrollLeft = function (n) {
            window.scroll(n, window.pageYOffset);
        };
        WindowScrollController.prototype.getScrollWidth = function () {
            return document.documentElement.scrollWidth;
        };
        WindowScrollController.prototype.getScrollHeight = function () {
            return document.documentElement.scrollHeight;
        };
        WindowScrollController.prototype.getClientHeight = function () {
            return document.documentElement.clientHeight;
        };
        WindowScrollController.prototype.getClientWidth = function () {
            return document.documentElement.clientWidth;
        };
        return WindowScrollController;
    }(ScrollController));

    /*
    Embodies a div that has potential scrollbars
    */
    var ScrollComponent = /** @class */ (function (_super) {
        __extends(ScrollComponent, _super);
        function ScrollComponent(overflowX, overflowY) {
            var _this = _super.call(this, createElement('div', {
                className: 'fc-scroller'
            })) || this;
            _this.overflowX = overflowX;
            _this.overflowY = overflowY;
            _this.applyOverflow();
            return _this;
        }
        // sets to natural height, unlocks overflow
        ScrollComponent.prototype.clear = function () {
            this.setHeight('auto');
            this.applyOverflow();
        };
        ScrollComponent.prototype.destroy = function () {
            removeElement(this.el);
        };
        // Overflow
        // -----------------------------------------------------------------------------------------------------------------
        ScrollComponent.prototype.applyOverflow = function () {
            applyStyle(this.el, {
                overflowX: this.overflowX,
                overflowY: this.overflowY
            });
        };
        // Causes any 'auto' overflow values to resolves to 'scroll' or 'hidden'.
        // Useful for preserving scrollbar widths regardless of future resizes.
        // Can pass in scrollbarWidths for optimization.
        ScrollComponent.prototype.lockOverflow = function (scrollbarWidths) {
            var overflowX = this.overflowX;
            var overflowY = this.overflowY;
            scrollbarWidths = scrollbarWidths || this.getScrollbarWidths();
            if (overflowX === 'auto') {
                overflowX = (scrollbarWidths.bottom || // horizontal scrollbars?
                    this.canScrollHorizontally() // OR scrolling pane with massless scrollbars?
                ) ? 'scroll' : 'hidden';
            }
            if (overflowY === 'auto') {
                overflowY = (scrollbarWidths.left || scrollbarWidths.right || // horizontal scrollbars?
                    this.canScrollVertically() // OR scrolling pane with massless scrollbars?
                ) ? 'scroll' : 'hidden';
            }
            applyStyle(this.el, { overflowX: overflowX, overflowY: overflowY });
        };
        ScrollComponent.prototype.setHeight = function (height) {
            applyStyleProp(this.el, 'height', height);
        };
        ScrollComponent.prototype.getScrollbarWidths = function () {
            var edges = computeEdges(this.el);
            return {
                left: edges.scrollbarLeft,
                right: edges.scrollbarRight,
                bottom: edges.scrollbarBottom
            };
        };
        return ScrollComponent;
    }(ElementScrollController));

    var Theme = /** @class */ (function () {
        function Theme(calendarOptions) {
            this.calendarOptions = calendarOptions;
            this.processIconOverride();
        }
        Theme.prototype.processIconOverride = function () {
            if (this.iconOverrideOption) {
                this.setIconOverride(this.calendarOptions[this.iconOverrideOption]);
            }
        };
        Theme.prototype.setIconOverride = function (iconOverrideHash) {
            var iconClassesCopy;
            var buttonName;
            if (typeof iconOverrideHash === 'object' && iconOverrideHash) { // non-null object
                iconClassesCopy = __assign({}, this.iconClasses);
                for (buttonName in iconOverrideHash) {
                    iconClassesCopy[buttonName] = this.applyIconOverridePrefix(iconOverrideHash[buttonName]);
                }
                this.iconClasses = iconClassesCopy;
            }
            else if (iconOverrideHash === false) {
                this.iconClasses = {};
            }
        };
        Theme.prototype.applyIconOverridePrefix = function (className) {
            var prefix = this.iconOverridePrefix;
            if (prefix && className.indexOf(prefix) !== 0) { // if not already present
                className = prefix + className;
            }
            return className;
        };
        Theme.prototype.getClass = function (key) {
            return this.classes[key] || '';
        };
        Theme.prototype.getIconClass = function (buttonName) {
            var className = this.iconClasses[buttonName];
            if (className) {
                return this.baseIconClass + ' ' + className;
            }
            return '';
        };
        Theme.prototype.getCustomButtonIconClass = function (customButtonProps) {
            var className;
            if (this.iconOverrideCustomButtonOption) {
                className = customButtonProps[this.iconOverrideCustomButtonOption];
                if (className) {
                    return this.baseIconClass + ' ' + this.applyIconOverridePrefix(className);
                }
            }
            return '';
        };
        return Theme;
    }());
    Theme.prototype.classes = {};
    Theme.prototype.iconClasses = {};
    Theme.prototype.baseIconClass = '';
    Theme.prototype.iconOverridePrefix = '';

    var guid = 0;
    var Component = /** @class */ (function () {
        function Component(context, isView) {
            // HACK to populate view at top of component instantiation call chain
            if (isView) {
                context.view = this;
            }
            this.uid = String(guid++);
            this.context = context;
            this.dateEnv = context.dateEnv;
            this.theme = context.theme;
            this.view = context.view;
            this.calendar = context.calendar;
            this.isRtl = this.opt('dir') === 'rtl';
        }
        Component.addEqualityFuncs = function (newFuncs) {
            this.prototype.equalityFuncs = __assign({}, this.prototype.equalityFuncs, newFuncs);
        };
        Component.prototype.opt = function (name) {
            return this.context.options[name];
        };
        Component.prototype.receiveProps = function (props) {
            var _a = recycleProps(this.props || {}, props, this.equalityFuncs), anyChanges = _a.anyChanges, comboProps = _a.comboProps;
            this.props = comboProps;
            if (anyChanges) {
                this.render(comboProps);
            }
        };
        Component.prototype.render = function (props) {
        };
        // after destroy is called, this component won't ever be used again
        Component.prototype.destroy = function () {
        };
        return Component;
    }());
    Component.prototype.equalityFuncs = {};
    /*
    Reuses old values when equal. If anything is unequal, returns newProps as-is.
    Great for PureComponent, but won't be feasible with React, so just eliminate and use React's DOM diffing.
    */
    function recycleProps(oldProps, newProps, equalityFuncs) {
        var comboProps = {}; // some old, some new
        var anyChanges = false;
        for (var key in newProps) {
            if (key in oldProps && (oldProps[key] === newProps[key] ||
                (equalityFuncs[key] && equalityFuncs[key](oldProps[key], newProps[key])))) {
                // equal to old? use old prop
                comboProps[key] = oldProps[key];
            }
            else {
                comboProps[key] = newProps[key];
                anyChanges = true;
            }
        }
        for (var key in oldProps) {
            if (!(key in newProps)) {
                anyChanges = true;
                break;
            }
        }
        return { anyChanges: anyChanges, comboProps: comboProps };
    }

    /*
    PURPOSES:
    - hook up to fg, fill, and mirror renderers
    - interface for dragging and hits
    */
    var DateComponent = /** @class */ (function (_super) {
        __extends(DateComponent, _super);
        function DateComponent(context, el, isView) {
            var _this = _super.call(this, context, isView) || this;
            _this.el = el;
            return _this;
        }
        DateComponent.prototype.destroy = function () {
            _super.prototype.destroy.call(this);
            removeElement(this.el);
        };
        // TODO: WHAT ABOUT (sourceSeg && sourceSeg.component.doesDragMirror)
        //
        // Event Drag-n-Drop Rendering (for both events and external elements)
        // ---------------------------------------------------------------------------------------------------------------
        /*
        renderEventDragSegs(state: EventSegUiInteractionState) {
          if (state) {
            let { isEvent, segs, sourceSeg } = state
      
            if (this.eventRenderer) {
              this.eventRenderer.hideByHash(state.affectedInstances)
            }
      
            // if the user is dragging something that is considered an event with real event data,
            // and this component likes to do drag mirrors OR the component where the seg came from
            // likes to do drag mirrors, then render a drag mirror.
            if (isEvent && (this.doesDragMirror || sourceSeg && sourceSeg.component.doesDragMirror)) {
              if (this.mirrorRenderer) {
                this.mirrorRenderer.renderSegs(segs, { isDragging: true, sourceSeg })
              }
            }
      
            // if it would be impossible to render a drag mirror OR this component likes to render
            // highlights, then render a highlight.
            if (!isEvent || this.doesDragHighlight) {
              if (this.fillRenderer) {
                this.fillRenderer.renderSegs('highlight', segs)
              }
            }
          }
        }
        */
        // Hit System
        // -----------------------------------------------------------------------------------------------------------------
        DateComponent.prototype.buildPositionCaches = function () {
        };
        DateComponent.prototype.queryHit = function (positionLeft, positionTop, elWidth, elHeight) {
            return null; // this should be abstract
        };
        // Validation
        // -----------------------------------------------------------------------------------------------------------------
        DateComponent.prototype.isInteractionValid = function (interaction) {
            var calendar = this.calendar;
            var dateProfile = this.props.dateProfile; // HACK
            var instances = interaction.mutatedEvents.instances;
            if (dateProfile) { // HACK for DayTile
                for (var instanceId in instances) {
                    if (!rangeContainsRange(dateProfile.validRange, instances[instanceId].range)) {
                        return false;
                    }
                }
            }
            return isInteractionValid(interaction, calendar);
        };
        DateComponent.prototype.isDateSelectionValid = function (selection) {
            var dateProfile = this.props.dateProfile; // HACK
            if (dateProfile && // HACK for DayTile
                !rangeContainsRange(dateProfile.validRange, selection.range)) {
                return false;
            }
            return isDateSelectionValid(selection, this.calendar);
        };
        // Triggering
        // -----------------------------------------------------------------------------------------------------------------
        // TODO: move to Calendar
        DateComponent.prototype.publiclyTrigger = function (name, args) {
            var calendar = this.calendar;
            return calendar.publiclyTrigger(name, args);
        };
        DateComponent.prototype.publiclyTriggerAfterSizing = function (name, args) {
            var calendar = this.calendar;
            return calendar.publiclyTriggerAfterSizing(name, args);
        };
        DateComponent.prototype.hasPublicHandlers = function (name) {
            var calendar = this.calendar;
            return calendar.hasPublicHandlers(name);
        };
        DateComponent.prototype.triggerRenderedSegs = function (segs, isMirrors) {
            var calendar = this.calendar;
            if (this.hasPublicHandlers('eventPositioned')) {
                for (var _i = 0, segs_1 = segs; _i < segs_1.length; _i++) {
                    var seg = segs_1[_i];
                    this.publiclyTriggerAfterSizing('eventPositioned', [
                        {
                            event: new EventApi(calendar, seg.eventRange.def, seg.eventRange.instance),
                            isMirror: isMirrors,
                            isStart: seg.isStart,
                            isEnd: seg.isEnd,
                            el: seg.el,
                            view: this // safe to cast because this method is only called on context.view
                        }
                    ]);
                }
            }
            if (!calendar.state.loadingLevel) { // avoid initial empty state while pending
                calendar.afterSizingTriggers._eventsPositioned = [null]; // fire once
            }
        };
        DateComponent.prototype.triggerWillRemoveSegs = function (segs, isMirrors) {
            var calendar = this.calendar;
            for (var _i = 0, segs_2 = segs; _i < segs_2.length; _i++) {
                var seg = segs_2[_i];
                calendar.trigger('eventElRemove', seg.el);
            }
            if (this.hasPublicHandlers('eventDestroy')) {
                for (var _a = 0, segs_3 = segs; _a < segs_3.length; _a++) {
                    var seg = segs_3[_a];
                    this.publiclyTrigger('eventDestroy', [
                        {
                            event: new EventApi(calendar, seg.eventRange.def, seg.eventRange.instance),
                            isMirror: isMirrors,
                            el: seg.el,
                            view: this // safe to cast because this method is only called on context.view
                        }
                    ]);
                }
            }
        };
        // Pointer Interaction Utils
        // -----------------------------------------------------------------------------------------------------------------
        DateComponent.prototype.isValidSegDownEl = function (el) {
            return !this.props.eventDrag && // HACK
                !this.props.eventResize && // HACK
                !elementClosest(el, '.fc-mirror') &&
                (this.isPopover() || !this.isInPopover(el));
            // ^above line ensures we don't detect a seg interaction within a nested component.
            // it's a HACK because it only supports a popover as the nested component.
        };
        DateComponent.prototype.isValidDateDownEl = function (el) {
            var segEl = elementClosest(el, this.fgSegSelector);
            return (!segEl || segEl.classList.contains('fc-mirror')) &&
                !elementClosest(el, '.fc-more') && // a "more.." link
                !elementClosest(el, 'a[data-goto]') && // a clickable nav link
                !this.isInPopover(el);
        };
        DateComponent.prototype.isPopover = function () {
            return this.el.classList.contains('fc-popover');
        };
        DateComponent.prototype.isInPopover = function (el) {
            return Boolean(elementClosest(el, '.fc-popover'));
        };
        return DateComponent;
    }(Component));
    DateComponent.prototype.fgSegSelector = '.fc-event-container > *';
    DateComponent.prototype.bgSegSelector = '.fc-bgevent:not(.fc-nonbusiness)';

    var uid$1 = 0;
    function createPlugin(input) {
        return {
            id: String(uid$1++),
            deps: input.deps || [],
            reducers: input.reducers || [],
            eventDefParsers: input.eventDefParsers || [],
            isDraggableTransformers: input.isDraggableTransformers || [],
            eventDragMutationMassagers: input.eventDragMutationMassagers || [],
            eventDefMutationAppliers: input.eventDefMutationAppliers || [],
            dateSelectionTransformers: input.dateSelectionTransformers || [],
            datePointTransforms: input.datePointTransforms || [],
            dateSpanTransforms: input.dateSpanTransforms || [],
            views: input.views || {},
            viewPropsTransformers: input.viewPropsTransformers || [],
            isPropsValid: input.isPropsValid || null,
            externalDefTransforms: input.externalDefTransforms || [],
            eventResizeJoinTransforms: input.eventResizeJoinTransforms || [],
            viewContainerModifiers: input.viewContainerModifiers || [],
            eventDropTransformers: input.eventDropTransformers || [],
            componentInteractions: input.componentInteractions || [],
            calendarInteractions: input.calendarInteractions || [],
            themeClasses: input.themeClasses || {},
            eventSourceDefs: input.eventSourceDefs || [],
            cmdFormatter: input.cmdFormatter,
            recurringTypes: input.recurringTypes || [],
            namedTimeZonedImpl: input.namedTimeZonedImpl,
            defaultView: input.defaultView || '',
            elementDraggingImpl: input.elementDraggingImpl,
            optionChangeHandlers: input.optionChangeHandlers || {}
        };
    }
    var PluginSystem = /** @class */ (function () {
        function PluginSystem() {
            this.hooks = {
                reducers: [],
                eventDefParsers: [],
                isDraggableTransformers: [],
                eventDragMutationMassagers: [],
                eventDefMutationAppliers: [],
                dateSelectionTransformers: [],
                datePointTransforms: [],
                dateSpanTransforms: [],
                views: {},
                viewPropsTransformers: [],
                isPropsValid: null,
                externalDefTransforms: [],
                eventResizeJoinTransforms: [],
                viewContainerModifiers: [],
                eventDropTransformers: [],
                componentInteractions: [],
                calendarInteractions: [],
                themeClasses: {},
                eventSourceDefs: [],
                cmdFormatter: null,
                recurringTypes: [],
                namedTimeZonedImpl: null,
                defaultView: '',
                elementDraggingImpl: null,
                optionChangeHandlers: {}
            };
            this.addedHash = {};
        }
        PluginSystem.prototype.add = function (plugin) {
            if (!this.addedHash[plugin.id]) {
                this.addedHash[plugin.id] = true;
                for (var _i = 0, _a = plugin.deps; _i < _a.length; _i++) {
                    var dep = _a[_i];
                    this.add(dep);
                }
                this.hooks = combineHooks(this.hooks, plugin);
            }
        };
        return PluginSystem;
    }());
    function combineHooks(hooks0, hooks1) {
        return {
            reducers: hooks0.reducers.concat(hooks1.reducers),
            eventDefParsers: hooks0.eventDefParsers.concat(hooks1.eventDefParsers),
            isDraggableTransformers: hooks0.isDraggableTransformers.concat(hooks1.isDraggableTransformers),
            eventDragMutationMassagers: hooks0.eventDragMutationMassagers.concat(hooks1.eventDragMutationMassagers),
            eventDefMutationAppliers: hooks0.eventDefMutationAppliers.concat(hooks1.eventDefMutationAppliers),
            dateSelectionTransformers: hooks0.dateSelectionTransformers.concat(hooks1.dateSelectionTransformers),
            datePointTransforms: hooks0.datePointTransforms.concat(hooks1.datePointTransforms),
            dateSpanTransforms: hooks0.dateSpanTransforms.concat(hooks1.dateSpanTransforms),
            views: __assign({}, hooks0.views, hooks1.views),
            viewPropsTransformers: hooks0.viewPropsTransformers.concat(hooks1.viewPropsTransformers),
            isPropsValid: hooks1.isPropsValid || hooks0.isPropsValid,
            externalDefTransforms: hooks0.externalDefTransforms.concat(hooks1.externalDefTransforms),
            eventResizeJoinTransforms: hooks0.eventResizeJoinTransforms.concat(hooks1.eventResizeJoinTransforms),
            viewContainerModifiers: hooks0.viewContainerModifiers.concat(hooks1.viewContainerModifiers),
            eventDropTransformers: hooks0.eventDropTransformers.concat(hooks1.eventDropTransformers),
            calendarInteractions: hooks0.calendarInteractions.concat(hooks1.calendarInteractions),
            componentInteractions: hooks0.componentInteractions.concat(hooks1.componentInteractions),
            themeClasses: __assign({}, hooks0.themeClasses, hooks1.themeClasses),
            eventSourceDefs: hooks0.eventSourceDefs.concat(hooks1.eventSourceDefs),
            cmdFormatter: hooks1.cmdFormatter || hooks0.cmdFormatter,
            recurringTypes: hooks0.recurringTypes.concat(hooks1.recurringTypes),
            namedTimeZonedImpl: hooks1.namedTimeZonedImpl || hooks0.namedTimeZonedImpl,
            defaultView: hooks0.defaultView || hooks1.defaultView,
            elementDraggingImpl: hooks0.elementDraggingImpl || hooks1.elementDraggingImpl,
            optionChangeHandlers: __assign({}, hooks0.optionChangeHandlers, hooks1.optionChangeHandlers)
        };
    }

    var eventSourceDef = {
        ignoreRange: true,
        parseMeta: function (raw) {
            if (Array.isArray(raw)) { // short form
                return raw;
            }
            else if (Array.isArray(raw.events)) {
                return raw.events;
            }
            return null;
        },
        fetch: function (arg, success) {
            success({
                rawEvents: arg.eventSource.meta
            });
        }
    };
    var ArrayEventSourcePlugin = createPlugin({
        eventSourceDefs: [eventSourceDef]
    });

    var eventSourceDef$1 = {
        parseMeta: function (raw) {
            if (typeof raw === 'function') { // short form
                return raw;
            }
            else if (typeof raw.events === 'function') {
                return raw.events;
            }
            return null;
        },
        fetch: function (arg, success, failure) {
            var dateEnv = arg.calendar.dateEnv;
            var func = arg.eventSource.meta;
            unpromisify(func.bind(null, {
                start: dateEnv.toDate(arg.range.start),
                end: dateEnv.toDate(arg.range.end),
                startStr: dateEnv.formatIso(arg.range.start),
                endStr: dateEnv.formatIso(arg.range.end),
                timeZone: dateEnv.timeZone
            }), function (rawEvents) {
                success({ rawEvents: rawEvents }); // needs an object response
            }, failure // send errorObj directly to failure callback
            );
        }
    };
    var FuncEventSourcePlugin = createPlugin({
        eventSourceDefs: [eventSourceDef$1]
    });

    function requestJson(method, url, params, successCallback, failureCallback) {
        method = method.toUpperCase();
        var body = null;
        if (method === 'GET') {
            url = injectQueryStringParams(url, params);
        }
        else {
            body = encodeParams(params);
        }
        var xhr = new XMLHttpRequest();
        xhr.open(method, url, true);
        if (method !== 'GET') {
            xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
        }
        xhr.onload = function () {
            if (xhr.status >= 200 && xhr.status < 400) {
                try {
                    var res = JSON.parse(xhr.responseText);
                    successCallback(res, xhr);
                }
                catch (err) {
                    failureCallback('Failure parsing JSON', xhr);
                }
            }
            else {
                failureCallback('Request failed', xhr);
            }
        };
        xhr.onerror = function () {
            failureCallback('Request failed', xhr);
        };
        xhr.send(body);
    }
    function injectQueryStringParams(url, params) {
        return url +
            (url.indexOf('?') === -1 ? '?' : '&') +
            encodeParams(params);
    }
    function encodeParams(params) {
        var parts = [];
        for (var key in params) {
            parts.push(encodeURIComponent(key) + '=' + encodeURIComponent(params[key]));
        }
        return parts.join('&');
    }

    var eventSourceDef$2 = {
        parseMeta: function (raw) {
            if (typeof raw === 'string') { // short form
                raw = { url: raw };
            }
            else if (!raw || typeof raw !== 'object' || !raw.url) {
                return null;
            }
            return {
                url: raw.url,
                method: (raw.method || 'GET').toUpperCase(),
                extraParams: raw.extraParams,
                startParam: raw.startParam,
                endParam: raw.endParam,
                timeZoneParam: raw.timeZoneParam
            };
        },
        fetch: function (arg, success, failure) {
            var meta = arg.eventSource.meta;
            var requestParams = buildRequestParams(meta, arg.range, arg.calendar);
            requestJson(meta.method, meta.url, requestParams, function (rawEvents, xhr) {
                success({ rawEvents: rawEvents, xhr: xhr });
            }, function (errorMessage, xhr) {
                failure({ message: errorMessage, xhr: xhr });
            });
        }
    };
    var JsonFeedEventSourcePlugin = createPlugin({
        eventSourceDefs: [eventSourceDef$2]
    });
    function buildRequestParams(meta, range, calendar) {
        var dateEnv = calendar.dateEnv;
        var startParam;
        var endParam;
        var timeZoneParam;
        var customRequestParams;
        var params = {};
        startParam = meta.startParam;
        if (startParam == null) {
            startParam = calendar.opt('startParam');
        }
        endParam = meta.endParam;
        if (endParam == null) {
            endParam = calendar.opt('endParam');
        }
        timeZoneParam = meta.timeZoneParam;
        if (timeZoneParam == null) {
            timeZoneParam = calendar.opt('timeZoneParam');
        }
        // retrieve any outbound GET/POST data from the options
        if (typeof meta.extraParams === 'function') {
            // supplied as a function that returns a key/value object
            customRequestParams = meta.extraParams();
        }
        else {
            // probably supplied as a straight key/value object
            customRequestParams = meta.extraParams || {};
        }
        __assign(params, customRequestParams);
        params[startParam] = dateEnv.formatIso(range.start);
        params[endParam] = dateEnv.formatIso(range.end);
        if (dateEnv.timeZone !== 'local') {
            params[timeZoneParam] = dateEnv.timeZone;
        }
        return params;
    }

    var recurring = {
        parse: function (rawEvent, leftoverProps, dateEnv) {
            var createMarker = dateEnv.createMarker.bind(dateEnv);
            var processors = {
                daysOfWeek: null,
                startTime: createDuration,
                endTime: createDuration,
                startRecur: createMarker,
                endRecur: createMarker
            };
            var props = refineProps(rawEvent, processors, {}, leftoverProps);
            var anyValid = false;
            for (var propName in props) {
                if (props[propName] != null) {
                    anyValid = true;
                    break;
                }
            }
            if (anyValid) {
                var duration = null;
                if ('duration' in leftoverProps) {
                    duration = createDuration(leftoverProps.duration);
                    delete leftoverProps.duration;
                }
                if (!duration && props.startTime && props.endTime) {
                    duration = subtractDurations(props.endTime, props.startTime);
                }
                return {
                    allDayGuess: Boolean(!props.startTime && !props.endTime),
                    duration: duration,
                    typeData: props // doesn't need endTime anymore but oh well
                };
            }
            return null;
        },
        expand: function (typeData, framingRange, dateEnv) {
            var clippedFramingRange = intersectRanges(framingRange, { start: typeData.startRecur, end: typeData.endRecur });
            if (clippedFramingRange) {
                return expandRanges(typeData.daysOfWeek, typeData.startTime, clippedFramingRange, dateEnv);
            }
            else {
                return [];
            }
        }
    };
    var SimpleRecurrencePlugin = createPlugin({
        recurringTypes: [recurring]
    });
    function expandRanges(daysOfWeek, startTime, framingRange, dateEnv) {
        var dowHash = daysOfWeek ? arrayToHash(daysOfWeek) : null;
        var dayMarker = startOfDay(framingRange.start);
        var endMarker = framingRange.end;
        var instanceStarts = [];
        while (dayMarker < endMarker) {
            var instanceStart 
            // if everyday, or this particular day-of-week
            = void 0;
            // if everyday, or this particular day-of-week
            if (!dowHash || dowHash[dayMarker.getUTCDay()]) {
                if (startTime) {
                    instanceStart = dateEnv.add(dayMarker, startTime);
                }
                else {
                    instanceStart = dayMarker;
                }
                instanceStarts.push(instanceStart);
            }
            dayMarker = addDays(dayMarker, 1);
        }
        return instanceStarts;
    }

    var DefaultOptionChangeHandlers = createPlugin({
        optionChangeHandlers: {
            events: function (events, calendar, deepEqual) {
                handleEventSources([events], calendar, deepEqual);
            },
            eventSources: handleEventSources,
            plugins: handlePlugins
        }
    });
    function handleEventSources(inputs, calendar, deepEqual) {
        var unfoundSources = hashValuesToArray(calendar.state.eventSources);
        var newInputs = [];
        for (var _i = 0, inputs_1 = inputs; _i < inputs_1.length; _i++) {
            var input = inputs_1[_i];
            var inputFound = false;
            for (var i = 0; i < unfoundSources.length; i++) {
                if (deepEqual(unfoundSources[i]._raw, input)) {
                    unfoundSources.splice(i, 1); // delete
                    inputFound = true;
                    break;
                }
            }
            if (!inputFound) {
                newInputs.push(input);
            }
        }
        for (var _a = 0, unfoundSources_1 = unfoundSources; _a < unfoundSources_1.length; _a++) {
            var unfoundSource = unfoundSources_1[_a];
            calendar.dispatch({
                type: 'REMOVE_EVENT_SOURCE',
                sourceId: unfoundSource.sourceId
            });
        }
        for (var _b = 0, newInputs_1 = newInputs; _b < newInputs_1.length; _b++) {
            var newInput = newInputs_1[_b];
            calendar.addEventSource(newInput);
        }
    }
    // shortcoming: won't remove plugins
    function handlePlugins(inputs, calendar) {
        calendar.addPluginInputs(inputs); // will gracefully handle duplicates
    }

    var config = {}; // TODO: make these options
    var globalDefaults = {
        defaultRangeSeparator: ' - ',
        titleRangeSeparator: ' \u2013 ',
        defaultTimedEventDuration: '01:00:00',
        defaultAllDayEventDuration: { day: 1 },
        forceEventDuration: false,
        nextDayThreshold: '00:00:00',
        // display
        columnHeader: true,
        defaultView: '',
        aspectRatio: 1.35,
        header: {
            left: 'title',
            center: '',
            right: 'today prev,next'
        },
        weekends: true,
        weekNumbers: false,
        weekNumberCalculation: 'local',
        editable: false,
        // nowIndicator: false,
        scrollTime: '06:00:00',
        minTime: '00:00:00',
        maxTime: '24:00:00',
        showNonCurrentDates: true,
        // event ajax
        lazyFetching: true,
        startParam: 'start',
        endParam: 'end',
        timeZoneParam: 'timeZone',
        timeZone: 'local',
        // allDayDefault: undefined,
        // locale
        locales: [],
        locale: '',
        // dir: will get this from the default locale
        // buttonIcons: null,
        // allows setting a min-height to the event segment to prevent short events overlapping each other
        timeGridEventMinHeight: 0,
        themeSystem: 'standard',
        // eventResizableFromStart: false,
        dragRevertDuration: 500,
        dragScroll: true,
        allDayMaintainDuration: false,
        // selectable: false,
        unselectAuto: true,
        // selectMinDistance: 0,
        dropAccept: '*',
        eventOrder: 'start,-duration,allDay,title',
        // ^ if start tie, longer events go before shorter. final tie-breaker is title text
        // rerenderDelay: null,
        eventLimit: false,
        eventLimitClick: 'popover',
        dayPopoverFormat: { month: 'long', day: 'numeric', year: 'numeric' },
        handleWindowResize: true,
        windowResizeDelay: 100,
        longPressDelay: 1000,
        eventDragMinDistance: 5 // only applies to mouse
    };
    var rtlDefaults = {
        header: {
            left: 'next,prev today',
            center: '',
            right: 'title'
        },
        buttonIcons: {
            // TODO: make RTL support the responibility of the theme
            prev: 'fc-icon-chevron-right',
            next: 'fc-icon-chevron-left',
            prevYear: 'fc-icon-chevrons-right',
            nextYear: 'fc-icon-chevrons-left'
        }
    };
    var complexOptions = [
        'header',
        'footer',
        'buttonText',
        'buttonIcons'
    ];
    // Merges an array of option objects into a single object
    function mergeOptions(optionObjs) {
        return mergeProps(optionObjs, complexOptions);
    }
    // TODO: move this stuff to a "plugin"-related file...
    var INTERNAL_PLUGINS = [
        ArrayEventSourcePlugin,
        FuncEventSourcePlugin,
        JsonFeedEventSourcePlugin,
        SimpleRecurrencePlugin,
        DefaultOptionChangeHandlers
    ];
    function refinePluginDefs(pluginInputs) {
        var plugins = [];
        for (var _i = 0, pluginInputs_1 = pluginInputs; _i < pluginInputs_1.length; _i++) {
            var pluginInput = pluginInputs_1[_i];
            if (typeof pluginInput === 'string') {
                var globalName = 'FullCalendar' + capitaliseFirstLetter(pluginInput);
                if (!window[globalName]) {
                    console.warn('Plugin file not loaded for ' + pluginInput);
                }
                else {
                    plugins.push(window[globalName].default); // is an ES6 module
                }
            }
            else {
                plugins.push(pluginInput);
            }
        }
        return INTERNAL_PLUGINS.concat(plugins);
    }

    var RAW_EN_LOCALE = {
        code: 'en',
        week: {
            dow: 0,
            doy: 4 // 4 days need to be within the year to be considered the first week
        },
        dir: 'ltr',
        buttonText: {
            prev: 'prev',
            next: 'next',
            prevYear: 'prev year',
            nextYear: 'next year',
            year: 'year',
            today: 'today',
            month: 'month',
            week: 'week',
            day: 'day',
            list: 'list'
        },
        weekLabel: 'W',
        allDayText: 'all-day',
        eventLimitText: 'more',
        noEventsMessage: 'No events to display'
    };
    function parseRawLocales(explicitRawLocales) {
        var defaultCode = explicitRawLocales.length > 0 ? explicitRawLocales[0].code : 'en';
        var globalArray = window['FullCalendarLocalesAll'] || []; // from locales-all.js
        var globalObject = window['FullCalendarLocales'] || {}; // from locales/*.js. keys are meaningless
        var allRawLocales = globalArray.concat(// globalArray is low prio
        hashValuesToArray(globalObject), // medium prio
        explicitRawLocales // highest prio
        );
        var rawLocaleMap = {
            en: RAW_EN_LOCALE // necessary?
        };
        for (var _i = 0, allRawLocales_1 = allRawLocales; _i < allRawLocales_1.length; _i++) {
            var rawLocale = allRawLocales_1[_i];
            rawLocaleMap[rawLocale.code] = rawLocale;
        }
        return {
            map: rawLocaleMap,
            defaultCode: defaultCode
        };
    }
    function buildLocale(inputSingular, available) {
        if (typeof inputSingular === 'object' && !Array.isArray(inputSingular)) {
            return parseLocale(inputSingular.code, [inputSingular.code], inputSingular);
        }
        else {
            return queryLocale(inputSingular, available);
        }
    }
    function queryLocale(codeArg, available) {
        var codes = [].concat(codeArg || []); // will convert to array
        var raw = queryRawLocale(codes, available) || RAW_EN_LOCALE;
        return parseLocale(codeArg, codes, raw);
    }
    function queryRawLocale(codes, available) {
        for (var i = 0; i < codes.length; i++) {
            var parts = codes[i].toLocaleLowerCase().split('-');
            for (var j = parts.length; j > 0; j--) {
                var simpleId = parts.slice(0, j).join('-');
                if (available[simpleId]) {
                    return available[simpleId];
                }
            }
        }
        return null;
    }
    function parseLocale(codeArg, codes, raw) {
        var merged = mergeProps([RAW_EN_LOCALE, raw], ['buttonText']);
        delete merged.code; // don't want this part of the options
        var week = merged.week;
        delete merged.week;
        return {
            codeArg: codeArg,
            codes: codes,
            week: week,
            simpleNumberFormat: new Intl.NumberFormat(codeArg),
            options: merged
        };
    }

    var OptionsManager = /** @class */ (function () {
        function OptionsManager(overrides) {
            this.overrides = __assign({}, overrides); // make a copy
            this.dynamicOverrides = {};
            this.compute();
        }
        OptionsManager.prototype.mutate = function (updates, removals, isDynamic) {
            var overrideHash = isDynamic ? this.dynamicOverrides : this.overrides;
            __assign(overrideHash, updates);
            for (var _i = 0, removals_1 = removals; _i < removals_1.length; _i++) {
                var propName = removals_1[_i];
                delete overrideHash[propName];
            }
            this.compute();
        };
        // Computes the flattened options hash for the calendar and assigns to `this.options`.
        // Assumes this.overrides and this.dynamicOverrides have already been initialized.
        OptionsManager.prototype.compute = function () {
            // TODO: not a very efficient system
            var locales = firstDefined(// explicit locale option given?
            this.dynamicOverrides.locales, this.overrides.locales, globalDefaults.locales);
            var locale = firstDefined(// explicit locales option given?
            this.dynamicOverrides.locale, this.overrides.locale, globalDefaults.locale);
            var available = parseRawLocales(locales);
            var localeDefaults = buildLocale(locale || available.defaultCode, available.map).options;
            var dir = firstDefined(// based on options computed so far, is direction RTL?
            this.dynamicOverrides.dir, this.overrides.dir, localeDefaults.dir);
            var dirDefaults = dir === 'rtl' ? rtlDefaults : {};
            this.dirDefaults = dirDefaults;
            this.localeDefaults = localeDefaults;
            this.computed = mergeOptions([
                globalDefaults,
                dirDefaults,
                localeDefaults,
                this.overrides,
                this.dynamicOverrides
            ]);
        };
        return OptionsManager;
    }());

    var calendarSystemClassMap = {};
    function registerCalendarSystem(name, theClass) {
        calendarSystemClassMap[name] = theClass;
    }
    function createCalendarSystem(name) {
        return new calendarSystemClassMap[name]();
    }
    var GregorianCalendarSystem = /** @class */ (function () {
        function GregorianCalendarSystem() {
        }
        GregorianCalendarSystem.prototype.getMarkerYear = function (d) {
            return d.getUTCFullYear();
        };
        GregorianCalendarSystem.prototype.getMarkerMonth = function (d) {
            return d.getUTCMonth();
        };
        GregorianCalendarSystem.prototype.getMarkerDay = function (d) {
            return d.getUTCDate();
        };
        GregorianCalendarSystem.prototype.arrayToMarker = function (arr) {
            return arrayToUtcDate(arr);
        };
        GregorianCalendarSystem.prototype.markerToArray = function (marker) {
            return dateToUtcArray(marker);
        };
        return GregorianCalendarSystem;
    }());
    registerCalendarSystem('gregory', GregorianCalendarSystem);

    var ISO_RE = /^\s*(\d{4})(-(\d{2})(-(\d{2})([T ](\d{2}):(\d{2})(:(\d{2})(\.(\d+))?)?(Z|(([-+])(\d{2})(:?(\d{2}))?))?)?)?)?$/;
    function parse(str) {
        var m = ISO_RE.exec(str);
        if (m) {
            var marker = new Date(Date.UTC(Number(m[1]), m[3] ? Number(m[3]) - 1 : 0, Number(m[5] || 1), Number(m[7] || 0), Number(m[8] || 0), Number(m[10] || 0), m[12] ? Number('0.' + m[12]) * 1000 : 0));
            if (isValidDate(marker)) {
                var timeZoneOffset = null;
                if (m[13]) {
                    timeZoneOffset = (m[15] === '-' ? -1 : 1) * (Number(m[16] || 0) * 60 +
                        Number(m[18] || 0));
                }
                return {
                    marker: marker,
                    isTimeUnspecified: !m[6],
                    timeZoneOffset: timeZoneOffset
                };
            }
        }
        return null;
    }

    var DateEnv = /** @class */ (function () {
        function DateEnv(settings) {
            var timeZone = this.timeZone = settings.timeZone;
            var isNamedTimeZone = timeZone !== 'local' && timeZone !== 'UTC';
            if (settings.namedTimeZoneImpl && isNamedTimeZone) {
                this.namedTimeZoneImpl = new settings.namedTimeZoneImpl(timeZone);
            }
            this.canComputeOffset = Boolean(!isNamedTimeZone || this.namedTimeZoneImpl);
            this.calendarSystem = createCalendarSystem(settings.calendarSystem);
            this.locale = settings.locale;
            this.weekDow = settings.locale.week.dow;
            this.weekDoy = settings.locale.week.doy;
            if (settings.weekNumberCalculation === 'ISO') {
                this.weekDow = 1;
                this.weekDoy = 4;
            }
            if (typeof settings.firstDay === 'number') {
                this.weekDow = settings.firstDay;
            }
            if (typeof settings.weekNumberCalculation === 'function') {
                this.weekNumberFunc = settings.weekNumberCalculation;
            }
            this.weekLabel = settings.weekLabel != null ? settings.weekLabel : settings.locale.options.weekLabel;
            this.cmdFormatter = settings.cmdFormatter;
        }
        // Creating / Parsing
        DateEnv.prototype.createMarker = function (input) {
            var meta = this.createMarkerMeta(input);
            if (meta === null) {
                return null;
            }
            return meta.marker;
        };
        DateEnv.prototype.createNowMarker = function () {
            if (this.canComputeOffset) {
                return this.timestampToMarker(new Date().valueOf());
            }
            else {
                // if we can't compute the current date val for a timezone,
                // better to give the current local date vals than UTC
                return arrayToUtcDate(dateToLocalArray(new Date()));
            }
        };
        DateEnv.prototype.createMarkerMeta = function (input) {
            if (typeof input === 'string') {
                return this.parse(input);
            }
            var marker = null;
            if (typeof input === 'number') {
                marker = this.timestampToMarker(input);
            }
            else if (input instanceof Date) {
                input = input.valueOf();
                if (!isNaN(input)) {
                    marker = this.timestampToMarker(input);
                }
            }
            else if (Array.isArray(input)) {
                marker = arrayToUtcDate(input);
            }
            if (marker === null || !isValidDate(marker)) {
                return null;
            }
            return { marker: marker, isTimeUnspecified: false, forcedTzo: null };
        };
        DateEnv.prototype.parse = function (s) {
            var parts = parse(s);
            if (parts === null) {
                return null;
            }
            var marker = parts.marker;
            var forcedTzo = null;
            if (parts.timeZoneOffset !== null) {
                if (this.canComputeOffset) {
                    marker = this.timestampToMarker(marker.valueOf() - parts.timeZoneOffset * 60 * 1000);
                }
                else {
                    forcedTzo = parts.timeZoneOffset;
                }
            }
            return { marker: marker, isTimeUnspecified: parts.isTimeUnspecified, forcedTzo: forcedTzo };
        };
        // Accessors
        DateEnv.prototype.getYear = function (marker) {
            return this.calendarSystem.getMarkerYear(marker);
        };
        DateEnv.prototype.getMonth = function (marker) {
            return this.calendarSystem.getMarkerMonth(marker);
        };
        // Adding / Subtracting
        DateEnv.prototype.add = function (marker, dur) {
            var a = this.calendarSystem.markerToArray(marker);
            a[0] += dur.years;
            a[1] += dur.months;
            a[2] += dur.days;
            a[6] += dur.milliseconds;
            return this.calendarSystem.arrayToMarker(a);
        };
        DateEnv.prototype.subtract = function (marker, dur) {
            var a = this.calendarSystem.markerToArray(marker);
            a[0] -= dur.years;
            a[1] -= dur.months;
            a[2] -= dur.days;
            a[6] -= dur.milliseconds;
            return this.calendarSystem.arrayToMarker(a);
        };
        DateEnv.prototype.addYears = function (marker, n) {
            var a = this.calendarSystem.markerToArray(marker);
            a[0] += n;
            return this.calendarSystem.arrayToMarker(a);
        };
        DateEnv.prototype.addMonths = function (marker, n) {
            var a = this.calendarSystem.markerToArray(marker);
            a[1] += n;
            return this.calendarSystem.arrayToMarker(a);
        };
        // Diffing Whole Units
        DateEnv.prototype.diffWholeYears = function (m0, m1) {
            var calendarSystem = this.calendarSystem;
            if (timeAsMs(m0) === timeAsMs(m1) &&
                calendarSystem.getMarkerDay(m0) === calendarSystem.getMarkerDay(m1) &&
                calendarSystem.getMarkerMonth(m0) === calendarSystem.getMarkerMonth(m1)) {
                return calendarSystem.getMarkerYear(m1) - calendarSystem.getMarkerYear(m0);
            }
            return null;
        };
        DateEnv.prototype.diffWholeMonths = function (m0, m1) {
            var calendarSystem = this.calendarSystem;
            if (timeAsMs(m0) === timeAsMs(m1) &&
                calendarSystem.getMarkerDay(m0) === calendarSystem.getMarkerDay(m1)) {
                return (calendarSystem.getMarkerMonth(m1) - calendarSystem.getMarkerMonth(m0)) +
                    (calendarSystem.getMarkerYear(m1) - calendarSystem.getMarkerYear(m0)) * 12;
            }
            return null;
        };
        // Range / Duration
        DateEnv.prototype.greatestWholeUnit = function (m0, m1) {
            var n = this.diffWholeYears(m0, m1);
            if (n !== null) {
                return { unit: 'year', value: n };
            }
            n = this.diffWholeMonths(m0, m1);
            if (n !== null) {
                return { unit: 'month', value: n };
            }
            n = diffWholeWeeks(m0, m1);
            if (n !== null) {
                return { unit: 'week', value: n };
            }
            n = diffWholeDays(m0, m1);
            if (n !== null) {
                return { unit: 'day', value: n };
            }
            n = diffHours(m0, m1);
            if (isInt(n)) {
                return { unit: 'hour', value: n };
            }
            n = diffMinutes(m0, m1);
            if (isInt(n)) {
                return { unit: 'minute', value: n };
            }
            n = diffSeconds(m0, m1);
            if (isInt(n)) {
                return { unit: 'second', value: n };
            }
            return { unit: 'millisecond', value: m1.valueOf() - m0.valueOf() };
        };
        DateEnv.prototype.countDurationsBetween = function (m0, m1, d) {
            // TODO: can use greatestWholeUnit
            var diff;
            if (d.years) {
                diff = this.diffWholeYears(m0, m1);
                if (diff !== null) {
                    return diff / asRoughYears(d);
                }
            }
            if (d.months) {
                diff = this.diffWholeMonths(m0, m1);
                if (diff !== null) {
                    return diff / asRoughMonths(d);
                }
            }
            if (d.days) {
                diff = diffWholeDays(m0, m1);
                if (diff !== null) {
                    return diff / asRoughDays(d);
                }
            }
            return (m1.valueOf() - m0.valueOf()) / asRoughMs(d);
        };
        // Start-Of
        DateEnv.prototype.startOf = function (m, unit) {
            if (unit === 'year') {
                return this.startOfYear(m);
            }
            else if (unit === 'month') {
                return this.startOfMonth(m);
            }
            else if (unit === 'week') {
                return this.startOfWeek(m);
            }
            else if (unit === 'day') {
                return startOfDay(m);
            }
            else if (unit === 'hour') {
                return startOfHour(m);
            }
            else if (unit === 'minute') {
                return startOfMinute(m);
            }
            else if (unit === 'second') {
                return startOfSecond(m);
            }
        };
        DateEnv.prototype.startOfYear = function (m) {
            return this.calendarSystem.arrayToMarker([
                this.calendarSystem.getMarkerYear(m)
            ]);
        };
        DateEnv.prototype.startOfMonth = function (m) {
            return this.calendarSystem.arrayToMarker([
                this.calendarSystem.getMarkerYear(m),
                this.calendarSystem.getMarkerMonth(m)
            ]);
        };
        DateEnv.prototype.startOfWeek = function (m) {
            return this.calendarSystem.arrayToMarker([
                this.calendarSystem.getMarkerYear(m),
                this.calendarSystem.getMarkerMonth(m),
                m.getUTCDate() - ((m.getUTCDay() - this.weekDow + 7) % 7)
            ]);
        };
        // Week Number
        DateEnv.prototype.computeWeekNumber = function (marker) {
            if (this.weekNumberFunc) {
                return this.weekNumberFunc(this.toDate(marker));
            }
            else {
                return weekOfYear(marker, this.weekDow, this.weekDoy);
            }
        };
        // TODO: choke on timeZoneName: long
        DateEnv.prototype.format = function (marker, formatter, dateOptions) {
            if (dateOptions === void 0) { dateOptions = {}; }
            return formatter.format({
                marker: marker,
                timeZoneOffset: dateOptions.forcedTzo != null ?
                    dateOptions.forcedTzo :
                    this.offsetForMarker(marker)
            }, this);
        };
        DateEnv.prototype.formatRange = function (start, end, formatter, dateOptions) {
            if (dateOptions === void 0) { dateOptions = {}; }
            if (dateOptions.isEndExclusive) {
                end = addMs(end, -1);
            }
            return formatter.formatRange({
                marker: start,
                timeZoneOffset: dateOptions.forcedStartTzo != null ?
                    dateOptions.forcedStartTzo :
                    this.offsetForMarker(start)
            }, {
                marker: end,
                timeZoneOffset: dateOptions.forcedEndTzo != null ?
                    dateOptions.forcedEndTzo :
                    this.offsetForMarker(end)
            }, this);
        };
        DateEnv.prototype.formatIso = function (marker, extraOptions) {
            if (extraOptions === void 0) { extraOptions = {}; }
            var timeZoneOffset = null;
            if (!extraOptions.omitTimeZoneOffset) {
                if (extraOptions.forcedTzo != null) {
                    timeZoneOffset = extraOptions.forcedTzo;
                }
                else {
                    timeZoneOffset = this.offsetForMarker(marker);
                }
            }
            return buildIsoString(marker, timeZoneOffset, extraOptions.omitTime);
        };
        // TimeZone
        DateEnv.prototype.timestampToMarker = function (ms) {
            if (this.timeZone === 'local') {
                return arrayToUtcDate(dateToLocalArray(new Date(ms)));
            }
            else if (this.timeZone === 'UTC' || !this.namedTimeZoneImpl) {
                return new Date(ms);
            }
            else {
                return arrayToUtcDate(this.namedTimeZoneImpl.timestampToArray(ms));
            }
        };
        DateEnv.prototype.offsetForMarker = function (m) {
            if (this.timeZone === 'local') {
                return -arrayToLocalDate(dateToUtcArray(m)).getTimezoneOffset(); // convert "inverse" offset to "normal" offset
            }
            else if (this.timeZone === 'UTC') {
                return 0;
            }
            else if (this.namedTimeZoneImpl) {
                return this.namedTimeZoneImpl.offsetForArray(dateToUtcArray(m));
            }
            return null;
        };
        // Conversion
        DateEnv.prototype.toDate = function (m, forcedTzo) {
            if (this.timeZone === 'local') {
                return arrayToLocalDate(dateToUtcArray(m));
            }
            else if (this.timeZone === 'UTC') {
                return new Date(m.valueOf()); // make sure it's a copy
            }
            else if (!this.namedTimeZoneImpl) {
                return new Date(m.valueOf() - (forcedTzo || 0));
            }
            else {
                return new Date(m.valueOf() -
                    this.namedTimeZoneImpl.offsetForArray(dateToUtcArray(m)) * 1000 * 60 // convert minutes -> ms
                );
            }
        };
        return DateEnv;
    }());

    var SIMPLE_SOURCE_PROPS = {
        id: String,
        allDayDefault: Boolean,
        eventDataTransform: Function,
        success: Function,
        failure: Function
    };
    var uid$2 = 0;
    function doesSourceNeedRange(eventSource, calendar) {
        var defs = calendar.pluginSystem.hooks.eventSourceDefs;
        return !defs[eventSource.sourceDefId].ignoreRange;
    }
    function parseEventSource(raw, calendar) {
        var defs = calendar.pluginSystem.hooks.eventSourceDefs;
        for (var i = defs.length - 1; i >= 0; i--) { // later-added plugins take precedence
            var def = defs[i];
            var meta = def.parseMeta(raw);
            if (meta) {
                var res = parseEventSourceProps(typeof raw === 'object' ? raw : {}, meta, i, calendar);
                res._raw = raw;
                return res;
            }
        }
        return null;
    }
    function parseEventSourceProps(raw, meta, sourceDefId, calendar) {
        var leftovers0 = {};
        var props = refineProps(raw, SIMPLE_SOURCE_PROPS, {}, leftovers0);
        var leftovers1 = {};
        var ui = processUnscopedUiProps(leftovers0, calendar, leftovers1);
        props.isFetching = false;
        props.latestFetchId = '';
        props.fetchRange = null;
        props.publicId = String(raw.id || '');
        props.sourceId = String(uid$2++);
        props.sourceDefId = sourceDefId;
        props.meta = meta;
        props.ui = ui;
        props.extendedProps = leftovers1;
        return props;
    }

    function reduceEventSources (eventSources, action, dateProfile, calendar) {
        switch (action.type) {
            case 'ADD_EVENT_SOURCES': // already parsed
                return addSources(eventSources, action.sources, dateProfile ? dateProfile.activeRange : null, calendar);
            case 'REMOVE_EVENT_SOURCE':
                return removeSource(eventSources, action.sourceId);
            case 'PREV': // TODO: how do we track all actions that affect dateProfile :(
            case 'NEXT':
            case 'SET_DATE':
            case 'SET_VIEW_TYPE':
                if (dateProfile) {
                    return fetchDirtySources(eventSources, dateProfile.activeRange, calendar);
                }
                else {
                    return eventSources;
                }
            case 'FETCH_EVENT_SOURCES':
            case 'CHANGE_TIMEZONE':
                return fetchSourcesByIds(eventSources, action.sourceIds ?
                    arrayToHash(action.sourceIds) :
                    excludeStaticSources(eventSources, calendar), dateProfile ? dateProfile.activeRange : null, calendar);
            case 'RECEIVE_EVENTS':
            case 'RECEIVE_EVENT_ERROR':
                return receiveResponse(eventSources, action.sourceId, action.fetchId, action.fetchRange);
            case 'REMOVE_ALL_EVENT_SOURCES':
                return {};
            default:
                return eventSources;
        }
    }
    var uid$3 = 0;
    function addSources(eventSourceHash, sources, fetchRange, calendar) {
        var hash = {};
        for (var _i = 0, sources_1 = sources; _i < sources_1.length; _i++) {
            var source = sources_1[_i];
            hash[source.sourceId] = source;
        }
        if (fetchRange) {
            hash = fetchDirtySources(hash, fetchRange, calendar);
        }
        return __assign({}, eventSourceHash, hash);
    }
    function removeSource(eventSourceHash, sourceId) {
        return filterHash(eventSourceHash, function (eventSource) {
            return eventSource.sourceId !== sourceId;
        });
    }
    function fetchDirtySources(sourceHash, fetchRange, calendar) {
        return fetchSourcesByIds(sourceHash, filterHash(sourceHash, function (eventSource) {
            return isSourceDirty(eventSource, fetchRange, calendar);
        }), fetchRange, calendar);
    }
    function isSourceDirty(eventSource, fetchRange, calendar) {
        if (!doesSourceNeedRange(eventSource, calendar)) {
            return !eventSource.latestFetchId;
        }
        else {
            return !calendar.opt('lazyFetching') ||
                !eventSource.fetchRange ||
                fetchRange.start < eventSource.fetchRange.start ||
                fetchRange.end > eventSource.fetchRange.end;
        }
    }
    function fetchSourcesByIds(prevSources, sourceIdHash, fetchRange, calendar) {
        var nextSources = {};
        for (var sourceId in prevSources) {
            var source = prevSources[sourceId];
            if (sourceIdHash[sourceId]) {
                nextSources[sourceId] = fetchSource(source, fetchRange, calendar);
            }
            else {
                nextSources[sourceId] = source;
            }
        }
        return nextSources;
    }
    function fetchSource(eventSource, fetchRange, calendar) {
        var sourceDef = calendar.pluginSystem.hooks.eventSourceDefs[eventSource.sourceDefId];
        var fetchId = String(uid$3++);
        sourceDef.fetch({
            eventSource: eventSource,
            calendar: calendar,
            range: fetchRange
        }, function (res) {
            var rawEvents = res.rawEvents;
            var calSuccess = calendar.opt('eventSourceSuccess');
            var calSuccessRes;
            var sourceSuccessRes;
            if (eventSource.success) {
                sourceSuccessRes = eventSource.success(rawEvents, res.xhr);
            }
            if (calSuccess) {
                calSuccessRes = calSuccess(rawEvents, res.xhr);
            }
            rawEvents = sourceSuccessRes || calSuccessRes || rawEvents;
            calendar.dispatch({
                type: 'RECEIVE_EVENTS',
                sourceId: eventSource.sourceId,
                fetchId: fetchId,
                fetchRange: fetchRange,
                rawEvents: rawEvents
            });
        }, function (error) {
            var callFailure = calendar.opt('eventSourceFailure');
            console.warn(error.message, error);
            if (eventSource.failure) {
                eventSource.failure(error);
            }
            if (callFailure) {
                callFailure(error);
            }
            calendar.dispatch({
                type: 'RECEIVE_EVENT_ERROR',
                sourceId: eventSource.sourceId,
                fetchId: fetchId,
                fetchRange: fetchRange,
                error: error
            });
        });
        return __assign({}, eventSource, { isFetching: true, latestFetchId: fetchId });
    }
    function receiveResponse(sourceHash, sourceId, fetchId, fetchRange) {
        var _a;
        var eventSource = sourceHash[sourceId];
        if (eventSource && // not already removed
            fetchId === eventSource.latestFetchId) {
            return __assign({}, sourceHash, (_a = {}, _a[sourceId] = __assign({}, eventSource, { isFetching: false, fetchRange: fetchRange }), _a));
        }
        return sourceHash;
    }
    function excludeStaticSources(eventSources, calendar) {
        return filterHash(eventSources, function (eventSource) {
            return doesSourceNeedRange(eventSource, calendar);
        });
    }

    var DateProfileGenerator = /** @class */ (function () {
        function DateProfileGenerator(viewSpec, calendar) {
            this.viewSpec = viewSpec;
            this.options = viewSpec.options;
            this.dateEnv = calendar.dateEnv;
            this.calendar = calendar;
            this.initHiddenDays();
        }
        /* Date Range Computation
        ------------------------------------------------------------------------------------------------------------------*/
        // Builds a structure with info about what the dates/ranges will be for the "prev" view.
        DateProfileGenerator.prototype.buildPrev = function (currentDateProfile, currentDate) {
            var dateEnv = this.dateEnv;
            var prevDate = dateEnv.subtract(dateEnv.startOf(currentDate, currentDateProfile.currentRangeUnit), // important for start-of-month
            currentDateProfile.dateIncrement);
            return this.build(prevDate, -1);
        };
        // Builds a structure with info about what the dates/ranges will be for the "next" view.
        DateProfileGenerator.prototype.buildNext = function (currentDateProfile, currentDate) {
            var dateEnv = this.dateEnv;
            var nextDate = dateEnv.add(dateEnv.startOf(currentDate, currentDateProfile.currentRangeUnit), // important for start-of-month
            currentDateProfile.dateIncrement);
            return this.build(nextDate, 1);
        };
        // Builds a structure holding dates/ranges for rendering around the given date.
        // Optional direction param indicates whether the date is being incremented/decremented
        // from its previous value. decremented = -1, incremented = 1 (default).
        DateProfileGenerator.prototype.build = function (currentDate, direction, forceToValid) {
            if (forceToValid === void 0) { forceToValid = false; }
            var validRange;
            var minTime = null;
            var maxTime = null;
            var currentInfo;
            var isRangeAllDay;
            var renderRange;
            var activeRange;
            var isValid;
            validRange = this.buildValidRange();
            validRange = this.trimHiddenDays(validRange);
            if (forceToValid) {
                currentDate = constrainMarkerToRange(currentDate, validRange);
            }
            currentInfo = this.buildCurrentRangeInfo(currentDate, direction);
            isRangeAllDay = /^(year|month|week|day)$/.test(currentInfo.unit);
            renderRange = this.buildRenderRange(this.trimHiddenDays(currentInfo.range), currentInfo.unit, isRangeAllDay);
            renderRange = this.trimHiddenDays(renderRange);
            activeRange = renderRange;
            if (!this.options.showNonCurrentDates) {
                activeRange = intersectRanges(activeRange, currentInfo.range);
            }
            minTime = createDuration(this.options.minTime);
            maxTime = createDuration(this.options.maxTime);
            activeRange = this.adjustActiveRange(activeRange, minTime, maxTime);
            activeRange = intersectRanges(activeRange, validRange); // might return null
            // it's invalid if the originally requested date is not contained,
            // or if the range is completely outside of the valid range.
            isValid = rangesIntersect(currentInfo.range, validRange);
            return {
                // constraint for where prev/next operations can go and where events can be dragged/resized to.
                // an object with optional start and end properties.
                validRange: validRange,
                // range the view is formally responsible for.
                // for example, a month view might have 1st-31st, excluding padded dates
                currentRange: currentInfo.range,
                // name of largest unit being displayed, like "month" or "week"
                currentRangeUnit: currentInfo.unit,
                isRangeAllDay: isRangeAllDay,
                // dates that display events and accept drag-n-drop
                // will be `null` if no dates accept events
                activeRange: activeRange,
                // date range with a rendered skeleton
                // includes not-active days that need some sort of DOM
                renderRange: renderRange,
                // Duration object that denotes the first visible time of any given day
                minTime: minTime,
                // Duration object that denotes the exclusive visible end time of any given day
                maxTime: maxTime,
                isValid: isValid,
                // how far the current date will move for a prev/next operation
                dateIncrement: this.buildDateIncrement(currentInfo.duration)
                // pass a fallback (might be null) ^
            };
        };
        // Builds an object with optional start/end properties.
        // Indicates the minimum/maximum dates to display.
        // not responsible for trimming hidden days.
        DateProfileGenerator.prototype.buildValidRange = function () {
            return this.getRangeOption('validRange', this.calendar.getNow()) ||
                { start: null, end: null }; // completely open-ended
        };
        // Builds a structure with info about the "current" range, the range that is
        // highlighted as being the current month for example.
        // See build() for a description of `direction`.
        // Guaranteed to have `range` and `unit` properties. `duration` is optional.
        DateProfileGenerator.prototype.buildCurrentRangeInfo = function (date, direction) {
            var _a = this, viewSpec = _a.viewSpec, dateEnv = _a.dateEnv;
            var duration = null;
            var unit = null;
            var range = null;
            var dayCount;
            if (viewSpec.duration) {
                duration = viewSpec.duration;
                unit = viewSpec.durationUnit;
                range = this.buildRangeFromDuration(date, direction, duration, unit);
            }
            else if ((dayCount = this.options.dayCount)) {
                unit = 'day';
                range = this.buildRangeFromDayCount(date, direction, dayCount);
            }
            else if ((range = this.buildCustomVisibleRange(date))) {
                unit = dateEnv.greatestWholeUnit(range.start, range.end).unit;
            }
            else {
                duration = this.getFallbackDuration();
                unit = greatestDurationDenominator(duration).unit;
                range = this.buildRangeFromDuration(date, direction, duration, unit);
            }
            return { duration: duration, unit: unit, range: range };
        };
        DateProfileGenerator.prototype.getFallbackDuration = function () {
            return createDuration({ day: 1 });
        };
        // Returns a new activeRange to have time values (un-ambiguate)
        // minTime or maxTime causes the range to expand.
        DateProfileGenerator.prototype.adjustActiveRange = function (range, minTime, maxTime) {
            var dateEnv = this.dateEnv;
            var start = range.start;
            var end = range.end;
            if (this.viewSpec.class.prototype.usesMinMaxTime) {
                // expand active range if minTime is negative (why not when positive?)
                if (asRoughDays(minTime) < 0) {
                    start = startOfDay(start); // necessary?
                    start = dateEnv.add(start, minTime);
                }
                // expand active range if maxTime is beyond one day (why not when positive?)
                if (asRoughDays(maxTime) > 1) {
                    end = startOfDay(end); // necessary?
                    end = addDays(end, -1);
                    end = dateEnv.add(end, maxTime);
                }
            }
            return { start: start, end: end };
        };
        // Builds the "current" range when it is specified as an explicit duration.
        // `unit` is the already-computed greatestDurationDenominator unit of duration.
        DateProfileGenerator.prototype.buildRangeFromDuration = function (date, direction, duration, unit) {
            var dateEnv = this.dateEnv;
            var alignment = this.options.dateAlignment;
            var dateIncrementInput;
            var dateIncrementDuration;
            var start;
            var end;
            var res;
            // compute what the alignment should be
            if (!alignment) {
                dateIncrementInput = this.options.dateIncrement;
                if (dateIncrementInput) {
                    dateIncrementDuration = createDuration(dateIncrementInput);
                    // use the smaller of the two units
                    if (asRoughMs(dateIncrementDuration) < asRoughMs(duration)) {
                        alignment = greatestDurationDenominator(dateIncrementDuration, !getWeeksFromInput(dateIncrementInput)).unit;
                    }
                    else {
                        alignment = unit;
                    }
                }
                else {
                    alignment = unit;
                }
            }
            // if the view displays a single day or smaller
            if (asRoughDays(duration) <= 1) {
                if (this.isHiddenDay(start)) {
                    start = this.skipHiddenDays(start, direction);
                    start = startOfDay(start);
                }
            }
            function computeRes() {
                start = dateEnv.startOf(date, alignment);
                end = dateEnv.add(start, duration);
                res = { start: start, end: end };
            }
            computeRes();
            // if range is completely enveloped by hidden days, go past the hidden days
            if (!this.trimHiddenDays(res)) {
                date = this.skipHiddenDays(date, direction);
                computeRes();
            }
            return res;
        };
        // Builds the "current" range when a dayCount is specified.
        DateProfileGenerator.prototype.buildRangeFromDayCount = function (date, direction, dayCount) {
            var dateEnv = this.dateEnv;
            var customAlignment = this.options.dateAlignment;
            var runningCount = 0;
            var start = date;
            var end;
            if (customAlignment) {
                start = dateEnv.startOf(start, customAlignment);
            }
            start = startOfDay(start);
            start = this.skipHiddenDays(start, direction);
            end = start;
            do {
                end = addDays(end, 1);
                if (!this.isHiddenDay(end)) {
                    runningCount++;
                }
            } while (runningCount < dayCount);
            return { start: start, end: end };
        };
        // Builds a normalized range object for the "visible" range,
        // which is a way to define the currentRange and activeRange at the same time.
        DateProfileGenerator.prototype.buildCustomVisibleRange = function (date) {
            var dateEnv = this.dateEnv;
            var visibleRange = this.getRangeOption('visibleRange', dateEnv.toDate(date));
            if (visibleRange && (visibleRange.start == null || visibleRange.end == null)) {
                return null;
            }
            return visibleRange;
        };
        // Computes the range that will represent the element/cells for *rendering*,
        // but which may have voided days/times.
        // not responsible for trimming hidden days.
        DateProfileGenerator.prototype.buildRenderRange = function (currentRange, currentRangeUnit, isRangeAllDay) {
            return currentRange;
        };
        // Compute the duration value that should be added/substracted to the current date
        // when a prev/next operation happens.
        DateProfileGenerator.prototype.buildDateIncrement = function (fallback) {
            var dateIncrementInput = this.options.dateIncrement;
            var customAlignment;
            if (dateIncrementInput) {
                return createDuration(dateIncrementInput);
            }
            else if ((customAlignment = this.options.dateAlignment)) {
                return createDuration(1, customAlignment);
            }
            else if (fallback) {
                return fallback;
            }
            else {
                return createDuration({ days: 1 });
            }
        };
        // Arguments after name will be forwarded to a hypothetical function value
        // WARNING: passed-in arguments will be given to generator functions as-is and can cause side-effects.
        // Always clone your objects if you fear mutation.
        DateProfileGenerator.prototype.getRangeOption = function (name) {
            var otherArgs = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                otherArgs[_i - 1] = arguments[_i];
            }
            var val = this.options[name];
            if (typeof val === 'function') {
                val = val.apply(null, otherArgs);
            }
            if (val) {
                val = parseRange(val, this.dateEnv);
            }
            if (val) {
                val = computeVisibleDayRange(val);
            }
            return val;
        };
        /* Hidden Days
        ------------------------------------------------------------------------------------------------------------------*/
        // Initializes internal variables related to calculating hidden days-of-week
        DateProfileGenerator.prototype.initHiddenDays = function () {
            var hiddenDays = this.options.hiddenDays || []; // array of day-of-week indices that are hidden
            var isHiddenDayHash = []; // is the day-of-week hidden? (hash with day-of-week-index -> bool)
            var dayCnt = 0;
            var i;
            if (this.options.weekends === false) {
                hiddenDays.push(0, 6); // 0=sunday, 6=saturday
            }
            for (i = 0; i < 7; i++) {
                if (!(isHiddenDayHash[i] = hiddenDays.indexOf(i) !== -1)) {
                    dayCnt++;
                }
            }
            if (!dayCnt) {
                throw new Error('invalid hiddenDays'); // all days were hidden? bad.
            }
            this.isHiddenDayHash = isHiddenDayHash;
        };
        // Remove days from the beginning and end of the range that are computed as hidden.
        // If the whole range is trimmed off, returns null
        DateProfileGenerator.prototype.trimHiddenDays = function (range) {
            var start = range.start;
            var end = range.end;
            if (start) {
                start = this.skipHiddenDays(start);
            }
            if (end) {
                end = this.skipHiddenDays(end, -1, true);
            }
            if (start == null || end == null || start < end) {
                return { start: start, end: end };
            }
            return null;
        };
        // Is the current day hidden?
        // `day` is a day-of-week index (0-6), or a Date (used for UTC)
        DateProfileGenerator.prototype.isHiddenDay = function (day) {
            if (day instanceof Date) {
                day = day.getUTCDay();
            }
            return this.isHiddenDayHash[day];
        };
        // Incrementing the current day until it is no longer a hidden day, returning a copy.
        // DOES NOT CONSIDER validRange!
        // If the initial value of `date` is not a hidden day, don't do anything.
        // Pass `isExclusive` as `true` if you are dealing with an end date.
        // `inc` defaults to `1` (increment one day forward each time)
        DateProfileGenerator.prototype.skipHiddenDays = function (date, inc, isExclusive) {
            if (inc === void 0) { inc = 1; }
            if (isExclusive === void 0) { isExclusive = false; }
            while (this.isHiddenDayHash[(date.getUTCDay() + (isExclusive ? inc : 0) + 7) % 7]) {
                date = addDays(date, inc);
            }
            return date;
        };
        return DateProfileGenerator;
    }());
    // TODO: find a way to avoid comparing DateProfiles. it's tedious
    function isDateProfilesEqual(p0, p1) {
        return rangesEqual(p0.validRange, p1.validRange) &&
            rangesEqual(p0.activeRange, p1.activeRange) &&
            rangesEqual(p0.renderRange, p1.renderRange) &&
            durationsEqual(p0.minTime, p1.minTime) &&
            durationsEqual(p0.maxTime, p1.maxTime);
        /*
        TODO: compare more?
          currentRange: DateRange
          currentRangeUnit: string
          isRangeAllDay: boolean
          isValid: boolean
          dateIncrement: Duration
        */
    }

    function reduce (state, action, calendar) {
        var viewType = reduceViewType(state.viewType, action);
        var dateProfile = reduceDateProfile(state.dateProfile, action, state.currentDate, viewType, calendar);
        var eventSources = reduceEventSources(state.eventSources, action, dateProfile, calendar);
        var nextState = __assign({}, state, { viewType: viewType,
            dateProfile: dateProfile, currentDate: reduceCurrentDate(state.currentDate, action, dateProfile), eventSources: eventSources, eventStore: reduceEventStore(state.eventStore, action, eventSources, dateProfile, calendar), dateSelection: reduceDateSelection(state.dateSelection, action, calendar), eventSelection: reduceSelectedEvent(state.eventSelection, action), eventDrag: reduceEventDrag(state.eventDrag, action, eventSources, calendar), eventResize: reduceEventResize(state.eventResize, action, eventSources, calendar), eventSourceLoadingLevel: computeLoadingLevel(eventSources), loadingLevel: computeLoadingLevel(eventSources) });
        for (var _i = 0, _a = calendar.pluginSystem.hooks.reducers; _i < _a.length; _i++) {
            var reducerFunc = _a[_i];
            nextState = reducerFunc(nextState, action, calendar);
        }
        // console.log(action.type, nextState)
        return nextState;
    }
    function reduceViewType(currentViewType, action) {
        switch (action.type) {
            case 'SET_VIEW_TYPE':
                return action.viewType;
            default:
                return currentViewType;
        }
    }
    function reduceDateProfile(currentDateProfile, action, currentDate, viewType, calendar) {
        var newDateProfile;
        switch (action.type) {
            case 'PREV':
                newDateProfile = calendar.dateProfileGenerators[viewType].buildPrev(currentDateProfile, currentDate);
                break;
            case 'NEXT':
                newDateProfile = calendar.dateProfileGenerators[viewType].buildNext(currentDateProfile, currentDate);
                break;
            case 'SET_DATE':
                if (!currentDateProfile.activeRange ||
                    !rangeContainsMarker(currentDateProfile.currentRange, action.dateMarker)) {
                    newDateProfile = calendar.dateProfileGenerators[viewType].build(action.dateMarker, undefined, true // forceToValid
                    );
                }
                break;
            case 'SET_VIEW_TYPE':
                var generator = calendar.dateProfileGenerators[viewType];
                if (!generator) {
                    throw new Error(viewType ?
                        'The FullCalendar view "' + viewType + '" does not exist. Make sure your plugins are loaded correctly.' :
                        'No available FullCalendar view plugins.');
                }
                newDateProfile = generator.build(action.dateMarker || currentDate, undefined, true // forceToValid
                );
                break;
        }
        if (newDateProfile &&
            newDateProfile.isValid &&
            !(currentDateProfile && isDateProfilesEqual(currentDateProfile, newDateProfile))) {
            return newDateProfile;
        }
        else {
            return currentDateProfile;
        }
    }
    function reduceCurrentDate(currentDate, action, dateProfile) {
        switch (action.type) {
            case 'PREV':
            case 'NEXT':
                if (!rangeContainsMarker(dateProfile.currentRange, currentDate)) {
                    return dateProfile.currentRange.start;
                }
                else {
                    return currentDate;
                }
            case 'SET_DATE':
            case 'SET_VIEW_TYPE':
                var newDate = action.dateMarker || currentDate;
                if (dateProfile.activeRange && !rangeContainsMarker(dateProfile.activeRange, newDate)) {
                    return dateProfile.currentRange.start;
                }
                else {
                    return newDate;
                }
            default:
                return currentDate;
        }
    }
    function reduceDateSelection(currentSelection, action, calendar) {
        switch (action.type) {
            case 'SELECT_DATES':
                return action.selection;
            case 'UNSELECT_DATES':
                return null;
            default:
                return currentSelection;
        }
    }
    function reduceSelectedEvent(currentInstanceId, action) {
        switch (action.type) {
            case 'SELECT_EVENT':
                return action.eventInstanceId;
            case 'UNSELECT_EVENT':
                return '';
            default:
                return currentInstanceId;
        }
    }
    function reduceEventDrag(currentDrag, action, sources, calendar) {
        switch (action.type) {
            case 'SET_EVENT_DRAG':
                var newDrag = action.state;
                return {
                    affectedEvents: newDrag.affectedEvents,
                    mutatedEvents: newDrag.mutatedEvents,
                    isEvent: newDrag.isEvent,
                    origSeg: newDrag.origSeg
                };
            case 'UNSET_EVENT_DRAG':
                return null;
            default:
                return currentDrag;
        }
    }
    function reduceEventResize(currentResize, action, sources, calendar) {
        switch (action.type) {
            case 'SET_EVENT_RESIZE':
                var newResize = action.state;
                return {
                    affectedEvents: newResize.affectedEvents,
                    mutatedEvents: newResize.mutatedEvents,
                    isEvent: newResize.isEvent,
                    origSeg: newResize.origSeg
                };
            case 'UNSET_EVENT_RESIZE':
                return null;
            default:
                return currentResize;
        }
    }
    function computeLoadingLevel(eventSources) {
        var cnt = 0;
        for (var sourceId in eventSources) {
            if (eventSources[sourceId].isFetching) {
                cnt++;
            }
        }
        return cnt;
    }

    var STANDARD_PROPS = {
        start: null,
        end: null,
        allDay: Boolean
    };
    function parseDateSpan(raw, dateEnv, defaultDuration) {
        var span = parseOpenDateSpan(raw, dateEnv);
        var range = span.range;
        if (!range.start) {
            return null;
        }
        if (!range.end) {
            if (defaultDuration == null) {
                return null;
            }
            else {
                range.end = dateEnv.add(range.start, defaultDuration);
            }
        }
        return span;
    }
    /*
    TODO: somehow combine with parseRange?
    Will return null if the start/end props were present but parsed invalidly.
    */
    function parseOpenDateSpan(raw, dateEnv) {
        var leftovers = {};
        var standardProps = refineProps(raw, STANDARD_PROPS, {}, leftovers);
        var startMeta = standardProps.start ? dateEnv.createMarkerMeta(standardProps.start) : null;
        var endMeta = standardProps.end ? dateEnv.createMarkerMeta(standardProps.end) : null;
        var allDay = standardProps.allDay;
        if (allDay == null) {
            allDay = (startMeta && startMeta.isTimeUnspecified) &&
                (!endMeta || endMeta.isTimeUnspecified);
        }
        // use this leftover object as the selection object
        leftovers.range = {
            start: startMeta ? startMeta.marker : null,
            end: endMeta ? endMeta.marker : null
        };
        leftovers.allDay = allDay;
        return leftovers;
    }
    function isDateSpansEqual(span0, span1) {
        return rangesEqual(span0.range, span1.range) &&
            span0.allDay === span1.allDay &&
            isSpanPropsEqual(span0, span1);
    }
    // the NON-DATE-RELATED props
    function isSpanPropsEqual(span0, span1) {
        for (var propName in span1) {
            if (propName !== 'range' && propName !== 'allDay') {
                if (span0[propName] !== span1[propName]) {
                    return false;
                }
            }
        }
        // are there any props that span0 has that span1 DOESN'T have?
        // both have range/allDay, so no need to special-case.
        for (var propName in span0) {
            if (!(propName in span1)) {
                return false;
            }
        }
        return true;
    }
    function buildDateSpanApi(span, dateEnv) {
        return {
            start: dateEnv.toDate(span.range.start),
            end: dateEnv.toDate(span.range.end),
            startStr: dateEnv.formatIso(span.range.start, { omitTime: span.allDay }),
            endStr: dateEnv.formatIso(span.range.end, { omitTime: span.allDay }),
            allDay: span.allDay
        };
    }
    function buildDatePointApi(span, dateEnv) {
        return {
            date: dateEnv.toDate(span.range.start),
            dateStr: dateEnv.formatIso(span.range.start, { omitTime: span.allDay }),
            allDay: span.allDay
        };
    }
    function fabricateEventRange(dateSpan, eventUiBases, calendar) {
        var def = parseEventDef({ editable: false }, '', // sourceId
        dateSpan.allDay, true, // hasEnd
        calendar);
        return {
            def: def,
            ui: compileEventUi(def, eventUiBases),
            instance: createEventInstance(def.defId, dateSpan.range),
            range: dateSpan.range,
            isStart: true,
            isEnd: true
        };
    }

    function compileViewDefs(defaultConfigs, overrideConfigs) {
        var hash = {};
        var viewType;
        for (viewType in defaultConfigs) {
            ensureViewDef(viewType, hash, defaultConfigs, overrideConfigs);
        }
        for (viewType in overrideConfigs) {
            ensureViewDef(viewType, hash, defaultConfigs, overrideConfigs);
        }
        return hash;
    }
    function ensureViewDef(viewType, hash, defaultConfigs, overrideConfigs) {
        if (hash[viewType]) {
            return hash[viewType];
        }
        var viewDef = buildViewDef(viewType, hash, defaultConfigs, overrideConfigs);
        if (viewDef) {
            hash[viewType] = viewDef;
        }
        return viewDef;
    }
    function buildViewDef(viewType, hash, defaultConfigs, overrideConfigs) {
        var defaultConfig = defaultConfigs[viewType];
        var overrideConfig = overrideConfigs[viewType];
        var queryProp = function (name) {
            return (defaultConfig && defaultConfig[name] !== null) ? defaultConfig[name] :
                ((overrideConfig && overrideConfig[name] !== null) ? overrideConfig[name] : null);
        };
        var theClass = queryProp('class');
        var superType = queryProp('superType');
        if (!superType && theClass) {
            superType =
                findViewNameBySubclass(theClass, overrideConfigs) ||
                    findViewNameBySubclass(theClass, defaultConfigs);
        }
        var superDef = null;
        if (superType) {
            if (superType === viewType) {
                throw new Error('Can\'t have a custom view type that references itself');
            }
            superDef = ensureViewDef(superType, hash, defaultConfigs, overrideConfigs);
        }
        if (!theClass && superDef) {
            theClass = superDef.class;
        }
        if (!theClass) {
            return null; // don't throw a warning, might be settings for a single-unit view
        }
        return {
            type: viewType,
            class: theClass,
            defaults: __assign({}, (superDef ? superDef.defaults : {}), (defaultConfig ? defaultConfig.options : {})),
            overrides: __assign({}, (superDef ? superDef.overrides : {}), (overrideConfig ? overrideConfig.options : {}))
        };
    }
    function findViewNameBySubclass(viewSubclass, configs) {
        var superProto = Object.getPrototypeOf(viewSubclass.prototype);
        for (var viewType in configs) {
            var parsed = configs[viewType];
            // need DIRECT subclass, so instanceof won't do it
            if (parsed.class && parsed.class.prototype === superProto) {
                return viewType;
            }
        }
        return '';
    }

    function parseViewConfigs(inputs) {
        return mapHash(inputs, parseViewConfig);
    }
    var VIEW_DEF_PROPS = {
        type: String,
        class: null
    };
    function parseViewConfig(input) {
        if (typeof input === 'function') {
            input = { class: input };
        }
        var options = {};
        var props = refineProps(input, VIEW_DEF_PROPS, {}, options);
        return {
            superType: props.type,
            class: props.class,
            options: options
        };
    }

    function buildViewSpecs(defaultInputs, optionsManager) {
        var defaultConfigs = parseViewConfigs(defaultInputs);
        var overrideConfigs = parseViewConfigs(optionsManager.overrides.views);
        var viewDefs = compileViewDefs(defaultConfigs, overrideConfigs);
        return mapHash(viewDefs, function (viewDef) {
            return buildViewSpec(viewDef, overrideConfigs, optionsManager);
        });
    }
    function buildViewSpec(viewDef, overrideConfigs, optionsManager) {
        var durationInput = viewDef.overrides.duration ||
            viewDef.defaults.duration ||
            optionsManager.dynamicOverrides.duration ||
            optionsManager.overrides.duration;
        var duration = null;
        var durationUnit = '';
        var singleUnit = '';
        var singleUnitOverrides = {};
        if (durationInput) {
            duration = createDuration(durationInput);
            if (duration) { // valid?
                var denom = greatestDurationDenominator(duration, !getWeeksFromInput(durationInput));
                durationUnit = denom.unit;
                if (denom.value === 1) {
                    singleUnit = durationUnit;
                    singleUnitOverrides = overrideConfigs[durationUnit] ? overrideConfigs[durationUnit].options : {};
                }
            }
        }
        var queryButtonText = function (options) {
            var buttonTextMap = options.buttonText || {};
            var buttonTextKey = viewDef.defaults.buttonTextKey;
            if (buttonTextKey != null && buttonTextMap[buttonTextKey] != null) {
                return buttonTextMap[buttonTextKey];
            }
            if (buttonTextMap[viewDef.type] != null) {
                return buttonTextMap[viewDef.type];
            }
            if (buttonTextMap[singleUnit] != null) {
                return buttonTextMap[singleUnit];
            }
        };
        return {
            type: viewDef.type,
            class: viewDef.class,
            duration: duration,
            durationUnit: durationUnit,
            singleUnit: singleUnit,
            options: __assign({}, globalDefaults, viewDef.defaults, optionsManager.dirDefaults, optionsManager.localeDefaults, optionsManager.overrides, singleUnitOverrides, viewDef.overrides, optionsManager.dynamicOverrides),
            buttonTextOverride: queryButtonText(optionsManager.dynamicOverrides) ||
                queryButtonText(optionsManager.overrides) || // constructor-specified buttonText lookup hash takes precedence
                viewDef.overrides.buttonText,
            buttonTextDefault: queryButtonText(optionsManager.localeDefaults) ||
                queryButtonText(optionsManager.dirDefaults) ||
                viewDef.defaults.buttonText ||
                queryButtonText(globalDefaults) ||
                viewDef.type // fall back to given view name
        };
    }

    var Toolbar = /** @class */ (function (_super) {
        __extends(Toolbar, _super);
        function Toolbar(context, extraClassName) {
            var _this = _super.call(this, context) || this;
            _this._renderLayout = memoizeRendering(_this.renderLayout, _this.unrenderLayout);
            _this._updateTitle = memoizeRendering(_this.updateTitle, null, [_this._renderLayout]);
            _this._updateActiveButton = memoizeRendering(_this.updateActiveButton, null, [_this._renderLayout]);
            _this._updateToday = memoizeRendering(_this.updateToday, null, [_this._renderLayout]);
            _this._updatePrev = memoizeRendering(_this.updatePrev, null, [_this._renderLayout]);
            _this._updateNext = memoizeRendering(_this.updateNext, null, [_this._renderLayout]);
            _this.el = createElement('div', { className: 'fc-toolbar ' + extraClassName });
            return _this;
        }
        Toolbar.prototype.destroy = function () {
            _super.prototype.destroy.call(this);
            this._renderLayout.unrender(); // should unrender everything else
            removeElement(this.el);
        };
        Toolbar.prototype.render = function (props) {
            this._renderLayout(props.layout);
            this._updateTitle(props.title);
            this._updateActiveButton(props.activeButton);
            this._updateToday(props.isTodayEnabled);
            this._updatePrev(props.isPrevEnabled);
            this._updateNext(props.isNextEnabled);
        };
        Toolbar.prototype.renderLayout = function (layout) {
            var el = this.el;
            this.viewsWithButtons = [];
            appendToElement(el, this.renderSection('left', layout.left));
            appendToElement(el, this.renderSection('center', layout.center));
            appendToElement(el, this.renderSection('right', layout.right));
        };
        Toolbar.prototype.unrenderLayout = function () {
            this.el.innerHTML = '';
        };
        Toolbar.prototype.renderSection = function (position, buttonStr) {
            var _this = this;
            var _a = this, theme = _a.theme, calendar = _a.calendar;
            var optionsManager = calendar.optionsManager;
            var viewSpecs = calendar.viewSpecs;
            var sectionEl = createElement('div', { className: 'fc-' + position });
            var calendarCustomButtons = optionsManager.computed.customButtons || {};
            var calendarButtonTextOverrides = optionsManager.overrides.buttonText || {};
            var calendarButtonText = optionsManager.computed.buttonText || {};
            if (buttonStr) {
                buttonStr.split(' ').forEach(function (buttonGroupStr, i) {
                    var groupChildren = [];
                    var isOnlyButtons = true;
                    var groupEl;
                    buttonGroupStr.split(',').forEach(function (buttonName, j) {
                        var customButtonProps;
                        var viewSpec;
                        var buttonClick;
                        var buttonIcon; // only one of these will be set
                        var buttonText; // "
                        var buttonInnerHtml;
                        var buttonClasses;
                        var buttonEl;
                        var buttonAriaAttr;
                        if (buttonName === 'title') {
                            groupChildren.push(htmlToElement('<h2>&nbsp;</h2>')); // we always want it to take up height
                            isOnlyButtons = false;
                        }
                        else {
                            if ((customButtonProps = calendarCustomButtons[buttonName])) {
                                buttonClick = function (ev) {
                                    if (customButtonProps.click) {
                                        customButtonProps.click.call(buttonEl, ev);
                                    }
                                };
                                (buttonIcon = theme.getCustomButtonIconClass(customButtonProps)) ||
                                    (buttonIcon = theme.getIconClass(buttonName)) ||
                                    (buttonText = customButtonProps.text);
                            }
                            else if ((viewSpec = viewSpecs[buttonName])) {
                                _this.viewsWithButtons.push(buttonName);
                                buttonClick = function () {
                                    calendar.changeView(buttonName);
                                };
                                (buttonText = viewSpec.buttonTextOverride) ||
                                    (buttonIcon = theme.getIconClass(buttonName)) ||
                                    (buttonText = viewSpec.buttonTextDefault);
                            }
                            else if (calendar[buttonName]) { // a calendar method
                                buttonClick = function () {
                                    calendar[buttonName]();
                                };
                                (buttonText = calendarButtonTextOverrides[buttonName]) ||
                                    (buttonIcon = theme.getIconClass(buttonName)) ||
                                    (buttonText = calendarButtonText[buttonName]);
                                //            ^ everything else is considered default
                            }
                            if (buttonClick) {
                                buttonClasses = [
                                    'fc-' + buttonName + '-button',
                                    theme.getClass('button')
                                ];
                                if (buttonText) {
                                    buttonInnerHtml = htmlEscape(buttonText);
                                    buttonAriaAttr = '';
                                }
                                else if (buttonIcon) {
                                    buttonInnerHtml = "<span class='" + buttonIcon + "'></span>";
                                    buttonAriaAttr = ' aria-label="' + buttonName + '"';
                                }
                                buttonEl = htmlToElement(// type="button" so that it doesn't submit a form
                                '<button type="button" class="' + buttonClasses.join(' ') + '"' +
                                    buttonAriaAttr +
                                    '>' + buttonInnerHtml + '</button>');
                                buttonEl.addEventListener('click', buttonClick);
                                groupChildren.push(buttonEl);
                            }
                        }
                    });
                    if (groupChildren.length > 1) {
                        groupEl = document.createElement('div');
                        var buttonGroupClassName = theme.getClass('buttonGroup');
                        if (isOnlyButtons && buttonGroupClassName) {
                            groupEl.classList.add(buttonGroupClassName);
                        }
                        appendToElement(groupEl, groupChildren);
                        sectionEl.appendChild(groupEl);
                    }
                    else {
                        appendToElement(sectionEl, groupChildren); // 1 or 0 children
                    }
                });
            }
            return sectionEl;
        };
        Toolbar.prototype.updateToday = function (isTodayEnabled) {
            this.toggleButtonEnabled('today', isTodayEnabled);
        };
        Toolbar.prototype.updatePrev = function (isPrevEnabled) {
            this.toggleButtonEnabled('prev', isPrevEnabled);
        };
        Toolbar.prototype.updateNext = function (isNextEnabled) {
            this.toggleButtonEnabled('next', isNextEnabled);
        };
        Toolbar.prototype.updateTitle = function (text) {
            findElements(this.el, 'h2').forEach(function (titleEl) {
                titleEl.innerText = text;
            });
        };
        Toolbar.prototype.updateActiveButton = function (buttonName) {
            var className = this.theme.getClass('buttonActive');
            findElements(this.el, 'button').forEach(function (buttonEl) {
                if (buttonName && buttonEl.classList.contains('fc-' + buttonName + '-button')) {
                    buttonEl.classList.add(className);
                }
                else {
                    buttonEl.classList.remove(className);
                }
            });
        };
        Toolbar.prototype.toggleButtonEnabled = function (buttonName, bool) {
            findElements(this.el, '.fc-' + buttonName + '-button').forEach(function (buttonEl) {
                buttonEl.disabled = !bool;
            });
        };
        return Toolbar;
    }(Component));

    var CalendarComponent = /** @class */ (function (_super) {
        __extends(CalendarComponent, _super);
        function CalendarComponent(context, el) {
            var _this = _super.call(this, context) || this;
            _this._renderToolbars = memoizeRendering(_this.renderToolbars);
            _this.buildViewPropTransformers = memoize(buildViewPropTransformers);
            _this.el = el;
            prependToElement(el, _this.contentEl = createElement('div', { className: 'fc-view-container' }));
            var calendar = _this.calendar;
            for (var _i = 0, _a = calendar.pluginSystem.hooks.viewContainerModifiers; _i < _a.length; _i++) {
                var modifyViewContainer = _a[_i];
                modifyViewContainer(_this.contentEl, calendar);
            }
            _this.toggleElClassNames(true);
            _this.computeTitle = memoize(computeTitle);
            _this.parseBusinessHours = memoize(function (input) {
                return parseBusinessHours(input, _this.calendar);
            });
            return _this;
        }
        CalendarComponent.prototype.destroy = function () {
            if (this.header) {
                this.header.destroy();
            }
            if (this.footer) {
                this.footer.destroy();
            }
            if (this.view) {
                this.view.destroy();
            }
            removeElement(this.contentEl);
            this.toggleElClassNames(false);
            _super.prototype.destroy.call(this);
        };
        CalendarComponent.prototype.toggleElClassNames = function (bool) {
            var classList = this.el.classList;
            var dirClassName = 'fc-' + this.opt('dir');
            var themeClassName = this.theme.getClass('widget');
            if (bool) {
                classList.add('fc');
                classList.add(dirClassName);
                classList.add(themeClassName);
            }
            else {
                classList.remove('fc');
                classList.remove(dirClassName);
                classList.remove(themeClassName);
            }
        };
        CalendarComponent.prototype.render = function (props) {
            this.freezeHeight();
            var title = this.computeTitle(props.dateProfile, props.viewSpec.options);
            this._renderToolbars(props.viewSpec, props.dateProfile, props.currentDate, props.dateProfileGenerator, title);
            this.renderView(props, title);
            this.updateSize();
            this.thawHeight();
        };
        CalendarComponent.prototype.renderToolbars = function (viewSpec, dateProfile, currentDate, dateProfileGenerator, title) {
            var headerLayout = this.opt('header');
            var footerLayout = this.opt('footer');
            var now = this.calendar.getNow();
            var todayInfo = dateProfileGenerator.build(now);
            var prevInfo = dateProfileGenerator.buildPrev(dateProfile, currentDate);
            var nextInfo = dateProfileGenerator.buildNext(dateProfile, currentDate);
            var toolbarProps = {
                title: title,
                activeButton: viewSpec.type,
                isTodayEnabled: todayInfo.isValid && !rangeContainsMarker(dateProfile.currentRange, now),
                isPrevEnabled: prevInfo.isValid,
                isNextEnabled: nextInfo.isValid
            };
            if (headerLayout) {
                if (!this.header) {
                    this.header = new Toolbar(this.context, 'fc-header-toolbar');
                    prependToElement(this.el, this.header.el);
                }
                this.header.receiveProps(__assign({ layout: headerLayout }, toolbarProps));
            }
            else if (this.header) {
                this.header.destroy();
                this.header = null;
            }
            if (footerLayout) {
                if (!this.footer) {
                    this.footer = new Toolbar(this.context, 'fc-footer-toolbar');
                    appendToElement(this.el, this.footer.el);
                }
                this.footer.receiveProps(__assign({ layout: footerLayout }, toolbarProps));
            }
            else if (this.footer) {
                this.footer.destroy();
                this.footer = null;
            }
        };
        CalendarComponent.prototype.renderView = function (props, title) {
            var view = this.view;
            var viewSpec = props.viewSpec, dateProfileGenerator = props.dateProfileGenerator;
            if (!view || view.viewSpec !== viewSpec) {
                if (view) {
                    view.destroy();
                }
                view = this.view = new viewSpec['class']({
                    calendar: this.calendar,
                    view: null,
                    dateEnv: this.dateEnv,
                    theme: this.theme,
                    options: viewSpec.options
                }, viewSpec, dateProfileGenerator, this.contentEl);
            }
            else {
                view.addScroll(view.queryScroll());
            }
            view.title = title; // for the API
            var viewProps = {
                dateProfile: props.dateProfile,
                businessHours: this.parseBusinessHours(viewSpec.options.businessHours),
                eventStore: props.eventStore,
                eventUiBases: props.eventUiBases,
                dateSelection: props.dateSelection,
                eventSelection: props.eventSelection,
                eventDrag: props.eventDrag,
                eventResize: props.eventResize
            };
            var transformers = this.buildViewPropTransformers(this.calendar.pluginSystem.hooks.viewPropsTransformers);
            for (var _i = 0, transformers_1 = transformers; _i < transformers_1.length; _i++) {
                var transformer = transformers_1[_i];
                __assign(viewProps, transformer.transform(viewProps, viewSpec, props, view));
            }
            view.receiveProps(viewProps);
        };
        // Sizing
        // -----------------------------------------------------------------------------------------------------------------
        CalendarComponent.prototype.updateSize = function (isResize) {
            if (isResize === void 0) { isResize = false; }
            var view = this.view;
            if (isResize) {
                view.addScroll(view.queryScroll());
            }
            if (isResize || this.isHeightAuto == null) {
                this.computeHeightVars();
            }
            view.updateSize(isResize, this.viewHeight, this.isHeightAuto);
            view.updateNowIndicator(); // we need to guarantee this will run after updateSize
            view.popScroll(isResize);
        };
        CalendarComponent.prototype.computeHeightVars = function () {
            var calendar = this.calendar; // yuck. need to handle dynamic options
            var heightInput = calendar.opt('height');
            var contentHeightInput = calendar.opt('contentHeight');
            this.isHeightAuto = heightInput === 'auto' || contentHeightInput === 'auto';
            if (typeof contentHeightInput === 'number') { // exists and not 'auto'
                this.viewHeight = contentHeightInput;
            }
            else if (typeof contentHeightInput === 'function') { // exists and is a function
                this.viewHeight = contentHeightInput();
            }
            else if (typeof heightInput === 'number') { // exists and not 'auto'
                this.viewHeight = heightInput - this.queryToolbarsHeight();
            }
            else if (typeof heightInput === 'function') { // exists and is a function
                this.viewHeight = heightInput() - this.queryToolbarsHeight();
            }
            else if (heightInput === 'parent') { // set to height of parent element
                var parentEl = this.el.parentNode;
                this.viewHeight = parentEl.getBoundingClientRect().height - this.queryToolbarsHeight();
            }
            else {
                this.viewHeight = Math.round(this.contentEl.getBoundingClientRect().width /
                    Math.max(calendar.opt('aspectRatio'), .5));
            }
        };
        CalendarComponent.prototype.queryToolbarsHeight = function () {
            var height = 0;
            if (this.header) {
                height += computeHeightAndMargins(this.header.el);
            }
            if (this.footer) {
                height += computeHeightAndMargins(this.footer.el);
            }
            return height;
        };
        // Height "Freezing"
        // -----------------------------------------------------------------------------------------------------------------
        CalendarComponent.prototype.freezeHeight = function () {
            applyStyle(this.el, {
                height: this.el.getBoundingClientRect().height,
                overflow: 'hidden'
            });
        };
        CalendarComponent.prototype.thawHeight = function () {
            applyStyle(this.el, {
                height: '',
                overflow: ''
            });
        };
        return CalendarComponent;
    }(Component));
    // Title and Date Formatting
    // -----------------------------------------------------------------------------------------------------------------
    // Computes what the title at the top of the calendar should be for this view
    function computeTitle(dateProfile, viewOptions) {
        var range;
        // for views that span a large unit of time, show the proper interval, ignoring stray days before and after
        if (/^(year|month)$/.test(dateProfile.currentRangeUnit)) {
            range = dateProfile.currentRange;
        }
        else { // for day units or smaller, use the actual day range
            range = dateProfile.activeRange;
        }
        return this.dateEnv.formatRange(range.start, range.end, createFormatter(viewOptions.titleFormat || computeTitleFormat(dateProfile), viewOptions.titleRangeSeparator), { isEndExclusive: dateProfile.isRangeAllDay });
    }
    // Generates the format string that should be used to generate the title for the current date range.
    // Attempts to compute the most appropriate format if not explicitly specified with `titleFormat`.
    function computeTitleFormat(dateProfile) {
        var currentRangeUnit = dateProfile.currentRangeUnit;
        if (currentRangeUnit === 'year') {
            return { year: 'numeric' };
        }
        else if (currentRangeUnit === 'month') {
            return { year: 'numeric', month: 'long' }; // like "September 2014"
        }
        else {
            var days = diffWholeDays(dateProfile.currentRange.start, dateProfile.currentRange.end);
            if (days !== null && days > 1) {
                // multi-day range. shorter, like "Sep 9 - 10 2014"
                return { year: 'numeric', month: 'short', day: 'numeric' };
            }
            else {
                // one day. longer, like "September 9 2014"
                return { year: 'numeric', month: 'long', day: 'numeric' };
            }
        }
    }
    // Plugin
    // -----------------------------------------------------------------------------------------------------------------
    function buildViewPropTransformers(theClasses) {
        return theClasses.map(function (theClass) {
            return new theClass();
        });
    }

    var Interaction = /** @class */ (function () {
        function Interaction(settings) {
            this.component = settings.component;
        }
        Interaction.prototype.destroy = function () {
        };
        return Interaction;
    }());
    function parseInteractionSettings(component, input) {
        return {
            component: component,
            el: input.el,
            useEventCenter: input.useEventCenter != null ? input.useEventCenter : true
        };
    }
    function interactionSettingsToStore(settings) {
        var _a;
        return _a = {},
            _a[settings.component.uid] = settings,
            _a;
    }
    // global state
    var interactionSettingsStore = {};

    /*
    Detects when the user clicks on an event within a DateComponent
    */
    var EventClicking = /** @class */ (function (_super) {
        __extends(EventClicking, _super);
        function EventClicking(settings) {
            var _this = _super.call(this, settings) || this;
            _this.handleSegClick = function (ev, segEl) {
                var component = _this.component;
                var seg = getElSeg(segEl);
                if (seg && // might be the <div> surrounding the more link
                    component.isValidSegDownEl(ev.target)) {
                    // our way to simulate a link click for elements that can't be <a> tags
                    // grab before trigger fired in case trigger trashes DOM thru rerendering
                    var hasUrlContainer = elementClosest(ev.target, '.fc-has-url');
                    var url = hasUrlContainer ? hasUrlContainer.querySelector('a[href]').href : '';
                    component.publiclyTrigger('eventClick', [
                        {
                            el: segEl,
                            event: new EventApi(component.calendar, seg.eventRange.def, seg.eventRange.instance),
                            jsEvent: ev,
                            view: component.view
                        }
                    ]);
                    if (url && !ev.defaultPrevented) {
                        window.location.href = url;
                    }
                }
            };
            var component = settings.component;
            _this.destroy = listenBySelector(component.el, 'click', component.fgSegSelector + ',' + component.bgSegSelector, _this.handleSegClick);
            return _this;
        }
        return EventClicking;
    }(Interaction));

    /*
    Triggers events and adds/removes core classNames when the user's pointer
    enters/leaves event-elements of a component.
    */
    var EventHovering = /** @class */ (function (_super) {
        __extends(EventHovering, _super);
        function EventHovering(settings) {
            var _this = _super.call(this, settings) || this;
            // for simulating an eventMouseLeave when the event el is destroyed while mouse is over it
            _this.handleEventElRemove = function (el) {
                if (el === _this.currentSegEl) {
                    _this.handleSegLeave(null, _this.currentSegEl);
                }
            };
            _this.handleSegEnter = function (ev, segEl) {
                if (getElSeg(segEl)) { // TODO: better way to make sure not hovering over more+ link or its wrapper
                    segEl.classList.add('fc-allow-mouse-resize');
                    _this.currentSegEl = segEl;
                    _this.triggerEvent('eventMouseEnter', ev, segEl);
                }
            };
            _this.handleSegLeave = function (ev, segEl) {
                if (_this.currentSegEl) {
                    segEl.classList.remove('fc-allow-mouse-resize');
                    _this.currentSegEl = null;
                    _this.triggerEvent('eventMouseLeave', ev, segEl);
                }
            };
            var component = settings.component;
            _this.removeHoverListeners = listenToHoverBySelector(component.el, component.fgSegSelector + ',' + component.bgSegSelector, _this.handleSegEnter, _this.handleSegLeave);
            component.calendar.on('eventElRemove', _this.handleEventElRemove);
            return _this;
        }
        EventHovering.prototype.destroy = function () {
            this.removeHoverListeners();
            this.component.calendar.off('eventElRemove', this.handleEventElRemove);
        };
        EventHovering.prototype.triggerEvent = function (publicEvName, ev, segEl) {
            var component = this.component;
            var seg = getElSeg(segEl);
            if (!ev || component.isValidSegDownEl(ev.target)) {
                component.publiclyTrigger(publicEvName, [
                    {
                        el: segEl,
                        event: new EventApi(this.component.calendar, seg.eventRange.def, seg.eventRange.instance),
                        jsEvent: ev,
                        view: component.view
                    }
                ]);
            }
        };
        return EventHovering;
    }(Interaction));

    var StandardTheme = /** @class */ (function (_super) {
        __extends(StandardTheme, _super);
        function StandardTheme() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return StandardTheme;
    }(Theme));
    StandardTheme.prototype.classes = {
        widget: 'fc-unthemed',
        widgetHeader: 'fc-widget-header',
        widgetContent: 'fc-widget-content',
        buttonGroup: 'fc-button-group',
        button: 'fc-button fc-button-primary',
        buttonActive: 'fc-button-active',
        popoverHeader: 'fc-widget-header',
        popoverContent: 'fc-widget-content',
        // day grid
        headerRow: 'fc-widget-header',
        dayRow: 'fc-widget-content',
        // list view
        listView: 'fc-widget-content'
    };
    StandardTheme.prototype.baseIconClass = 'fc-icon';
    StandardTheme.prototype.iconClasses = {
        close: 'fc-icon-x',
        prev: 'fc-icon-chevron-left',
        next: 'fc-icon-chevron-right',
        prevYear: 'fc-icon-chevrons-left',
        nextYear: 'fc-icon-chevrons-right'
    };
    StandardTheme.prototype.iconOverrideOption = 'buttonIcons';
    StandardTheme.prototype.iconOverrideCustomButtonOption = 'icon';
    StandardTheme.prototype.iconOverridePrefix = 'fc-icon-';

    var Calendar = /** @class */ (function () {
        function Calendar(el, overrides) {
            var _this = this;
            this.parseRawLocales = memoize(parseRawLocales);
            this.buildLocale = memoize(buildLocale);
            this.buildDateEnv = memoize(buildDateEnv);
            this.buildTheme = memoize(buildTheme);
            this.buildEventUiSingleBase = memoize(this._buildEventUiSingleBase);
            this.buildSelectionConfig = memoize(this._buildSelectionConfig);
            this.buildEventUiBySource = memoizeOutput(buildEventUiBySource, isPropsEqual);
            this.buildEventUiBases = memoize(buildEventUiBases);
            this.interactionsStore = {};
            this.actionQueue = [];
            this.isReducing = false;
            // isDisplaying: boolean = false // installed in DOM? accepting renders?
            this.needsRerender = false; // needs a render?
            this.needsFullRerender = false;
            this.isRendering = false; // currently in the executeRender function?
            this.renderingPauseDepth = 0;
            this.buildDelayedRerender = memoize(buildDelayedRerender);
            this.afterSizingTriggers = {};
            this.isViewUpdated = false;
            this.isDatesUpdated = false;
            this.isEventsUpdated = false;
            this.el = el;
            this.optionsManager = new OptionsManager(overrides || {});
            this.pluginSystem = new PluginSystem();
            // only do once. don't do in handleOptions. because can't remove plugins
            this.addPluginInputs(this.optionsManager.computed.plugins || []);
            this.handleOptions(this.optionsManager.computed);
            this.publiclyTrigger('_init'); // for tests
            this.hydrate();
            this.calendarInteractions = this.pluginSystem.hooks.calendarInteractions
                .map(function (calendarInteractionClass) {
                return new calendarInteractionClass(_this);
            });
        }
        Calendar.prototype.addPluginInputs = function (pluginInputs) {
            var pluginDefs = refinePluginDefs(pluginInputs);
            for (var _i = 0, pluginDefs_1 = pluginDefs; _i < pluginDefs_1.length; _i++) {
                var pluginDef = pluginDefs_1[_i];
                this.pluginSystem.add(pluginDef);
            }
        };
        Object.defineProperty(Calendar.prototype, "view", {
            // public API
            get: function () {
                return this.component ? this.component.view : null;
            },
            enumerable: true,
            configurable: true
        });
        // Public API for rendering
        // -----------------------------------------------------------------------------------------------------------------
        Calendar.prototype.render = function () {
            if (!this.component) {
                this.renderableEventStore = createEmptyEventStore();
                this.bindHandlers();
                this.executeRender();
            }
            else {
                this.requestRerender(true);
            }
        };
        Calendar.prototype.destroy = function () {
            if (this.component) {
                this.unbindHandlers();
                this.component.destroy(); // don't null-out. in case API needs access
                this.component = null; // umm ???
                for (var _i = 0, _a = this.calendarInteractions; _i < _a.length; _i++) {
                    var interaction = _a[_i];
                    interaction.destroy();
                }
                this.publiclyTrigger('_destroyed');
            }
        };
        // Handlers
        // -----------------------------------------------------------------------------------------------------------------
        Calendar.prototype.bindHandlers = function () {
            var _this = this;
            // event delegation for nav links
            this.removeNavLinkListener = listenBySelector(this.el, 'click', 'a[data-goto]', function (ev, anchorEl) {
                var gotoOptions = anchorEl.getAttribute('data-goto');
                gotoOptions = gotoOptions ? JSON.parse(gotoOptions) : {};
                var dateEnv = _this.dateEnv;
                var dateMarker = dateEnv.createMarker(gotoOptions.date);
                var viewType = gotoOptions.type;
                // property like "navLinkDayClick". might be a string or a function
                var customAction = _this.viewOpt('navLink' + capitaliseFirstLetter(viewType) + 'Click');
                if (typeof customAction === 'function') {
                    customAction(dateEnv.toDate(dateMarker), ev);
                }
                else {
                    if (typeof customAction === 'string') {
                        viewType = customAction;
                    }
                    _this.zoomTo(dateMarker, viewType);
                }
            });
            if (this.opt('handleWindowResize')) {
                window.addEventListener('resize', this.windowResizeProxy = debounce(// prevents rapid calls
                this.windowResize.bind(this), this.opt('windowResizeDelay')));
            }
        };
        Calendar.prototype.unbindHandlers = function () {
            this.removeNavLinkListener();
            if (this.windowResizeProxy) {
                window.removeEventListener('resize', this.windowResizeProxy);
                this.windowResizeProxy = null;
            }
        };
        // Dispatcher
        // -----------------------------------------------------------------------------------------------------------------
        Calendar.prototype.hydrate = function () {
            var _this = this;
            this.state = this.buildInitialState();
            var rawSources = this.opt('eventSources') || [];
            var singleRawSource = this.opt('events');
            var sources = []; // parsed
            if (singleRawSource) {
                rawSources.unshift(singleRawSource);
            }
            for (var _i = 0, rawSources_1 = rawSources; _i < rawSources_1.length; _i++) {
                var rawSource = rawSources_1[_i];
                var source = parseEventSource(rawSource, this);
                if (source) {
                    sources.push(source);
                }
            }
            this.batchRendering(function () {
                _this.dispatch({ type: 'INIT' }); // pass in sources here?
                _this.dispatch({ type: 'ADD_EVENT_SOURCES', sources: sources });
                _this.dispatch({
                    type: 'SET_VIEW_TYPE',
                    viewType: _this.opt('defaultView') || _this.pluginSystem.hooks.defaultView
                });
            });
        };
        Calendar.prototype.buildInitialState = function () {
            return {
                viewType: null,
                loadingLevel: 0,
                eventSourceLoadingLevel: 0,
                currentDate: this.getInitialDate(),
                dateProfile: null,
                eventSources: {},
                eventStore: createEmptyEventStore(),
                dateSelection: null,
                eventSelection: '',
                eventDrag: null,
                eventResize: null
            };
        };
        Calendar.prototype.dispatch = function (action) {
            this.actionQueue.push(action);
            if (!this.isReducing) {
                this.isReducing = true;
                var oldState = this.state;
                while (this.actionQueue.length) {
                    this.state = this.reduce(this.state, this.actionQueue.shift(), this);
                }
                var newState = this.state;
                this.isReducing = false;
                if (!oldState.loadingLevel && newState.loadingLevel) {
                    this.publiclyTrigger('loading', [true]);
                }
                else if (oldState.loadingLevel && !newState.loadingLevel) {
                    this.publiclyTrigger('loading', [false]);
                }
                var view = this.component && this.component.view;
                if (oldState.eventStore !== newState.eventStore || this.needsFullRerender) {
                    if (oldState.eventStore) {
                        this.isEventsUpdated = true;
                    }
                }
                if (oldState.dateProfile !== newState.dateProfile || this.needsFullRerender) {
                    if (oldState.dateProfile && view) { // why would view be null!?
                        this.publiclyTrigger('datesDestroy', [
                            {
                                view: view,
                                el: view.el
                            }
                        ]);
                    }
                    this.isDatesUpdated = true;
                }
                if (oldState.viewType !== newState.viewType || this.needsFullRerender) {
                    if (oldState.viewType && view) { // why would view be null!?
                        this.publiclyTrigger('viewSkeletonDestroy', [
                            {
                                view: view,
                                el: view.el
                            }
                        ]);
                    }
                    this.isViewUpdated = true;
                }
                this.requestRerender();
            }
        };
        Calendar.prototype.reduce = function (state, action, calendar) {
            return reduce(state, action, calendar);
        };
        // Render Queue
        // -----------------------------------------------------------------------------------------------------------------
        Calendar.prototype.requestRerender = function (needsFull) {
            if (needsFull === void 0) { needsFull = false; }
            this.needsRerender = true;
            this.needsFullRerender = this.needsFullRerender || needsFull;
            this.delayedRerender(); // will call a debounced-version of tryRerender
        };
        Calendar.prototype.tryRerender = function () {
            if (this.component && // must be accepting renders
                this.needsRerender && // indicates that a rerender was requested
                !this.renderingPauseDepth && // not paused
                !this.isRendering // not currently in the render loop
            ) {
                this.executeRender();
            }
        };
        Calendar.prototype.batchRendering = function (func) {
            this.renderingPauseDepth++;
            func();
            this.renderingPauseDepth--;
            if (this.needsRerender) {
                this.requestRerender();
            }
        };
        // Rendering
        // -----------------------------------------------------------------------------------------------------------------
        Calendar.prototype.executeRender = function () {
            var needsFullRerender = this.needsFullRerender; // save before clearing
            // clear these BEFORE the render so that new values will accumulate during render
            this.needsRerender = false;
            this.needsFullRerender = false;
            this.isRendering = true;
            this.renderComponent(needsFullRerender);
            this.isRendering = false;
            // received a rerender request while rendering
            if (this.needsRerender) {
                this.delayedRerender();
            }
        };
        /*
        don't call this directly. use executeRender instead
        */
        Calendar.prototype.renderComponent = function (needsFull) {
            var _a = this, state = _a.state, component = _a.component;
            var viewType = state.viewType;
            var viewSpec = this.viewSpecs[viewType];
            var savedScroll = (needsFull && component) ? component.view.queryScroll() : null;
            if (!viewSpec) {
                throw new Error("View type \"" + viewType + "\" is not valid");
            }
            // if event sources are still loading and progressive rendering hasn't been enabled,
            // keep rendering the last fully loaded set of events
            var renderableEventStore = this.renderableEventStore =
                (state.eventSourceLoadingLevel && !this.opt('progressiveEventRendering')) ?
                    this.renderableEventStore :
                    state.eventStore;
            var eventUiSingleBase = this.buildEventUiSingleBase(viewSpec.options);
            var eventUiBySource = this.buildEventUiBySource(state.eventSources);
            var eventUiBases = this.eventUiBases = this.buildEventUiBases(renderableEventStore.defs, eventUiSingleBase, eventUiBySource);
            if (needsFull || !component) {
                if (component) {
                    component.freezeHeight(); // next component will unfreeze it
                    component.destroy();
                }
                component = this.component = new CalendarComponent({
                    calendar: this,
                    view: null,
                    dateEnv: this.dateEnv,
                    theme: this.theme,
                    options: this.optionsManager.computed
                }, this.el);
                this.isViewUpdated = true;
                this.isDatesUpdated = true;
                this.isEventsUpdated = true;
            }
            component.receiveProps(__assign({}, state, { viewSpec: viewSpec, dateProfile: state.dateProfile, dateProfileGenerator: this.dateProfileGenerators[viewType], eventStore: renderableEventStore, eventUiBases: eventUiBases, dateSelection: state.dateSelection, eventSelection: state.eventSelection, eventDrag: state.eventDrag, eventResize: state.eventResize }));
            if (savedScroll) {
                component.view.applyScroll(savedScroll, false);
            }
            if (this.isViewUpdated) {
                this.isViewUpdated = false;
                this.publiclyTrigger('viewSkeletonRender', [
                    {
                        view: component.view,
                        el: component.view.el
                    }
                ]);
            }
            if (this.isDatesUpdated) {
                this.isDatesUpdated = false;
                this.publiclyTrigger('datesRender', [
                    {
                        view: component.view,
                        el: component.view.el
                    }
                ]);
            }
            if (this.isEventsUpdated) {
                this.isEventsUpdated = false;
            }
            this.releaseAfterSizingTriggers();
        };
        // Options
        // -----------------------------------------------------------------------------------------------------------------
        Calendar.prototype.setOption = function (name, val) {
            var _a;
            this.mutateOptions((_a = {}, _a[name] = val, _a), [], true);
        };
        Calendar.prototype.getOption = function (name) {
            return this.optionsManager.computed[name];
        };
        Calendar.prototype.opt = function (name) {
            return this.optionsManager.computed[name];
        };
        Calendar.prototype.viewOpt = function (name) {
            return this.viewOpts()[name];
        };
        Calendar.prototype.viewOpts = function () {
            return this.viewSpecs[this.state.viewType].options;
        };
        /*
        handles option changes (like a diff)
        */
        Calendar.prototype.mutateOptions = function (updates, removals, isDynamic, deepEqual) {
            var _this = this;
            var changeHandlers = this.pluginSystem.hooks.optionChangeHandlers;
            var normalUpdates = {};
            var specialUpdates = {};
            var oldDateEnv = this.dateEnv; // do this before handleOptions
            var isTimeZoneDirty = false;
            var isSizeDirty = false;
            var anyDifficultOptions = Boolean(removals.length);
            for (var name_1 in updates) {
                if (changeHandlers[name_1]) {
                    specialUpdates[name_1] = updates[name_1];
                }
                else {
                    normalUpdates[name_1] = updates[name_1];
                }
            }
            for (var name_2 in normalUpdates) {
                if (/^(height|contentHeight|aspectRatio)$/.test(name_2)) {
                    isSizeDirty = true;
                }
                else if (/^(defaultDate|defaultView)$/.test(name_2)) ;
                else {
                    anyDifficultOptions = true;
                    if (name_2 === 'timeZone') {
                        isTimeZoneDirty = true;
                    }
                }
            }
            this.optionsManager.mutate(normalUpdates, removals, isDynamic);
            if (anyDifficultOptions) {
                this.handleOptions(this.optionsManager.computed);
                this.needsFullRerender = true;
            }
            this.batchRendering(function () {
                if (anyDifficultOptions) {
                    if (isTimeZoneDirty) {
                        _this.dispatch({
                            type: 'CHANGE_TIMEZONE',
                            oldDateEnv: oldDateEnv
                        });
                    }
                    /* HACK
                    has the same effect as calling this.requestRerender(true)
                    but recomputes the state's dateProfile
                    */
                    _this.dispatch({
                        type: 'SET_VIEW_TYPE',
                        viewType: _this.state.viewType
                    });
                }
                else if (isSizeDirty) {
                    _this.updateSize();
                }
                // special updates
                if (deepEqual) {
                    for (var name_3 in specialUpdates) {
                        changeHandlers[name_3](specialUpdates[name_3], _this, deepEqual);
                    }
                }
            });
        };
        /*
        rebuilds things based off of a complete set of refined options
        */
        Calendar.prototype.handleOptions = function (options) {
            var _this = this;
            var pluginHooks = this.pluginSystem.hooks;
            this.defaultAllDayEventDuration = createDuration(options.defaultAllDayEventDuration);
            this.defaultTimedEventDuration = createDuration(options.defaultTimedEventDuration);
            this.delayedRerender = this.buildDelayedRerender(options.rerenderDelay);
            this.theme = this.buildTheme(options);
            var available = this.parseRawLocales(options.locales);
            this.availableRawLocales = available.map;
            var locale = this.buildLocale(options.locale || available.defaultCode, available.map);
            this.dateEnv = this.buildDateEnv(locale, options.timeZone, pluginHooks.namedTimeZonedImpl, options.firstDay, options.weekNumberCalculation, options.weekLabel, pluginHooks.cmdFormatter);
            this.selectionConfig = this.buildSelectionConfig(options); // needs dateEnv. do after :(
            // ineffecient to do every time?
            this.viewSpecs = buildViewSpecs(pluginHooks.views, this.optionsManager);
            // ineffecient to do every time?
            this.dateProfileGenerators = mapHash(this.viewSpecs, function (viewSpec) {
                return new viewSpec.class.prototype.dateProfileGeneratorClass(viewSpec, _this);
            });
        };
        Calendar.prototype.getAvailableLocaleCodes = function () {
            return Object.keys(this.availableRawLocales);
        };
        Calendar.prototype._buildSelectionConfig = function (rawOpts) {
            return processScopedUiProps('select', rawOpts, this);
        };
        Calendar.prototype._buildEventUiSingleBase = function (rawOpts) {
            if (rawOpts.editable) { // so 'editable' affected events
                rawOpts = __assign({}, rawOpts, { eventEditable: true });
            }
            return processScopedUiProps('event', rawOpts, this);
        };
        // Trigger
        // -----------------------------------------------------------------------------------------------------------------
        Calendar.prototype.hasPublicHandlers = function (name) {
            return this.hasHandlers(name) ||
                this.opt(name); // handler specified in options
        };
        Calendar.prototype.publiclyTrigger = function (name, args) {
            var optHandler = this.opt(name);
            this.triggerWith(name, this, args);
            if (optHandler) {
                return optHandler.apply(this, args);
            }
        };
        Calendar.prototype.publiclyTriggerAfterSizing = function (name, args) {
            var afterSizingTriggers = this.afterSizingTriggers;
            (afterSizingTriggers[name] || (afterSizingTriggers[name] = [])).push(args);
        };
        Calendar.prototype.releaseAfterSizingTriggers = function () {
            var afterSizingTriggers = this.afterSizingTriggers;
            for (var name_4 in afterSizingTriggers) {
                for (var _i = 0, _a = afterSizingTriggers[name_4]; _i < _a.length; _i++) {
                    var args = _a[_i];
                    this.publiclyTrigger(name_4, args);
                }
            }
            this.afterSizingTriggers = {};
        };
        // View
        // -----------------------------------------------------------------------------------------------------------------
        // Returns a boolean about whether the view is okay to instantiate at some point
        Calendar.prototype.isValidViewType = function (viewType) {
            return Boolean(this.viewSpecs[viewType]);
        };
        Calendar.prototype.changeView = function (viewType, dateOrRange) {
            var dateMarker = null;
            if (dateOrRange) {
                if (dateOrRange.start && dateOrRange.end) { // a range
                    this.optionsManager.mutate({ visibleRange: dateOrRange }, []); // will not rerender
                    this.handleOptions(this.optionsManager.computed); // ...but yuck
                }
                else { // a date
                    dateMarker = this.dateEnv.createMarker(dateOrRange); // just like gotoDate
                }
            }
            this.unselect();
            this.dispatch({
                type: 'SET_VIEW_TYPE',
                viewType: viewType,
                dateMarker: dateMarker
            });
        };
        // Forces navigation to a view for the given date.
        // `viewType` can be a specific view name or a generic one like "week" or "day".
        // needs to change
        Calendar.prototype.zoomTo = function (dateMarker, viewType) {
            var spec;
            viewType = viewType || 'day'; // day is default zoom
            spec = this.viewSpecs[viewType] ||
                this.getUnitViewSpec(viewType);
            this.unselect();
            if (spec) {
                this.dispatch({
                    type: 'SET_VIEW_TYPE',
                    viewType: spec.type,
                    dateMarker: dateMarker
                });
            }
            else {
                this.dispatch({
                    type: 'SET_DATE',
                    dateMarker: dateMarker
                });
            }
        };
        // Given a duration singular unit, like "week" or "day", finds a matching view spec.
        // Preference is given to views that have corresponding buttons.
        Calendar.prototype.getUnitViewSpec = function (unit) {
            var component = this.component;
            var viewTypes = [];
            var i;
            var spec;
            // put views that have buttons first. there will be duplicates, but oh
            if (component.header) {
                viewTypes.push.apply(viewTypes, component.header.viewsWithButtons);
            }
            if (component.footer) {
                viewTypes.push.apply(viewTypes, component.footer.viewsWithButtons);
            }
            for (var viewType in this.viewSpecs) {
                viewTypes.push(viewType);
            }
            for (i = 0; i < viewTypes.length; i++) {
                spec = this.viewSpecs[viewTypes[i]];
                if (spec) {
                    if (spec.singleUnit === unit) {
                        return spec;
                    }
                }
            }
        };
        // Current Date
        // -----------------------------------------------------------------------------------------------------------------
        Calendar.prototype.getInitialDate = function () {
            var defaultDateInput = this.opt('defaultDate');
            // compute the initial ambig-timezone date
            if (defaultDateInput != null) {
                return this.dateEnv.createMarker(defaultDateInput);
            }
            else {
                return this.getNow(); // getNow already returns unzoned
            }
        };
        Calendar.prototype.prev = function () {
            this.unselect();
            this.dispatch({ type: 'PREV' });
        };
        Calendar.prototype.next = function () {
            this.unselect();
            this.dispatch({ type: 'NEXT' });
        };
        Calendar.prototype.prevYear = function () {
            this.unselect();
            this.dispatch({
                type: 'SET_DATE',
                dateMarker: this.dateEnv.addYears(this.state.currentDate, -1)
            });
        };
        Calendar.prototype.nextYear = function () {
            this.unselect();
            this.dispatch({
                type: 'SET_DATE',
                dateMarker: this.dateEnv.addYears(this.state.currentDate, 1)
            });
        };
        Calendar.prototype.today = function () {
            this.unselect();
            this.dispatch({
                type: 'SET_DATE',
                dateMarker: this.getNow()
            });
        };
        Calendar.prototype.gotoDate = function (zonedDateInput) {
            this.unselect();
            this.dispatch({
                type: 'SET_DATE',
                dateMarker: this.dateEnv.createMarker(zonedDateInput)
            });
        };
        Calendar.prototype.incrementDate = function (deltaInput) {
            var delta = createDuration(deltaInput);
            if (delta) { // else, warn about invalid input?
                this.unselect();
                this.dispatch({
                    type: 'SET_DATE',
                    dateMarker: this.dateEnv.add(this.state.currentDate, delta)
                });
            }
        };
        // for external API
        Calendar.prototype.getDate = function () {
            return this.dateEnv.toDate(this.state.currentDate);
        };
        // Date Formatting Utils
        // -----------------------------------------------------------------------------------------------------------------
        Calendar.prototype.formatDate = function (d, formatter) {
            var dateEnv = this.dateEnv;
            return dateEnv.format(dateEnv.createMarker(d), createFormatter(formatter));
        };
        // `settings` is for formatter AND isEndExclusive
        Calendar.prototype.formatRange = function (d0, d1, settings) {
            var dateEnv = this.dateEnv;
            return dateEnv.formatRange(dateEnv.createMarker(d0), dateEnv.createMarker(d1), createFormatter(settings, this.opt('defaultRangeSeparator')), settings);
        };
        Calendar.prototype.formatIso = function (d, omitTime) {
            var dateEnv = this.dateEnv;
            return dateEnv.formatIso(dateEnv.createMarker(d), { omitTime: omitTime });
        };
        // Sizing
        // -----------------------------------------------------------------------------------------------------------------
        Calendar.prototype.windowResize = function (ev) {
            if (!this.isHandlingWindowResize &&
                this.component && // why?
                ev.target === window // not a jqui resize event
            ) {
                this.isHandlingWindowResize = true;
                this.updateSize();
                this.publiclyTrigger('windowResize', [this.view]);
                this.isHandlingWindowResize = false;
            }
        };
        Calendar.prototype.updateSize = function () {
            if (this.component) { // when?
                this.component.updateSize(true);
            }
        };
        // Component Registration
        // -----------------------------------------------------------------------------------------------------------------
        Calendar.prototype.registerInteractiveComponent = function (component, settingsInput) {
            var settings = parseInteractionSettings(component, settingsInput);
            var DEFAULT_INTERACTIONS = [
                EventClicking,
                EventHovering
            ];
            var interactionClasses = DEFAULT_INTERACTIONS.concat(this.pluginSystem.hooks.componentInteractions);
            var interactions = interactionClasses.map(function (interactionClass) {
                return new interactionClass(settings);
            });
            this.interactionsStore[component.uid] = interactions;
            interactionSettingsStore[component.uid] = settings;
        };
        Calendar.prototype.unregisterInteractiveComponent = function (component) {
            for (var _i = 0, _a = this.interactionsStore[component.uid]; _i < _a.length; _i++) {
                var listener = _a[_i];
                listener.destroy();
            }
            delete this.interactionsStore[component.uid];
            delete interactionSettingsStore[component.uid];
        };
        // Date Selection / Event Selection / DayClick
        // -----------------------------------------------------------------------------------------------------------------
        // this public method receives start/end dates in any format, with any timezone
        // NOTE: args were changed from v3
        Calendar.prototype.select = function (dateOrObj, endDate) {
            var selectionInput;
            if (endDate == null) {
                if (dateOrObj.start != null) {
                    selectionInput = dateOrObj;
                }
                else {
                    selectionInput = {
                        start: dateOrObj,
                        end: null
                    };
                }
            }
            else {
                selectionInput = {
                    start: dateOrObj,
                    end: endDate
                };
            }
            var selection = parseDateSpan(selectionInput, this.dateEnv, createDuration({ days: 1 }) // TODO: cache this?
            );
            if (selection) { // throw parse error otherwise?
                this.dispatch({ type: 'SELECT_DATES', selection: selection });
                this.triggerDateSelect(selection);
            }
        };
        // public method
        Calendar.prototype.unselect = function (pev) {
            if (this.state.dateSelection) {
                this.dispatch({ type: 'UNSELECT_DATES' });
                this.triggerDateUnselect(pev);
            }
        };
        Calendar.prototype.triggerDateSelect = function (selection, pev) {
            var arg = __assign({}, this.buildDateSpanApi(selection), { jsEvent: pev ? pev.origEvent : null, view: this.view });
            this.publiclyTrigger('select', [arg]);
        };
        Calendar.prototype.triggerDateUnselect = function (pev) {
            this.publiclyTrigger('unselect', [
                {
                    jsEvent: pev ? pev.origEvent : null,
                    view: this.view
                }
            ]);
        };
        // TODO: receive pev?
        Calendar.prototype.triggerDateClick = function (dateSpan, dayEl, view, ev) {
            var arg = __assign({}, this.buildDatePointApi(dateSpan), { dayEl: dayEl, jsEvent: ev, // Is this always a mouse event? See #4655
                view: view });
            this.publiclyTrigger('dateClick', [arg]);
        };
        Calendar.prototype.buildDatePointApi = function (dateSpan) {
            var props = {};
            for (var _i = 0, _a = this.pluginSystem.hooks.datePointTransforms; _i < _a.length; _i++) {
                var transform = _a[_i];
                __assign(props, transform(dateSpan, this));
            }
            __assign(props, buildDatePointApi(dateSpan, this.dateEnv));
            return props;
        };
        Calendar.prototype.buildDateSpanApi = function (dateSpan) {
            var props = {};
            for (var _i = 0, _a = this.pluginSystem.hooks.dateSpanTransforms; _i < _a.length; _i++) {
                var transform = _a[_i];
                __assign(props, transform(dateSpan, this));
            }
            __assign(props, buildDateSpanApi(dateSpan, this.dateEnv));
            return props;
        };
        // Date Utils
        // -----------------------------------------------------------------------------------------------------------------
        // Returns a DateMarker for the current date, as defined by the client's computer or from the `now` option
        Calendar.prototype.getNow = function () {
            var now = this.opt('now');
            if (typeof now === 'function') {
                now = now();
            }
            if (now == null) {
                return this.dateEnv.createNowMarker();
            }
            return this.dateEnv.createMarker(now);
        };
        // Event-Date Utilities
        // -----------------------------------------------------------------------------------------------------------------
        // Given an event's allDay status and start date, return what its fallback end date should be.
        // TODO: rename to computeDefaultEventEnd
        Calendar.prototype.getDefaultEventEnd = function (allDay, marker) {
            var end = marker;
            if (allDay) {
                end = startOfDay(end);
                end = this.dateEnv.add(end, this.defaultAllDayEventDuration);
            }
            else {
                end = this.dateEnv.add(end, this.defaultTimedEventDuration);
            }
            return end;
        };
        // Public Events API
        // -----------------------------------------------------------------------------------------------------------------
        Calendar.prototype.addEvent = function (eventInput, sourceInput) {
            if (eventInput instanceof EventApi) {
                var def = eventInput._def;
                var instance = eventInput._instance;
                // not already present? don't want to add an old snapshot
                if (!this.state.eventStore.defs[def.defId]) {
                    this.dispatch({
                        type: 'ADD_EVENTS',
                        eventStore: eventTupleToStore({ def: def, instance: instance }) // TODO: better util for two args?
                    });
                }
                return eventInput;
            }
            var sourceId;
            if (sourceInput instanceof EventSourceApi) {
                sourceId = sourceInput.internalEventSource.sourceId;
            }
            else if (sourceInput != null) {
                var sourceApi = this.getEventSourceById(sourceInput); // TODO: use an internal function
                if (!sourceApi) {
                    console.warn('Could not find an event source with ID "' + sourceInput + '"'); // TODO: test
                    return null;
                }
                else {
                    sourceId = sourceApi.internalEventSource.sourceId;
                }
            }
            var tuple = parseEvent(eventInput, sourceId, this);
            if (tuple) {
                this.dispatch({
                    type: 'ADD_EVENTS',
                    eventStore: eventTupleToStore(tuple)
                });
                return new EventApi(this, tuple.def, tuple.def.recurringDef ? null : tuple.instance);
            }
            return null;
        };
        // TODO: optimize
        Calendar.prototype.getEventById = function (id) {
            var _a = this.state.eventStore, defs = _a.defs, instances = _a.instances;
            id = String(id);
            for (var defId in defs) {
                var def = defs[defId];
                if (def.publicId === id) {
                    if (def.recurringDef) {
                        return new EventApi(this, def, null);
                    }
                    else {
                        for (var instanceId in instances) {
                            var instance = instances[instanceId];
                            if (instance.defId === def.defId) {
                                return new EventApi(this, def, instance);
                            }
                        }
                    }
                }
            }
            return null;
        };
        Calendar.prototype.getEvents = function () {
            var _a = this.state.eventStore, defs = _a.defs, instances = _a.instances;
            var eventApis = [];
            for (var id in instances) {
                var instance = instances[id];
                var def = defs[instance.defId];
                eventApis.push(new EventApi(this, def, instance));
            }
            return eventApis;
        };
        Calendar.prototype.removeAllEvents = function () {
            this.dispatch({ type: 'REMOVE_ALL_EVENTS' });
        };
        Calendar.prototype.rerenderEvents = function () {
            this.dispatch({ type: 'RESET_EVENTS' });
        };
        // Public Event Sources API
        // -----------------------------------------------------------------------------------------------------------------
        Calendar.prototype.getEventSources = function () {
            var sourceHash = this.state.eventSources;
            var sourceApis = [];
            for (var internalId in sourceHash) {
                sourceApis.push(new EventSourceApi(this, sourceHash[internalId]));
            }
            return sourceApis;
        };
        Calendar.prototype.getEventSourceById = function (id) {
            var sourceHash = this.state.eventSources;
            id = String(id);
            for (var sourceId in sourceHash) {
                if (sourceHash[sourceId].publicId === id) {
                    return new EventSourceApi(this, sourceHash[sourceId]);
                }
            }
            return null;
        };
        Calendar.prototype.addEventSource = function (sourceInput) {
            if (sourceInput instanceof EventSourceApi) {
                // not already present? don't want to add an old snapshot
                if (!this.state.eventSources[sourceInput.internalEventSource.sourceId]) {
                    this.dispatch({
                        type: 'ADD_EVENT_SOURCES',
                        sources: [sourceInput.internalEventSource]
                    });
                }
                return sourceInput;
            }
            var eventSource = parseEventSource(sourceInput, this);
            if (eventSource) { // TODO: error otherwise?
                this.dispatch({ type: 'ADD_EVENT_SOURCES', sources: [eventSource] });
                return new EventSourceApi(this, eventSource);
            }
            return null;
        };
        Calendar.prototype.removeAllEventSources = function () {
            this.dispatch({ type: 'REMOVE_ALL_EVENT_SOURCES' });
        };
        Calendar.prototype.refetchEvents = function () {
            this.dispatch({ type: 'FETCH_EVENT_SOURCES' });
        };
        // Scroll
        // -----------------------------------------------------------------------------------------------------------------
        Calendar.prototype.scrollToTime = function (timeInput) {
            var duration = createDuration(timeInput);
            if (duration) {
                this.component.view.scrollToDuration(duration);
            }
        };
        return Calendar;
    }());
    EmitterMixin.mixInto(Calendar);
    // for memoizers
    // -----------------------------------------------------------------------------------------------------------------
    function buildDateEnv(locale, timeZone, namedTimeZoneImpl, firstDay, weekNumberCalculation, weekLabel, cmdFormatter) {
        return new DateEnv({
            calendarSystem: 'gregory',
            timeZone: timeZone,
            namedTimeZoneImpl: namedTimeZoneImpl,
            locale: locale,
            weekNumberCalculation: weekNumberCalculation,
            firstDay: firstDay,
            weekLabel: weekLabel,
            cmdFormatter: cmdFormatter
        });
    }
    function buildTheme(calendarOptions) {
        var themeClass = this.pluginSystem.hooks.themeClasses[calendarOptions.themeSystem] || StandardTheme;
        return new themeClass(calendarOptions);
    }
    function buildDelayedRerender(wait) {
        var func = this.tryRerender.bind(this);
        if (wait != null) {
            func = debounce(func, wait);
        }
        return func;
    }
    function buildEventUiBySource(eventSources) {
        return mapHash(eventSources, function (eventSource) {
            return eventSource.ui;
        });
    }
    function buildEventUiBases(eventDefs, eventUiSingleBase, eventUiBySource) {
        var eventUiBases = { '': eventUiSingleBase };
        for (var defId in eventDefs) {
            var def = eventDefs[defId];
            if (def.sourceId && eventUiBySource[def.sourceId]) {
                eventUiBases[defId] = eventUiBySource[def.sourceId];
            }
        }
        return eventUiBases;
    }

    var View = /** @class */ (function (_super) {
        __extends(View, _super);
        function View(context, viewSpec, dateProfileGenerator, parentEl) {
            var _this = _super.call(this, context, createElement('div', { className: 'fc-view fc-' + viewSpec.type + '-view' }), true // isView (HACK)
            ) || this;
            _this.renderDatesMem = memoizeRendering(_this.renderDatesWrap, _this.unrenderDatesWrap);
            _this.renderBusinessHoursMem = memoizeRendering(_this.renderBusinessHours, _this.unrenderBusinessHours, [_this.renderDatesMem]);
            _this.renderDateSelectionMem = memoizeRendering(_this.renderDateSelectionWrap, _this.unrenderDateSelectionWrap, [_this.renderDatesMem]);
            _this.renderEventsMem = memoizeRendering(_this.renderEvents, _this.unrenderEvents, [_this.renderDatesMem]);
            _this.renderEventSelectionMem = memoizeRendering(_this.renderEventSelectionWrap, _this.unrenderEventSelectionWrap, [_this.renderEventsMem]);
            _this.renderEventDragMem = memoizeRendering(_this.renderEventDragWrap, _this.unrenderEventDragWrap, [_this.renderDatesMem]);
            _this.renderEventResizeMem = memoizeRendering(_this.renderEventResizeWrap, _this.unrenderEventResizeWrap, [_this.renderDatesMem]);
            _this.viewSpec = viewSpec;
            _this.dateProfileGenerator = dateProfileGenerator;
            _this.type = viewSpec.type;
            _this.eventOrderSpecs = parseFieldSpecs(_this.opt('eventOrder'));
            _this.nextDayThreshold = createDuration(_this.opt('nextDayThreshold'));
            parentEl.appendChild(_this.el);
            _this.initialize();
            return _this;
        }
        View.prototype.initialize = function () {
        };
        Object.defineProperty(View.prototype, "activeStart", {
            // Date Setting/Unsetting
            // -----------------------------------------------------------------------------------------------------------------
            get: function () {
                return this.dateEnv.toDate(this.props.dateProfile.activeRange.start);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(View.prototype, "activeEnd", {
            get: function () {
                return this.dateEnv.toDate(this.props.dateProfile.activeRange.end);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(View.prototype, "currentStart", {
            get: function () {
                return this.dateEnv.toDate(this.props.dateProfile.currentRange.start);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(View.prototype, "currentEnd", {
            get: function () {
                return this.dateEnv.toDate(this.props.dateProfile.currentRange.end);
            },
            enumerable: true,
            configurable: true
        });
        // General Rendering
        // -----------------------------------------------------------------------------------------------------------------
        View.prototype.render = function (props) {
            this.renderDatesMem(props.dateProfile);
            this.renderBusinessHoursMem(props.businessHours);
            this.renderDateSelectionMem(props.dateSelection);
            this.renderEventsMem(props.eventStore);
            this.renderEventSelectionMem(props.eventSelection);
            this.renderEventDragMem(props.eventDrag);
            this.renderEventResizeMem(props.eventResize);
        };
        View.prototype.destroy = function () {
            _super.prototype.destroy.call(this);
            this.renderDatesMem.unrender(); // should unrender everything else
        };
        // Sizing
        // -----------------------------------------------------------------------------------------------------------------
        View.prototype.updateSize = function (isResize, viewHeight, isAuto) {
            var calendar = this.calendar;
            if (isResize || // HACKS...
                calendar.isViewUpdated ||
                calendar.isDatesUpdated ||
                calendar.isEventsUpdated) {
                // sort of the catch-all sizing
                // anything that might cause dimension changes
                this.updateBaseSize(isResize, viewHeight, isAuto);
            }
        };
        View.prototype.updateBaseSize = function (isResize, viewHeight, isAuto) {
        };
        // Date Rendering
        // -----------------------------------------------------------------------------------------------------------------
        View.prototype.renderDatesWrap = function (dateProfile) {
            this.renderDates(dateProfile);
            this.addScroll({
                duration: createDuration(this.opt('scrollTime'))
            });
            this.startNowIndicator(dateProfile); // shouldn't render yet because updateSize will be called soon
        };
        View.prototype.unrenderDatesWrap = function () {
            this.stopNowIndicator();
            this.unrenderDates();
        };
        View.prototype.renderDates = function (dateProfile) { };
        View.prototype.unrenderDates = function () { };
        // Business Hours
        // -----------------------------------------------------------------------------------------------------------------
        View.prototype.renderBusinessHours = function (businessHours) { };
        View.prototype.unrenderBusinessHours = function () { };
        // Date Selection
        // -----------------------------------------------------------------------------------------------------------------
        View.prototype.renderDateSelectionWrap = function (selection) {
            if (selection) {
                this.renderDateSelection(selection);
            }
        };
        View.prototype.unrenderDateSelectionWrap = function (selection) {
            if (selection) {
                this.unrenderDateSelection(selection);
            }
        };
        View.prototype.renderDateSelection = function (selection) { };
        View.prototype.unrenderDateSelection = function (selection) { };
        // Event Rendering
        // -----------------------------------------------------------------------------------------------------------------
        View.prototype.renderEvents = function (eventStore) { };
        View.prototype.unrenderEvents = function () { };
        // util for subclasses
        View.prototype.sliceEvents = function (eventStore, allDay) {
            var props = this.props;
            return sliceEventStore(eventStore, props.eventUiBases, props.dateProfile.activeRange, allDay ? this.nextDayThreshold : null).fg;
        };
        View.prototype.computeEventDraggable = function (eventDef, eventUi) {
            var transformers = this.calendar.pluginSystem.hooks.isDraggableTransformers;
            var val = eventUi.startEditable;
            for (var _i = 0, transformers_1 = transformers; _i < transformers_1.length; _i++) {
                var transformer = transformers_1[_i];
                val = transformer(val, eventDef, eventUi, this);
            }
            return val;
        };
        View.prototype.computeEventStartResizable = function (eventDef, eventUi) {
            return eventUi.durationEditable && this.opt('eventResizableFromStart');
        };
        View.prototype.computeEventEndResizable = function (eventDef, eventUi) {
            return eventUi.durationEditable;
        };
        // Event Selection
        // -----------------------------------------------------------------------------------------------------------------
        View.prototype.renderEventSelectionWrap = function (instanceId) {
            if (instanceId) {
                this.renderEventSelection(instanceId);
            }
        };
        View.prototype.unrenderEventSelectionWrap = function (instanceId) {
            if (instanceId) {
                this.unrenderEventSelection(instanceId);
            }
        };
        View.prototype.renderEventSelection = function (instanceId) { };
        View.prototype.unrenderEventSelection = function (instanceId) { };
        // Event Drag
        // -----------------------------------------------------------------------------------------------------------------
        View.prototype.renderEventDragWrap = function (state) {
            if (state) {
                this.renderEventDrag(state);
            }
        };
        View.prototype.unrenderEventDragWrap = function (state) {
            if (state) {
                this.unrenderEventDrag(state);
            }
        };
        View.prototype.renderEventDrag = function (state) { };
        View.prototype.unrenderEventDrag = function (state) { };
        // Event Resize
        // -----------------------------------------------------------------------------------------------------------------
        View.prototype.renderEventResizeWrap = function (state) {
            if (state) {
                this.renderEventResize(state);
            }
        };
        View.prototype.unrenderEventResizeWrap = function (state) {
            if (state) {
                this.unrenderEventResize(state);
            }
        };
        View.prototype.renderEventResize = function (state) { };
        View.prototype.unrenderEventResize = function (state) { };
        /* Now Indicator
        ------------------------------------------------------------------------------------------------------------------*/
        // Immediately render the current time indicator and begins re-rendering it at an interval,
        // which is defined by this.getNowIndicatorUnit().
        // TODO: somehow do this for the current whole day's background too
        View.prototype.startNowIndicator = function (dateProfile) {
            var _this = this;
            var dateEnv = this.dateEnv;
            var unit;
            var update;
            var delay; // ms wait value
            if (this.opt('nowIndicator')) {
                unit = this.getNowIndicatorUnit(dateProfile);
                if (unit) {
                    update = this.updateNowIndicator.bind(this);
                    this.initialNowDate = this.calendar.getNow();
                    this.initialNowQueriedMs = new Date().valueOf();
                    // wait until the beginning of the next interval
                    delay = dateEnv.add(dateEnv.startOf(this.initialNowDate, unit), createDuration(1, unit)).valueOf() - this.initialNowDate.valueOf();
                    // TODO: maybe always use setTimeout, waiting until start of next unit
                    this.nowIndicatorTimeoutID = setTimeout(function () {
                        _this.nowIndicatorTimeoutID = null;
                        update();
                        if (unit === 'second') {
                            delay = 1000; // every second
                        }
                        else {
                            delay = 1000 * 60; // otherwise, every minute
                        }
                        _this.nowIndicatorIntervalID = setInterval(update, delay); // update every interval
                    }, delay);
                }
                // rendering will be initiated in updateSize
            }
        };
        // rerenders the now indicator, computing the new current time from the amount of time that has passed
        // since the initial getNow call.
        View.prototype.updateNowIndicator = function () {
            if (this.props.dateProfile && // a way to determine if dates were rendered yet
                this.initialNowDate // activated before?
            ) {
                this.unrenderNowIndicator(); // won't unrender if unnecessary
                this.renderNowIndicator(addMs(this.initialNowDate, new Date().valueOf() - this.initialNowQueriedMs));
                this.isNowIndicatorRendered = true;
            }
        };
        // Immediately unrenders the view's current time indicator and stops any re-rendering timers.
        // Won't cause side effects if indicator isn't rendered.
        View.prototype.stopNowIndicator = function () {
            if (this.isNowIndicatorRendered) {
                if (this.nowIndicatorTimeoutID) {
                    clearTimeout(this.nowIndicatorTimeoutID);
                    this.nowIndicatorTimeoutID = null;
                }
                if (this.nowIndicatorIntervalID) {
                    clearInterval(this.nowIndicatorIntervalID);
                    this.nowIndicatorIntervalID = null;
                }
                this.unrenderNowIndicator();
                this.isNowIndicatorRendered = false;
            }
        };
        View.prototype.getNowIndicatorUnit = function (dateProfile) {
            // subclasses should implement
        };
        // Renders a current time indicator at the given datetime
        View.prototype.renderNowIndicator = function (date) {
            // SUBCLASSES MUST PASS TO CHILDREN!
        };
        // Undoes the rendering actions from renderNowIndicator
        View.prototype.unrenderNowIndicator = function () {
            // SUBCLASSES MUST PASS TO CHILDREN!
        };
        /* Scroller
        ------------------------------------------------------------------------------------------------------------------*/
        View.prototype.addScroll = function (scroll) {
            var queuedScroll = this.queuedScroll || (this.queuedScroll = {});
            __assign(queuedScroll, scroll);
        };
        View.prototype.popScroll = function (isResize) {
            this.applyQueuedScroll(isResize);
            this.queuedScroll = null;
        };
        View.prototype.applyQueuedScroll = function (isResize) {
            this.applyScroll(this.queuedScroll || {}, isResize);
        };
        View.prototype.queryScroll = function () {
            var scroll = {};
            if (this.props.dateProfile) { // dates rendered yet?
                __assign(scroll, this.queryDateScroll());
            }
            return scroll;
        };
        View.prototype.applyScroll = function (scroll, isResize) {
            var duration = scroll.duration;
            if (duration != null) {
                delete scroll.duration;
                if (this.props.dateProfile) { // dates rendered yet?
                    __assign(scroll, this.computeDateScroll(duration));
                }
            }
            if (this.props.dateProfile) { // dates rendered yet?
                this.applyDateScroll(scroll);
            }
        };
        View.prototype.computeDateScroll = function (duration) {
            return {}; // subclasses must implement
        };
        View.prototype.queryDateScroll = function () {
            return {}; // subclasses must implement
        };
        View.prototype.applyDateScroll = function (scroll) {
            // subclasses must implement
        };
        // for API
        View.prototype.scrollToDuration = function (duration) {
            this.applyScroll({ duration: duration }, false);
        };
        return View;
    }(DateComponent));
    EmitterMixin.mixInto(View);
    View.prototype.usesMinMaxTime = false;
    View.prototype.dateProfileGeneratorClass = DateProfileGenerator;

    var FgEventRenderer = /** @class */ (function () {
        function FgEventRenderer(context) {
            this.segs = [];
            this.isSizeDirty = false;
            this.context = context;
        }
        FgEventRenderer.prototype.renderSegs = function (segs, mirrorInfo) {
            this.rangeUpdated(); // called too frequently :(
            // render an `.el` on each seg
            // returns a subset of the segs. segs that were actually rendered
            segs = this.renderSegEls(segs, mirrorInfo);
            this.segs = segs;
            this.attachSegs(segs, mirrorInfo);
            this.isSizeDirty = true;
            this.context.view.triggerRenderedSegs(this.segs, Boolean(mirrorInfo));
        };
        FgEventRenderer.prototype.unrender = function (_segs, mirrorInfo) {
            this.context.view.triggerWillRemoveSegs(this.segs, Boolean(mirrorInfo));
            this.detachSegs(this.segs);
            this.segs = [];
        };
        // Updates values that rely on options and also relate to range
        FgEventRenderer.prototype.rangeUpdated = function () {
            var options = this.context.options;
            var displayEventTime;
            var displayEventEnd;
            this.eventTimeFormat = createFormatter(options.eventTimeFormat || this.computeEventTimeFormat(), options.defaultRangeSeparator);
            displayEventTime = options.displayEventTime;
            if (displayEventTime == null) {
                displayEventTime = this.computeDisplayEventTime(); // might be based off of range
            }
            displayEventEnd = options.displayEventEnd;
            if (displayEventEnd == null) {
                displayEventEnd = this.computeDisplayEventEnd(); // might be based off of range
            }
            this.displayEventTime = displayEventTime;
            this.displayEventEnd = displayEventEnd;
        };
        // Renders and assigns an `el` property for each foreground event segment.
        // Only returns segments that successfully rendered.
        FgEventRenderer.prototype.renderSegEls = function (segs, mirrorInfo) {
            var html = '';
            var i;
            if (segs.length) { // don't build an empty html string
                // build a large concatenation of event segment HTML
                for (i = 0; i < segs.length; i++) {
                    html += this.renderSegHtml(segs[i], mirrorInfo);
                }
                // Grab individual elements from the combined HTML string. Use each as the default rendering.
                // Then, compute the 'el' for each segment. An el might be null if the eventRender callback returned false.
                htmlToElements(html).forEach(function (el, i) {
                    var seg = segs[i];
                    if (el) {
                        seg.el = el;
                    }
                });
                segs = filterSegsViaEls(this.context.view, segs, Boolean(mirrorInfo));
            }
            return segs;
        };
        // Generic utility for generating the HTML classNames for an event segment's element
        FgEventRenderer.prototype.getSegClasses = function (seg, isDraggable, isResizable, mirrorInfo) {
            var classes = [
                'fc-event',
                seg.isStart ? 'fc-start' : 'fc-not-start',
                seg.isEnd ? 'fc-end' : 'fc-not-end'
            ].concat(seg.eventRange.ui.classNames);
            if (isDraggable) {
                classes.push('fc-draggable');
            }
            if (isResizable) {
                classes.push('fc-resizable');
            }
            if (mirrorInfo) {
                classes.push('fc-mirror');
                if (mirrorInfo.isDragging) {
                    classes.push('fc-dragging');
                }
                if (mirrorInfo.isResizing) {
                    classes.push('fc-resizing');
                }
            }
            return classes;
        };
        // Compute the text that should be displayed on an event's element.
        // `range` can be the Event object itself, or something range-like, with at least a `start`.
        // If event times are disabled, or the event has no time, will return a blank string.
        // If not specified, formatter will default to the eventTimeFormat setting,
        // and displayEnd will default to the displayEventEnd setting.
        FgEventRenderer.prototype.getTimeText = function (eventRange, formatter, displayEnd) {
            var def = eventRange.def, instance = eventRange.instance;
            return this._getTimeText(instance.range.start, def.hasEnd ? instance.range.end : null, def.allDay, formatter, displayEnd, instance.forcedStartTzo, instance.forcedEndTzo);
        };
        FgEventRenderer.prototype._getTimeText = function (start, end, allDay, formatter, displayEnd, forcedStartTzo, forcedEndTzo) {
            var dateEnv = this.context.dateEnv;
            if (formatter == null) {
                formatter = this.eventTimeFormat;
            }
            if (displayEnd == null) {
                displayEnd = this.displayEventEnd;
            }
            if (this.displayEventTime && !allDay) {
                if (displayEnd && end) {
                    return dateEnv.formatRange(start, end, formatter, {
                        forcedStartTzo: forcedStartTzo,
                        forcedEndTzo: forcedEndTzo
                    });
                }
                else {
                    return dateEnv.format(start, formatter, {
                        forcedTzo: forcedStartTzo
                    });
                }
            }
            return '';
        };
        FgEventRenderer.prototype.computeEventTimeFormat = function () {
            return {
                hour: 'numeric',
                minute: '2-digit',
                omitZeroMinute: true
            };
        };
        FgEventRenderer.prototype.computeDisplayEventTime = function () {
            return true;
        };
        FgEventRenderer.prototype.computeDisplayEventEnd = function () {
            return true;
        };
        // Utility for generating event skin-related CSS properties
        FgEventRenderer.prototype.getSkinCss = function (ui) {
            return {
                'background-color': ui.backgroundColor,
                'border-color': ui.borderColor,
                color: ui.textColor
            };
        };
        FgEventRenderer.prototype.sortEventSegs = function (segs) {
            var specs = this.context.view.eventOrderSpecs;
            var objs = segs.map(buildSegCompareObj);
            objs.sort(function (obj0, obj1) {
                return compareByFieldSpecs(obj0, obj1, specs);
            });
            return objs.map(function (c) {
                return c._seg;
            });
        };
        FgEventRenderer.prototype.computeSizes = function (force) {
            if (force || this.isSizeDirty) {
                this.computeSegSizes(this.segs);
            }
        };
        FgEventRenderer.prototype.assignSizes = function (force) {
            if (force || this.isSizeDirty) {
                this.assignSegSizes(this.segs);
                this.isSizeDirty = false;
            }
        };
        FgEventRenderer.prototype.computeSegSizes = function (segs) {
        };
        FgEventRenderer.prototype.assignSegSizes = function (segs) {
        };
        // Manipulation on rendered segs
        FgEventRenderer.prototype.hideByHash = function (hash) {
            if (hash) {
                for (var _i = 0, _a = this.segs; _i < _a.length; _i++) {
                    var seg = _a[_i];
                    if (hash[seg.eventRange.instance.instanceId]) {
                        seg.el.style.visibility = 'hidden';
                    }
                }
            }
        };
        FgEventRenderer.prototype.showByHash = function (hash) {
            if (hash) {
                for (var _i = 0, _a = this.segs; _i < _a.length; _i++) {
                    var seg = _a[_i];
                    if (hash[seg.eventRange.instance.instanceId]) {
                        seg.el.style.visibility = '';
                    }
                }
            }
        };
        FgEventRenderer.prototype.selectByInstanceId = function (instanceId) {
            if (instanceId) {
                for (var _i = 0, _a = this.segs; _i < _a.length; _i++) {
                    var seg = _a[_i];
                    var eventInstance = seg.eventRange.instance;
                    if (eventInstance && eventInstance.instanceId === instanceId &&
                        seg.el // necessary?
                    ) {
                        seg.el.classList.add('fc-selected');
                    }
                }
            }
        };
        FgEventRenderer.prototype.unselectByInstanceId = function (instanceId) {
            if (instanceId) {
                for (var _i = 0, _a = this.segs; _i < _a.length; _i++) {
                    var seg = _a[_i];
                    if (seg.el) { // necessary?
                        seg.el.classList.remove('fc-selected');
                    }
                }
            }
        };
        return FgEventRenderer;
    }());
    // returns a object with all primitive props that can be compared
    function buildSegCompareObj(seg) {
        var eventDef = seg.eventRange.def;
        var range = seg.eventRange.instance.range;
        var start = range.start ? range.start.valueOf() : 0; // TODO: better support for open-range events
        var end = range.end ? range.end.valueOf() : 0; // "
        return __assign({}, eventDef.extendedProps, eventDef, { id: eventDef.publicId, start: start,
            end: end, duration: end - start, allDay: Number(eventDef.allDay), _seg: seg // for later retrieval
         });
    }

    var FillRenderer = /** @class */ (function () {
        function FillRenderer(context) {
            this.fillSegTag = 'div';
            this.dirtySizeFlags = {};
            this.context = context;
            this.containerElsByType = {};
            this.segsByType = {};
        }
        FillRenderer.prototype.getSegsByType = function (type) {
            return this.segsByType[type] || [];
        };
        FillRenderer.prototype.renderSegs = function (type, segs) {
            var _a;
            var renderedSegs = this.renderSegEls(type, segs); // assignes `.el` to each seg. returns successfully rendered segs
            var containerEls = this.attachSegs(type, renderedSegs);
            if (containerEls) {
                (_a = (this.containerElsByType[type] || (this.containerElsByType[type] = []))).push.apply(_a, containerEls);
            }
            this.segsByType[type] = renderedSegs;
            if (type === 'bgEvent') {
                this.context.view.triggerRenderedSegs(renderedSegs, false); // isMirror=false
            }
            this.dirtySizeFlags[type] = true;
        };
        // Unrenders a specific type of fill that is currently rendered on the grid
        FillRenderer.prototype.unrender = function (type) {
            var segs = this.segsByType[type];
            if (segs) {
                if (type === 'bgEvent') {
                    this.context.view.triggerWillRemoveSegs(segs, false); // isMirror=false
                }
                this.detachSegs(type, segs);
            }
        };
        // Renders and assigns an `el` property for each fill segment. Generic enough to work with different types.
        // Only returns segments that successfully rendered.
        FillRenderer.prototype.renderSegEls = function (type, segs) {
            var _this = this;
            var html = '';
            var i;
            if (segs.length) {
                // build a large concatenation of segment HTML
                for (i = 0; i < segs.length; i++) {
                    html += this.renderSegHtml(type, segs[i]);
                }
                // Grab individual elements from the combined HTML string. Use each as the default rendering.
                // Then, compute the 'el' for each segment.
                htmlToElements(html).forEach(function (el, i) {
                    var seg = segs[i];
                    if (el) {
                        seg.el = el;
                    }
                });
                if (type === 'bgEvent') {
                    segs = filterSegsViaEls(this.context.view, segs, false // isMirror. background events can never be mirror elements
                    );
                }
                // correct element type? (would be bad if a non-TD were inserted into a table for example)
                segs = segs.filter(function (seg) {
                    return elementMatches(seg.el, _this.fillSegTag);
                });
            }
            return segs;
        };
        // Builds the HTML needed for one fill segment. Generic enough to work with different types.
        FillRenderer.prototype.renderSegHtml = function (type, seg) {
            var css = null;
            var classNames = [];
            if (type !== 'highlight' && type !== 'businessHours') {
                css = {
                    'background-color': seg.eventRange.ui.backgroundColor
                };
            }
            if (type !== 'highlight') {
                classNames = classNames.concat(seg.eventRange.ui.classNames);
            }
            if (type === 'businessHours') {
                classNames.push('fc-bgevent');
            }
            else {
                classNames.push('fc-' + type.toLowerCase());
            }
            return '<' + this.fillSegTag +
                (classNames.length ? ' class="' + classNames.join(' ') + '"' : '') +
                (css ? ' style="' + cssToStr(css) + '"' : '') +
                '></' + this.fillSegTag + '>';
        };
        FillRenderer.prototype.detachSegs = function (type, segs) {
            var containerEls = this.containerElsByType[type];
            if (containerEls) {
                containerEls.forEach(removeElement);
                delete this.containerElsByType[type];
            }
        };
        FillRenderer.prototype.computeSizes = function (force) {
            for (var type in this.segsByType) {
                if (force || this.dirtySizeFlags[type]) {
                    this.computeSegSizes(this.segsByType[type]);
                }
            }
        };
        FillRenderer.prototype.assignSizes = function (force) {
            for (var type in this.segsByType) {
                if (force || this.dirtySizeFlags[type]) {
                    this.assignSegSizes(this.segsByType[type]);
                }
            }
            this.dirtySizeFlags = {};
        };
        FillRenderer.prototype.computeSegSizes = function (segs) {
        };
        FillRenderer.prototype.assignSegSizes = function (segs) {
        };
        return FillRenderer;
    }());

    var NamedTimeZoneImpl = /** @class */ (function () {
        function NamedTimeZoneImpl(timeZoneName) {
            this.timeZoneName = timeZoneName;
        }
        return NamedTimeZoneImpl;
    }());

    /*
    An abstraction for a dragging interaction originating on an event.
    Does higher-level things than PointerDragger, such as possibly:
    - a "mirror" that moves with the pointer
    - a minimum number of pixels or other criteria for a true drag to begin

    subclasses must emit:
    - pointerdown
    - dragstart
    - dragmove
    - pointerup
    - dragend
    */
    var ElementDragging = /** @class */ (function () {
        function ElementDragging(el) {
            this.emitter = new EmitterMixin();
        }
        ElementDragging.prototype.destroy = function () {
        };
        ElementDragging.prototype.setMirrorIsVisible = function (bool) {
            // optional if subclass doesn't want to support a mirror
        };
        ElementDragging.prototype.setMirrorNeedsRevert = function (bool) {
            // optional if subclass doesn't want to support a mirror
        };
        ElementDragging.prototype.setAutoScrollEnabled = function (bool) {
            // optional
        };
        return ElementDragging;
    }());

    function formatDate(dateInput, settings) {
        if (settings === void 0) { settings = {}; }
        var dateEnv = buildDateEnv$1(settings);
        var formatter = createFormatter(settings);
        var dateMeta = dateEnv.createMarkerMeta(dateInput);
        if (!dateMeta) { // TODO: warning?
            return '';
        }
        return dateEnv.format(dateMeta.marker, formatter, {
            forcedTzo: dateMeta.forcedTzo
        });
    }
    function formatRange(startInput, endInput, settings // mixture of env and formatter settings
    ) {
        var dateEnv = buildDateEnv$1(typeof settings === 'object' && settings ? settings : {}); // pass in if non-null object
        var formatter = createFormatter(settings, globalDefaults.defaultRangeSeparator);
        var startMeta = dateEnv.createMarkerMeta(startInput);
        var endMeta = dateEnv.createMarkerMeta(endInput);
        if (!startMeta || !endMeta) { // TODO: warning?
            return '';
        }
        return dateEnv.formatRange(startMeta.marker, endMeta.marker, formatter, {
            forcedStartTzo: startMeta.forcedTzo,
            forcedEndTzo: endMeta.forcedTzo,
            isEndExclusive: settings.isEndExclusive
        });
    }
    // TODO: more DRY and optimized
    function buildDateEnv$1(settings) {
        var locale = buildLocale(settings.locale || 'en', parseRawLocales([]).map); // TODO: don't hardcode 'en' everywhere
        // ensure required settings
        settings = __assign({ timeZone: globalDefaults.timeZone, calendarSystem: 'gregory' }, settings, { locale: locale });
        return new DateEnv(settings);
    }

    var DRAG_META_PROPS = {
        startTime: createDuration,
        duration: createDuration,
        create: Boolean,
        sourceId: String
    };
    var DRAG_META_DEFAULTS = {
        create: true
    };
    function parseDragMeta(raw) {
        var leftoverProps = {};
        var refined = refineProps(raw, DRAG_META_PROPS, DRAG_META_DEFAULTS, leftoverProps);
        refined.leftoverProps = leftoverProps;
        return refined;
    }

    // Computes a default column header formatting string if `colFormat` is not explicitly defined
    function computeFallbackHeaderFormat(datesRepDistinctDays, dayCnt) {
        // if more than one week row, or if there are a lot of columns with not much space,
        // put just the day numbers will be in each cell
        if (!datesRepDistinctDays || dayCnt > 10) {
            return { weekday: 'short' }; // "Sat"
        }
        else if (dayCnt > 1) {
            return { weekday: 'short', month: 'numeric', day: 'numeric', omitCommas: true }; // "Sat 11/12"
        }
        else {
            return { weekday: 'long' }; // "Saturday"
        }
    }
    function renderDateCell(dateMarker, dateProfile, datesRepDistinctDays, colCnt, colHeadFormat, context, colspan, otherAttrs) {
        var view = context.view, dateEnv = context.dateEnv, theme = context.theme, options = context.options;
        var isDateValid = rangeContainsMarker(dateProfile.activeRange, dateMarker); // TODO: called too frequently. cache somehow.
        var classNames = [
            'fc-day-header',
            theme.getClass('widgetHeader')
        ];
        var innerHtml;
        if (typeof options.columnHeaderHtml === 'function') {
            innerHtml = options.columnHeaderHtml(dateEnv.toDate(dateMarker));
        }
        else if (typeof options.columnHeaderText === 'function') {
            innerHtml = htmlEscape(options.columnHeaderText(dateEnv.toDate(dateMarker)));
        }
        else {
            innerHtml = htmlEscape(dateEnv.format(dateMarker, colHeadFormat));
        }
        // if only one row of days, the classNames on the header can represent the specific days beneath
        if (datesRepDistinctDays) {
            classNames = classNames.concat(
            // includes the day-of-week class
            // noThemeHighlight=true (don't highlight the header)
            getDayClasses(dateMarker, dateProfile, context, true));
        }
        else {
            classNames.push('fc-' + DAY_IDS[dateMarker.getUTCDay()]); // only add the day-of-week class
        }
        return '' +
            '<th class="' + classNames.join(' ') + '"' +
            ((isDateValid && datesRepDistinctDays) ?
                ' data-date="' + dateEnv.formatIso(dateMarker, { omitTime: true }) + '"' :
                '') +
            (colspan > 1 ?
                ' colspan="' + colspan + '"' :
                '') +
            (otherAttrs ?
                ' ' + otherAttrs :
                '') +
            '>' +
            (isDateValid ?
                // don't make a link if the heading could represent multiple days, or if there's only one day (forceOff)
                buildGotoAnchorHtml(view, { date: dateMarker, forceOff: !datesRepDistinctDays || colCnt === 1 }, innerHtml) :
                // if not valid, display text, but no link
                innerHtml) +
            '</th>';
    }

    var DayHeader = /** @class */ (function (_super) {
        __extends(DayHeader, _super);
        function DayHeader(context, parentEl) {
            var _this = _super.call(this, context) || this;
            parentEl.innerHTML = ''; // because might be nbsp
            parentEl.appendChild(_this.el = htmlToElement('<div class="fc-row ' + _this.theme.getClass('headerRow') + '">' +
                '<table class="' + _this.theme.getClass('tableGrid') + '">' +
                '<thead></thead>' +
                '</table>' +
                '</div>'));
            _this.thead = _this.el.querySelector('thead');
            return _this;
        }
        DayHeader.prototype.destroy = function () {
            removeElement(this.el);
        };
        DayHeader.prototype.render = function (props) {
            var dates = props.dates, datesRepDistinctDays = props.datesRepDistinctDays;
            var parts = [];
            if (props.renderIntroHtml) {
                parts.push(props.renderIntroHtml());
            }
            var colHeadFormat = createFormatter(this.opt('columnHeaderFormat') ||
                computeFallbackHeaderFormat(datesRepDistinctDays, dates.length));
            for (var _i = 0, dates_1 = dates; _i < dates_1.length; _i++) {
                var date = dates_1[_i];
                parts.push(renderDateCell(date, props.dateProfile, datesRepDistinctDays, dates.length, colHeadFormat, this.context));
            }
            if (this.isRtl) {
                parts.reverse();
            }
            this.thead.innerHTML = '<tr>' + parts.join('') + '</tr>';
        };
        return DayHeader;
    }(Component));

    var DaySeries = /** @class */ (function () {
        function DaySeries(range, dateProfileGenerator) {
            var date = range.start;
            var end = range.end;
            var indices = [];
            var dates = [];
            var dayIndex = -1;
            while (date < end) { // loop each day from start to end
                if (dateProfileGenerator.isHiddenDay(date)) {
                    indices.push(dayIndex + 0.5); // mark that it's between indices
                }
                else {
                    dayIndex++;
                    indices.push(dayIndex);
                    dates.push(date);
                }
                date = addDays(date, 1);
            }
            this.dates = dates;
            this.indices = indices;
            this.cnt = dates.length;
        }
        DaySeries.prototype.sliceRange = function (range) {
            var firstIndex = this.getDateDayIndex(range.start); // inclusive first index
            var lastIndex = this.getDateDayIndex(addDays(range.end, -1)); // inclusive last index
            var clippedFirstIndex = Math.max(0, firstIndex);
            var clippedLastIndex = Math.min(this.cnt - 1, lastIndex);
            // deal with in-between indices
            clippedFirstIndex = Math.ceil(clippedFirstIndex); // in-between starts round to next cell
            clippedLastIndex = Math.floor(clippedLastIndex); // in-between ends round to prev cell
            if (clippedFirstIndex <= clippedLastIndex) {
                return {
                    firstIndex: clippedFirstIndex,
                    lastIndex: clippedLastIndex,
                    isStart: firstIndex === clippedFirstIndex,
                    isEnd: lastIndex === clippedLastIndex
                };
            }
            else {
                return null;
            }
        };
        // Given a date, returns its chronolocial cell-index from the first cell of the grid.
        // If the date lies between cells (because of hiddenDays), returns a floating-point value between offsets.
        // If before the first offset, returns a negative number.
        // If after the last offset, returns an offset past the last cell offset.
        // Only works for *start* dates of cells. Will not work for exclusive end dates for cells.
        DaySeries.prototype.getDateDayIndex = function (date) {
            var indices = this.indices;
            var dayOffset = Math.floor(diffDays(this.dates[0], date));
            if (dayOffset < 0) {
                return indices[0] - 1;
            }
            else if (dayOffset >= indices.length) {
                return indices[indices.length - 1] + 1;
            }
            else {
                return indices[dayOffset];
            }
        };
        return DaySeries;
    }());

    var DayTable = /** @class */ (function () {
        function DayTable(daySeries, breakOnWeeks) {
            var dates = daySeries.dates;
            var daysPerRow;
            var firstDay;
            var rowCnt;
            if (breakOnWeeks) {
                // count columns until the day-of-week repeats
                firstDay = dates[0].getUTCDay();
                for (daysPerRow = 1; daysPerRow < dates.length; daysPerRow++) {
                    if (dates[daysPerRow].getUTCDay() === firstDay) {
                        break;
                    }
                }
                rowCnt = Math.ceil(dates.length / daysPerRow);
            }
            else {
                rowCnt = 1;
                daysPerRow = dates.length;
            }
            this.rowCnt = rowCnt;
            this.colCnt = daysPerRow;
            this.daySeries = daySeries;
            this.cells = this.buildCells();
            this.headerDates = this.buildHeaderDates();
        }
        DayTable.prototype.buildCells = function () {
            var rows = [];
            for (var row = 0; row < this.rowCnt; row++) {
                var cells = [];
                for (var col = 0; col < this.colCnt; col++) {
                    cells.push(this.buildCell(row, col));
                }
                rows.push(cells);
            }
            return rows;
        };
        DayTable.prototype.buildCell = function (row, col) {
            return {
                date: this.daySeries.dates[row * this.colCnt + col]
            };
        };
        DayTable.prototype.buildHeaderDates = function () {
            var dates = [];
            for (var col = 0; col < this.colCnt; col++) {
                dates.push(this.cells[0][col].date);
            }
            return dates;
        };
        DayTable.prototype.sliceRange = function (range) {
            var colCnt = this.colCnt;
            var seriesSeg = this.daySeries.sliceRange(range);
            var segs = [];
            if (seriesSeg) {
                var firstIndex = seriesSeg.firstIndex, lastIndex = seriesSeg.lastIndex;
                var index = firstIndex;
                while (index <= lastIndex) {
                    var row = Math.floor(index / colCnt);
                    var nextIndex = Math.min((row + 1) * colCnt, lastIndex + 1);
                    segs.push({
                        row: row,
                        firstCol: index % colCnt,
                        lastCol: (nextIndex - 1) % colCnt,
                        isStart: seriesSeg.isStart && index === firstIndex,
                        isEnd: seriesSeg.isEnd && (nextIndex - 1) === lastIndex
                    });
                    index = nextIndex;
                }
            }
            return segs;
        };
        return DayTable;
    }());

    var Slicer = /** @class */ (function () {
        function Slicer() {
            this.sliceBusinessHours = memoize(this._sliceBusinessHours);
            this.sliceDateSelection = memoize(this._sliceDateSpan);
            this.sliceEventStore = memoize(this._sliceEventStore);
            this.sliceEventDrag = memoize(this._sliceInteraction);
            this.sliceEventResize = memoize(this._sliceInteraction);
        }
        Slicer.prototype.sliceProps = function (props, dateProfile, nextDayThreshold, component) {
            var extraArgs = [];
            for (var _i = 4; _i < arguments.length; _i++) {
                extraArgs[_i - 4] = arguments[_i];
            }
            var eventUiBases = props.eventUiBases;
            var eventSegs = this.sliceEventStore.apply(this, [props.eventStore, eventUiBases, dateProfile, nextDayThreshold, component].concat(extraArgs));
            return {
                dateSelectionSegs: this.sliceDateSelection.apply(this, [props.dateSelection, eventUiBases, component].concat(extraArgs)),
                businessHourSegs: this.sliceBusinessHours.apply(this, [props.businessHours, dateProfile, nextDayThreshold, component].concat(extraArgs)),
                fgEventSegs: eventSegs.fg,
                bgEventSegs: eventSegs.bg,
                eventDrag: this.sliceEventDrag.apply(this, [props.eventDrag, eventUiBases, dateProfile, nextDayThreshold, component].concat(extraArgs)),
                eventResize: this.sliceEventResize.apply(this, [props.eventResize, eventUiBases, dateProfile, nextDayThreshold, component].concat(extraArgs)),
                eventSelection: props.eventSelection
            }; // TODO: give interactionSegs?
        };
        Slicer.prototype.sliceNowDate = function (// does not memoize
        date, component) {
            var extraArgs = [];
            for (var _i = 2; _i < arguments.length; _i++) {
                extraArgs[_i - 2] = arguments[_i];
            }
            return this._sliceDateSpan.apply(this, [{ range: { start: date, end: addMs(date, 1) }, allDay: false },
                {},
                component].concat(extraArgs));
        };
        Slicer.prototype._sliceBusinessHours = function (businessHours, dateProfile, nextDayThreshold, component) {
            var extraArgs = [];
            for (var _i = 4; _i < arguments.length; _i++) {
                extraArgs[_i - 4] = arguments[_i];
            }
            if (!businessHours) {
                return [];
            }
            return this._sliceEventStore.apply(this, [expandRecurring(businessHours, computeActiveRange(dateProfile, Boolean(nextDayThreshold)), component.calendar),
                {},
                dateProfile,
                nextDayThreshold,
                component].concat(extraArgs)).bg;
        };
        Slicer.prototype._sliceEventStore = function (eventStore, eventUiBases, dateProfile, nextDayThreshold, component) {
            var extraArgs = [];
            for (var _i = 5; _i < arguments.length; _i++) {
                extraArgs[_i - 5] = arguments[_i];
            }
            if (eventStore) {
                var rangeRes = sliceEventStore(eventStore, eventUiBases, computeActiveRange(dateProfile, Boolean(nextDayThreshold)), nextDayThreshold);
                return {
                    bg: this.sliceEventRanges(rangeRes.bg, component, extraArgs),
                    fg: this.sliceEventRanges(rangeRes.fg, component, extraArgs)
                };
            }
            else {
                return { bg: [], fg: [] };
            }
        };
        Slicer.prototype._sliceInteraction = function (interaction, eventUiBases, dateProfile, nextDayThreshold, component) {
            var extraArgs = [];
            for (var _i = 5; _i < arguments.length; _i++) {
                extraArgs[_i - 5] = arguments[_i];
            }
            if (!interaction) {
                return null;
            }
            var rangeRes = sliceEventStore(interaction.mutatedEvents, eventUiBases, computeActiveRange(dateProfile, Boolean(nextDayThreshold)), nextDayThreshold);
            return {
                segs: this.sliceEventRanges(rangeRes.fg, component, extraArgs),
                affectedInstances: interaction.affectedEvents.instances,
                isEvent: interaction.isEvent,
                sourceSeg: interaction.origSeg
            };
        };
        Slicer.prototype._sliceDateSpan = function (dateSpan, eventUiBases, component) {
            var extraArgs = [];
            for (var _i = 3; _i < arguments.length; _i++) {
                extraArgs[_i - 3] = arguments[_i];
            }
            if (!dateSpan) {
                return [];
            }
            var eventRange = fabricateEventRange(dateSpan, eventUiBases, component.calendar);
            var segs = this.sliceRange.apply(this, [dateSpan.range].concat(extraArgs));
            for (var _a = 0, segs_1 = segs; _a < segs_1.length; _a++) {
                var seg = segs_1[_a];
                seg.component = component;
                seg.eventRange = eventRange;
            }
            return segs;
        };
        /*
        "complete" seg means it has component and eventRange
        */
        Slicer.prototype.sliceEventRanges = function (eventRanges, component, // TODO: kill
        extraArgs) {
            var segs = [];
            for (var _i = 0, eventRanges_1 = eventRanges; _i < eventRanges_1.length; _i++) {
                var eventRange = eventRanges_1[_i];
                segs.push.apply(segs, this.sliceEventRange(eventRange, component, extraArgs));
            }
            return segs;
        };
        /*
        "complete" seg means it has component and eventRange
        */
        Slicer.prototype.sliceEventRange = function (eventRange, component, // TODO: kill
        extraArgs) {
            var segs = this.sliceRange.apply(this, [eventRange.range].concat(extraArgs));
            for (var _i = 0, segs_2 = segs; _i < segs_2.length; _i++) {
                var seg = segs_2[_i];
                seg.component = component;
                seg.eventRange = eventRange;
                seg.isStart = eventRange.isStart && seg.isStart;
                seg.isEnd = eventRange.isEnd && seg.isEnd;
            }
            return segs;
        };
        return Slicer;
    }());
    /*
    for incorporating minTime/maxTime if appropriate
    TODO: should be part of DateProfile!
    TimelineDateProfile already does this btw
    */
    function computeActiveRange(dateProfile, isComponentAllDay) {
        var range = dateProfile.activeRange;
        if (isComponentAllDay) {
            return range;
        }
        return {
            start: addMs(range.start, dateProfile.minTime.milliseconds),
            end: addMs(range.end, dateProfile.maxTime.milliseconds - 864e5) // 864e5 = ms in a day
        };
    }

    // exports
    // --------------------------------------------------------------------------------------------------
    var version = '4.3.1';

    exports.Calendar = Calendar;
    exports.Component = Component;
    exports.DateComponent = DateComponent;
    exports.DateEnv = DateEnv;
    exports.DateProfileGenerator = DateProfileGenerator;
    exports.DayHeader = DayHeader;
    exports.DaySeries = DaySeries;
    exports.DayTable = DayTable;
    exports.ElementDragging = ElementDragging;
    exports.ElementScrollController = ElementScrollController;
    exports.EmitterMixin = EmitterMixin;
    exports.EventApi = EventApi;
    exports.FgEventRenderer = FgEventRenderer;
    exports.FillRenderer = FillRenderer;
    exports.Interaction = Interaction;
    exports.Mixin = Mixin;
    exports.NamedTimeZoneImpl = NamedTimeZoneImpl;
    exports.PositionCache = PositionCache;
    exports.ScrollComponent = ScrollComponent;
    exports.ScrollController = ScrollController;
    exports.Slicer = Slicer;
    exports.Splitter = Splitter;
    exports.Theme = Theme;
    exports.View = View;
    exports.WindowScrollController = WindowScrollController;
    exports.addDays = addDays;
    exports.addDurations = addDurations;
    exports.addMs = addMs;
    exports.addWeeks = addWeeks;
    exports.allowContextMenu = allowContextMenu;
    exports.allowSelection = allowSelection;
    exports.appendToElement = appendToElement;
    exports.applyAll = applyAll;
    exports.applyMutationToEventStore = applyMutationToEventStore;
    exports.applyStyle = applyStyle;
    exports.applyStyleProp = applyStyleProp;
    exports.asRoughMinutes = asRoughMinutes;
    exports.asRoughMs = asRoughMs;
    exports.asRoughSeconds = asRoughSeconds;
    exports.buildGotoAnchorHtml = buildGotoAnchorHtml;
    exports.buildSegCompareObj = buildSegCompareObj;
    exports.capitaliseFirstLetter = capitaliseFirstLetter;
    exports.combineEventUis = combineEventUis;
    exports.compareByFieldSpec = compareByFieldSpec;
    exports.compareByFieldSpecs = compareByFieldSpecs;
    exports.compareNumbers = compareNumbers;
    exports.compensateScroll = compensateScroll;
    exports.computeClippingRect = computeClippingRect;
    exports.computeEdges = computeEdges;
    exports.computeFallbackHeaderFormat = computeFallbackHeaderFormat;
    exports.computeHeightAndMargins = computeHeightAndMargins;
    exports.computeInnerRect = computeInnerRect;
    exports.computeRect = computeRect;
    exports.computeVisibleDayRange = computeVisibleDayRange;
    exports.config = config;
    exports.constrainPoint = constrainPoint;
    exports.createDuration = createDuration;
    exports.createElement = createElement;
    exports.createEmptyEventStore = createEmptyEventStore;
    exports.createEventInstance = createEventInstance;
    exports.createFormatter = createFormatter;
    exports.createPlugin = createPlugin;
    exports.cssToStr = cssToStr;
    exports.debounce = debounce;
    exports.diffDates = diffDates;
    exports.diffDayAndTime = diffDayAndTime;
    exports.diffDays = diffDays;
    exports.diffPoints = diffPoints;
    exports.diffWeeks = diffWeeks;
    exports.diffWholeDays = diffWholeDays;
    exports.diffWholeWeeks = diffWholeWeeks;
    exports.disableCursor = disableCursor;
    exports.distributeHeight = distributeHeight;
    exports.elementClosest = elementClosest;
    exports.elementMatches = elementMatches;
    exports.enableCursor = enableCursor;
    exports.eventTupleToStore = eventTupleToStore;
    exports.filterEventStoreDefs = filterEventStoreDefs;
    exports.filterHash = filterHash;
    exports.findChildren = findChildren;
    exports.findElements = findElements;
    exports.flexibleCompare = flexibleCompare;
    exports.forceClassName = forceClassName;
    exports.formatDate = formatDate;
    exports.formatIsoTimeString = formatIsoTimeString;
    exports.formatRange = formatRange;
    exports.getAllDayHtml = getAllDayHtml;
    exports.getClippingParents = getClippingParents;
    exports.getDayClasses = getDayClasses;
    exports.getElSeg = getElSeg;
    exports.getRectCenter = getRectCenter;
    exports.getRelevantEvents = getRelevantEvents;
    exports.globalDefaults = globalDefaults;
    exports.greatestDurationDenominator = greatestDurationDenominator;
    exports.hasBgRendering = hasBgRendering;
    exports.htmlEscape = htmlEscape;
    exports.htmlToElement = htmlToElement;
    exports.insertAfterElement = insertAfterElement;
    exports.interactionSettingsStore = interactionSettingsStore;
    exports.interactionSettingsToStore = interactionSettingsToStore;
    exports.intersectRanges = intersectRanges;
    exports.intersectRects = intersectRects;
    exports.isArraysEqual = isArraysEqual;
    exports.isDateSpansEqual = isDateSpansEqual;
    exports.isInt = isInt;
    exports.isInteractionValid = isInteractionValid;
    exports.isMultiDayRange = isMultiDayRange;
    exports.isPropsEqual = isPropsEqual;
    exports.isPropsValid = isPropsValid;
    exports.isSingleDay = isSingleDay;
    exports.isValidDate = isValidDate;
    exports.listenBySelector = listenBySelector;
    exports.mapHash = mapHash;
    exports.matchCellWidths = matchCellWidths;
    exports.memoize = memoize;
    exports.memoizeOutput = memoizeOutput;
    exports.memoizeRendering = memoizeRendering;
    exports.mergeEventStores = mergeEventStores;
    exports.multiplyDuration = multiplyDuration;
    exports.padStart = padStart;
    exports.parseBusinessHours = parseBusinessHours;
    exports.parseDragMeta = parseDragMeta;
    exports.parseEventDef = parseEventDef;
    exports.parseFieldSpecs = parseFieldSpecs;
    exports.parseMarker = parse;
    exports.pointInsideRect = pointInsideRect;
    exports.prependToElement = prependToElement;
    exports.preventContextMenu = preventContextMenu;
    exports.preventDefault = preventDefault;
    exports.preventSelection = preventSelection;
    exports.processScopedUiProps = processScopedUiProps;
    exports.rangeContainsMarker = rangeContainsMarker;
    exports.rangeContainsRange = rangeContainsRange;
    exports.rangesEqual = rangesEqual;
    exports.rangesIntersect = rangesIntersect;
    exports.refineProps = refineProps;
    exports.removeElement = removeElement;
    exports.removeExact = removeExact;
    exports.renderDateCell = renderDateCell;
    exports.requestJson = requestJson;
    exports.sliceEventStore = sliceEventStore;
    exports.startOfDay = startOfDay;
    exports.subtractInnerElHeight = subtractInnerElHeight;
    exports.translateRect = translateRect;
    exports.uncompensateScroll = uncompensateScroll;
    exports.undistributeHeight = undistributeHeight;
    exports.unpromisify = unpromisify;
    exports.version = version;
    exports.whenTransitionDone = whenTransitionDone;
    exports.wholeDivideDurations = wholeDivideDurations;

    Object.defineProperty(exports, '__esModule', { value: true });

}));

/*!
FullCalendar Day Grid Plugin v4.3.0
Docs & License: https://fullcalendar.io/
(c) 2019 Adam Shaw
*/

(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@fullcalendar/core')) :
    typeof define === 'function' && define.amd ? define(['exports', '@fullcalendar/core'], factory) :
    (global = global || self, factory(global.FullCalendarDayGrid = {}, global.FullCalendar));
}(this, function (exports, core) { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    /* global Reflect, Promise */

    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };

    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    var __assign = function() {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };

    var DayGridDateProfileGenerator = /** @class */ (function (_super) {
        __extends(DayGridDateProfileGenerator, _super);
        function DayGridDateProfileGenerator() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        // Computes the date range that will be rendered.
        DayGridDateProfileGenerator.prototype.buildRenderRange = function (currentRange, currentRangeUnit, isRangeAllDay) {
            var dateEnv = this.dateEnv;
            var renderRange = _super.prototype.buildRenderRange.call(this, currentRange, currentRangeUnit, isRangeAllDay);
            var start = renderRange.start;
            var end = renderRange.end;
            var endOfWeek;
            // year and month views should be aligned with weeks. this is already done for week
            if (/^(year|month)$/.test(currentRangeUnit)) {
                start = dateEnv.startOfWeek(start);
                // make end-of-week if not already
                endOfWeek = dateEnv.startOfWeek(end);
                if (endOfWeek.valueOf() !== end.valueOf()) {
                    end = core.addWeeks(endOfWeek, 1);
                }
            }
            // ensure 6 weeks
            if (this.options.monthMode &&
                this.options.fixedWeekCount) {
                var rowCnt = Math.ceil(// could be partial weeks due to hiddenDays
                core.diffWeeks(start, end));
                end = core.addWeeks(end, 6 - rowCnt);
            }
            return { start: start, end: end };
        };
        return DayGridDateProfileGenerator;
    }(core.DateProfileGenerator));

    /* A rectangular panel that is absolutely positioned over other content
    ------------------------------------------------------------------------------------------------------------------------
    Options:
      - className (string)
      - content (HTML string, element, or element array)
      - parentEl
      - top
      - left
      - right (the x coord of where the right edge should be. not a "CSS" right)
      - autoHide (boolean)
      - show (callback)
      - hide (callback)
    */
    var Popover = /** @class */ (function () {
        function Popover(options) {
            var _this = this;
            this.isHidden = true;
            this.margin = 10; // the space required between the popover and the edges of the scroll container
            // Triggered when the user clicks *anywhere* in the document, for the autoHide feature
            this.documentMousedown = function (ev) {
                // only hide the popover if the click happened outside the popover
                if (_this.el && !_this.el.contains(ev.target)) {
                    _this.hide();
                }
            };
            this.options = options;
        }
        // Shows the popover on the specified position. Renders it if not already
        Popover.prototype.show = function () {
            if (this.isHidden) {
                if (!this.el) {
                    this.render();
                }
                this.el.style.display = '';
                this.position();
                this.isHidden = false;
                this.trigger('show');
            }
        };
        // Hides the popover, through CSS, but does not remove it from the DOM
        Popover.prototype.hide = function () {
            if (!this.isHidden) {
                this.el.style.display = 'none';
                this.isHidden = true;
                this.trigger('hide');
            }
        };
        // Creates `this.el` and renders content inside of it
        Popover.prototype.render = function () {
            var _this = this;
            var options = this.options;
            var el = this.el = core.createElement('div', {
                className: 'fc-popover ' + (options.className || ''),
                style: {
                    top: '0',
                    left: '0'
                }
            });
            if (typeof options.content === 'function') {
                options.content(el);
            }
            options.parentEl.appendChild(el);
            // when a click happens on anything inside with a 'fc-close' className, hide the popover
            core.listenBySelector(el, 'click', '.fc-close', function (ev) {
                _this.hide();
            });
            if (options.autoHide) {
                document.addEventListener('mousedown', this.documentMousedown);
            }
        };
        // Hides and unregisters any handlers
        Popover.prototype.destroy = function () {
            this.hide();
            if (this.el) {
                core.removeElement(this.el);
                this.el = null;
            }
            document.removeEventListener('mousedown', this.documentMousedown);
        };
        // Positions the popover optimally, using the top/left/right options
        Popover.prototype.position = function () {
            var options = this.options;
            var el = this.el;
            var elDims = el.getBoundingClientRect(); // only used for width,height
            var origin = core.computeRect(el.offsetParent);
            var clippingRect = core.computeClippingRect(options.parentEl);
            var top; // the "position" (not "offset") values for the popover
            var left; //
            // compute top and left
            top = options.top || 0;
            if (options.left !== undefined) {
                left = options.left;
            }
            else if (options.right !== undefined) {
                left = options.right - elDims.width; // derive the left value from the right value
            }
            else {
                left = 0;
            }
            // constrain to the view port. if constrained by two edges, give precedence to top/left
            top = Math.min(top, clippingRect.bottom - elDims.height - this.margin);
            top = Math.max(top, clippingRect.top + this.margin);
            left = Math.min(left, clippingRect.right - elDims.width - this.margin);
            left = Math.max(left, clippingRect.left + this.margin);
            core.applyStyle(el, {
                top: top - origin.top,
                left: left - origin.left
            });
        };
        // Triggers a callback. Calls a function in the option hash of the same name.
        // Arguments beyond the first `name` are forwarded on.
        // TODO: better code reuse for this. Repeat code
        // can kill this???
        Popover.prototype.trigger = function (name) {
            if (this.options[name]) {
                this.options[name].apply(this, Array.prototype.slice.call(arguments, 1));
            }
        };
        return Popover;
    }());

    /* Event-rendering methods for the DayGrid class
    ----------------------------------------------------------------------------------------------------------------------*/
    // "Simple" is bad a name. has nothing to do with SimpleDayGrid
    var SimpleDayGridEventRenderer = /** @class */ (function (_super) {
        __extends(SimpleDayGridEventRenderer, _super);
        function SimpleDayGridEventRenderer() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        // Builds the HTML to be used for the default element for an individual segment
        SimpleDayGridEventRenderer.prototype.renderSegHtml = function (seg, mirrorInfo) {
            var _a = this.context, view = _a.view, options = _a.options;
            var eventRange = seg.eventRange;
            var eventDef = eventRange.def;
            var eventUi = eventRange.ui;
            var allDay = eventDef.allDay;
            var isDraggable = view.computeEventDraggable(eventDef, eventUi);
            var isResizableFromStart = allDay && seg.isStart && view.computeEventStartResizable(eventDef, eventUi);
            var isResizableFromEnd = allDay && seg.isEnd && view.computeEventEndResizable(eventDef, eventUi);
            var classes = this.getSegClasses(seg, isDraggable, isResizableFromStart || isResizableFromEnd, mirrorInfo);
            var skinCss = core.cssToStr(this.getSkinCss(eventUi));
            var timeHtml = '';
            var timeText;
            var titleHtml;
            classes.unshift('fc-day-grid-event', 'fc-h-event');
            // Only display a timed events time if it is the starting segment
            if (seg.isStart) {
                timeText = this.getTimeText(eventRange);
                if (timeText) {
                    timeHtml = '<span class="fc-time">' + core.htmlEscape(timeText) + '</span>';
                }
            }
            titleHtml =
                '<span class="fc-title">' +
                    (core.htmlEscape(eventDef.title || '') || '&nbsp;') + // we always want one line of height
                    '</span>';
            return '<a class="' + classes.join(' ') + '"' +
                (eventDef.url ?
                    ' href="' + core.htmlEscape(eventDef.url) + '"' :
                    '') +
                (skinCss ?
                    ' style="' + skinCss + '"' :
                    '') +
                '>' +
                '<div class="fc-content">' +
                (options.dir === 'rtl' ?
                    titleHtml + ' ' + timeHtml : // put a natural space in between
                    timeHtml + ' ' + titleHtml //
                ) +
                '</div>' +
                (isResizableFromStart ?
                    '<div class="fc-resizer fc-start-resizer"></div>' :
                    '') +
                (isResizableFromEnd ?
                    '<div class="fc-resizer fc-end-resizer"></div>' :
                    '') +
                '</a>';
        };
        // Computes a default event time formatting string if `eventTimeFormat` is not explicitly defined
        SimpleDayGridEventRenderer.prototype.computeEventTimeFormat = function () {
            return {
                hour: 'numeric',
                minute: '2-digit',
                omitZeroMinute: true,
                meridiem: 'narrow'
            };
        };
        SimpleDayGridEventRenderer.prototype.computeDisplayEventEnd = function () {
            return false; // TODO: somehow consider the originating DayGrid's column count
        };
        return SimpleDayGridEventRenderer;
    }(core.FgEventRenderer));

    /* Event-rendering methods for the DayGrid class
    ----------------------------------------------------------------------------------------------------------------------*/
    var DayGridEventRenderer = /** @class */ (function (_super) {
        __extends(DayGridEventRenderer, _super);
        function DayGridEventRenderer(dayGrid) {
            var _this = _super.call(this, dayGrid.context) || this;
            _this.dayGrid = dayGrid;
            return _this;
        }
        // Renders the given foreground event segments onto the grid
        DayGridEventRenderer.prototype.attachSegs = function (segs, mirrorInfo) {
            var rowStructs = this.rowStructs = this.renderSegRows(segs);
            // append to each row's content skeleton
            this.dayGrid.rowEls.forEach(function (rowNode, i) {
                rowNode.querySelector('.fc-content-skeleton > table').appendChild(rowStructs[i].tbodyEl);
            });
            // removes the "more.." events popover
            if (!mirrorInfo) {
                this.dayGrid.removeSegPopover();
            }
        };
        // Unrenders all currently rendered foreground event segments
        DayGridEventRenderer.prototype.detachSegs = function () {
            var rowStructs = this.rowStructs || [];
            var rowStruct;
            while ((rowStruct = rowStructs.pop())) {
                core.removeElement(rowStruct.tbodyEl);
            }
            this.rowStructs = null;
        };
        // Uses the given events array to generate <tbody> elements that should be appended to each row's content skeleton.
        // Returns an array of rowStruct objects (see the bottom of `renderSegRow`).
        // PRECONDITION: each segment shoud already have a rendered and assigned `.el`
        DayGridEventRenderer.prototype.renderSegRows = function (segs) {
            var rowStructs = [];
            var segRows;
            var row;
            segRows = this.groupSegRows(segs); // group into nested arrays
            // iterate each row of segment groupings
            for (row = 0; row < segRows.length; row++) {
                rowStructs.push(this.renderSegRow(row, segRows[row]));
            }
            return rowStructs;
        };
        // Given a row # and an array of segments all in the same row, render a <tbody> element, a skeleton that contains
        // the segments. Returns object with a bunch of internal data about how the render was calculated.
        // NOTE: modifies rowSegs
        DayGridEventRenderer.prototype.renderSegRow = function (row, rowSegs) {
            var dayGrid = this.dayGrid;
            var colCnt = dayGrid.colCnt, isRtl = dayGrid.isRtl;
            var segLevels = this.buildSegLevels(rowSegs); // group into sub-arrays of levels
            var levelCnt = Math.max(1, segLevels.length); // ensure at least one level
            var tbody = document.createElement('tbody');
            var segMatrix = []; // lookup for which segments are rendered into which level+col cells
            var cellMatrix = []; // lookup for all <td> elements of the level+col matrix
            var loneCellMatrix = []; // lookup for <td> elements that only take up a single column
            var i;
            var levelSegs;
            var col;
            var tr;
            var j;
            var seg;
            var td;
            // populates empty cells from the current column (`col`) to `endCol`
            function emptyCellsUntil(endCol) {
                while (col < endCol) {
                    // try to grab a cell from the level above and extend its rowspan. otherwise, create a fresh cell
                    td = (loneCellMatrix[i - 1] || [])[col];
                    if (td) {
                        td.rowSpan = (td.rowSpan || 1) + 1;
                    }
                    else {
                        td = document.createElement('td');
                        tr.appendChild(td);
                    }
                    cellMatrix[i][col] = td;
                    loneCellMatrix[i][col] = td;
                    col++;
                }
            }
            for (i = 0; i < levelCnt; i++) { // iterate through all levels
                levelSegs = segLevels[i];
                col = 0;
                tr = document.createElement('tr');
                segMatrix.push([]);
                cellMatrix.push([]);
                loneCellMatrix.push([]);
                // levelCnt might be 1 even though there are no actual levels. protect against this.
                // this single empty row is useful for styling.
                if (levelSegs) {
                    for (j = 0; j < levelSegs.length; j++) { // iterate through segments in level
                        seg = levelSegs[j];
                        var leftCol = isRtl ? (colCnt - 1 - seg.lastCol) : seg.firstCol;
                        var rightCol = isRtl ? (colCnt - 1 - seg.firstCol) : seg.lastCol;
                        emptyCellsUntil(leftCol);
                        // create a container that occupies or more columns. append the event element.
                        td = core.createElement('td', { className: 'fc-event-container' }, seg.el);
                        if (leftCol !== rightCol) {
                            td.colSpan = rightCol - leftCol + 1;
                        }
                        else { // a single-column segment
                            loneCellMatrix[i][col] = td;
                        }
                        while (col <= rightCol) {
                            cellMatrix[i][col] = td;
                            segMatrix[i][col] = seg;
                            col++;
                        }
                        tr.appendChild(td);
                    }
                }
                emptyCellsUntil(colCnt); // finish off the row
                var introHtml = dayGrid.renderProps.renderIntroHtml();
                if (introHtml) {
                    if (dayGrid.isRtl) {
                        core.appendToElement(tr, introHtml);
                    }
                    else {
                        core.prependToElement(tr, introHtml);
                    }
                }
                tbody.appendChild(tr);
            }
            return {
                row: row,
                tbodyEl: tbody,
                cellMatrix: cellMatrix,
                segMatrix: segMatrix,
                segLevels: segLevels,
                segs: rowSegs
            };
        };
        // Stacks a flat array of segments, which are all assumed to be in the same row, into subarrays of vertical levels.
        // NOTE: modifies segs
        DayGridEventRenderer.prototype.buildSegLevels = function (segs) {
            var _a = this.dayGrid, isRtl = _a.isRtl, colCnt = _a.colCnt;
            var levels = [];
            var i;
            var seg;
            var j;
            // Give preference to elements with certain criteria, so they have
            // a chance to be closer to the top.
            segs = this.sortEventSegs(segs);
            for (i = 0; i < segs.length; i++) {
                seg = segs[i];
                // loop through levels, starting with the topmost, until the segment doesn't collide with other segments
                for (j = 0; j < levels.length; j++) {
                    if (!isDaySegCollision(seg, levels[j])) {
                        break;
                    }
                }
                // `j` now holds the desired subrow index
                seg.level = j;
                seg.leftCol = isRtl ? (colCnt - 1 - seg.lastCol) : seg.firstCol; // for sorting only
                seg.rightCol = isRtl ? (colCnt - 1 - seg.firstCol) : seg.lastCol // for sorting only
                ;
                (levels[j] || (levels[j] = [])).push(seg);
            }
            // order segments left-to-right. very important if calendar is RTL
            for (j = 0; j < levels.length; j++) {
                levels[j].sort(compareDaySegCols);
            }
            return levels;
        };
        // Given a flat array of segments, return an array of sub-arrays, grouped by each segment's row
        DayGridEventRenderer.prototype.groupSegRows = function (segs) {
            var segRows = [];
            var i;
            for (i = 0; i < this.dayGrid.rowCnt; i++) {
                segRows.push([]);
            }
            for (i = 0; i < segs.length; i++) {
                segRows[segs[i].row].push(segs[i]);
            }
            return segRows;
        };
        // Computes a default `displayEventEnd` value if one is not expliclty defined
        DayGridEventRenderer.prototype.computeDisplayEventEnd = function () {
            return this.dayGrid.colCnt === 1; // we'll likely have space if there's only one day
        };
        return DayGridEventRenderer;
    }(SimpleDayGridEventRenderer));
    // Computes whether two segments' columns collide. They are assumed to be in the same row.
    function isDaySegCollision(seg, otherSegs) {
        var i;
        var otherSeg;
        for (i = 0; i < otherSegs.length; i++) {
            otherSeg = otherSegs[i];
            if (otherSeg.firstCol <= seg.lastCol &&
                otherSeg.lastCol >= seg.firstCol) {
                return true;
            }
        }
        return false;
    }
    // A cmp function for determining the leftmost event
    function compareDaySegCols(a, b) {
        return a.leftCol - b.leftCol;
    }

    var DayGridMirrorRenderer = /** @class */ (function (_super) {
        __extends(DayGridMirrorRenderer, _super);
        function DayGridMirrorRenderer() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DayGridMirrorRenderer.prototype.attachSegs = function (segs, mirrorInfo) {
            var sourceSeg = mirrorInfo.sourceSeg;
            var rowStructs = this.rowStructs = this.renderSegRows(segs);
            // inject each new event skeleton into each associated row
            this.dayGrid.rowEls.forEach(function (rowNode, row) {
                var skeletonEl = core.htmlToElement('<div class="fc-mirror-skeleton"><table></table></div>'); // will be absolutely positioned
                var skeletonTopEl;
                var skeletonTop;
                // If there is an original segment, match the top position. Otherwise, put it at the row's top level
                if (sourceSeg && sourceSeg.row === row) {
                    skeletonTopEl = sourceSeg.el;
                }
                else {
                    skeletonTopEl = rowNode.querySelector('.fc-content-skeleton tbody');
                    if (!skeletonTopEl) { // when no events
                        skeletonTopEl = rowNode.querySelector('.fc-content-skeleton table');
                    }
                }
                skeletonTop = skeletonTopEl.getBoundingClientRect().top -
                    rowNode.getBoundingClientRect().top; // the offsetParent origin
                skeletonEl.style.top = skeletonTop + 'px';
                skeletonEl.querySelector('table').appendChild(rowStructs[row].tbodyEl);
                rowNode.appendChild(skeletonEl);
            });
        };
        return DayGridMirrorRenderer;
    }(DayGridEventRenderer));

    var EMPTY_CELL_HTML = '<td style="pointer-events:none"></td>';
    var DayGridFillRenderer = /** @class */ (function (_super) {
        __extends(DayGridFillRenderer, _super);
        function DayGridFillRenderer(dayGrid) {
            var _this = _super.call(this, dayGrid.context) || this;
            _this.fillSegTag = 'td'; // override the default tag name
            _this.dayGrid = dayGrid;
            return _this;
        }
        DayGridFillRenderer.prototype.renderSegs = function (type, segs) {
            // don't render timed background events
            if (type === 'bgEvent') {
                segs = segs.filter(function (seg) {
                    return seg.eventRange.def.allDay;
                });
            }
            _super.prototype.renderSegs.call(this, type, segs);
        };
        DayGridFillRenderer.prototype.attachSegs = function (type, segs) {
            var els = [];
            var i;
            var seg;
            var skeletonEl;
            for (i = 0; i < segs.length; i++) {
                seg = segs[i];
                skeletonEl = this.renderFillRow(type, seg);
                this.dayGrid.rowEls[seg.row].appendChild(skeletonEl);
                els.push(skeletonEl);
            }
            return els;
        };
        // Generates the HTML needed for one row of a fill. Requires the seg's el to be rendered.
        DayGridFillRenderer.prototype.renderFillRow = function (type, seg) {
            var dayGrid = this.dayGrid;
            var colCnt = dayGrid.colCnt, isRtl = dayGrid.isRtl;
            var leftCol = isRtl ? (colCnt - 1 - seg.lastCol) : seg.firstCol;
            var rightCol = isRtl ? (colCnt - 1 - seg.firstCol) : seg.lastCol;
            var startCol = leftCol;
            var endCol = rightCol + 1;
            var className;
            var skeletonEl;
            var trEl;
            if (type === 'businessHours') {
                className = 'bgevent';
            }
            else {
                className = type.toLowerCase();
            }
            skeletonEl = core.htmlToElement('<div class="fc-' + className + '-skeleton">' +
                '<table><tr></tr></table>' +
                '</div>');
            trEl = skeletonEl.getElementsByTagName('tr')[0];
            if (startCol > 0) {
                core.appendToElement(trEl, 
                // will create (startCol + 1) td's
                new Array(startCol + 1).join(EMPTY_CELL_HTML));
            }
            seg.el.colSpan = endCol - startCol;
            trEl.appendChild(seg.el);
            if (endCol < colCnt) {
                core.appendToElement(trEl, 
                // will create (colCnt - endCol) td's
                new Array(colCnt - endCol + 1).join(EMPTY_CELL_HTML));
            }
            var introHtml = dayGrid.renderProps.renderIntroHtml();
            if (introHtml) {
                if (dayGrid.isRtl) {
                    core.appendToElement(trEl, introHtml);
                }
                else {
                    core.prependToElement(trEl, introHtml);
                }
            }
            return skeletonEl;
        };
        return DayGridFillRenderer;
    }(core.FillRenderer));

    var DayTile = /** @class */ (function (_super) {
        __extends(DayTile, _super);
        function DayTile(context, el) {
            var _this = _super.call(this, context, el) || this;
            var eventRenderer = _this.eventRenderer = new DayTileEventRenderer(_this);
            var renderFrame = _this.renderFrame = core.memoizeRendering(_this._renderFrame);
            _this.renderFgEvents = core.memoizeRendering(eventRenderer.renderSegs.bind(eventRenderer), eventRenderer.unrender.bind(eventRenderer), [renderFrame]);
            _this.renderEventSelection = core.memoizeRendering(eventRenderer.selectByInstanceId.bind(eventRenderer), eventRenderer.unselectByInstanceId.bind(eventRenderer), [_this.renderFgEvents]);
            _this.renderEventDrag = core.memoizeRendering(eventRenderer.hideByHash.bind(eventRenderer), eventRenderer.showByHash.bind(eventRenderer), [renderFrame]);
            _this.renderEventResize = core.memoizeRendering(eventRenderer.hideByHash.bind(eventRenderer), eventRenderer.showByHash.bind(eventRenderer), [renderFrame]);
            context.calendar.registerInteractiveComponent(_this, {
                el: _this.el,
                useEventCenter: false
            });
            return _this;
        }
        DayTile.prototype.render = function (props) {
            this.renderFrame(props.date);
            this.renderFgEvents(props.fgSegs);
            this.renderEventSelection(props.eventSelection);
            this.renderEventDrag(props.eventDragInstances);
            this.renderEventResize(props.eventResizeInstances);
        };
        DayTile.prototype.destroy = function () {
            _super.prototype.destroy.call(this);
            this.renderFrame.unrender(); // should unrender everything else
            this.calendar.unregisterInteractiveComponent(this);
        };
        DayTile.prototype._renderFrame = function (date) {
            var _a = this, theme = _a.theme, dateEnv = _a.dateEnv;
            var title = dateEnv.format(date, core.createFormatter(this.opt('dayPopoverFormat')) // TODO: cache
            );
            this.el.innerHTML =
                '<div class="fc-header ' + theme.getClass('popoverHeader') + '">' +
                    '<span class="fc-title">' +
                    core.htmlEscape(title) +
                    '</span>' +
                    '<span class="fc-close ' + theme.getIconClass('close') + '"></span>' +
                    '</div>' +
                    '<div class="fc-body ' + theme.getClass('popoverContent') + '">' +
                    '<div class="fc-event-container"></div>' +
                    '</div>';
            this.segContainerEl = this.el.querySelector('.fc-event-container');
        };
        DayTile.prototype.queryHit = function (positionLeft, positionTop, elWidth, elHeight) {
            var date = this.props.date; // HACK
            if (positionLeft < elWidth && positionTop < elHeight) {
                return {
                    component: this,
                    dateSpan: {
                        allDay: true,
                        range: { start: date, end: core.addDays(date, 1) }
                    },
                    dayEl: this.el,
                    rect: {
                        left: 0,
                        top: 0,
                        right: elWidth,
                        bottom: elHeight
                    },
                    layer: 1
                };
            }
        };
        return DayTile;
    }(core.DateComponent));
    var DayTileEventRenderer = /** @class */ (function (_super) {
        __extends(DayTileEventRenderer, _super);
        function DayTileEventRenderer(dayTile) {
            var _this = _super.call(this, dayTile.context) || this;
            _this.dayTile = dayTile;
            return _this;
        }
        DayTileEventRenderer.prototype.attachSegs = function (segs) {
            for (var _i = 0, segs_1 = segs; _i < segs_1.length; _i++) {
                var seg = segs_1[_i];
                this.dayTile.segContainerEl.appendChild(seg.el);
            }
        };
        DayTileEventRenderer.prototype.detachSegs = function (segs) {
            for (var _i = 0, segs_2 = segs; _i < segs_2.length; _i++) {
                var seg = segs_2[_i];
                core.removeElement(seg.el);
            }
        };
        return DayTileEventRenderer;
    }(SimpleDayGridEventRenderer));

    var DayBgRow = /** @class */ (function () {
        function DayBgRow(context) {
            this.context = context;
        }
        DayBgRow.prototype.renderHtml = function (props) {
            var parts = [];
            if (props.renderIntroHtml) {
                parts.push(props.renderIntroHtml());
            }
            for (var _i = 0, _a = props.cells; _i < _a.length; _i++) {
                var cell = _a[_i];
                parts.push(renderCellHtml(cell.date, props.dateProfile, this.context, cell.htmlAttrs));
            }
            if (!props.cells.length) {
                parts.push('<td class="fc-day ' + this.context.theme.getClass('widgetContent') + '"></td>');
            }
            if (this.context.options.dir === 'rtl') {
                parts.reverse();
            }
            return '<tr>' + parts.join('') + '</tr>';
        };
        return DayBgRow;
    }());
    function renderCellHtml(date, dateProfile, context, otherAttrs) {
        var dateEnv = context.dateEnv, theme = context.theme;
        var isDateValid = core.rangeContainsMarker(dateProfile.activeRange, date); // TODO: called too frequently. cache somehow.
        var classes = core.getDayClasses(date, dateProfile, context);
        classes.unshift('fc-day', theme.getClass('widgetContent'));
        return '<td class="' + classes.join(' ') + '"' +
            (isDateValid ?
                ' data-date="' + dateEnv.formatIso(date, { omitTime: true }) + '"' :
                '') +
            (otherAttrs ?
                ' ' + otherAttrs :
                '') +
            '></td>';
    }

    var DAY_NUM_FORMAT = core.createFormatter({ day: 'numeric' });
    var WEEK_NUM_FORMAT = core.createFormatter({ week: 'numeric' });
    var DayGrid = /** @class */ (function (_super) {
        __extends(DayGrid, _super);
        function DayGrid(context, el, renderProps) {
            var _this = _super.call(this, context, el) || this;
            _this.bottomCoordPadding = 0; // hack for extending the hit area for the last row of the coordinate grid
            _this.isCellSizesDirty = false;
            var eventRenderer = _this.eventRenderer = new DayGridEventRenderer(_this);
            var fillRenderer = _this.fillRenderer = new DayGridFillRenderer(_this);
            _this.mirrorRenderer = new DayGridMirrorRenderer(_this);
            var renderCells = _this.renderCells = core.memoizeRendering(_this._renderCells, _this._unrenderCells);
            _this.renderBusinessHours = core.memoizeRendering(fillRenderer.renderSegs.bind(fillRenderer, 'businessHours'), fillRenderer.unrender.bind(fillRenderer, 'businessHours'), [renderCells]);
            _this.renderDateSelection = core.memoizeRendering(fillRenderer.renderSegs.bind(fillRenderer, 'highlight'), fillRenderer.unrender.bind(fillRenderer, 'highlight'), [renderCells]);
            _this.renderBgEvents = core.memoizeRendering(fillRenderer.renderSegs.bind(fillRenderer, 'bgEvent'), fillRenderer.unrender.bind(fillRenderer, 'bgEvent'), [renderCells]);
            _this.renderFgEvents = core.memoizeRendering(eventRenderer.renderSegs.bind(eventRenderer), eventRenderer.unrender.bind(eventRenderer), [renderCells]);
            _this.renderEventSelection = core.memoizeRendering(eventRenderer.selectByInstanceId.bind(eventRenderer), eventRenderer.unselectByInstanceId.bind(eventRenderer), [_this.renderFgEvents]);
            _this.renderEventDrag = core.memoizeRendering(_this._renderEventDrag, _this._unrenderEventDrag, [renderCells]);
            _this.renderEventResize = core.memoizeRendering(_this._renderEventResize, _this._unrenderEventResize, [renderCells]);
            _this.renderProps = renderProps;
            return _this;
        }
        DayGrid.prototype.render = function (props) {
            var cells = props.cells;
            this.rowCnt = cells.length;
            this.colCnt = cells[0].length;
            this.renderCells(cells, props.isRigid);
            this.renderBusinessHours(props.businessHourSegs);
            this.renderDateSelection(props.dateSelectionSegs);
            this.renderBgEvents(props.bgEventSegs);
            this.renderFgEvents(props.fgEventSegs);
            this.renderEventSelection(props.eventSelection);
            this.renderEventDrag(props.eventDrag);
            this.renderEventResize(props.eventResize);
            if (this.segPopoverTile) {
                this.updateSegPopoverTile();
            }
        };
        DayGrid.prototype.destroy = function () {
            _super.prototype.destroy.call(this);
            this.renderCells.unrender(); // will unrender everything else
        };
        DayGrid.prototype.getCellRange = function (row, col) {
            var start = this.props.cells[row][col].date;
            var end = core.addDays(start, 1);
            return { start: start, end: end };
        };
        DayGrid.prototype.updateSegPopoverTile = function (date, segs) {
            var ownProps = this.props;
            this.segPopoverTile.receiveProps({
                date: date || this.segPopoverTile.props.date,
                fgSegs: segs || this.segPopoverTile.props.fgSegs,
                eventSelection: ownProps.eventSelection,
                eventDragInstances: ownProps.eventDrag ? ownProps.eventDrag.affectedInstances : null,
                eventResizeInstances: ownProps.eventResize ? ownProps.eventResize.affectedInstances : null
            });
        };
        /* Date Rendering
        ------------------------------------------------------------------------------------------------------------------*/
        DayGrid.prototype._renderCells = function (cells, isRigid) {
            var _a = this, view = _a.view, dateEnv = _a.dateEnv;
            var _b = this, rowCnt = _b.rowCnt, colCnt = _b.colCnt;
            var html = '';
            var row;
            var col;
            for (row = 0; row < rowCnt; row++) {
                html += this.renderDayRowHtml(row, isRigid);
            }
            this.el.innerHTML = html;
            this.rowEls = core.findElements(this.el, '.fc-row');
            this.cellEls = core.findElements(this.el, '.fc-day, .fc-disabled-day');
            if (this.isRtl) {
                this.cellEls.reverse();
            }
            this.rowPositions = new core.PositionCache(this.el, this.rowEls, false, true // vertical
            );
            this.colPositions = new core.PositionCache(this.el, this.cellEls.slice(0, colCnt), // only the first row
            true, false // horizontal
            );
            // trigger dayRender with each cell's element
            for (row = 0; row < rowCnt; row++) {
                for (col = 0; col < colCnt; col++) {
                    this.publiclyTrigger('dayRender', [
                        {
                            date: dateEnv.toDate(cells[row][col].date),
                            el: this.getCellEl(row, col),
                            view: view
                        }
                    ]);
                }
            }
            this.isCellSizesDirty = true;
        };
        DayGrid.prototype._unrenderCells = function () {
            this.removeSegPopover();
        };
        // Generates the HTML for a single row, which is a div that wraps a table.
        // `row` is the row number.
        DayGrid.prototype.renderDayRowHtml = function (row, isRigid) {
            var theme = this.theme;
            var classes = ['fc-row', 'fc-week', theme.getClass('dayRow')];
            if (isRigid) {
                classes.push('fc-rigid');
            }
            var bgRow = new DayBgRow(this.context);
            return '' +
                '<div class="' + classes.join(' ') + '">' +
                '<div class="fc-bg">' +
                '<table class="' + theme.getClass('tableGrid') + '">' +
                bgRow.renderHtml({
                    cells: this.props.cells[row],
                    dateProfile: this.props.dateProfile,
                    renderIntroHtml: this.renderProps.renderBgIntroHtml
                }) +
                '</table>' +
                '</div>' +
                '<div class="fc-content-skeleton">' +
                '<table>' +
                (this.getIsNumbersVisible() ?
                    '<thead>' +
                        this.renderNumberTrHtml(row) +
                        '</thead>' :
                    '') +
                '</table>' +
                '</div>' +
                '</div>';
        };
        DayGrid.prototype.getIsNumbersVisible = function () {
            return this.getIsDayNumbersVisible() ||
                this.renderProps.cellWeekNumbersVisible ||
                this.renderProps.colWeekNumbersVisible;
        };
        DayGrid.prototype.getIsDayNumbersVisible = function () {
            return this.rowCnt > 1;
        };
        /* Grid Number Rendering
        ------------------------------------------------------------------------------------------------------------------*/
        DayGrid.prototype.renderNumberTrHtml = function (row) {
            var intro = this.renderProps.renderNumberIntroHtml(row, this);
            return '' +
                '<tr>' +
                (this.isRtl ? '' : intro) +
                this.renderNumberCellsHtml(row) +
                (this.isRtl ? intro : '') +
                '</tr>';
        };
        DayGrid.prototype.renderNumberCellsHtml = function (row) {
            var htmls = [];
            var col;
            var date;
            for (col = 0; col < this.colCnt; col++) {
                date = this.props.cells[row][col].date;
                htmls.push(this.renderNumberCellHtml(date));
            }
            if (this.isRtl) {
                htmls.reverse();
            }
            return htmls.join('');
        };
        // Generates the HTML for the <td>s of the "number" row in the DayGrid's content skeleton.
        // The number row will only exist if either day numbers or week numbers are turned on.
        DayGrid.prototype.renderNumberCellHtml = function (date) {
            var _a = this, view = _a.view, dateEnv = _a.dateEnv;
            var html = '';
            var isDateValid = core.rangeContainsMarker(this.props.dateProfile.activeRange, date); // TODO: called too frequently. cache somehow.
            var isDayNumberVisible = this.getIsDayNumbersVisible() && isDateValid;
            var classes;
            var weekCalcFirstDow;
            if (!isDayNumberVisible && !this.renderProps.cellWeekNumbersVisible) {
                // no numbers in day cell (week number must be along the side)
                return '<td></td>'; //  will create an empty space above events :(
            }
            classes = core.getDayClasses(date, this.props.dateProfile, this.context);
            classes.unshift('fc-day-top');
            if (this.renderProps.cellWeekNumbersVisible) {
                weekCalcFirstDow = dateEnv.weekDow;
            }
            html += '<td class="' + classes.join(' ') + '"' +
                (isDateValid ?
                    ' data-date="' + dateEnv.formatIso(date, { omitTime: true }) + '"' :
                    '') +
                '>';
            if (this.renderProps.cellWeekNumbersVisible && (date.getUTCDay() === weekCalcFirstDow)) {
                html += core.buildGotoAnchorHtml(view, { date: date, type: 'week' }, { 'class': 'fc-week-number' }, dateEnv.format(date, WEEK_NUM_FORMAT) // inner HTML
                );
            }
            if (isDayNumberVisible) {
                html += core.buildGotoAnchorHtml(view, date, { 'class': 'fc-day-number' }, dateEnv.format(date, DAY_NUM_FORMAT) // inner HTML
                );
            }
            html += '</td>';
            return html;
        };
        /* Sizing
        ------------------------------------------------------------------------------------------------------------------*/
        DayGrid.prototype.updateSize = function (isResize) {
            var _a = this, fillRenderer = _a.fillRenderer, eventRenderer = _a.eventRenderer, mirrorRenderer = _a.mirrorRenderer;
            if (isResize ||
                this.isCellSizesDirty ||
                this.view.calendar.isEventsUpdated // hack
            ) {
                this.buildPositionCaches();
                this.isCellSizesDirty = false;
            }
            fillRenderer.computeSizes(isResize);
            eventRenderer.computeSizes(isResize);
            mirrorRenderer.computeSizes(isResize);
            fillRenderer.assignSizes(isResize);
            eventRenderer.assignSizes(isResize);
            mirrorRenderer.assignSizes(isResize);
        };
        DayGrid.prototype.buildPositionCaches = function () {
            this.buildColPositions();
            this.buildRowPositions();
        };
        DayGrid.prototype.buildColPositions = function () {
            this.colPositions.build();
        };
        DayGrid.prototype.buildRowPositions = function () {
            this.rowPositions.build();
            this.rowPositions.bottoms[this.rowCnt - 1] += this.bottomCoordPadding; // hack
        };
        /* Hit System
        ------------------------------------------------------------------------------------------------------------------*/
        DayGrid.prototype.positionToHit = function (leftPosition, topPosition) {
            var _a = this, colPositions = _a.colPositions, rowPositions = _a.rowPositions;
            var col = colPositions.leftToIndex(leftPosition);
            var row = rowPositions.topToIndex(topPosition);
            if (row != null && col != null) {
                return {
                    row: row,
                    col: col,
                    dateSpan: {
                        range: this.getCellRange(row, col),
                        allDay: true
                    },
                    dayEl: this.getCellEl(row, col),
                    relativeRect: {
                        left: colPositions.lefts[col],
                        right: colPositions.rights[col],
                        top: rowPositions.tops[row],
                        bottom: rowPositions.bottoms[row]
                    }
                };
            }
        };
        /* Cell System
        ------------------------------------------------------------------------------------------------------------------*/
        // FYI: the first column is the leftmost column, regardless of date
        DayGrid.prototype.getCellEl = function (row, col) {
            return this.cellEls[row * this.colCnt + col];
        };
        /* Event Drag Visualization
        ------------------------------------------------------------------------------------------------------------------*/
        DayGrid.prototype._renderEventDrag = function (state) {
            if (state) {
                this.eventRenderer.hideByHash(state.affectedInstances);
                this.fillRenderer.renderSegs('highlight', state.segs);
            }
        };
        DayGrid.prototype._unrenderEventDrag = function (state) {
            if (state) {
                this.eventRenderer.showByHash(state.affectedInstances);
                this.fillRenderer.unrender('highlight');
            }
        };
        /* Event Resize Visualization
        ------------------------------------------------------------------------------------------------------------------*/
        DayGrid.prototype._renderEventResize = function (state) {
            if (state) {
                this.eventRenderer.hideByHash(state.affectedInstances);
                this.fillRenderer.renderSegs('highlight', state.segs);
                this.mirrorRenderer.renderSegs(state.segs, { isResizing: true, sourceSeg: state.sourceSeg });
            }
        };
        DayGrid.prototype._unrenderEventResize = function (state) {
            if (state) {
                this.eventRenderer.showByHash(state.affectedInstances);
                this.fillRenderer.unrender('highlight');
                this.mirrorRenderer.unrender(state.segs, { isResizing: true, sourceSeg: state.sourceSeg });
            }
        };
        /* More+ Link Popover
        ------------------------------------------------------------------------------------------------------------------*/
        DayGrid.prototype.removeSegPopover = function () {
            if (this.segPopover) {
                this.segPopover.hide(); // in handler, will call segPopover's removeElement
            }
        };
        // Limits the number of "levels" (vertically stacking layers of events) for each row of the grid.
        // `levelLimit` can be false (don't limit), a number, or true (should be computed).
        DayGrid.prototype.limitRows = function (levelLimit) {
            var rowStructs = this.eventRenderer.rowStructs || [];
            var row; // row #
            var rowLevelLimit;
            for (row = 0; row < rowStructs.length; row++) {
                this.unlimitRow(row);
                if (!levelLimit) {
                    rowLevelLimit = false;
                }
                else if (typeof levelLimit === 'number') {
                    rowLevelLimit = levelLimit;
                }
                else {
                    rowLevelLimit = this.computeRowLevelLimit(row);
                }
                if (rowLevelLimit !== false) {
                    this.limitRow(row, rowLevelLimit);
                }
            }
        };
        // Computes the number of levels a row will accomodate without going outside its bounds.
        // Assumes the row is "rigid" (maintains a constant height regardless of what is inside).
        // `row` is the row number.
        DayGrid.prototype.computeRowLevelLimit = function (row) {
            var rowEl = this.rowEls[row]; // the containing "fake" row div
            var rowBottom = rowEl.getBoundingClientRect().bottom; // relative to viewport!
            var trEls = core.findChildren(this.eventRenderer.rowStructs[row].tbodyEl);
            var i;
            var trEl;
            // Reveal one level <tr> at a time and stop when we find one out of bounds
            for (i = 0; i < trEls.length; i++) {
                trEl = trEls[i];
                trEl.classList.remove('fc-limited'); // reset to original state (reveal)
                if (trEl.getBoundingClientRect().bottom > rowBottom) {
                    return i;
                }
            }
            return false; // should not limit at all
        };
        // Limits the given grid row to the maximum number of levels and injects "more" links if necessary.
        // `row` is the row number.
        // `levelLimit` is a number for the maximum (inclusive) number of levels allowed.
        DayGrid.prototype.limitRow = function (row, levelLimit) {
            var _this = this;
            var _a = this, colCnt = _a.colCnt, isRtl = _a.isRtl;
            var rowStruct = this.eventRenderer.rowStructs[row];
            var moreNodes = []; // array of "more" <a> links and <td> DOM nodes
            var col = 0; // col #, left-to-right (not chronologically)
            var levelSegs; // array of segment objects in the last allowable level, ordered left-to-right
            var cellMatrix; // a matrix (by level, then column) of all <td> elements in the row
            var limitedNodes; // array of temporarily hidden level <tr> and segment <td> DOM nodes
            var i;
            var seg;
            var segsBelow; // array of segment objects below `seg` in the current `col`
            var totalSegsBelow; // total number of segments below `seg` in any of the columns `seg` occupies
            var colSegsBelow; // array of segment arrays, below seg, one for each column (offset from segs's first column)
            var td;
            var rowSpan;
            var segMoreNodes; // array of "more" <td> cells that will stand-in for the current seg's cell
            var j;
            var moreTd;
            var moreWrap;
            var moreLink;
            // Iterates through empty level cells and places "more" links inside if need be
            var emptyCellsUntil = function (endCol) {
                while (col < endCol) {
                    segsBelow = _this.getCellSegs(row, col, levelLimit);
                    if (segsBelow.length) {
                        td = cellMatrix[levelLimit - 1][col];
                        moreLink = _this.renderMoreLink(row, col, segsBelow);
                        moreWrap = core.createElement('div', null, moreLink);
                        td.appendChild(moreWrap);
                        moreNodes.push(moreWrap);
                    }
                    col++;
                }
            };
            if (levelLimit && levelLimit < rowStruct.segLevels.length) { // is it actually over the limit?
                levelSegs = rowStruct.segLevels[levelLimit - 1];
                cellMatrix = rowStruct.cellMatrix;
                limitedNodes = core.findChildren(rowStruct.tbodyEl).slice(levelLimit); // get level <tr> elements past the limit
                limitedNodes.forEach(function (node) {
                    node.classList.add('fc-limited'); // hide elements and get a simple DOM-nodes array
                });
                // iterate though segments in the last allowable level
                for (i = 0; i < levelSegs.length; i++) {
                    seg = levelSegs[i];
                    var leftCol = isRtl ? (colCnt - 1 - seg.lastCol) : seg.firstCol;
                    var rightCol = isRtl ? (colCnt - 1 - seg.firstCol) : seg.lastCol;
                    emptyCellsUntil(leftCol); // process empty cells before the segment
                    // determine *all* segments below `seg` that occupy the same columns
                    colSegsBelow = [];
                    totalSegsBelow = 0;
                    while (col <= rightCol) {
                        segsBelow = this.getCellSegs(row, col, levelLimit);
                        colSegsBelow.push(segsBelow);
                        totalSegsBelow += segsBelow.length;
                        col++;
                    }
                    if (totalSegsBelow) { // do we need to replace this segment with one or many "more" links?
                        td = cellMatrix[levelLimit - 1][leftCol]; // the segment's parent cell
                        rowSpan = td.rowSpan || 1;
                        segMoreNodes = [];
                        // make a replacement <td> for each column the segment occupies. will be one for each colspan
                        for (j = 0; j < colSegsBelow.length; j++) {
                            moreTd = core.createElement('td', { className: 'fc-more-cell', rowSpan: rowSpan });
                            segsBelow = colSegsBelow[j];
                            moreLink = this.renderMoreLink(row, leftCol + j, [seg].concat(segsBelow) // count seg as hidden too
                            );
                            moreWrap = core.createElement('div', null, moreLink);
                            moreTd.appendChild(moreWrap);
                            segMoreNodes.push(moreTd);
                            moreNodes.push(moreTd);
                        }
                        td.classList.add('fc-limited');
                        core.insertAfterElement(td, segMoreNodes);
                        limitedNodes.push(td);
                    }
                }
                emptyCellsUntil(this.colCnt); // finish off the level
                rowStruct.moreEls = moreNodes; // for easy undoing later
                rowStruct.limitedEls = limitedNodes; // for easy undoing later
            }
        };
        // Reveals all levels and removes all "more"-related elements for a grid's row.
        // `row` is a row number.
        DayGrid.prototype.unlimitRow = function (row) {
            var rowStruct = this.eventRenderer.rowStructs[row];
            if (rowStruct.moreEls) {
                rowStruct.moreEls.forEach(core.removeElement);
                rowStruct.moreEls = null;
            }
            if (rowStruct.limitedEls) {
                rowStruct.limitedEls.forEach(function (limitedEl) {
                    limitedEl.classList.remove('fc-limited');
                });
                rowStruct.limitedEls = null;
            }
        };
        // Renders an <a> element that represents hidden event element for a cell.
        // Responsible for attaching click handler as well.
        DayGrid.prototype.renderMoreLink = function (row, col, hiddenSegs) {
            var _this = this;
            var _a = this, view = _a.view, dateEnv = _a.dateEnv;
            var a = core.createElement('a', { className: 'fc-more' });
            a.innerText = this.getMoreLinkText(hiddenSegs.length);
            a.addEventListener('click', function (ev) {
                var clickOption = _this.opt('eventLimitClick');
                var _col = _this.isRtl ? _this.colCnt - col - 1 : col; // HACK: props.cells has different dir system?
                var date = _this.props.cells[row][_col].date;
                var moreEl = ev.currentTarget;
                var dayEl = _this.getCellEl(row, col);
                var allSegs = _this.getCellSegs(row, col);
                // rescope the segments to be within the cell's date
                var reslicedAllSegs = _this.resliceDaySegs(allSegs, date);
                var reslicedHiddenSegs = _this.resliceDaySegs(hiddenSegs, date);
                if (typeof clickOption === 'function') {
                    // the returned value can be an atomic option
                    clickOption = _this.publiclyTrigger('eventLimitClick', [
                        {
                            date: dateEnv.toDate(date),
                            allDay: true,
                            dayEl: dayEl,
                            moreEl: moreEl,
                            segs: reslicedAllSegs,
                            hiddenSegs: reslicedHiddenSegs,
                            jsEvent: ev,
                            view: view
                        }
                    ]);
                }
                if (clickOption === 'popover') {
                    _this.showSegPopover(row, col, moreEl, reslicedAllSegs);
                }
                else if (typeof clickOption === 'string') { // a view name
                    view.calendar.zoomTo(date, clickOption);
                }
            });
            return a;
        };
        // Reveals the popover that displays all events within a cell
        DayGrid.prototype.showSegPopover = function (row, col, moreLink, segs) {
            var _this = this;
            var _a = this, calendar = _a.calendar, view = _a.view, theme = _a.theme;
            var _col = this.isRtl ? this.colCnt - col - 1 : col; // HACK: props.cells has different dir system?
            var moreWrap = moreLink.parentNode; // the <div> wrapper around the <a>
            var topEl; // the element we want to match the top coordinate of
            var options;
            if (this.rowCnt === 1) {
                topEl = view.el; // will cause the popover to cover any sort of header
            }
            else {
                topEl = this.rowEls[row]; // will align with top of row
            }
            options = {
                className: 'fc-more-popover ' + theme.getClass('popover'),
                parentEl: view.el,
                top: core.computeRect(topEl).top,
                autoHide: true,
                content: function (el) {
                    _this.segPopoverTile = new DayTile(_this.context, el);
                    _this.updateSegPopoverTile(_this.props.cells[row][_col].date, segs);
                },
                hide: function () {
                    _this.segPopoverTile.destroy();
                    _this.segPopoverTile = null;
                    _this.segPopover.destroy();
                    _this.segPopover = null;
                }
            };
            // Determine horizontal coordinate.
            // We use the moreWrap instead of the <td> to avoid border confusion.
            if (this.isRtl) {
                options.right = core.computeRect(moreWrap).right + 1; // +1 to be over cell border
            }
            else {
                options.left = core.computeRect(moreWrap).left - 1; // -1 to be over cell border
            }
            this.segPopover = new Popover(options);
            this.segPopover.show();
            calendar.releaseAfterSizingTriggers(); // hack for eventPositioned
        };
        // Given the events within an array of segment objects, reslice them to be in a single day
        DayGrid.prototype.resliceDaySegs = function (segs, dayDate) {
            var dayStart = dayDate;
            var dayEnd = core.addDays(dayStart, 1);
            var dayRange = { start: dayStart, end: dayEnd };
            var newSegs = [];
            for (var _i = 0, segs_1 = segs; _i < segs_1.length; _i++) {
                var seg = segs_1[_i];
                var eventRange = seg.eventRange;
                var origRange = eventRange.range;
                var slicedRange = core.intersectRanges(origRange, dayRange);
                if (slicedRange) {
                    newSegs.push(__assign({}, seg, { eventRange: {
                            def: eventRange.def,
                            ui: __assign({}, eventRange.ui, { durationEditable: false }),
                            instance: eventRange.instance,
                            range: slicedRange
                        }, isStart: seg.isStart && slicedRange.start.valueOf() === origRange.start.valueOf(), isEnd: seg.isEnd && slicedRange.end.valueOf() === origRange.end.valueOf() }));
                }
            }
            return newSegs;
        };
        // Generates the text that should be inside a "more" link, given the number of events it represents
        DayGrid.prototype.getMoreLinkText = function (num) {
            var opt = this.opt('eventLimitText');
            if (typeof opt === 'function') {
                return opt(num);
            }
            else {
                return '+' + num + ' ' + opt;
            }
        };
        // Returns segments within a given cell.
        // If `startLevel` is specified, returns only events including and below that level. Otherwise returns all segs.
        DayGrid.prototype.getCellSegs = function (row, col, startLevel) {
            var segMatrix = this.eventRenderer.rowStructs[row].segMatrix;
            var level = startLevel || 0;
            var segs = [];
            var seg;
            while (level < segMatrix.length) {
                seg = segMatrix[level][col];
                if (seg) {
                    segs.push(seg);
                }
                level++;
            }
            return segs;
        };
        return DayGrid;
    }(core.DateComponent));

    var WEEK_NUM_FORMAT$1 = core.createFormatter({ week: 'numeric' });
    /* An abstract class for the daygrid views, as well as month view. Renders one or more rows of day cells.
    ----------------------------------------------------------------------------------------------------------------------*/
    // It is a manager for a DayGrid subcomponent, which does most of the heavy lifting.
    // It is responsible for managing width/height.
    var DayGridView = /** @class */ (function (_super) {
        __extends(DayGridView, _super);
        function DayGridView(context, viewSpec, dateProfileGenerator, parentEl) {
            var _this = _super.call(this, context, viewSpec, dateProfileGenerator, parentEl) || this;
            /* Header Rendering
            ------------------------------------------------------------------------------------------------------------------*/
            // Generates the HTML that will go before the day-of week header cells
            _this.renderHeadIntroHtml = function () {
                var theme = _this.theme;
                if (_this.colWeekNumbersVisible) {
                    return '' +
                        '<th class="fc-week-number ' + theme.getClass('widgetHeader') + '" ' + _this.weekNumberStyleAttr() + '>' +
                        '<span>' + // needed for matchCellWidths
                        core.htmlEscape(_this.opt('weekLabel')) +
                        '</span>' +
                        '</th>';
                }
                return '';
            };
            /* Day Grid Rendering
            ------------------------------------------------------------------------------------------------------------------*/
            // Generates the HTML that will go before content-skeleton cells that display the day/week numbers
            _this.renderDayGridNumberIntroHtml = function (row, dayGrid) {
                var dateEnv = _this.dateEnv;
                var weekStart = dayGrid.props.cells[row][0].date;
                if (_this.colWeekNumbersVisible) {
                    return '' +
                        '<td class="fc-week-number" ' + _this.weekNumberStyleAttr() + '>' +
                        core.buildGotoAnchorHtml(// aside from link, important for matchCellWidths
                        _this, { date: weekStart, type: 'week', forceOff: dayGrid.colCnt === 1 }, dateEnv.format(weekStart, WEEK_NUM_FORMAT$1) // inner HTML
                        ) +
                        '</td>';
                }
                return '';
            };
            // Generates the HTML that goes before the day bg cells for each day-row
            _this.renderDayGridBgIntroHtml = function () {
                var theme = _this.theme;
                if (_this.colWeekNumbersVisible) {
                    return '<td class="fc-week-number ' + theme.getClass('widgetContent') + '" ' + _this.weekNumberStyleAttr() + '></td>';
                }
                return '';
            };
            // Generates the HTML that goes before every other type of row generated by DayGrid.
            // Affects mirror-skeleton and highlight-skeleton rows.
            _this.renderDayGridIntroHtml = function () {
                if (_this.colWeekNumbersVisible) {
                    return '<td class="fc-week-number" ' + _this.weekNumberStyleAttr() + '></td>';
                }
                return '';
            };
            _this.el.classList.add('fc-dayGrid-view');
            _this.el.innerHTML = _this.renderSkeletonHtml();
            _this.scroller = new core.ScrollComponent('hidden', // overflow x
            'auto' // overflow y
            );
            var dayGridContainerEl = _this.scroller.el;
            _this.el.querySelector('.fc-body > tr > td').appendChild(dayGridContainerEl);
            dayGridContainerEl.classList.add('fc-day-grid-container');
            var dayGridEl = core.createElement('div', { className: 'fc-day-grid' });
            dayGridContainerEl.appendChild(dayGridEl);
            var cellWeekNumbersVisible;
            if (_this.opt('weekNumbers')) {
                if (_this.opt('weekNumbersWithinDays')) {
                    cellWeekNumbersVisible = true;
                    _this.colWeekNumbersVisible = false;
                }
                else {
                    cellWeekNumbersVisible = false;
                    _this.colWeekNumbersVisible = true;
                }
            }
            else {
                _this.colWeekNumbersVisible = false;
                cellWeekNumbersVisible = false;
            }
            _this.dayGrid = new DayGrid(_this.context, dayGridEl, {
                renderNumberIntroHtml: _this.renderDayGridNumberIntroHtml,
                renderBgIntroHtml: _this.renderDayGridBgIntroHtml,
                renderIntroHtml: _this.renderDayGridIntroHtml,
                colWeekNumbersVisible: _this.colWeekNumbersVisible,
                cellWeekNumbersVisible: cellWeekNumbersVisible
            });
            return _this;
        }
        DayGridView.prototype.destroy = function () {
            _super.prototype.destroy.call(this);
            this.dayGrid.destroy();
            this.scroller.destroy();
        };
        // Builds the HTML skeleton for the view.
        // The day-grid component will render inside of a container defined by this HTML.
        DayGridView.prototype.renderSkeletonHtml = function () {
            var theme = this.theme;
            return '' +
                '<table class="' + theme.getClass('tableGrid') + '">' +
                (this.opt('columnHeader') ?
                    '<thead class="fc-head">' +
                        '<tr>' +
                        '<td class="fc-head-container ' + theme.getClass('widgetHeader') + '">&nbsp;</td>' +
                        '</tr>' +
                        '</thead>' :
                    '') +
                '<tbody class="fc-body">' +
                '<tr>' +
                '<td class="' + theme.getClass('widgetContent') + '"></td>' +
                '</tr>' +
                '</tbody>' +
                '</table>';
        };
        // Generates an HTML attribute string for setting the width of the week number column, if it is known
        DayGridView.prototype.weekNumberStyleAttr = function () {
            if (this.weekNumberWidth != null) {
                return 'style="width:' + this.weekNumberWidth + 'px"';
            }
            return '';
        };
        // Determines whether each row should have a constant height
        DayGridView.prototype.hasRigidRows = function () {
            var eventLimit = this.opt('eventLimit');
            return eventLimit && typeof eventLimit !== 'number';
        };
        /* Dimensions
        ------------------------------------------------------------------------------------------------------------------*/
        DayGridView.prototype.updateSize = function (isResize, viewHeight, isAuto) {
            _super.prototype.updateSize.call(this, isResize, viewHeight, isAuto); // will call updateBaseSize. important that executes first
            this.dayGrid.updateSize(isResize);
        };
        // Refreshes the horizontal dimensions of the view
        DayGridView.prototype.updateBaseSize = function (isResize, viewHeight, isAuto) {
            var dayGrid = this.dayGrid;
            var eventLimit = this.opt('eventLimit');
            var headRowEl = this.header ? this.header.el : null; // HACK
            var scrollerHeight;
            var scrollbarWidths;
            // hack to give the view some height prior to dayGrid's columns being rendered
            // TODO: separate setting height from scroller VS dayGrid.
            if (!dayGrid.rowEls) {
                if (!isAuto) {
                    scrollerHeight = this.computeScrollerHeight(viewHeight);
                    this.scroller.setHeight(scrollerHeight);
                }
                return;
            }
            if (this.colWeekNumbersVisible) {
                // Make sure all week number cells running down the side have the same width.
                this.weekNumberWidth = core.matchCellWidths(core.findElements(this.el, '.fc-week-number'));
            }
            // reset all heights to be natural
            this.scroller.clear();
            if (headRowEl) {
                core.uncompensateScroll(headRowEl);
            }
            dayGrid.removeSegPopover(); // kill the "more" popover if displayed
            // is the event limit a constant level number?
            if (eventLimit && typeof eventLimit === 'number') {
                dayGrid.limitRows(eventLimit); // limit the levels first so the height can redistribute after
            }
            // distribute the height to the rows
            // (viewHeight is a "recommended" value if isAuto)
            scrollerHeight = this.computeScrollerHeight(viewHeight);
            this.setGridHeight(scrollerHeight, isAuto);
            // is the event limit dynamically calculated?
            if (eventLimit && typeof eventLimit !== 'number') {
                dayGrid.limitRows(eventLimit); // limit the levels after the grid's row heights have been set
            }
            if (!isAuto) { // should we force dimensions of the scroll container?
                this.scroller.setHeight(scrollerHeight);
                scrollbarWidths = this.scroller.getScrollbarWidths();
                if (scrollbarWidths.left || scrollbarWidths.right) { // using scrollbars?
                    if (headRowEl) {
                        core.compensateScroll(headRowEl, scrollbarWidths);
                    }
                    // doing the scrollbar compensation might have created text overflow which created more height. redo
                    scrollerHeight = this.computeScrollerHeight(viewHeight);
                    this.scroller.setHeight(scrollerHeight);
                }
                // guarantees the same scrollbar widths
                this.scroller.lockOverflow(scrollbarWidths);
            }
        };
        // given a desired total height of the view, returns what the height of the scroller should be
        DayGridView.prototype.computeScrollerHeight = function (viewHeight) {
            return viewHeight -
                core.subtractInnerElHeight(this.el, this.scroller.el); // everything that's NOT the scroller
        };
        // Sets the height of just the DayGrid component in this view
        DayGridView.prototype.setGridHeight = function (height, isAuto) {
            if (this.opt('monthMode')) {
                // if auto, make the height of each row the height that it would be if there were 6 weeks
                if (isAuto) {
                    height *= this.dayGrid.rowCnt / 6;
                }
                core.distributeHeight(this.dayGrid.rowEls, height, !isAuto); // if auto, don't compensate for height-hogging rows
            }
            else {
                if (isAuto) {
                    core.undistributeHeight(this.dayGrid.rowEls); // let the rows be their natural height with no expanding
                }
                else {
                    core.distributeHeight(this.dayGrid.rowEls, height, true); // true = compensate for height-hogging rows
                }
            }
        };
        /* Scroll
        ------------------------------------------------------------------------------------------------------------------*/
        DayGridView.prototype.computeDateScroll = function (duration) {
            return { top: 0 };
        };
        DayGridView.prototype.queryDateScroll = function () {
            return { top: this.scroller.getScrollTop() };
        };
        DayGridView.prototype.applyDateScroll = function (scroll) {
            if (scroll.top !== undefined) {
                this.scroller.setScrollTop(scroll.top);
            }
        };
        return DayGridView;
    }(core.View));
    DayGridView.prototype.dateProfileGeneratorClass = DayGridDateProfileGenerator;

    var SimpleDayGrid = /** @class */ (function (_super) {
        __extends(SimpleDayGrid, _super);
        function SimpleDayGrid(context, dayGrid) {
            var _this = _super.call(this, context, dayGrid.el) || this;
            _this.slicer = new DayGridSlicer();
            _this.dayGrid = dayGrid;
            context.calendar.registerInteractiveComponent(_this, { el: _this.dayGrid.el });
            return _this;
        }
        SimpleDayGrid.prototype.destroy = function () {
            _super.prototype.destroy.call(this);
            this.calendar.unregisterInteractiveComponent(this);
        };
        SimpleDayGrid.prototype.render = function (props) {
            var dayGrid = this.dayGrid;
            var dateProfile = props.dateProfile, dayTable = props.dayTable;
            dayGrid.receiveProps(__assign({}, this.slicer.sliceProps(props, dateProfile, props.nextDayThreshold, dayGrid, dayTable), { dateProfile: dateProfile, cells: dayTable.cells, isRigid: props.isRigid }));
        };
        SimpleDayGrid.prototype.buildPositionCaches = function () {
            this.dayGrid.buildPositionCaches();
        };
        SimpleDayGrid.prototype.queryHit = function (positionLeft, positionTop) {
            var rawHit = this.dayGrid.positionToHit(positionLeft, positionTop);
            if (rawHit) {
                return {
                    component: this.dayGrid,
                    dateSpan: rawHit.dateSpan,
                    dayEl: rawHit.dayEl,
                    rect: {
                        left: rawHit.relativeRect.left,
                        right: rawHit.relativeRect.right,
                        top: rawHit.relativeRect.top,
                        bottom: rawHit.relativeRect.bottom
                    },
                    layer: 0
                };
            }
        };
        return SimpleDayGrid;
    }(core.DateComponent));
    var DayGridSlicer = /** @class */ (function (_super) {
        __extends(DayGridSlicer, _super);
        function DayGridSlicer() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DayGridSlicer.prototype.sliceRange = function (dateRange, dayTable) {
            return dayTable.sliceRange(dateRange);
        };
        return DayGridSlicer;
    }(core.Slicer));

    var DayGridView$1 = /** @class */ (function (_super) {
        __extends(DayGridView, _super);
        function DayGridView(_context, viewSpec, dateProfileGenerator, parentEl) {
            var _this = _super.call(this, _context, viewSpec, dateProfileGenerator, parentEl) || this;
            _this.buildDayTable = core.memoize(buildDayTable);
            if (_this.opt('columnHeader')) {
                _this.header = new core.DayHeader(_this.context, _this.el.querySelector('.fc-head-container'));
            }
            _this.simpleDayGrid = new SimpleDayGrid(_this.context, _this.dayGrid);
            return _this;
        }
        DayGridView.prototype.destroy = function () {
            _super.prototype.destroy.call(this);
            if (this.header) {
                this.header.destroy();
            }
            this.simpleDayGrid.destroy();
        };
        DayGridView.prototype.render = function (props) {
            _super.prototype.render.call(this, props);
            var dateProfile = this.props.dateProfile;
            var dayTable = this.dayTable =
                this.buildDayTable(dateProfile, this.dateProfileGenerator);
            if (this.header) {
                this.header.receiveProps({
                    dateProfile: dateProfile,
                    dates: dayTable.headerDates,
                    datesRepDistinctDays: dayTable.rowCnt === 1,
                    renderIntroHtml: this.renderHeadIntroHtml
                });
            }
            this.simpleDayGrid.receiveProps({
                dateProfile: dateProfile,
                dayTable: dayTable,
                businessHours: props.businessHours,
                dateSelection: props.dateSelection,
                eventStore: props.eventStore,
                eventUiBases: props.eventUiBases,
                eventSelection: props.eventSelection,
                eventDrag: props.eventDrag,
                eventResize: props.eventResize,
                isRigid: this.hasRigidRows(),
                nextDayThreshold: this.nextDayThreshold
            });
        };
        return DayGridView;
    }(DayGridView));
    function buildDayTable(dateProfile, dateProfileGenerator) {
        var daySeries = new core.DaySeries(dateProfile.renderRange, dateProfileGenerator);
        return new core.DayTable(daySeries, /year|month|week/.test(dateProfile.currentRangeUnit));
    }

    var main = core.createPlugin({
        defaultView: 'dayGridMonth',
        views: {
            dayGrid: DayGridView$1,
            dayGridDay: {
                type: 'dayGrid',
                duration: { days: 1 }
            },
            dayGridWeek: {
                type: 'dayGrid',
                duration: { weeks: 1 }
            },
            dayGridMonth: {
                type: 'dayGrid',
                duration: { months: 1 },
                monthMode: true,
                fixedWeekCount: true
            }
        }
    });

    exports.AbstractDayGridView = DayGridView;
    exports.DayBgRow = DayBgRow;
    exports.DayGrid = DayGrid;
    exports.DayGridSlicer = DayGridSlicer;
    exports.DayGridView = DayGridView$1;
    exports.SimpleDayGrid = SimpleDayGrid;
    exports.buildBasicDayTable = buildDayTable;
    exports.default = main;

    Object.defineProperty(exports, '__esModule', { value: true });

}));

/*!
FullCalendar List View Plugin v4.3.0
Docs & License: https://fullcalendar.io/
(c) 2019 Adam Shaw
*/

(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@fullcalendar/core')) :
    typeof define === 'function' && define.amd ? define(['exports', '@fullcalendar/core'], factory) :
    (global = global || self, factory(global.FullCalendarList = {}, global.FullCalendar));
}(this, function (exports, core) { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    /* global Reflect, Promise */

    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };

    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    var ListEventRenderer = /** @class */ (function (_super) {
        __extends(ListEventRenderer, _super);
        function ListEventRenderer(listView) {
            var _this = _super.call(this, listView.context) || this;
            _this.listView = listView;
            return _this;
        }
        ListEventRenderer.prototype.attachSegs = function (segs) {
            if (!segs.length) {
                this.listView.renderEmptyMessage();
            }
            else {
                this.listView.renderSegList(segs);
            }
        };
        ListEventRenderer.prototype.detachSegs = function () {
        };
        // generates the HTML for a single event row
        ListEventRenderer.prototype.renderSegHtml = function (seg) {
            var _a = this.context, view = _a.view, theme = _a.theme;
            var eventRange = seg.eventRange;
            var eventDef = eventRange.def;
            var eventInstance = eventRange.instance;
            var eventUi = eventRange.ui;
            var url = eventDef.url;
            var classes = ['fc-list-item'].concat(eventUi.classNames);
            var bgColor = eventUi.backgroundColor;
            var timeHtml;
            if (eventDef.allDay) {
                timeHtml = core.getAllDayHtml(view);
            }
            else if (core.isMultiDayRange(eventRange.range)) {
                if (seg.isStart) {
                    timeHtml = core.htmlEscape(this._getTimeText(eventInstance.range.start, seg.end, false // allDay
                    ));
                }
                else if (seg.isEnd) {
                    timeHtml = core.htmlEscape(this._getTimeText(seg.start, eventInstance.range.end, false // allDay
                    ));
                }
                else { // inner segment that lasts the whole day
                    timeHtml = core.getAllDayHtml(view);
                }
            }
            else {
                // Display the normal time text for the *event's* times
                timeHtml = core.htmlEscape(this.getTimeText(eventRange));
            }
            if (url) {
                classes.push('fc-has-url');
            }
            return '<tr class="' + classes.join(' ') + '">' +
                (this.displayEventTime ?
                    '<td class="fc-list-item-time ' + theme.getClass('widgetContent') + '">' +
                        (timeHtml || '') +
                        '</td>' :
                    '') +
                '<td class="fc-list-item-marker ' + theme.getClass('widgetContent') + '">' +
                '<span class="fc-event-dot"' +
                (bgColor ?
                    ' style="background-color:' + bgColor + '"' :
                    '') +
                '></span>' +
                '</td>' +
                '<td class="fc-list-item-title ' + theme.getClass('widgetContent') + '">' +
                '<a' + (url ? ' href="' + core.htmlEscape(url) + '"' : '') + '>' +
                core.htmlEscape(eventDef.title || '') +
                '</a>' +
                '</td>' +
                '</tr>';
        };
        // like "4:00am"
        ListEventRenderer.prototype.computeEventTimeFormat = function () {
            return {
                hour: 'numeric',
                minute: '2-digit',
                meridiem: 'short'
            };
        };
        return ListEventRenderer;
    }(core.FgEventRenderer));

    /*
    Responsible for the scroller, and forwarding event-related actions into the "grid".
    */
    var ListView = /** @class */ (function (_super) {
        __extends(ListView, _super);
        function ListView(context, viewSpec, dateProfileGenerator, parentEl) {
            var _this = _super.call(this, context, viewSpec, dateProfileGenerator, parentEl) || this;
            _this.computeDateVars = core.memoize(computeDateVars);
            _this.eventStoreToSegs = core.memoize(_this._eventStoreToSegs);
            var eventRenderer = _this.eventRenderer = new ListEventRenderer(_this);
            _this.renderContent = core.memoizeRendering(eventRenderer.renderSegs.bind(eventRenderer), eventRenderer.unrender.bind(eventRenderer));
            _this.el.classList.add('fc-list-view');
            var listViewClassNames = (_this.theme.getClass('listView') || '').split(' '); // wish we didn't have to do this
            for (var _i = 0, listViewClassNames_1 = listViewClassNames; _i < listViewClassNames_1.length; _i++) {
                var listViewClassName = listViewClassNames_1[_i];
                if (listViewClassName) { // in case input was empty string
                    _this.el.classList.add(listViewClassName);
                }
            }
            _this.scroller = new core.ScrollComponent('hidden', // overflow x
            'auto' // overflow y
            );
            _this.el.appendChild(_this.scroller.el);
            _this.contentEl = _this.scroller.el; // shortcut
            context.calendar.registerInteractiveComponent(_this, {
                el: _this.el
                // TODO: make aware that it doesn't do Hits
            });
            return _this;
        }
        ListView.prototype.render = function (props) {
            var _a = this.computeDateVars(props.dateProfile), dayDates = _a.dayDates, dayRanges = _a.dayRanges;
            this.dayDates = dayDates;
            this.renderContent(this.eventStoreToSegs(props.eventStore, props.eventUiBases, dayRanges));
        };
        ListView.prototype.destroy = function () {
            _super.prototype.destroy.call(this);
            this.renderContent.unrender();
            this.scroller.destroy(); // will remove the Grid too
            this.calendar.unregisterInteractiveComponent(this);
        };
        ListView.prototype.updateSize = function (isResize, viewHeight, isAuto) {
            _super.prototype.updateSize.call(this, isResize, viewHeight, isAuto);
            this.eventRenderer.computeSizes(isResize);
            this.eventRenderer.assignSizes(isResize);
            this.scroller.clear(); // sets height to 'auto' and clears overflow
            if (!isAuto) {
                this.scroller.setHeight(this.computeScrollerHeight(viewHeight));
            }
        };
        ListView.prototype.computeScrollerHeight = function (viewHeight) {
            return viewHeight -
                core.subtractInnerElHeight(this.el, this.scroller.el); // everything that's NOT the scroller
        };
        ListView.prototype._eventStoreToSegs = function (eventStore, eventUiBases, dayRanges) {
            return this.eventRangesToSegs(core.sliceEventStore(eventStore, eventUiBases, this.props.dateProfile.activeRange, this.nextDayThreshold).fg, dayRanges);
        };
        ListView.prototype.eventRangesToSegs = function (eventRanges, dayRanges) {
            var segs = [];
            for (var _i = 0, eventRanges_1 = eventRanges; _i < eventRanges_1.length; _i++) {
                var eventRange = eventRanges_1[_i];
                segs.push.apply(segs, this.eventRangeToSegs(eventRange, dayRanges));
            }
            return segs;
        };
        ListView.prototype.eventRangeToSegs = function (eventRange, dayRanges) {
            var _a = this, dateEnv = _a.dateEnv, nextDayThreshold = _a.nextDayThreshold;
            var range = eventRange.range;
            var allDay = eventRange.def.allDay;
            var dayIndex;
            var segRange;
            var seg;
            var segs = [];
            for (dayIndex = 0; dayIndex < dayRanges.length; dayIndex++) {
                segRange = core.intersectRanges(range, dayRanges[dayIndex]);
                if (segRange) {
                    seg = {
                        component: this,
                        eventRange: eventRange,
                        start: segRange.start,
                        end: segRange.end,
                        isStart: eventRange.isStart && segRange.start.valueOf() === range.start.valueOf(),
                        isEnd: eventRange.isEnd && segRange.end.valueOf() === range.end.valueOf(),
                        dayIndex: dayIndex
                    };
                    segs.push(seg);
                    // detect when range won't go fully into the next day,
                    // and mutate the latest seg to the be the end.
                    if (!seg.isEnd && !allDay &&
                        dayIndex + 1 < dayRanges.length &&
                        range.end <
                            dateEnv.add(dayRanges[dayIndex + 1].start, nextDayThreshold)) {
                        seg.end = range.end;
                        seg.isEnd = true;
                        break;
                    }
                }
            }
            return segs;
        };
        ListView.prototype.renderEmptyMessage = function () {
            this.contentEl.innerHTML =
                '<div class="fc-list-empty-wrap2">' + // TODO: try less wraps
                    '<div class="fc-list-empty-wrap1">' +
                    '<div class="fc-list-empty">' +
                    core.htmlEscape(this.opt('noEventsMessage')) +
                    '</div>' +
                    '</div>' +
                    '</div>';
        };
        // called by ListEventRenderer
        ListView.prototype.renderSegList = function (allSegs) {
            var segsByDay = this.groupSegsByDay(allSegs); // sparse array
            var dayIndex;
            var daySegs;
            var i;
            var tableEl = core.htmlToElement('<table class="fc-list-table ' + this.calendar.theme.getClass('tableList') + '"><tbody></tbody></table>');
            var tbodyEl = tableEl.querySelector('tbody');
            for (dayIndex = 0; dayIndex < segsByDay.length; dayIndex++) {
                daySegs = segsByDay[dayIndex];
                if (daySegs) { // sparse array, so might be undefined
                    // append a day header
                    tbodyEl.appendChild(this.buildDayHeaderRow(this.dayDates[dayIndex]));
                    daySegs = this.eventRenderer.sortEventSegs(daySegs);
                    for (i = 0; i < daySegs.length; i++) {
                        tbodyEl.appendChild(daySegs[i].el); // append event row
                    }
                }
            }
            this.contentEl.innerHTML = '';
            this.contentEl.appendChild(tableEl);
        };
        // Returns a sparse array of arrays, segs grouped by their dayIndex
        ListView.prototype.groupSegsByDay = function (segs) {
            var segsByDay = []; // sparse array
            var i;
            var seg;
            for (i = 0; i < segs.length; i++) {
                seg = segs[i];
                (segsByDay[seg.dayIndex] || (segsByDay[seg.dayIndex] = []))
                    .push(seg);
            }
            return segsByDay;
        };
        // generates the HTML for the day headers that live amongst the event rows
        ListView.prototype.buildDayHeaderRow = function (dayDate) {
            var dateEnv = this.dateEnv;
            var mainFormat = core.createFormatter(this.opt('listDayFormat')); // TODO: cache
            var altFormat = core.createFormatter(this.opt('listDayAltFormat')); // TODO: cache
            return core.createElement('tr', {
                className: 'fc-list-heading',
                'data-date': dateEnv.formatIso(dayDate, { omitTime: true })
            }, '<td class="' + (this.calendar.theme.getClass('tableListHeading') ||
                this.calendar.theme.getClass('widgetHeader')) + '" colspan="3">' +
                (mainFormat ?
                    core.buildGotoAnchorHtml(this, dayDate, { 'class': 'fc-list-heading-main' }, core.htmlEscape(dateEnv.format(dayDate, mainFormat)) // inner HTML
                    ) :
                    '') +
                (altFormat ?
                    core.buildGotoAnchorHtml(this, dayDate, { 'class': 'fc-list-heading-alt' }, core.htmlEscape(dateEnv.format(dayDate, altFormat)) // inner HTML
                    ) :
                    '') +
                '</td>');
        };
        return ListView;
    }(core.View));
    ListView.prototype.fgSegSelector = '.fc-list-item'; // which elements accept event actions
    function computeDateVars(dateProfile) {
        var dayStart = core.startOfDay(dateProfile.renderRange.start);
        var viewEnd = dateProfile.renderRange.end;
        var dayDates = [];
        var dayRanges = [];
        while (dayStart < viewEnd) {
            dayDates.push(dayStart);
            dayRanges.push({
                start: dayStart,
                end: core.addDays(dayStart, 1)
            });
            dayStart = core.addDays(dayStart, 1);
        }
        return { dayDates: dayDates, dayRanges: dayRanges };
    }

    var main = core.createPlugin({
        views: {
            list: {
                class: ListView,
                buttonTextKey: 'list',
                listDayFormat: { month: 'long', day: 'numeric', year: 'numeric' } // like "January 1, 2016"
            },
            listDay: {
                type: 'list',
                duration: { days: 1 },
                listDayFormat: { weekday: 'long' } // day-of-week is all we need. full date is probably in header
            },
            listWeek: {
                type: 'list',
                duration: { weeks: 1 },
                listDayFormat: { weekday: 'long' },
                listDayAltFormat: { month: 'long', day: 'numeric', year: 'numeric' }
            },
            listMonth: {
                type: 'list',
                duration: { month: 1 },
                listDayAltFormat: { weekday: 'long' } // day-of-week is nice-to-have
            },
            listYear: {
                type: 'list',
                duration: { year: 1 },
                listDayAltFormat: { weekday: 'long' } // day-of-week is nice-to-have
            }
        }
    });

    exports.ListView = ListView;
    exports.default = main;

    Object.defineProperty(exports, '__esModule', { value: true });

}));

/*!
FullCalendar Time Grid Plugin v4.3.0
Docs & License: https://fullcalendar.io/
(c) 2019 Adam Shaw
*/

(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@fullcalendar/core'), require('@fullcalendar/daygrid')) :
    typeof define === 'function' && define.amd ? define(['exports', '@fullcalendar/core', '@fullcalendar/daygrid'], factory) :
    (global = global || self, factory(global.FullCalendarTimeGrid = {}, global.FullCalendar, global.FullCalendarDayGrid));
}(this, function (exports, core, daygrid) { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    /* global Reflect, Promise */

    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };

    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    var __assign = function() {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };

    /*
    Only handles foreground segs.
    Does not own rendering. Use for low-level util methods by TimeGrid.
    */
    var TimeGridEventRenderer = /** @class */ (function (_super) {
        __extends(TimeGridEventRenderer, _super);
        function TimeGridEventRenderer(timeGrid) {
            var _this = _super.call(this, timeGrid.context) || this;
            _this.timeGrid = timeGrid;
            _this.fullTimeFormat = core.createFormatter({
                hour: 'numeric',
                minute: '2-digit',
                separator: _this.context.options.defaultRangeSeparator
            });
            return _this;
        }
        // Given an array of foreground segments, render a DOM element for each, computes position,
        // and attaches to the column inner-container elements.
        TimeGridEventRenderer.prototype.attachSegs = function (segs, mirrorInfo) {
            var segsByCol = this.timeGrid.groupSegsByCol(segs);
            // order the segs within each column
            // TODO: have groupSegsByCol do this?
            for (var col = 0; col < segsByCol.length; col++) {
                segsByCol[col] = this.sortEventSegs(segsByCol[col]);
            }
            this.segsByCol = segsByCol;
            this.timeGrid.attachSegsByCol(segsByCol, this.timeGrid.fgContainerEls);
        };
        TimeGridEventRenderer.prototype.detachSegs = function (segs) {
            segs.forEach(function (seg) {
                core.removeElement(seg.el);
            });
            this.segsByCol = null;
        };
        TimeGridEventRenderer.prototype.computeSegSizes = function (allSegs) {
            var _a = this, timeGrid = _a.timeGrid, segsByCol = _a.segsByCol;
            var colCnt = timeGrid.colCnt;
            timeGrid.computeSegVerticals(allSegs); // horizontals relies on this
            if (segsByCol) {
                for (var col = 0; col < colCnt; col++) {
                    this.computeSegHorizontals(segsByCol[col]); // compute horizontal coordinates, z-index's, and reorder the array
                }
            }
        };
        TimeGridEventRenderer.prototype.assignSegSizes = function (allSegs) {
            var _a = this, timeGrid = _a.timeGrid, segsByCol = _a.segsByCol;
            var colCnt = timeGrid.colCnt;
            timeGrid.assignSegVerticals(allSegs); // horizontals relies on this
            if (segsByCol) {
                for (var col = 0; col < colCnt; col++) {
                    this.assignSegCss(segsByCol[col]);
                }
            }
        };
        // Computes a default event time formatting string if `eventTimeFormat` is not explicitly defined
        TimeGridEventRenderer.prototype.computeEventTimeFormat = function () {
            return {
                hour: 'numeric',
                minute: '2-digit',
                meridiem: false
            };
        };
        // Computes a default `displayEventEnd` value if one is not expliclty defined
        TimeGridEventRenderer.prototype.computeDisplayEventEnd = function () {
            return true;
        };
        // Renders the HTML for a single event segment's default rendering
        TimeGridEventRenderer.prototype.renderSegHtml = function (seg, mirrorInfo) {
            var view = this.context.view;
            var eventRange = seg.eventRange;
            var eventDef = eventRange.def;
            var eventUi = eventRange.ui;
            var allDay = eventDef.allDay;
            var isDraggable = view.computeEventDraggable(eventDef, eventUi);
            var isResizableFromStart = seg.isStart && view.computeEventStartResizable(eventDef, eventUi);
            var isResizableFromEnd = seg.isEnd && view.computeEventEndResizable(eventDef, eventUi);
            var classes = this.getSegClasses(seg, isDraggable, isResizableFromStart || isResizableFromEnd, mirrorInfo);
            var skinCss = core.cssToStr(this.getSkinCss(eventUi));
            var timeText;
            var fullTimeText; // more verbose time text. for the print stylesheet
            var startTimeText; // just the start time text
            classes.unshift('fc-time-grid-event');
            // if the event appears to span more than one day...
            if (core.isMultiDayRange(eventRange.range)) {
                // Don't display time text on segments that run entirely through a day.
                // That would appear as midnight-midnight and would look dumb.
                // Otherwise, display the time text for the *segment's* times (like 6pm-midnight or midnight-10am)
                if (seg.isStart || seg.isEnd) {
                    var unzonedStart = seg.start;
                    var unzonedEnd = seg.end;
                    timeText = this._getTimeText(unzonedStart, unzonedEnd, allDay); // TODO: give the timezones
                    fullTimeText = this._getTimeText(unzonedStart, unzonedEnd, allDay, this.fullTimeFormat);
                    startTimeText = this._getTimeText(unzonedStart, unzonedEnd, allDay, null, false); // displayEnd=false
                }
            }
            else {
                // Display the normal time text for the *event's* times
                timeText = this.getTimeText(eventRange);
                fullTimeText = this.getTimeText(eventRange, this.fullTimeFormat);
                startTimeText = this.getTimeText(eventRange, null, false); // displayEnd=false
            }
            return '<a class="' + classes.join(' ') + '"' +
                (eventDef.url ?
                    ' href="' + core.htmlEscape(eventDef.url) + '"' :
                    '') +
                (skinCss ?
                    ' style="' + skinCss + '"' :
                    '') +
                '>' +
                '<div class="fc-content">' +
                (timeText ?
                    '<div class="fc-time"' +
                        ' data-start="' + core.htmlEscape(startTimeText) + '"' +
                        ' data-full="' + core.htmlEscape(fullTimeText) + '"' +
                        '>' +
                        '<span>' + core.htmlEscape(timeText) + '</span>' +
                        '</div>' :
                    '') +
                (eventDef.title ?
                    '<div class="fc-title">' +
                        core.htmlEscape(eventDef.title) +
                        '</div>' :
                    '') +
                '</div>' +
                /* TODO: write CSS for this
                (isResizableFromStart ?
                  '<div class="fc-resizer fc-start-resizer"></div>' :
                  ''
                  ) +
                */
                (isResizableFromEnd ?
                    '<div class="fc-resizer fc-end-resizer"></div>' :
                    '') +
                '</a>';
        };
        // Given an array of segments that are all in the same column, sets the backwardCoord and forwardCoord on each.
        // Assumed the segs are already ordered.
        // NOTE: Also reorders the given array by date!
        TimeGridEventRenderer.prototype.computeSegHorizontals = function (segs) {
            var levels;
            var level0;
            var i;
            levels = buildSlotSegLevels(segs);
            computeForwardSlotSegs(levels);
            if ((level0 = levels[0])) {
                for (i = 0; i < level0.length; i++) {
                    computeSlotSegPressures(level0[i]);
                }
                for (i = 0; i < level0.length; i++) {
                    this.computeSegForwardBack(level0[i], 0, 0);
                }
            }
        };
        // Calculate seg.forwardCoord and seg.backwardCoord for the segment, where both values range
        // from 0 to 1. If the calendar is left-to-right, the seg.backwardCoord maps to "left" and
        // seg.forwardCoord maps to "right" (via percentage). Vice-versa if the calendar is right-to-left.
        //
        // The segment might be part of a "series", which means consecutive segments with the same pressure
        // who's width is unknown until an edge has been hit. `seriesBackwardPressure` is the number of
        // segments behind this one in the current series, and `seriesBackwardCoord` is the starting
        // coordinate of the first segment in the series.
        TimeGridEventRenderer.prototype.computeSegForwardBack = function (seg, seriesBackwardPressure, seriesBackwardCoord) {
            var forwardSegs = seg.forwardSegs;
            var i;
            if (seg.forwardCoord === undefined) { // not already computed
                if (!forwardSegs.length) {
                    // if there are no forward segments, this segment should butt up against the edge
                    seg.forwardCoord = 1;
                }
                else {
                    // sort highest pressure first
                    this.sortForwardSegs(forwardSegs);
                    // this segment's forwardCoord will be calculated from the backwardCoord of the
                    // highest-pressure forward segment.
                    this.computeSegForwardBack(forwardSegs[0], seriesBackwardPressure + 1, seriesBackwardCoord);
                    seg.forwardCoord = forwardSegs[0].backwardCoord;
                }
                // calculate the backwardCoord from the forwardCoord. consider the series
                seg.backwardCoord = seg.forwardCoord -
                    (seg.forwardCoord - seriesBackwardCoord) / // available width for series
                        (seriesBackwardPressure + 1); // # of segments in the series
                // use this segment's coordinates to computed the coordinates of the less-pressurized
                // forward segments
                for (i = 0; i < forwardSegs.length; i++) {
                    this.computeSegForwardBack(forwardSegs[i], 0, seg.forwardCoord);
                }
            }
        };
        TimeGridEventRenderer.prototype.sortForwardSegs = function (forwardSegs) {
            var objs = forwardSegs.map(buildTimeGridSegCompareObj);
            var specs = [
                // put higher-pressure first
                { field: 'forwardPressure', order: -1 },
                // put segments that are closer to initial edge first (and favor ones with no coords yet)
                { field: 'backwardCoord', order: 1 }
            ].concat(this.context.view.eventOrderSpecs);
            objs.sort(function (obj0, obj1) {
                return core.compareByFieldSpecs(obj0, obj1, specs);
            });
            return objs.map(function (c) {
                return c._seg;
            });
        };
        // Given foreground event segments that have already had their position coordinates computed,
        // assigns position-related CSS values to their elements.
        TimeGridEventRenderer.prototype.assignSegCss = function (segs) {
            for (var _i = 0, segs_1 = segs; _i < segs_1.length; _i++) {
                var seg = segs_1[_i];
                core.applyStyle(seg.el, this.generateSegCss(seg));
                if (seg.level > 0) {
                    seg.el.classList.add('fc-time-grid-event-inset');
                }
                // if the event is short that the title will be cut off,
                // attach a className that condenses the title into the time area.
                if (seg.eventRange.def.title && seg.bottom - seg.top < 30) {
                    seg.el.classList.add('fc-short'); // TODO: "condensed" is a better name
                }
            }
        };
        // Generates an object with CSS properties/values that should be applied to an event segment element.
        // Contains important positioning-related properties that should be applied to any event element, customized or not.
        TimeGridEventRenderer.prototype.generateSegCss = function (seg) {
            var shouldOverlap = this.context.options.slotEventOverlap;
            var backwardCoord = seg.backwardCoord; // the left side if LTR. the right side if RTL. floating-point
            var forwardCoord = seg.forwardCoord; // the right side if LTR. the left side if RTL. floating-point
            var props = this.timeGrid.generateSegVerticalCss(seg); // get top/bottom first
            var isRtl = this.timeGrid.isRtl;
            var left; // amount of space from left edge, a fraction of the total width
            var right; // amount of space from right edge, a fraction of the total width
            if (shouldOverlap) {
                // double the width, but don't go beyond the maximum forward coordinate (1.0)
                forwardCoord = Math.min(1, backwardCoord + (forwardCoord - backwardCoord) * 2);
            }
            if (isRtl) {
                left = 1 - forwardCoord;
                right = backwardCoord;
            }
            else {
                left = backwardCoord;
                right = 1 - forwardCoord;
            }
            props.zIndex = seg.level + 1; // convert from 0-base to 1-based
            props.left = left * 100 + '%';
            props.right = right * 100 + '%';
            if (shouldOverlap && seg.forwardPressure) {
                // add padding to the edge so that forward stacked events don't cover the resizer's icon
                props[isRtl ? 'marginLeft' : 'marginRight'] = 10 * 2; // 10 is a guesstimate of the icon's width
            }
            return props;
        };
        return TimeGridEventRenderer;
    }(core.FgEventRenderer));
    // Builds an array of segments "levels". The first level will be the leftmost tier of segments if the calendar is
    // left-to-right, or the rightmost if the calendar is right-to-left. Assumes the segments are already ordered by date.
    function buildSlotSegLevels(segs) {
        var levels = [];
        var i;
        var seg;
        var j;
        for (i = 0; i < segs.length; i++) {
            seg = segs[i];
            // go through all the levels and stop on the first level where there are no collisions
            for (j = 0; j < levels.length; j++) {
                if (!computeSlotSegCollisions(seg, levels[j]).length) {
                    break;
                }
            }
            seg.level = j;
            (levels[j] || (levels[j] = [])).push(seg);
        }
        return levels;
    }
    // For every segment, figure out the other segments that are in subsequent
    // levels that also occupy the same vertical space. Accumulate in seg.forwardSegs
    function computeForwardSlotSegs(levels) {
        var i;
        var level;
        var j;
        var seg;
        var k;
        for (i = 0; i < levels.length; i++) {
            level = levels[i];
            for (j = 0; j < level.length; j++) {
                seg = level[j];
                seg.forwardSegs = [];
                for (k = i + 1; k < levels.length; k++) {
                    computeSlotSegCollisions(seg, levels[k], seg.forwardSegs);
                }
            }
        }
    }
    // Figure out which path forward (via seg.forwardSegs) results in the longest path until
    // the furthest edge is reached. The number of segments in this path will be seg.forwardPressure
    function computeSlotSegPressures(seg) {
        var forwardSegs = seg.forwardSegs;
        var forwardPressure = 0;
        var i;
        var forwardSeg;
        if (seg.forwardPressure === undefined) { // not already computed
            for (i = 0; i < forwardSegs.length; i++) {
                forwardSeg = forwardSegs[i];
                // figure out the child's maximum forward path
                computeSlotSegPressures(forwardSeg);
                // either use the existing maximum, or use the child's forward pressure
                // plus one (for the forwardSeg itself)
                forwardPressure = Math.max(forwardPressure, 1 + forwardSeg.forwardPressure);
            }
            seg.forwardPressure = forwardPressure;
        }
    }
    // Find all the segments in `otherSegs` that vertically collide with `seg`.
    // Append into an optionally-supplied `results` array and return.
    function computeSlotSegCollisions(seg, otherSegs, results) {
        if (results === void 0) { results = []; }
        for (var i = 0; i < otherSegs.length; i++) {
            if (isSlotSegCollision(seg, otherSegs[i])) {
                results.push(otherSegs[i]);
            }
        }
        return results;
    }
    // Do these segments occupy the same vertical space?
    function isSlotSegCollision(seg1, seg2) {
        return seg1.bottom > seg2.top && seg1.top < seg2.bottom;
    }
    function buildTimeGridSegCompareObj(seg) {
        var obj = core.buildSegCompareObj(seg);
        obj.forwardPressure = seg.forwardPressure;
        obj.backwardCoord = seg.backwardCoord;
        return obj;
    }

    var TimeGridMirrorRenderer = /** @class */ (function (_super) {
        __extends(TimeGridMirrorRenderer, _super);
        function TimeGridMirrorRenderer() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        TimeGridMirrorRenderer.prototype.attachSegs = function (segs, mirrorInfo) {
            this.segsByCol = this.timeGrid.groupSegsByCol(segs);
            this.timeGrid.attachSegsByCol(this.segsByCol, this.timeGrid.mirrorContainerEls);
            this.sourceSeg = mirrorInfo.sourceSeg;
        };
        TimeGridMirrorRenderer.prototype.generateSegCss = function (seg) {
            var props = _super.prototype.generateSegCss.call(this, seg);
            var sourceSeg = this.sourceSeg;
            if (sourceSeg && sourceSeg.col === seg.col) {
                var sourceSegProps = _super.prototype.generateSegCss.call(this, sourceSeg);
                props.left = sourceSegProps.left;
                props.right = sourceSegProps.right;
                props.marginLeft = sourceSegProps.marginLeft;
                props.marginRight = sourceSegProps.marginRight;
            }
            return props;
        };
        return TimeGridMirrorRenderer;
    }(TimeGridEventRenderer));

    var TimeGridFillRenderer = /** @class */ (function (_super) {
        __extends(TimeGridFillRenderer, _super);
        function TimeGridFillRenderer(timeGrid) {
            var _this = _super.call(this, timeGrid.context) || this;
            _this.timeGrid = timeGrid;
            return _this;
        }
        TimeGridFillRenderer.prototype.attachSegs = function (type, segs) {
            var timeGrid = this.timeGrid;
            var containerEls;
            // TODO: more efficient lookup
            if (type === 'bgEvent') {
                containerEls = timeGrid.bgContainerEls;
            }
            else if (type === 'businessHours') {
                containerEls = timeGrid.businessContainerEls;
            }
            else if (type === 'highlight') {
                containerEls = timeGrid.highlightContainerEls;
            }
            timeGrid.attachSegsByCol(timeGrid.groupSegsByCol(segs), containerEls);
            return segs.map(function (seg) {
                return seg.el;
            });
        };
        TimeGridFillRenderer.prototype.computeSegSizes = function (segs) {
            this.timeGrid.computeSegVerticals(segs);
        };
        TimeGridFillRenderer.prototype.assignSegSizes = function (segs) {
            this.timeGrid.assignSegVerticals(segs);
        };
        return TimeGridFillRenderer;
    }(core.FillRenderer));

    /* A component that renders one or more columns of vertical time slots
    ----------------------------------------------------------------------------------------------------------------------*/
    // potential nice values for the slot-duration and interval-duration
    // from largest to smallest
    var AGENDA_STOCK_SUB_DURATIONS = [
        { hours: 1 },
        { minutes: 30 },
        { minutes: 15 },
        { seconds: 30 },
        { seconds: 15 }
    ];
    var TimeGrid = /** @class */ (function (_super) {
        __extends(TimeGrid, _super);
        function TimeGrid(context, el, renderProps) {
            var _this = _super.call(this, context, el) || this;
            _this.isSlatSizesDirty = false;
            _this.isColSizesDirty = false;
            _this.renderSlats = core.memoizeRendering(_this._renderSlats);
            var eventRenderer = _this.eventRenderer = new TimeGridEventRenderer(_this);
            var fillRenderer = _this.fillRenderer = new TimeGridFillRenderer(_this);
            _this.mirrorRenderer = new TimeGridMirrorRenderer(_this);
            var renderColumns = _this.renderColumns = core.memoizeRendering(_this._renderColumns, _this._unrenderColumns);
            _this.renderBusinessHours = core.memoizeRendering(fillRenderer.renderSegs.bind(fillRenderer, 'businessHours'), fillRenderer.unrender.bind(fillRenderer, 'businessHours'), [renderColumns]);
            _this.renderDateSelection = core.memoizeRendering(_this._renderDateSelection, _this._unrenderDateSelection, [renderColumns]);
            _this.renderFgEvents = core.memoizeRendering(eventRenderer.renderSegs.bind(eventRenderer), eventRenderer.unrender.bind(eventRenderer), [renderColumns]);
            _this.renderBgEvents = core.memoizeRendering(fillRenderer.renderSegs.bind(fillRenderer, 'bgEvent'), fillRenderer.unrender.bind(fillRenderer, 'bgEvent'), [renderColumns]);
            _this.renderEventSelection = core.memoizeRendering(eventRenderer.selectByInstanceId.bind(eventRenderer), eventRenderer.unselectByInstanceId.bind(eventRenderer), [_this.renderFgEvents]);
            _this.renderEventDrag = core.memoizeRendering(_this._renderEventDrag, _this._unrenderEventDrag, [renderColumns]);
            _this.renderEventResize = core.memoizeRendering(_this._renderEventResize, _this._unrenderEventResize, [renderColumns]);
            _this.processOptions();
            el.innerHTML =
                '<div class="fc-bg"></div>' +
                    '<div class="fc-slats"></div>' +
                    '<hr class="fc-divider ' + _this.theme.getClass('widgetHeader') + '" style="display:none" />';
            _this.rootBgContainerEl = el.querySelector('.fc-bg');
            _this.slatContainerEl = el.querySelector('.fc-slats');
            _this.bottomRuleEl = el.querySelector('.fc-divider');
            _this.renderProps = renderProps;
            return _this;
        }
        /* Options
        ------------------------------------------------------------------------------------------------------------------*/
        // Parses various options into properties of this object
        TimeGrid.prototype.processOptions = function () {
            var slotDuration = this.opt('slotDuration');
            var snapDuration = this.opt('snapDuration');
            var snapsPerSlot;
            var input;
            slotDuration = core.createDuration(slotDuration);
            snapDuration = snapDuration ? core.createDuration(snapDuration) : slotDuration;
            snapsPerSlot = core.wholeDivideDurations(slotDuration, snapDuration);
            if (snapsPerSlot === null) {
                snapDuration = slotDuration;
                snapsPerSlot = 1;
                // TODO: say warning?
            }
            this.slotDuration = slotDuration;
            this.snapDuration = snapDuration;
            this.snapsPerSlot = snapsPerSlot;
            // might be an array value (for TimelineView).
            // if so, getting the most granular entry (the last one probably).
            input = this.opt('slotLabelFormat');
            if (Array.isArray(input)) {
                input = input[input.length - 1];
            }
            this.labelFormat = core.createFormatter(input || {
                hour: 'numeric',
                minute: '2-digit',
                omitZeroMinute: true,
                meridiem: 'short'
            });
            input = this.opt('slotLabelInterval');
            this.labelInterval = input ?
                core.createDuration(input) :
                this.computeLabelInterval(slotDuration);
        };
        // Computes an automatic value for slotLabelInterval
        TimeGrid.prototype.computeLabelInterval = function (slotDuration) {
            var i;
            var labelInterval;
            var slotsPerLabel;
            // find the smallest stock label interval that results in more than one slots-per-label
            for (i = AGENDA_STOCK_SUB_DURATIONS.length - 1; i >= 0; i--) {
                labelInterval = core.createDuration(AGENDA_STOCK_SUB_DURATIONS[i]);
                slotsPerLabel = core.wholeDivideDurations(labelInterval, slotDuration);
                if (slotsPerLabel !== null && slotsPerLabel > 1) {
                    return labelInterval;
                }
            }
            return slotDuration; // fall back
        };
        /* Rendering
        ------------------------------------------------------------------------------------------------------------------*/
        TimeGrid.prototype.render = function (props) {
            var cells = props.cells;
            this.colCnt = cells.length;
            this.renderSlats(props.dateProfile);
            this.renderColumns(props.cells, props.dateProfile);
            this.renderBusinessHours(props.businessHourSegs);
            this.renderDateSelection(props.dateSelectionSegs);
            this.renderFgEvents(props.fgEventSegs);
            this.renderBgEvents(props.bgEventSegs);
            this.renderEventSelection(props.eventSelection);
            this.renderEventDrag(props.eventDrag);
            this.renderEventResize(props.eventResize);
        };
        TimeGrid.prototype.destroy = function () {
            _super.prototype.destroy.call(this);
            // should unrender everything else too
            this.renderSlats.unrender();
            this.renderColumns.unrender();
        };
        TimeGrid.prototype.updateSize = function (isResize) {
            var _a = this, fillRenderer = _a.fillRenderer, eventRenderer = _a.eventRenderer, mirrorRenderer = _a.mirrorRenderer;
            if (isResize || this.isSlatSizesDirty) {
                this.buildSlatPositions();
                this.isSlatSizesDirty = false;
            }
            if (isResize || this.isColSizesDirty) {
                this.buildColPositions();
                this.isColSizesDirty = false;
            }
            fillRenderer.computeSizes(isResize);
            eventRenderer.computeSizes(isResize);
            mirrorRenderer.computeSizes(isResize);
            fillRenderer.assignSizes(isResize);
            eventRenderer.assignSizes(isResize);
            mirrorRenderer.assignSizes(isResize);
        };
        TimeGrid.prototype._renderSlats = function (dateProfile) {
            var theme = this.theme;
            this.slatContainerEl.innerHTML =
                '<table class="' + theme.getClass('tableGrid') + '">' +
                    this.renderSlatRowHtml(dateProfile) +
                    '</table>';
            this.slatEls = core.findElements(this.slatContainerEl, 'tr');
            this.slatPositions = new core.PositionCache(this.el, this.slatEls, false, true // vertical
            );
            this.isSlatSizesDirty = true;
        };
        // Generates the HTML for the horizontal "slats" that run width-wise. Has a time axis on a side. Depends on RTL.
        TimeGrid.prototype.renderSlatRowHtml = function (dateProfile) {
            var _a = this, dateEnv = _a.dateEnv, theme = _a.theme, isRtl = _a.isRtl;
            var html = '';
            var dayStart = core.startOfDay(dateProfile.renderRange.start);
            var slotTime = dateProfile.minTime;
            var slotIterator = core.createDuration(0);
            var slotDate; // will be on the view's first day, but we only care about its time
            var isLabeled;
            var axisHtml;
            // Calculate the time for each slot
            while (core.asRoughMs(slotTime) < core.asRoughMs(dateProfile.maxTime)) {
                slotDate = dateEnv.add(dayStart, slotTime);
                isLabeled = core.wholeDivideDurations(slotIterator, this.labelInterval) !== null;
                axisHtml =
                    '<td class="fc-axis fc-time ' + theme.getClass('widgetContent') + '">' +
                        (isLabeled ?
                            '<span>' + // for matchCellWidths
                                core.htmlEscape(dateEnv.format(slotDate, this.labelFormat)) +
                                '</span>' :
                            '') +
                        '</td>';
                html +=
                    '<tr data-time="' + core.formatIsoTimeString(slotDate) + '"' +
                        (isLabeled ? '' : ' class="fc-minor"') +
                        '>' +
                        (!isRtl ? axisHtml : '') +
                        '<td class="' + theme.getClass('widgetContent') + '"></td>' +
                        (isRtl ? axisHtml : '') +
                        '</tr>';
                slotTime = core.addDurations(slotTime, this.slotDuration);
                slotIterator = core.addDurations(slotIterator, this.slotDuration);
            }
            return html;
        };
        TimeGrid.prototype._renderColumns = function (cells, dateProfile) {
            var _a = this, theme = _a.theme, dateEnv = _a.dateEnv, view = _a.view;
            var bgRow = new daygrid.DayBgRow(this.context);
            this.rootBgContainerEl.innerHTML =
                '<table class="' + theme.getClass('tableGrid') + '">' +
                    bgRow.renderHtml({
                        cells: cells,
                        dateProfile: dateProfile,
                        renderIntroHtml: this.renderProps.renderBgIntroHtml
                    }) +
                    '</table>';
            this.colEls = core.findElements(this.el, '.fc-day, .fc-disabled-day');
            for (var col = 0; col < this.colCnt; col++) {
                this.publiclyTrigger('dayRender', [
                    {
                        date: dateEnv.toDate(cells[col].date),
                        el: this.colEls[col],
                        view: view
                    }
                ]);
            }
            if (this.isRtl) {
                this.colEls.reverse();
            }
            this.colPositions = new core.PositionCache(this.el, this.colEls, true, // horizontal
            false);
            this.renderContentSkeleton();
            this.isColSizesDirty = true;
        };
        TimeGrid.prototype._unrenderColumns = function () {
            this.unrenderContentSkeleton();
        };
        /* Content Skeleton
        ------------------------------------------------------------------------------------------------------------------*/
        // Renders the DOM that the view's content will live in
        TimeGrid.prototype.renderContentSkeleton = function () {
            var parts = [];
            var skeletonEl;
            parts.push(this.renderProps.renderIntroHtml());
            for (var i = 0; i < this.colCnt; i++) {
                parts.push('<td>' +
                    '<div class="fc-content-col">' +
                    '<div class="fc-event-container fc-mirror-container"></div>' +
                    '<div class="fc-event-container"></div>' +
                    '<div class="fc-highlight-container"></div>' +
                    '<div class="fc-bgevent-container"></div>' +
                    '<div class="fc-business-container"></div>' +
                    '</div>' +
                    '</td>');
            }
            if (this.isRtl) {
                parts.reverse();
            }
            skeletonEl = this.contentSkeletonEl = core.htmlToElement('<div class="fc-content-skeleton">' +
                '<table>' +
                '<tr>' + parts.join('') + '</tr>' +
                '</table>' +
                '</div>');
            this.colContainerEls = core.findElements(skeletonEl, '.fc-content-col');
            this.mirrorContainerEls = core.findElements(skeletonEl, '.fc-mirror-container');
            this.fgContainerEls = core.findElements(skeletonEl, '.fc-event-container:not(.fc-mirror-container)');
            this.bgContainerEls = core.findElements(skeletonEl, '.fc-bgevent-container');
            this.highlightContainerEls = core.findElements(skeletonEl, '.fc-highlight-container');
            this.businessContainerEls = core.findElements(skeletonEl, '.fc-business-container');
            if (this.isRtl) {
                this.colContainerEls.reverse();
                this.mirrorContainerEls.reverse();
                this.fgContainerEls.reverse();
                this.bgContainerEls.reverse();
                this.highlightContainerEls.reverse();
                this.businessContainerEls.reverse();
            }
            this.el.appendChild(skeletonEl);
        };
        TimeGrid.prototype.unrenderContentSkeleton = function () {
            core.removeElement(this.contentSkeletonEl);
        };
        // Given a flat array of segments, return an array of sub-arrays, grouped by each segment's col
        TimeGrid.prototype.groupSegsByCol = function (segs) {
            var segsByCol = [];
            var i;
            for (i = 0; i < this.colCnt; i++) {
                segsByCol.push([]);
            }
            for (i = 0; i < segs.length; i++) {
                segsByCol[segs[i].col].push(segs[i]);
            }
            return segsByCol;
        };
        // Given segments grouped by column, insert the segments' elements into a parallel array of container
        // elements, each living within a column.
        TimeGrid.prototype.attachSegsByCol = function (segsByCol, containerEls) {
            var col;
            var segs;
            var i;
            for (col = 0; col < this.colCnt; col++) { // iterate each column grouping
                segs = segsByCol[col];
                for (i = 0; i < segs.length; i++) {
                    containerEls[col].appendChild(segs[i].el);
                }
            }
        };
        /* Now Indicator
        ------------------------------------------------------------------------------------------------------------------*/
        TimeGrid.prototype.getNowIndicatorUnit = function () {
            return 'minute'; // will refresh on the minute
        };
        TimeGrid.prototype.renderNowIndicator = function (segs, date) {
            // HACK: if date columns not ready for some reason (scheduler)
            if (!this.colContainerEls) {
                return;
            }
            var top = this.computeDateTop(date);
            var nodes = [];
            var i;
            // render lines within the columns
            for (i = 0; i < segs.length; i++) {
                var lineEl = core.createElement('div', { className: 'fc-now-indicator fc-now-indicator-line' });
                lineEl.style.top = top + 'px';
                this.colContainerEls[segs[i].col].appendChild(lineEl);
                nodes.push(lineEl);
            }
            // render an arrow over the axis
            if (segs.length > 0) { // is the current time in view?
                var arrowEl = core.createElement('div', { className: 'fc-now-indicator fc-now-indicator-arrow' });
                arrowEl.style.top = top + 'px';
                this.contentSkeletonEl.appendChild(arrowEl);
                nodes.push(arrowEl);
            }
            this.nowIndicatorEls = nodes;
        };
        TimeGrid.prototype.unrenderNowIndicator = function () {
            if (this.nowIndicatorEls) {
                this.nowIndicatorEls.forEach(core.removeElement);
                this.nowIndicatorEls = null;
            }
        };
        /* Coordinates
        ------------------------------------------------------------------------------------------------------------------*/
        TimeGrid.prototype.getTotalSlatHeight = function () {
            return this.slatContainerEl.getBoundingClientRect().height;
        };
        // Computes the top coordinate, relative to the bounds of the grid, of the given date.
        // A `startOfDayDate` must be given for avoiding ambiguity over how to treat midnight.
        TimeGrid.prototype.computeDateTop = function (when, startOfDayDate) {
            if (!startOfDayDate) {
                startOfDayDate = core.startOfDay(when);
            }
            return this.computeTimeTop(core.createDuration(when.valueOf() - startOfDayDate.valueOf()));
        };
        // Computes the top coordinate, relative to the bounds of the grid, of the given time (a Duration).
        TimeGrid.prototype.computeTimeTop = function (duration) {
            var len = this.slatEls.length;
            var dateProfile = this.props.dateProfile;
            var slatCoverage = (duration.milliseconds - core.asRoughMs(dateProfile.minTime)) / core.asRoughMs(this.slotDuration); // floating-point value of # of slots covered
            var slatIndex;
            var slatRemainder;
            // compute a floating-point number for how many slats should be progressed through.
            // from 0 to number of slats (inclusive)
            // constrained because minTime/maxTime might be customized.
            slatCoverage = Math.max(0, slatCoverage);
            slatCoverage = Math.min(len, slatCoverage);
            // an integer index of the furthest whole slat
            // from 0 to number slats (*exclusive*, so len-1)
            slatIndex = Math.floor(slatCoverage);
            slatIndex = Math.min(slatIndex, len - 1);
            // how much further through the slatIndex slat (from 0.0-1.0) must be covered in addition.
            // could be 1.0 if slatCoverage is covering *all* the slots
            slatRemainder = slatCoverage - slatIndex;
            return this.slatPositions.tops[slatIndex] +
                this.slatPositions.getHeight(slatIndex) * slatRemainder;
        };
        // For each segment in an array, computes and assigns its top and bottom properties
        TimeGrid.prototype.computeSegVerticals = function (segs) {
            var eventMinHeight = this.opt('timeGridEventMinHeight');
            var i;
            var seg;
            var dayDate;
            for (i = 0; i < segs.length; i++) {
                seg = segs[i];
                dayDate = this.props.cells[seg.col].date;
                seg.top = this.computeDateTop(seg.start, dayDate);
                seg.bottom = Math.max(seg.top + eventMinHeight, this.computeDateTop(seg.end, dayDate));
            }
        };
        // Given segments that already have their top/bottom properties computed, applies those values to
        // the segments' elements.
        TimeGrid.prototype.assignSegVerticals = function (segs) {
            var i;
            var seg;
            for (i = 0; i < segs.length; i++) {
                seg = segs[i];
                core.applyStyle(seg.el, this.generateSegVerticalCss(seg));
            }
        };
        // Generates an object with CSS properties for the top/bottom coordinates of a segment element
        TimeGrid.prototype.generateSegVerticalCss = function (seg) {
            return {
                top: seg.top,
                bottom: -seg.bottom // flipped because needs to be space beyond bottom edge of event container
            };
        };
        /* Sizing
        ------------------------------------------------------------------------------------------------------------------*/
        TimeGrid.prototype.buildPositionCaches = function () {
            this.buildColPositions();
            this.buildSlatPositions();
        };
        TimeGrid.prototype.buildColPositions = function () {
            this.colPositions.build();
        };
        TimeGrid.prototype.buildSlatPositions = function () {
            this.slatPositions.build();
        };
        /* Hit System
        ------------------------------------------------------------------------------------------------------------------*/
        TimeGrid.prototype.positionToHit = function (positionLeft, positionTop) {
            var _a = this, dateEnv = _a.dateEnv, snapsPerSlot = _a.snapsPerSlot, slatPositions = _a.slatPositions, colPositions = _a.colPositions;
            var colIndex = colPositions.leftToIndex(positionLeft);
            var slatIndex = slatPositions.topToIndex(positionTop);
            if (colIndex != null && slatIndex != null) {
                var slatTop = slatPositions.tops[slatIndex];
                var slatHeight = slatPositions.getHeight(slatIndex);
                var partial = (positionTop - slatTop) / slatHeight; // floating point number between 0 and 1
                var localSnapIndex = Math.floor(partial * snapsPerSlot); // the snap # relative to start of slat
                var snapIndex = slatIndex * snapsPerSlot + localSnapIndex;
                var dayDate = this.props.cells[colIndex].date;
                var time = core.addDurations(this.props.dateProfile.minTime, core.multiplyDuration(this.snapDuration, snapIndex));
                var start = dateEnv.add(dayDate, time);
                var end = dateEnv.add(start, this.snapDuration);
                return {
                    col: colIndex,
                    dateSpan: {
                        range: { start: start, end: end },
                        allDay: false
                    },
                    dayEl: this.colEls[colIndex],
                    relativeRect: {
                        left: colPositions.lefts[colIndex],
                        right: colPositions.rights[colIndex],
                        top: slatTop,
                        bottom: slatTop + slatHeight
                    }
                };
            }
        };
        /* Event Drag Visualization
        ------------------------------------------------------------------------------------------------------------------*/
        TimeGrid.prototype._renderEventDrag = function (state) {
            if (state) {
                this.eventRenderer.hideByHash(state.affectedInstances);
                if (state.isEvent) {
                    this.mirrorRenderer.renderSegs(state.segs, { isDragging: true, sourceSeg: state.sourceSeg });
                }
                else {
                    this.fillRenderer.renderSegs('highlight', state.segs);
                }
            }
        };
        TimeGrid.prototype._unrenderEventDrag = function (state) {
            if (state) {
                this.eventRenderer.showByHash(state.affectedInstances);
                this.mirrorRenderer.unrender(state.segs, { isDragging: true, sourceSeg: state.sourceSeg });
                this.fillRenderer.unrender('highlight');
            }
        };
        /* Event Resize Visualization
        ------------------------------------------------------------------------------------------------------------------*/
        TimeGrid.prototype._renderEventResize = function (state) {
            if (state) {
                this.eventRenderer.hideByHash(state.affectedInstances);
                this.mirrorRenderer.renderSegs(state.segs, { isResizing: true, sourceSeg: state.sourceSeg });
            }
        };
        TimeGrid.prototype._unrenderEventResize = function (state) {
            if (state) {
                this.eventRenderer.showByHash(state.affectedInstances);
                this.mirrorRenderer.unrender(state.segs, { isResizing: true, sourceSeg: state.sourceSeg });
            }
        };
        /* Selection
        ------------------------------------------------------------------------------------------------------------------*/
        // Renders a visual indication of a selection. Overrides the default, which was to simply render a highlight.
        TimeGrid.prototype._renderDateSelection = function (segs) {
            if (segs) {
                if (this.opt('selectMirror')) {
                    this.mirrorRenderer.renderSegs(segs, { isSelecting: true });
                }
                else {
                    this.fillRenderer.renderSegs('highlight', segs);
                }
            }
        };
        TimeGrid.prototype._unrenderDateSelection = function (segs) {
            this.mirrorRenderer.unrender(segs, { isSelecting: true });
            this.fillRenderer.unrender('highlight');
        };
        return TimeGrid;
    }(core.DateComponent));

    var AllDaySplitter = /** @class */ (function (_super) {
        __extends(AllDaySplitter, _super);
        function AllDaySplitter() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        AllDaySplitter.prototype.getKeyInfo = function () {
            return {
                allDay: {},
                timed: {}
            };
        };
        AllDaySplitter.prototype.getKeysForDateSpan = function (dateSpan) {
            if (dateSpan.allDay) {
                return ['allDay'];
            }
            else {
                return ['timed'];
            }
        };
        AllDaySplitter.prototype.getKeysForEventDef = function (eventDef) {
            if (!eventDef.allDay) {
                return ['timed'];
            }
            else if (core.hasBgRendering(eventDef)) {
                return ['timed', 'allDay'];
            }
            else {
                return ['allDay'];
            }
        };
        return AllDaySplitter;
    }(core.Splitter));

    var TIMEGRID_ALL_DAY_EVENT_LIMIT = 5;
    var WEEK_HEADER_FORMAT = core.createFormatter({ week: 'short' });
    /* An abstract class for all timegrid-related views. Displays one more columns with time slots running vertically.
    ----------------------------------------------------------------------------------------------------------------------*/
    // Is a manager for the TimeGrid subcomponent and possibly the DayGrid subcomponent (if allDaySlot is on).
    // Responsible for managing width/height.
    var TimeGridView = /** @class */ (function (_super) {
        __extends(TimeGridView, _super);
        function TimeGridView(context, viewSpec, dateProfileGenerator, parentEl) {
            var _this = _super.call(this, context, viewSpec, dateProfileGenerator, parentEl) || this;
            _this.splitter = new AllDaySplitter();
            /* Header Render Methods
            ------------------------------------------------------------------------------------------------------------------*/
            // Generates the HTML that will go before the day-of week header cells
            _this.renderHeadIntroHtml = function () {
                var _a = _this, theme = _a.theme, dateEnv = _a.dateEnv;
                var range = _this.props.dateProfile.renderRange;
                var dayCnt = core.diffDays(range.start, range.end);
                var weekText;
                if (_this.opt('weekNumbers')) {
                    weekText = dateEnv.format(range.start, WEEK_HEADER_FORMAT);
                    return '' +
                        '<th class="fc-axis fc-week-number ' + theme.getClass('widgetHeader') + '" ' + _this.axisStyleAttr() + '>' +
                        core.buildGotoAnchorHtml(// aside from link, important for matchCellWidths
                        _this, { date: range.start, type: 'week', forceOff: dayCnt > 1 }, core.htmlEscape(weekText) // inner HTML
                        ) +
                        '</th>';
                }
                else {
                    return '<th class="fc-axis ' + theme.getClass('widgetHeader') + '" ' + _this.axisStyleAttr() + '></th>';
                }
            };
            /* Time Grid Render Methods
            ------------------------------------------------------------------------------------------------------------------*/
            // Generates the HTML that goes before the bg of the TimeGrid slot area. Long vertical column.
            _this.renderTimeGridBgIntroHtml = function () {
                var theme = _this.theme;
                return '<td class="fc-axis ' + theme.getClass('widgetContent') + '" ' + _this.axisStyleAttr() + '></td>';
            };
            // Generates the HTML that goes before all other types of cells.
            // Affects content-skeleton, mirror-skeleton, highlight-skeleton for both the time-grid and day-grid.
            _this.renderTimeGridIntroHtml = function () {
                return '<td class="fc-axis" ' + _this.axisStyleAttr() + '></td>';
            };
            /* Day Grid Render Methods
            ------------------------------------------------------------------------------------------------------------------*/
            // Generates the HTML that goes before the all-day cells
            _this.renderDayGridBgIntroHtml = function () {
                var theme = _this.theme;
                return '' +
                    '<td class="fc-axis ' + theme.getClass('widgetContent') + '" ' + _this.axisStyleAttr() + '>' +
                    '<span>' + // needed for matchCellWidths
                    core.getAllDayHtml(_this) +
                    '</span>' +
                    '</td>';
            };
            // Generates the HTML that goes before all other types of cells.
            // Affects content-skeleton, mirror-skeleton, highlight-skeleton for both the time-grid and day-grid.
            _this.renderDayGridIntroHtml = function () {
                return '<td class="fc-axis" ' + _this.axisStyleAttr() + '></td>';
            };
            _this.el.classList.add('fc-timeGrid-view');
            _this.el.innerHTML = _this.renderSkeletonHtml();
            _this.scroller = new core.ScrollComponent('hidden', // overflow x
            'auto' // overflow y
            );
            var timeGridWrapEl = _this.scroller.el;
            _this.el.querySelector('.fc-body > tr > td').appendChild(timeGridWrapEl);
            timeGridWrapEl.classList.add('fc-time-grid-container');
            var timeGridEl = core.createElement('div', { className: 'fc-time-grid' });
            timeGridWrapEl.appendChild(timeGridEl);
            _this.timeGrid = new TimeGrid(_this.context, timeGridEl, {
                renderBgIntroHtml: _this.renderTimeGridBgIntroHtml,
                renderIntroHtml: _this.renderTimeGridIntroHtml
            });
            if (_this.opt('allDaySlot')) { // should we display the "all-day" area?
                _this.dayGrid = new daygrid.DayGrid(// the all-day subcomponent of this view
                _this.context, _this.el.querySelector('.fc-day-grid'), {
                    renderNumberIntroHtml: _this.renderDayGridIntroHtml,
                    renderBgIntroHtml: _this.renderDayGridBgIntroHtml,
                    renderIntroHtml: _this.renderDayGridIntroHtml,
                    colWeekNumbersVisible: false,
                    cellWeekNumbersVisible: false
                });
                // have the day-grid extend it's coordinate area over the <hr> dividing the two grids
                var dividerEl = _this.el.querySelector('.fc-divider');
                _this.dayGrid.bottomCoordPadding = dividerEl.getBoundingClientRect().height;
            }
            return _this;
        }
        TimeGridView.prototype.destroy = function () {
            _super.prototype.destroy.call(this);
            this.timeGrid.destroy();
            if (this.dayGrid) {
                this.dayGrid.destroy();
            }
            this.scroller.destroy();
        };
        /* Rendering
        ------------------------------------------------------------------------------------------------------------------*/
        // Builds the HTML skeleton for the view.
        // The day-grid and time-grid components will render inside containers defined by this HTML.
        TimeGridView.prototype.renderSkeletonHtml = function () {
            var theme = this.theme;
            return '' +
                '<table class="' + theme.getClass('tableGrid') + '">' +
                (this.opt('columnHeader') ?
                    '<thead class="fc-head">' +
                        '<tr>' +
                        '<td class="fc-head-container ' + theme.getClass('widgetHeader') + '">&nbsp;</td>' +
                        '</tr>' +
                        '</thead>' :
                    '') +
                '<tbody class="fc-body">' +
                '<tr>' +
                '<td class="' + theme.getClass('widgetContent') + '">' +
                (this.opt('allDaySlot') ?
                    '<div class="fc-day-grid"></div>' +
                        '<hr class="fc-divider ' + theme.getClass('widgetHeader') + '" />' :
                    '') +
                '</td>' +
                '</tr>' +
                '</tbody>' +
                '</table>';
        };
        /* Now Indicator
        ------------------------------------------------------------------------------------------------------------------*/
        TimeGridView.prototype.getNowIndicatorUnit = function () {
            return this.timeGrid.getNowIndicatorUnit();
        };
        // subclasses should implement
        // renderNowIndicator(date: DateMarker) {
        // }
        TimeGridView.prototype.unrenderNowIndicator = function () {
            this.timeGrid.unrenderNowIndicator();
        };
        /* Dimensions
        ------------------------------------------------------------------------------------------------------------------*/
        TimeGridView.prototype.updateSize = function (isResize, viewHeight, isAuto) {
            _super.prototype.updateSize.call(this, isResize, viewHeight, isAuto); // will call updateBaseSize. important that executes first
            this.timeGrid.updateSize(isResize);
            if (this.dayGrid) {
                this.dayGrid.updateSize(isResize);
            }
        };
        // Adjusts the vertical dimensions of the view to the specified values
        TimeGridView.prototype.updateBaseSize = function (isResize, viewHeight, isAuto) {
            var _this = this;
            var eventLimit;
            var scrollerHeight;
            var scrollbarWidths;
            // make all axis cells line up
            this.axisWidth = core.matchCellWidths(core.findElements(this.el, '.fc-axis'));
            // hack to give the view some height prior to timeGrid's columns being rendered
            // TODO: separate setting height from scroller VS timeGrid.
            if (!this.timeGrid.colEls) {
                if (!isAuto) {
                    scrollerHeight = this.computeScrollerHeight(viewHeight);
                    this.scroller.setHeight(scrollerHeight);
                }
                return;
            }
            // set of fake row elements that must compensate when scroller has scrollbars
            var noScrollRowEls = core.findElements(this.el, '.fc-row').filter(function (node) {
                return !_this.scroller.el.contains(node);
            });
            // reset all dimensions back to the original state
            this.timeGrid.bottomRuleEl.style.display = 'none'; // will be shown later if this <hr> is necessary
            this.scroller.clear(); // sets height to 'auto' and clears overflow
            noScrollRowEls.forEach(core.uncompensateScroll);
            // limit number of events in the all-day area
            if (this.dayGrid) {
                this.dayGrid.removeSegPopover(); // kill the "more" popover if displayed
                eventLimit = this.opt('eventLimit');
                if (eventLimit && typeof eventLimit !== 'number') {
                    eventLimit = TIMEGRID_ALL_DAY_EVENT_LIMIT; // make sure "auto" goes to a real number
                }
                if (eventLimit) {
                    this.dayGrid.limitRows(eventLimit);
                }
            }
            if (!isAuto) { // should we force dimensions of the scroll container?
                scrollerHeight = this.computeScrollerHeight(viewHeight);
                this.scroller.setHeight(scrollerHeight);
                scrollbarWidths = this.scroller.getScrollbarWidths();
                if (scrollbarWidths.left || scrollbarWidths.right) { // using scrollbars?
                    // make the all-day and header rows lines up
                    noScrollRowEls.forEach(function (rowEl) {
                        core.compensateScroll(rowEl, scrollbarWidths);
                    });
                    // the scrollbar compensation might have changed text flow, which might affect height, so recalculate
                    // and reapply the desired height to the scroller.
                    scrollerHeight = this.computeScrollerHeight(viewHeight);
                    this.scroller.setHeight(scrollerHeight);
                }
                // guarantees the same scrollbar widths
                this.scroller.lockOverflow(scrollbarWidths);
                // if there's any space below the slats, show the horizontal rule.
                // this won't cause any new overflow, because lockOverflow already called.
                if (this.timeGrid.getTotalSlatHeight() < scrollerHeight) {
                    this.timeGrid.bottomRuleEl.style.display = '';
                }
            }
        };
        // given a desired total height of the view, returns what the height of the scroller should be
        TimeGridView.prototype.computeScrollerHeight = function (viewHeight) {
            return viewHeight -
                core.subtractInnerElHeight(this.el, this.scroller.el); // everything that's NOT the scroller
        };
        /* Scroll
        ------------------------------------------------------------------------------------------------------------------*/
        // Computes the initial pre-configured scroll state prior to allowing the user to change it
        TimeGridView.prototype.computeDateScroll = function (duration) {
            var top = this.timeGrid.computeTimeTop(duration);
            // zoom can give weird floating-point values. rather scroll a little bit further
            top = Math.ceil(top);
            if (top) {
                top++; // to overcome top border that slots beyond the first have. looks better
            }
            return { top: top };
        };
        TimeGridView.prototype.queryDateScroll = function () {
            return { top: this.scroller.getScrollTop() };
        };
        TimeGridView.prototype.applyDateScroll = function (scroll) {
            if (scroll.top !== undefined) {
                this.scroller.setScrollTop(scroll.top);
            }
        };
        // Generates an HTML attribute string for setting the width of the axis, if it is known
        TimeGridView.prototype.axisStyleAttr = function () {
            if (this.axisWidth != null) {
                return 'style="width:' + this.axisWidth + 'px"';
            }
            return '';
        };
        return TimeGridView;
    }(core.View));
    TimeGridView.prototype.usesMinMaxTime = true; // indicates that minTime/maxTime affects rendering

    var SimpleTimeGrid = /** @class */ (function (_super) {
        __extends(SimpleTimeGrid, _super);
        function SimpleTimeGrid(context, timeGrid) {
            var _this = _super.call(this, context, timeGrid.el) || this;
            _this.buildDayRanges = core.memoize(buildDayRanges);
            _this.slicer = new TimeGridSlicer();
            _this.timeGrid = timeGrid;
            context.calendar.registerInteractiveComponent(_this, {
                el: _this.timeGrid.el
            });
            return _this;
        }
        SimpleTimeGrid.prototype.destroy = function () {
            _super.prototype.destroy.call(this);
            this.calendar.unregisterInteractiveComponent(this);
        };
        SimpleTimeGrid.prototype.render = function (props) {
            var dateProfile = props.dateProfile, dayTable = props.dayTable;
            var dayRanges = this.dayRanges = this.buildDayRanges(dayTable, dateProfile, this.dateEnv);
            this.timeGrid.receiveProps(__assign({}, this.slicer.sliceProps(props, dateProfile, null, this.timeGrid, dayRanges), { dateProfile: dateProfile, cells: dayTable.cells[0] }));
        };
        SimpleTimeGrid.prototype.renderNowIndicator = function (date) {
            this.timeGrid.renderNowIndicator(this.slicer.sliceNowDate(date, this.timeGrid, this.dayRanges), date);
        };
        SimpleTimeGrid.prototype.buildPositionCaches = function () {
            this.timeGrid.buildPositionCaches();
        };
        SimpleTimeGrid.prototype.queryHit = function (positionLeft, positionTop) {
            var rawHit = this.timeGrid.positionToHit(positionLeft, positionTop);
            if (rawHit) {
                return {
                    component: this.timeGrid,
                    dateSpan: rawHit.dateSpan,
                    dayEl: rawHit.dayEl,
                    rect: {
                        left: rawHit.relativeRect.left,
                        right: rawHit.relativeRect.right,
                        top: rawHit.relativeRect.top,
                        bottom: rawHit.relativeRect.bottom
                    },
                    layer: 0
                };
            }
        };
        return SimpleTimeGrid;
    }(core.DateComponent));
    function buildDayRanges(dayTable, dateProfile, dateEnv) {
        var ranges = [];
        for (var _i = 0, _a = dayTable.headerDates; _i < _a.length; _i++) {
            var date = _a[_i];
            ranges.push({
                start: dateEnv.add(date, dateProfile.minTime),
                end: dateEnv.add(date, dateProfile.maxTime)
            });
        }
        return ranges;
    }
    var TimeGridSlicer = /** @class */ (function (_super) {
        __extends(TimeGridSlicer, _super);
        function TimeGridSlicer() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        TimeGridSlicer.prototype.sliceRange = function (range, dayRanges) {
            var segs = [];
            for (var col = 0; col < dayRanges.length; col++) {
                var segRange = core.intersectRanges(range, dayRanges[col]);
                if (segRange) {
                    segs.push({
                        start: segRange.start,
                        end: segRange.end,
                        isStart: segRange.start.valueOf() === range.start.valueOf(),
                        isEnd: segRange.end.valueOf() === range.end.valueOf(),
                        col: col
                    });
                }
            }
            return segs;
        };
        return TimeGridSlicer;
    }(core.Slicer));

    var TimeGridView$1 = /** @class */ (function (_super) {
        __extends(TimeGridView, _super);
        function TimeGridView(_context, viewSpec, dateProfileGenerator, parentEl) {
            var _this = _super.call(this, _context, viewSpec, dateProfileGenerator, parentEl) || this;
            _this.buildDayTable = core.memoize(buildDayTable);
            if (_this.opt('columnHeader')) {
                _this.header = new core.DayHeader(_this.context, _this.el.querySelector('.fc-head-container'));
            }
            _this.simpleTimeGrid = new SimpleTimeGrid(_this.context, _this.timeGrid);
            if (_this.dayGrid) {
                _this.simpleDayGrid = new daygrid.SimpleDayGrid(_this.context, _this.dayGrid);
            }
            return _this;
        }
        TimeGridView.prototype.destroy = function () {
            _super.prototype.destroy.call(this);
            if (this.header) {
                this.header.destroy();
            }
            this.simpleTimeGrid.destroy();
            if (this.simpleDayGrid) {
                this.simpleDayGrid.destroy();
            }
        };
        TimeGridView.prototype.render = function (props) {
            _super.prototype.render.call(this, props); // for flags for updateSize
            var dateProfile = this.props.dateProfile;
            var dayTable = this.buildDayTable(dateProfile, this.dateProfileGenerator);
            var splitProps = this.splitter.splitProps(props);
            if (this.header) {
                this.header.receiveProps({
                    dateProfile: dateProfile,
                    dates: dayTable.headerDates,
                    datesRepDistinctDays: true,
                    renderIntroHtml: this.renderHeadIntroHtml
                });
            }
            this.simpleTimeGrid.receiveProps(__assign({}, splitProps['timed'], { dateProfile: dateProfile,
                dayTable: dayTable }));
            if (this.simpleDayGrid) {
                this.simpleDayGrid.receiveProps(__assign({}, splitProps['allDay'], { dateProfile: dateProfile,
                    dayTable: dayTable, nextDayThreshold: this.nextDayThreshold, isRigid: false }));
            }
        };
        TimeGridView.prototype.renderNowIndicator = function (date) {
            this.simpleTimeGrid.renderNowIndicator(date);
        };
        return TimeGridView;
    }(TimeGridView));
    function buildDayTable(dateProfile, dateProfileGenerator) {
        var daySeries = new core.DaySeries(dateProfile.renderRange, dateProfileGenerator);
        return new core.DayTable(daySeries, false);
    }

    var main = core.createPlugin({
        defaultView: 'timeGridWeek',
        views: {
            timeGrid: {
                class: TimeGridView$1,
                allDaySlot: true,
                slotDuration: '00:30:00',
                slotEventOverlap: true // a bad name. confused with overlap/constraint system
            },
            timeGridDay: {
                type: 'timeGrid',
                duration: { days: 1 }
            },
            timeGridWeek: {
                type: 'timeGrid',
                duration: { weeks: 1 }
            }
        }
    });

    exports.AbstractTimeGridView = TimeGridView;
    exports.TimeGrid = TimeGrid;
    exports.TimeGridSlicer = TimeGridSlicer;
    exports.TimeGridView = TimeGridView$1;
    exports.buildDayRanges = buildDayRanges;
    exports.buildDayTable = buildDayTable;
    exports.default = main;

    Object.defineProperty(exports, '__esModule', { value: true });

}));

/*!
FullCalendar Interaction Plugin v4.3.0
Docs & License: https://fullcalendar.io/
(c) 2019 Adam Shaw
*/

(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@fullcalendar/core')) :
    typeof define === 'function' && define.amd ? define(['exports', '@fullcalendar/core'], factory) :
    (global = global || self, factory(global.FullCalendarInteraction = {}, global.FullCalendar));
}(this, function (exports, core) { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    /* global Reflect, Promise */

    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };

    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    var __assign = function() {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };

    core.config.touchMouseIgnoreWait = 500;
    var ignoreMouseDepth = 0;
    var listenerCnt = 0;
    var isWindowTouchMoveCancelled = false;
    /*
    Uses a "pointer" abstraction, which monitors UI events for both mouse and touch.
    Tracks when the pointer "drags" on a certain element, meaning down+move+up.

    Also, tracks if there was touch-scrolling.
    Also, can prevent touch-scrolling from happening.
    Also, can fire pointermove events when scrolling happens underneath, even when no real pointer movement.

    emits:
    - pointerdown
    - pointermove
    - pointerup
    */
    var PointerDragging = /** @class */ (function () {
        function PointerDragging(containerEl) {
            var _this = this;
            this.subjectEl = null;
            this.downEl = null;
            // options that can be directly assigned by caller
            this.selector = ''; // will cause subjectEl in all emitted events to be this element
            this.handleSelector = '';
            this.shouldIgnoreMove = false;
            this.shouldWatchScroll = true; // for simulating pointermove on scroll
            // internal states
            this.isDragging = false;
            this.isTouchDragging = false;
            this.wasTouchScroll = false;
            // Mouse
            // ----------------------------------------------------------------------------------------------------
            this.handleMouseDown = function (ev) {
                if (!_this.shouldIgnoreMouse() &&
                    isPrimaryMouseButton(ev) &&
                    _this.tryStart(ev)) {
                    var pev = _this.createEventFromMouse(ev, true);
                    _this.emitter.trigger('pointerdown', pev);
                    _this.initScrollWatch(pev);
                    if (!_this.shouldIgnoreMove) {
                        document.addEventListener('mousemove', _this.handleMouseMove);
                    }
                    document.addEventListener('mouseup', _this.handleMouseUp);
                }
            };
            this.handleMouseMove = function (ev) {
                var pev = _this.createEventFromMouse(ev);
                _this.recordCoords(pev);
                _this.emitter.trigger('pointermove', pev);
            };
            this.handleMouseUp = function (ev) {
                document.removeEventListener('mousemove', _this.handleMouseMove);
                document.removeEventListener('mouseup', _this.handleMouseUp);
                _this.emitter.trigger('pointerup', _this.createEventFromMouse(ev));
                _this.cleanup(); // call last so that pointerup has access to props
            };
            // Touch
            // ----------------------------------------------------------------------------------------------------
            this.handleTouchStart = function (ev) {
                if (_this.tryStart(ev)) {
                    _this.isTouchDragging = true;
                    var pev = _this.createEventFromTouch(ev, true);
                    _this.emitter.trigger('pointerdown', pev);
                    _this.initScrollWatch(pev);
                    // unlike mouse, need to attach to target, not document
                    // https://stackoverflow.com/a/45760014
                    var target = ev.target;
                    if (!_this.shouldIgnoreMove) {
                        target.addEventListener('touchmove', _this.handleTouchMove);
                    }
                    target.addEventListener('touchend', _this.handleTouchEnd);
                    target.addEventListener('touchcancel', _this.handleTouchEnd); // treat it as a touch end
                    // attach a handler to get called when ANY scroll action happens on the page.
                    // this was impossible to do with normal on/off because 'scroll' doesn't bubble.
                    // http://stackoverflow.com/a/32954565/96342
                    window.addEventListener('scroll', _this.handleTouchScroll, true // useCapture
                    );
                }
            };
            this.handleTouchMove = function (ev) {
                var pev = _this.createEventFromTouch(ev);
                _this.recordCoords(pev);
                _this.emitter.trigger('pointermove', pev);
            };
            this.handleTouchEnd = function (ev) {
                if (_this.isDragging) { // done to guard against touchend followed by touchcancel
                    var target = ev.target;
                    target.removeEventListener('touchmove', _this.handleTouchMove);
                    target.removeEventListener('touchend', _this.handleTouchEnd);
                    target.removeEventListener('touchcancel', _this.handleTouchEnd);
                    window.removeEventListener('scroll', _this.handleTouchScroll, true); // useCaptured=true
                    _this.emitter.trigger('pointerup', _this.createEventFromTouch(ev));
                    _this.cleanup(); // call last so that pointerup has access to props
                    _this.isTouchDragging = false;
                    startIgnoringMouse();
                }
            };
            this.handleTouchScroll = function () {
                _this.wasTouchScroll = true;
            };
            this.handleScroll = function (ev) {
                if (!_this.shouldIgnoreMove) {
                    var pageX = (window.pageXOffset - _this.prevScrollX) + _this.prevPageX;
                    var pageY = (window.pageYOffset - _this.prevScrollY) + _this.prevPageY;
                    _this.emitter.trigger('pointermove', {
                        origEvent: ev,
                        isTouch: _this.isTouchDragging,
                        subjectEl: _this.subjectEl,
                        pageX: pageX,
                        pageY: pageY,
                        deltaX: pageX - _this.origPageX,
                        deltaY: pageY - _this.origPageY
                    });
                }
            };
            this.containerEl = containerEl;
            this.emitter = new core.EmitterMixin();
            containerEl.addEventListener('mousedown', this.handleMouseDown);
            containerEl.addEventListener('touchstart', this.handleTouchStart, { passive: true });
            listenerCreated();
        }
        PointerDragging.prototype.destroy = function () {
            this.containerEl.removeEventListener('mousedown', this.handleMouseDown);
            this.containerEl.removeEventListener('touchstart', this.handleTouchStart, { passive: true });
            listenerDestroyed();
        };
        PointerDragging.prototype.tryStart = function (ev) {
            var subjectEl = this.querySubjectEl(ev);
            var downEl = ev.target;
            if (subjectEl &&
                (!this.handleSelector || core.elementClosest(downEl, this.handleSelector))) {
                this.subjectEl = subjectEl;
                this.downEl = downEl;
                this.isDragging = true; // do this first so cancelTouchScroll will work
                this.wasTouchScroll = false;
                return true;
            }
            return false;
        };
        PointerDragging.prototype.cleanup = function () {
            isWindowTouchMoveCancelled = false;
            this.isDragging = false;
            this.subjectEl = null;
            this.downEl = null;
            // keep wasTouchScroll around for later access
            this.destroyScrollWatch();
        };
        PointerDragging.prototype.querySubjectEl = function (ev) {
            if (this.selector) {
                return core.elementClosest(ev.target, this.selector);
            }
            else {
                return this.containerEl;
            }
        };
        PointerDragging.prototype.shouldIgnoreMouse = function () {
            return ignoreMouseDepth || this.isTouchDragging;
        };
        // can be called by user of this class, to cancel touch-based scrolling for the current drag
        PointerDragging.prototype.cancelTouchScroll = function () {
            if (this.isDragging) {
                isWindowTouchMoveCancelled = true;
            }
        };
        // Scrolling that simulates pointermoves
        // ----------------------------------------------------------------------------------------------------
        PointerDragging.prototype.initScrollWatch = function (ev) {
            if (this.shouldWatchScroll) {
                this.recordCoords(ev);
                window.addEventListener('scroll', this.handleScroll, true); // useCapture=true
            }
        };
        PointerDragging.prototype.recordCoords = function (ev) {
            if (this.shouldWatchScroll) {
                this.prevPageX = ev.pageX;
                this.prevPageY = ev.pageY;
                this.prevScrollX = window.pageXOffset;
                this.prevScrollY = window.pageYOffset;
            }
        };
        PointerDragging.prototype.destroyScrollWatch = function () {
            if (this.shouldWatchScroll) {
                window.removeEventListener('scroll', this.handleScroll, true); // useCaptured=true
            }
        };
        // Event Normalization
        // ----------------------------------------------------------------------------------------------------
        PointerDragging.prototype.createEventFromMouse = function (ev, isFirst) {
            var deltaX = 0;
            var deltaY = 0;
            // TODO: repeat code
            if (isFirst) {
                this.origPageX = ev.pageX;
                this.origPageY = ev.pageY;
            }
            else {
                deltaX = ev.pageX - this.origPageX;
                deltaY = ev.pageY - this.origPageY;
            }
            return {
                origEvent: ev,
                isTouch: false,
                subjectEl: this.subjectEl,
                pageX: ev.pageX,
                pageY: ev.pageY,
                deltaX: deltaX,
                deltaY: deltaY
            };
        };
        PointerDragging.prototype.createEventFromTouch = function (ev, isFirst) {
            var touches = ev.touches;
            var pageX;
            var pageY;
            var deltaX = 0;
            var deltaY = 0;
            // if touch coords available, prefer,
            // because FF would give bad ev.pageX ev.pageY
            if (touches && touches.length) {
                pageX = touches[0].pageX;
                pageY = touches[0].pageY;
            }
            else {
                pageX = ev.pageX;
                pageY = ev.pageY;
            }
            // TODO: repeat code
            if (isFirst) {
                this.origPageX = pageX;
                this.origPageY = pageY;
            }
            else {
                deltaX = pageX - this.origPageX;
                deltaY = pageY - this.origPageY;
            }
            return {
                origEvent: ev,
                isTouch: true,
                subjectEl: this.subjectEl,
                pageX: pageX,
                pageY: pageY,
                deltaX: deltaX,
                deltaY: deltaY
            };
        };
        return PointerDragging;
    }());
    // Returns a boolean whether this was a left mouse click and no ctrl key (which means right click on Mac)
    function isPrimaryMouseButton(ev) {
        return ev.button === 0 && !ev.ctrlKey;
    }
    // Ignoring fake mouse events generated by touch
    // ----------------------------------------------------------------------------------------------------
    function startIgnoringMouse() {
        ignoreMouseDepth++;
        setTimeout(function () {
            ignoreMouseDepth--;
        }, core.config.touchMouseIgnoreWait);
    }
    // We want to attach touchmove as early as possible for Safari
    // ----------------------------------------------------------------------------------------------------
    function listenerCreated() {
        if (!(listenerCnt++)) {
            window.addEventListener('touchmove', onWindowTouchMove, { passive: false });
        }
    }
    function listenerDestroyed() {
        if (!(--listenerCnt)) {
            window.removeEventListener('touchmove', onWindowTouchMove, { passive: false });
        }
    }
    function onWindowTouchMove(ev) {
        if (isWindowTouchMoveCancelled) {
            ev.preventDefault();
        }
    }

    /*
    An effect in which an element follows the movement of a pointer across the screen.
    The moving element is a clone of some other element.
    Must call start + handleMove + stop.
    */
    var ElementMirror = /** @class */ (function () {
        function ElementMirror() {
            this.isVisible = false; // must be explicitly enabled
            this.sourceEl = null;
            this.mirrorEl = null;
            this.sourceElRect = null; // screen coords relative to viewport
            // options that can be set directly by caller
            this.parentNode = document.body;
            this.zIndex = 9999;
            this.revertDuration = 0;
        }
        ElementMirror.prototype.start = function (sourceEl, pageX, pageY) {
            this.sourceEl = sourceEl;
            this.sourceElRect = this.sourceEl.getBoundingClientRect();
            this.origScreenX = pageX - window.pageXOffset;
            this.origScreenY = pageY - window.pageYOffset;
            this.deltaX = 0;
            this.deltaY = 0;
            this.updateElPosition();
        };
        ElementMirror.prototype.handleMove = function (pageX, pageY) {
            this.deltaX = (pageX - window.pageXOffset) - this.origScreenX;
            this.deltaY = (pageY - window.pageYOffset) - this.origScreenY;
            this.updateElPosition();
        };
        // can be called before start
        ElementMirror.prototype.setIsVisible = function (bool) {
            if (bool) {
                if (!this.isVisible) {
                    if (this.mirrorEl) {
                        this.mirrorEl.style.display = '';
                    }
                    this.isVisible = bool; // needs to happen before updateElPosition
                    this.updateElPosition(); // because was not updating the position while invisible
                }
            }
            else {
                if (this.isVisible) {
                    if (this.mirrorEl) {
                        this.mirrorEl.style.display = 'none';
                    }
                    this.isVisible = bool;
                }
            }
        };
        // always async
        ElementMirror.prototype.stop = function (needsRevertAnimation, callback) {
            var _this = this;
            var done = function () {
                _this.cleanup();
                callback();
            };
            if (needsRevertAnimation &&
                this.mirrorEl &&
                this.isVisible &&
                this.revertDuration && // if 0, transition won't work
                (this.deltaX || this.deltaY) // if same coords, transition won't work
            ) {
                this.doRevertAnimation(done, this.revertDuration);
            }
            else {
                setTimeout(done, 0);
            }
        };
        ElementMirror.prototype.doRevertAnimation = function (callback, revertDuration) {
            var mirrorEl = this.mirrorEl;
            var finalSourceElRect = this.sourceEl.getBoundingClientRect(); // because autoscrolling might have happened
            mirrorEl.style.transition =
                'top ' + revertDuration + 'ms,' +
                    'left ' + revertDuration + 'ms';
            core.applyStyle(mirrorEl, {
                left: finalSourceElRect.left,
                top: finalSourceElRect.top
            });
            core.whenTransitionDone(mirrorEl, function () {
                mirrorEl.style.transition = '';
                callback();
            });
        };
        ElementMirror.prototype.cleanup = function () {
            if (this.mirrorEl) {
                core.removeElement(this.mirrorEl);
                this.mirrorEl = null;
            }
            this.sourceEl = null;
        };
        ElementMirror.prototype.updateElPosition = function () {
            if (this.sourceEl && this.isVisible) {
                core.applyStyle(this.getMirrorEl(), {
                    left: this.sourceElRect.left + this.deltaX,
                    top: this.sourceElRect.top + this.deltaY
                });
            }
        };
        ElementMirror.prototype.getMirrorEl = function () {
            var sourceElRect = this.sourceElRect;
            var mirrorEl = this.mirrorEl;
            if (!mirrorEl) {
                mirrorEl = this.mirrorEl = this.sourceEl.cloneNode(true); // cloneChildren=true
                // we don't want long taps or any mouse interaction causing selection/menus.
                // would use preventSelection(), but that prevents selectstart, causing problems.
                mirrorEl.classList.add('fc-unselectable');
                mirrorEl.classList.add('fc-dragging');
                core.applyStyle(mirrorEl, {
                    position: 'fixed',
                    zIndex: this.zIndex,
                    visibility: '',
                    boxSizing: 'border-box',
                    width: sourceElRect.right - sourceElRect.left,
                    height: sourceElRect.bottom - sourceElRect.top,
                    right: 'auto',
                    bottom: 'auto',
                    margin: 0
                });
                this.parentNode.appendChild(mirrorEl);
            }
            return mirrorEl;
        };
        return ElementMirror;
    }());

    /*
    Is a cache for a given element's scroll information (all the info that ScrollController stores)
    in addition the "client rectangle" of the element.. the area within the scrollbars.

    The cache can be in one of two modes:
    - doesListening:false - ignores when the container is scrolled by someone else
    - doesListening:true - watch for scrolling and update the cache
    */
    var ScrollGeomCache = /** @class */ (function (_super) {
        __extends(ScrollGeomCache, _super);
        function ScrollGeomCache(scrollController, doesListening) {
            var _this = _super.call(this) || this;
            _this.handleScroll = function () {
                _this.scrollTop = _this.scrollController.getScrollTop();
                _this.scrollLeft = _this.scrollController.getScrollLeft();
                _this.handleScrollChange();
            };
            _this.scrollController = scrollController;
            _this.doesListening = doesListening;
            _this.scrollTop = _this.origScrollTop = scrollController.getScrollTop();
            _this.scrollLeft = _this.origScrollLeft = scrollController.getScrollLeft();
            _this.scrollWidth = scrollController.getScrollWidth();
            _this.scrollHeight = scrollController.getScrollHeight();
            _this.clientWidth = scrollController.getClientWidth();
            _this.clientHeight = scrollController.getClientHeight();
            _this.clientRect = _this.computeClientRect(); // do last in case it needs cached values
            if (_this.doesListening) {
                _this.getEventTarget().addEventListener('scroll', _this.handleScroll);
            }
            return _this;
        }
        ScrollGeomCache.prototype.destroy = function () {
            if (this.doesListening) {
                this.getEventTarget().removeEventListener('scroll', this.handleScroll);
            }
        };
        ScrollGeomCache.prototype.getScrollTop = function () {
            return this.scrollTop;
        };
        ScrollGeomCache.prototype.getScrollLeft = function () {
            return this.scrollLeft;
        };
        ScrollGeomCache.prototype.setScrollTop = function (top) {
            this.scrollController.setScrollTop(top);
            if (!this.doesListening) {
                // we are not relying on the element to normalize out-of-bounds scroll values
                // so we need to sanitize ourselves
                this.scrollTop = Math.max(Math.min(top, this.getMaxScrollTop()), 0);
                this.handleScrollChange();
            }
        };
        ScrollGeomCache.prototype.setScrollLeft = function (top) {
            this.scrollController.setScrollLeft(top);
            if (!this.doesListening) {
                // we are not relying on the element to normalize out-of-bounds scroll values
                // so we need to sanitize ourselves
                this.scrollLeft = Math.max(Math.min(top, this.getMaxScrollLeft()), 0);
                this.handleScrollChange();
            }
        };
        ScrollGeomCache.prototype.getClientWidth = function () {
            return this.clientWidth;
        };
        ScrollGeomCache.prototype.getClientHeight = function () {
            return this.clientHeight;
        };
        ScrollGeomCache.prototype.getScrollWidth = function () {
            return this.scrollWidth;
        };
        ScrollGeomCache.prototype.getScrollHeight = function () {
            return this.scrollHeight;
        };
        ScrollGeomCache.prototype.handleScrollChange = function () {
        };
        return ScrollGeomCache;
    }(core.ScrollController));
    var ElementScrollGeomCache = /** @class */ (function (_super) {
        __extends(ElementScrollGeomCache, _super);
        function ElementScrollGeomCache(el, doesListening) {
            return _super.call(this, new core.ElementScrollController(el), doesListening) || this;
        }
        ElementScrollGeomCache.prototype.getEventTarget = function () {
            return this.scrollController.el;
        };
        ElementScrollGeomCache.prototype.computeClientRect = function () {
            return core.computeInnerRect(this.scrollController.el);
        };
        return ElementScrollGeomCache;
    }(ScrollGeomCache));
    var WindowScrollGeomCache = /** @class */ (function (_super) {
        __extends(WindowScrollGeomCache, _super);
        function WindowScrollGeomCache(doesListening) {
            return _super.call(this, new core.WindowScrollController(), doesListening) || this;
        }
        WindowScrollGeomCache.prototype.getEventTarget = function () {
            return window;
        };
        WindowScrollGeomCache.prototype.computeClientRect = function () {
            return {
                left: this.scrollLeft,
                right: this.scrollLeft + this.clientWidth,
                top: this.scrollTop,
                bottom: this.scrollTop + this.clientHeight
            };
        };
        // the window is the only scroll object that changes it's rectangle relative
        // to the document's topleft as it scrolls
        WindowScrollGeomCache.prototype.handleScrollChange = function () {
            this.clientRect = this.computeClientRect();
        };
        return WindowScrollGeomCache;
    }(ScrollGeomCache));

    // If available we are using native "performance" API instead of "Date"
    // Read more about it on MDN:
    // https://developer.mozilla.org/en-US/docs/Web/API/Performance
    var getTime = typeof performance === 'function' ? performance.now : Date.now;
    /*
    For a pointer interaction, automatically scrolls certain scroll containers when the pointer
    approaches the edge.

    The caller must call start + handleMove + stop.
    */
    var AutoScroller = /** @class */ (function () {
        function AutoScroller() {
            var _this = this;
            // options that can be set by caller
            this.isEnabled = true;
            this.scrollQuery = [window, '.fc-scroller'];
            this.edgeThreshold = 50; // pixels
            this.maxVelocity = 300; // pixels per second
            // internal state
            this.pointerScreenX = null;
            this.pointerScreenY = null;
            this.isAnimating = false;
            this.scrollCaches = null;
            // protect against the initial pointerdown being too close to an edge and starting the scroll
            this.everMovedUp = false;
            this.everMovedDown = false;
            this.everMovedLeft = false;
            this.everMovedRight = false;
            this.animate = function () {
                if (_this.isAnimating) { // wasn't cancelled between animation calls
                    var edge = _this.computeBestEdge(_this.pointerScreenX + window.pageXOffset, _this.pointerScreenY + window.pageYOffset);
                    if (edge) {
                        var now = getTime();
                        _this.handleSide(edge, (now - _this.msSinceRequest) / 1000);
                        _this.requestAnimation(now);
                    }
                    else {
                        _this.isAnimating = false; // will stop animation
                    }
                }
            };
        }
        AutoScroller.prototype.start = function (pageX, pageY) {
            if (this.isEnabled) {
                this.scrollCaches = this.buildCaches();
                this.pointerScreenX = null;
                this.pointerScreenY = null;
                this.everMovedUp = false;
                this.everMovedDown = false;
                this.everMovedLeft = false;
                this.everMovedRight = false;
                this.handleMove(pageX, pageY);
            }
        };
        AutoScroller.prototype.handleMove = function (pageX, pageY) {
            if (this.isEnabled) {
                var pointerScreenX = pageX - window.pageXOffset;
                var pointerScreenY = pageY - window.pageYOffset;
                var yDelta = this.pointerScreenY === null ? 0 : pointerScreenY - this.pointerScreenY;
                var xDelta = this.pointerScreenX === null ? 0 : pointerScreenX - this.pointerScreenX;
                if (yDelta < 0) {
                    this.everMovedUp = true;
                }
                else if (yDelta > 0) {
                    this.everMovedDown = true;
                }
                if (xDelta < 0) {
                    this.everMovedLeft = true;
                }
                else if (xDelta > 0) {
                    this.everMovedRight = true;
                }
                this.pointerScreenX = pointerScreenX;
                this.pointerScreenY = pointerScreenY;
                if (!this.isAnimating) {
                    this.isAnimating = true;
                    this.requestAnimation(getTime());
                }
            }
        };
        AutoScroller.prototype.stop = function () {
            if (this.isEnabled) {
                this.isAnimating = false; // will stop animation
                for (var _i = 0, _a = this.scrollCaches; _i < _a.length; _i++) {
                    var scrollCache = _a[_i];
                    scrollCache.destroy();
                }
                this.scrollCaches = null;
            }
        };
        AutoScroller.prototype.requestAnimation = function (now) {
            this.msSinceRequest = now;
            requestAnimationFrame(this.animate);
        };
        AutoScroller.prototype.handleSide = function (edge, seconds) {
            var scrollCache = edge.scrollCache;
            var edgeThreshold = this.edgeThreshold;
            var invDistance = edgeThreshold - edge.distance;
            var velocity = // the closer to the edge, the faster we scroll
             (invDistance * invDistance) / (edgeThreshold * edgeThreshold) * // quadratic
                this.maxVelocity * seconds;
            var sign = 1;
            switch (edge.name) {
                case 'left':
                    sign = -1;
                // falls through
                case 'right':
                    scrollCache.setScrollLeft(scrollCache.getScrollLeft() + velocity * sign);
                    break;
                case 'top':
                    sign = -1;
                // falls through
                case 'bottom':
                    scrollCache.setScrollTop(scrollCache.getScrollTop() + velocity * sign);
                    break;
            }
        };
        // left/top are relative to document topleft
        AutoScroller.prototype.computeBestEdge = function (left, top) {
            var edgeThreshold = this.edgeThreshold;
            var bestSide = null;
            for (var _i = 0, _a = this.scrollCaches; _i < _a.length; _i++) {
                var scrollCache = _a[_i];
                var rect = scrollCache.clientRect;
                var leftDist = left - rect.left;
                var rightDist = rect.right - left;
                var topDist = top - rect.top;
                var bottomDist = rect.bottom - top;
                // completely within the rect?
                if (leftDist >= 0 && rightDist >= 0 && topDist >= 0 && bottomDist >= 0) {
                    if (topDist <= edgeThreshold && this.everMovedUp && scrollCache.canScrollUp() &&
                        (!bestSide || bestSide.distance > topDist)) {
                        bestSide = { scrollCache: scrollCache, name: 'top', distance: topDist };
                    }
                    if (bottomDist <= edgeThreshold && this.everMovedDown && scrollCache.canScrollDown() &&
                        (!bestSide || bestSide.distance > bottomDist)) {
                        bestSide = { scrollCache: scrollCache, name: 'bottom', distance: bottomDist };
                    }
                    if (leftDist <= edgeThreshold && this.everMovedLeft && scrollCache.canScrollLeft() &&
                        (!bestSide || bestSide.distance > leftDist)) {
                        bestSide = { scrollCache: scrollCache, name: 'left', distance: leftDist };
                    }
                    if (rightDist <= edgeThreshold && this.everMovedRight && scrollCache.canScrollRight() &&
                        (!bestSide || bestSide.distance > rightDist)) {
                        bestSide = { scrollCache: scrollCache, name: 'right', distance: rightDist };
                    }
                }
            }
            return bestSide;
        };
        AutoScroller.prototype.buildCaches = function () {
            return this.queryScrollEls().map(function (el) {
                if (el === window) {
                    return new WindowScrollGeomCache(false); // false = don't listen to user-generated scrolls
                }
                else {
                    return new ElementScrollGeomCache(el, false); // false = don't listen to user-generated scrolls
                }
            });
        };
        AutoScroller.prototype.queryScrollEls = function () {
            var els = [];
            for (var _i = 0, _a = this.scrollQuery; _i < _a.length; _i++) {
                var query = _a[_i];
                if (typeof query === 'object') {
                    els.push(query);
                }
                else {
                    els.push.apply(els, Array.prototype.slice.call(document.querySelectorAll(query)));
                }
            }
            return els;
        };
        return AutoScroller;
    }());

    /*
    Monitors dragging on an element. Has a number of high-level features:
    - minimum distance required before dragging
    - minimum wait time ("delay") before dragging
    - a mirror element that follows the pointer
    */
    var FeaturefulElementDragging = /** @class */ (function (_super) {
        __extends(FeaturefulElementDragging, _super);
        function FeaturefulElementDragging(containerEl) {
            var _this = _super.call(this, containerEl) || this;
            // options that can be directly set by caller
            // the caller can also set the PointerDragging's options as well
            _this.delay = null;
            _this.minDistance = 0;
            _this.touchScrollAllowed = true; // prevents drag from starting and blocks scrolling during drag
            _this.mirrorNeedsRevert = false;
            _this.isInteracting = false; // is the user validly moving the pointer? lasts until pointerup
            _this.isDragging = false; // is it INTENTFULLY dragging? lasts until after revert animation
            _this.isDelayEnded = false;
            _this.isDistanceSurpassed = false;
            _this.delayTimeoutId = null;
            _this.onPointerDown = function (ev) {
                if (!_this.isDragging) { // so new drag doesn't happen while revert animation is going
                    _this.isInteracting = true;
                    _this.isDelayEnded = false;
                    _this.isDistanceSurpassed = false;
                    core.preventSelection(document.body);
                    core.preventContextMenu(document.body);
                    // prevent links from being visited if there's an eventual drag.
                    // also prevents selection in older browsers (maybe?).
                    // not necessary for touch, besides, browser would complain about passiveness.
                    if (!ev.isTouch) {
                        ev.origEvent.preventDefault();
                    }
                    _this.emitter.trigger('pointerdown', ev);
                    if (!_this.pointer.shouldIgnoreMove) {
                        // actions related to initiating dragstart+dragmove+dragend...
                        _this.mirror.setIsVisible(false); // reset. caller must set-visible
                        _this.mirror.start(ev.subjectEl, ev.pageX, ev.pageY); // must happen on first pointer down
                        _this.startDelay(ev);
                        if (!_this.minDistance) {
                            _this.handleDistanceSurpassed(ev);
                        }
                    }
                }
            };
            _this.onPointerMove = function (ev) {
                if (_this.isInteracting) { // if false, still waiting for previous drag's revert
                    _this.emitter.trigger('pointermove', ev);
                    if (!_this.isDistanceSurpassed) {
                        var minDistance = _this.minDistance;
                        var distanceSq = void 0; // current distance from the origin, squared
                        var deltaX = ev.deltaX, deltaY = ev.deltaY;
                        distanceSq = deltaX * deltaX + deltaY * deltaY;
                        if (distanceSq >= minDistance * minDistance) { // use pythagorean theorem
                            _this.handleDistanceSurpassed(ev);
                        }
                    }
                    if (_this.isDragging) {
                        // a real pointer move? (not one simulated by scrolling)
                        if (ev.origEvent.type !== 'scroll') {
                            _this.mirror.handleMove(ev.pageX, ev.pageY);
                            _this.autoScroller.handleMove(ev.pageX, ev.pageY);
                        }
                        _this.emitter.trigger('dragmove', ev);
                    }
                }
            };
            _this.onPointerUp = function (ev) {
                if (_this.isInteracting) { // if false, still waiting for previous drag's revert
                    _this.isInteracting = false;
                    core.allowSelection(document.body);
                    core.allowContextMenu(document.body);
                    _this.emitter.trigger('pointerup', ev); // can potentially set mirrorNeedsRevert
                    if (_this.isDragging) {
                        _this.autoScroller.stop();
                        _this.tryStopDrag(ev); // which will stop the mirror
                    }
                    if (_this.delayTimeoutId) {
                        clearTimeout(_this.delayTimeoutId);
                        _this.delayTimeoutId = null;
                    }
                }
            };
            var pointer = _this.pointer = new PointerDragging(containerEl);
            pointer.emitter.on('pointerdown', _this.onPointerDown);
            pointer.emitter.on('pointermove', _this.onPointerMove);
            pointer.emitter.on('pointerup', _this.onPointerUp);
            _this.mirror = new ElementMirror();
            _this.autoScroller = new AutoScroller();
            return _this;
        }
        FeaturefulElementDragging.prototype.destroy = function () {
            this.pointer.destroy();
        };
        FeaturefulElementDragging.prototype.startDelay = function (ev) {
            var _this = this;
            if (typeof this.delay === 'number') {
                this.delayTimeoutId = setTimeout(function () {
                    _this.delayTimeoutId = null;
                    _this.handleDelayEnd(ev);
                }, this.delay); // not assignable to number!
            }
            else {
                this.handleDelayEnd(ev);
            }
        };
        FeaturefulElementDragging.prototype.handleDelayEnd = function (ev) {
            this.isDelayEnded = true;
            this.tryStartDrag(ev);
        };
        FeaturefulElementDragging.prototype.handleDistanceSurpassed = function (ev) {
            this.isDistanceSurpassed = true;
            this.tryStartDrag(ev);
        };
        FeaturefulElementDragging.prototype.tryStartDrag = function (ev) {
            if (this.isDelayEnded && this.isDistanceSurpassed) {
                if (!this.pointer.wasTouchScroll || this.touchScrollAllowed) {
                    this.isDragging = true;
                    this.mirrorNeedsRevert = false;
                    this.autoScroller.start(ev.pageX, ev.pageY);
                    this.emitter.trigger('dragstart', ev);
                    if (this.touchScrollAllowed === false) {
                        this.pointer.cancelTouchScroll();
                    }
                }
            }
        };
        FeaturefulElementDragging.prototype.tryStopDrag = function (ev) {
            // .stop() is ALWAYS asynchronous, which we NEED because we want all pointerup events
            // that come from the document to fire beforehand. much more convenient this way.
            this.mirror.stop(this.mirrorNeedsRevert, this.stopDrag.bind(this, ev) // bound with args
            );
        };
        FeaturefulElementDragging.prototype.stopDrag = function (ev) {
            this.isDragging = false;
            this.emitter.trigger('dragend', ev);
        };
        // fill in the implementations...
        FeaturefulElementDragging.prototype.setIgnoreMove = function (bool) {
            this.pointer.shouldIgnoreMove = bool;
        };
        FeaturefulElementDragging.prototype.setMirrorIsVisible = function (bool) {
            this.mirror.setIsVisible(bool);
        };
        FeaturefulElementDragging.prototype.setMirrorNeedsRevert = function (bool) {
            this.mirrorNeedsRevert = bool;
        };
        FeaturefulElementDragging.prototype.setAutoScrollEnabled = function (bool) {
            this.autoScroller.isEnabled = bool;
        };
        return FeaturefulElementDragging;
    }(core.ElementDragging));

    /*
    When this class is instantiated, it records the offset of an element (relative to the document topleft),
    and continues to monitor scrolling, updating the cached coordinates if it needs to.
    Does not access the DOM after instantiation, so highly performant.

    Also keeps track of all scrolling/overflow:hidden containers that are parents of the given element
    and an determine if a given point is inside the combined clipping rectangle.
    */
    var OffsetTracker = /** @class */ (function () {
        function OffsetTracker(el) {
            this.origRect = core.computeRect(el);
            // will work fine for divs that have overflow:hidden
            this.scrollCaches = core.getClippingParents(el).map(function (el) {
                return new ElementScrollGeomCache(el, true); // listen=true
            });
        }
        OffsetTracker.prototype.destroy = function () {
            for (var _i = 0, _a = this.scrollCaches; _i < _a.length; _i++) {
                var scrollCache = _a[_i];
                scrollCache.destroy();
            }
        };
        OffsetTracker.prototype.computeLeft = function () {
            var left = this.origRect.left;
            for (var _i = 0, _a = this.scrollCaches; _i < _a.length; _i++) {
                var scrollCache = _a[_i];
                left += scrollCache.origScrollLeft - scrollCache.getScrollLeft();
            }
            return left;
        };
        OffsetTracker.prototype.computeTop = function () {
            var top = this.origRect.top;
            for (var _i = 0, _a = this.scrollCaches; _i < _a.length; _i++) {
                var scrollCache = _a[_i];
                top += scrollCache.origScrollTop - scrollCache.getScrollTop();
            }
            return top;
        };
        OffsetTracker.prototype.isWithinClipping = function (pageX, pageY) {
            var point = { left: pageX, top: pageY };
            for (var _i = 0, _a = this.scrollCaches; _i < _a.length; _i++) {
                var scrollCache = _a[_i];
                if (!isIgnoredClipping(scrollCache.getEventTarget()) &&
                    !core.pointInsideRect(point, scrollCache.clientRect)) {
                    return false;
                }
            }
            return true;
        };
        return OffsetTracker;
    }());
    // certain clipping containers should never constrain interactions, like <html> and <body>
    // https://github.com/fullcalendar/fullcalendar/issues/3615
    function isIgnoredClipping(node) {
        var tagName = node.tagName;
        return tagName === 'HTML' || tagName === 'BODY';
    }

    /*
    Tracks movement over multiple droppable areas (aka "hits")
    that exist in one or more DateComponents.
    Relies on an existing draggable.

    emits:
    - pointerdown
    - dragstart
    - hitchange - fires initially, even if not over a hit
    - pointerup
    - (hitchange - again, to null, if ended over a hit)
    - dragend
    */
    var HitDragging = /** @class */ (function () {
        function HitDragging(dragging, droppableStore) {
            var _this = this;
            // options that can be set by caller
            this.useSubjectCenter = false;
            this.requireInitial = true; // if doesn't start out on a hit, won't emit any events
            this.initialHit = null;
            this.movingHit = null;
            this.finalHit = null; // won't ever be populated if shouldIgnoreMove
            this.handlePointerDown = function (ev) {
                var dragging = _this.dragging;
                _this.initialHit = null;
                _this.movingHit = null;
                _this.finalHit = null;
                _this.prepareHits();
                _this.processFirstCoord(ev);
                if (_this.initialHit || !_this.requireInitial) {
                    dragging.setIgnoreMove(false);
                    _this.emitter.trigger('pointerdown', ev); // TODO: fire this before computing processFirstCoord, so listeners can cancel. this gets fired by almost every handler :(
                }
                else {
                    dragging.setIgnoreMove(true);
                }
            };
            this.handleDragStart = function (ev) {
                _this.emitter.trigger('dragstart', ev);
                _this.handleMove(ev, true); // force = fire even if initially null
            };
            this.handleDragMove = function (ev) {
                _this.emitter.trigger('dragmove', ev);
                _this.handleMove(ev);
            };
            this.handlePointerUp = function (ev) {
                _this.releaseHits();
                _this.emitter.trigger('pointerup', ev);
            };
            this.handleDragEnd = function (ev) {
                if (_this.movingHit) {
                    _this.emitter.trigger('hitupdate', null, true, ev);
                }
                _this.finalHit = _this.movingHit;
                _this.movingHit = null;
                _this.emitter.trigger('dragend', ev);
            };
            this.droppableStore = droppableStore;
            dragging.emitter.on('pointerdown', this.handlePointerDown);
            dragging.emitter.on('dragstart', this.handleDragStart);
            dragging.emitter.on('dragmove', this.handleDragMove);
            dragging.emitter.on('pointerup', this.handlePointerUp);
            dragging.emitter.on('dragend', this.handleDragEnd);
            this.dragging = dragging;
            this.emitter = new core.EmitterMixin();
        }
        // sets initialHit
        // sets coordAdjust
        HitDragging.prototype.processFirstCoord = function (ev) {
            var origPoint = { left: ev.pageX, top: ev.pageY };
            var adjustedPoint = origPoint;
            var subjectEl = ev.subjectEl;
            var subjectRect;
            if (subjectEl !== document) {
                subjectRect = core.computeRect(subjectEl);
                adjustedPoint = core.constrainPoint(adjustedPoint, subjectRect);
            }
            var initialHit = this.initialHit = this.queryHitForOffset(adjustedPoint.left, adjustedPoint.top);
            if (initialHit) {
                if (this.useSubjectCenter && subjectRect) {
                    var slicedSubjectRect = core.intersectRects(subjectRect, initialHit.rect);
                    if (slicedSubjectRect) {
                        adjustedPoint = core.getRectCenter(slicedSubjectRect);
                    }
                }
                this.coordAdjust = core.diffPoints(adjustedPoint, origPoint);
            }
            else {
                this.coordAdjust = { left: 0, top: 0 };
            }
        };
        HitDragging.prototype.handleMove = function (ev, forceHandle) {
            var hit = this.queryHitForOffset(ev.pageX + this.coordAdjust.left, ev.pageY + this.coordAdjust.top);
            if (forceHandle || !isHitsEqual(this.movingHit, hit)) {
                this.movingHit = hit;
                this.emitter.trigger('hitupdate', hit, false, ev);
            }
        };
        HitDragging.prototype.prepareHits = function () {
            this.offsetTrackers = core.mapHash(this.droppableStore, function (interactionSettings) {
                interactionSettings.component.buildPositionCaches();
                return new OffsetTracker(interactionSettings.el);
            });
        };
        HitDragging.prototype.releaseHits = function () {
            var offsetTrackers = this.offsetTrackers;
            for (var id in offsetTrackers) {
                offsetTrackers[id].destroy();
            }
            this.offsetTrackers = {};
        };
        HitDragging.prototype.queryHitForOffset = function (offsetLeft, offsetTop) {
            var _a = this, droppableStore = _a.droppableStore, offsetTrackers = _a.offsetTrackers;
            var bestHit = null;
            for (var id in droppableStore) {
                var component = droppableStore[id].component;
                var offsetTracker = offsetTrackers[id];
                if (offsetTracker.isWithinClipping(offsetLeft, offsetTop)) {
                    var originLeft = offsetTracker.computeLeft();
                    var originTop = offsetTracker.computeTop();
                    var positionLeft = offsetLeft - originLeft;
                    var positionTop = offsetTop - originTop;
                    var origRect = offsetTracker.origRect;
                    var width = origRect.right - origRect.left;
                    var height = origRect.bottom - origRect.top;
                    if (
                    // must be within the element's bounds
                    positionLeft >= 0 && positionLeft < width &&
                        positionTop >= 0 && positionTop < height) {
                        var hit = component.queryHit(positionLeft, positionTop, width, height);
                        if (hit &&
                            (
                            // make sure the hit is within activeRange, meaning it's not a deal cell
                            !component.props.dateProfile || // hack for DayTile
                                core.rangeContainsRange(component.props.dateProfile.activeRange, hit.dateSpan.range)) &&
                            (!bestHit || hit.layer > bestHit.layer)) {
                            // TODO: better way to re-orient rectangle
                            hit.rect.left += originLeft;
                            hit.rect.right += originLeft;
                            hit.rect.top += originTop;
                            hit.rect.bottom += originTop;
                            bestHit = hit;
                        }
                    }
                }
            }
            return bestHit;
        };
        return HitDragging;
    }());
    function isHitsEqual(hit0, hit1) {
        if (!hit0 && !hit1) {
            return true;
        }
        if (Boolean(hit0) !== Boolean(hit1)) {
            return false;
        }
        return core.isDateSpansEqual(hit0.dateSpan, hit1.dateSpan);
    }

    /*
    Monitors when the user clicks on a specific date/time of a component.
    A pointerdown+pointerup on the same "hit" constitutes a click.
    */
    var DateClicking = /** @class */ (function (_super) {
        __extends(DateClicking, _super);
        function DateClicking(settings) {
            var _this = _super.call(this, settings) || this;
            _this.handlePointerDown = function (ev) {
                var dragging = _this.dragging;
                // do this in pointerdown (not dragend) because DOM might be mutated by the time dragend is fired
                dragging.setIgnoreMove(!_this.component.isValidDateDownEl(dragging.pointer.downEl));
            };
            // won't even fire if moving was ignored
            _this.handleDragEnd = function (ev) {
                var component = _this.component;
                var pointer = _this.dragging.pointer;
                if (!pointer.wasTouchScroll) {
                    var _a = _this.hitDragging, initialHit = _a.initialHit, finalHit = _a.finalHit;
                    if (initialHit && finalHit && isHitsEqual(initialHit, finalHit)) {
                        component.calendar.triggerDateClick(initialHit.dateSpan, initialHit.dayEl, component.view, ev.origEvent);
                    }
                }
            };
            var component = settings.component;
            // we DO want to watch pointer moves because otherwise finalHit won't get populated
            _this.dragging = new FeaturefulElementDragging(component.el);
            _this.dragging.autoScroller.isEnabled = false;
            var hitDragging = _this.hitDragging = new HitDragging(_this.dragging, core.interactionSettingsToStore(settings));
            hitDragging.emitter.on('pointerdown', _this.handlePointerDown);
            hitDragging.emitter.on('dragend', _this.handleDragEnd);
            return _this;
        }
        DateClicking.prototype.destroy = function () {
            this.dragging.destroy();
        };
        return DateClicking;
    }(core.Interaction));

    /*
    Tracks when the user selects a portion of time of a component,
    constituted by a drag over date cells, with a possible delay at the beginning of the drag.
    */
    var DateSelecting = /** @class */ (function (_super) {
        __extends(DateSelecting, _super);
        function DateSelecting(settings) {
            var _this = _super.call(this, settings) || this;
            _this.dragSelection = null;
            _this.handlePointerDown = function (ev) {
                var _a = _this, component = _a.component, dragging = _a.dragging;
                var canSelect = component.opt('selectable') &&
                    component.isValidDateDownEl(ev.origEvent.target);
                // don't bother to watch expensive moves if component won't do selection
                dragging.setIgnoreMove(!canSelect);
                // if touch, require user to hold down
                dragging.delay = ev.isTouch ? getComponentTouchDelay(component) : null;
            };
            _this.handleDragStart = function (ev) {
                _this.component.calendar.unselect(ev); // unselect previous selections
            };
            _this.handleHitUpdate = function (hit, isFinal) {
                var calendar = _this.component.calendar;
                var dragSelection = null;
                var isInvalid = false;
                if (hit) {
                    dragSelection = joinHitsIntoSelection(_this.hitDragging.initialHit, hit, calendar.pluginSystem.hooks.dateSelectionTransformers);
                    if (!dragSelection || !_this.component.isDateSelectionValid(dragSelection)) {
                        isInvalid = true;
                        dragSelection = null;
                    }
                }
                if (dragSelection) {
                    calendar.dispatch({ type: 'SELECT_DATES', selection: dragSelection });
                }
                else if (!isFinal) { // only unselect if moved away while dragging
                    calendar.dispatch({ type: 'UNSELECT_DATES' });
                }
                if (!isInvalid) {
                    core.enableCursor();
                }
                else {
                    core.disableCursor();
                }
                if (!isFinal) {
                    _this.dragSelection = dragSelection; // only clear if moved away from all hits while dragging
                }
            };
            _this.handlePointerUp = function (pev) {
                if (_this.dragSelection) {
                    // selection is already rendered, so just need to report selection
                    _this.component.calendar.triggerDateSelect(_this.dragSelection, pev);
                    _this.dragSelection = null;
                }
            };
            var component = settings.component;
            var dragging = _this.dragging = new FeaturefulElementDragging(component.el);
            dragging.touchScrollAllowed = false;
            dragging.minDistance = component.opt('selectMinDistance') || 0;
            dragging.autoScroller.isEnabled = component.opt('dragScroll');
            var hitDragging = _this.hitDragging = new HitDragging(_this.dragging, core.interactionSettingsToStore(settings));
            hitDragging.emitter.on('pointerdown', _this.handlePointerDown);
            hitDragging.emitter.on('dragstart', _this.handleDragStart);
            hitDragging.emitter.on('hitupdate', _this.handleHitUpdate);
            hitDragging.emitter.on('pointerup', _this.handlePointerUp);
            return _this;
        }
        DateSelecting.prototype.destroy = function () {
            this.dragging.destroy();
        };
        return DateSelecting;
    }(core.Interaction));
    function getComponentTouchDelay(component) {
        var delay = component.opt('selectLongPressDelay');
        if (delay == null) {
            delay = component.opt('longPressDelay');
        }
        return delay;
    }
    function joinHitsIntoSelection(hit0, hit1, dateSelectionTransformers) {
        var dateSpan0 = hit0.dateSpan;
        var dateSpan1 = hit1.dateSpan;
        var ms = [
            dateSpan0.range.start,
            dateSpan0.range.end,
            dateSpan1.range.start,
            dateSpan1.range.end
        ];
        ms.sort(core.compareNumbers);
        var props = {};
        for (var _i = 0, dateSelectionTransformers_1 = dateSelectionTransformers; _i < dateSelectionTransformers_1.length; _i++) {
            var transformer = dateSelectionTransformers_1[_i];
            var res = transformer(hit0, hit1);
            if (res === false) {
                return null;
            }
            else if (res) {
                __assign(props, res);
            }
        }
        props.range = { start: ms[0], end: ms[3] };
        props.allDay = dateSpan0.allDay;
        return props;
    }

    var EventDragging = /** @class */ (function (_super) {
        __extends(EventDragging, _super);
        function EventDragging(settings) {
            var _this = _super.call(this, settings) || this;
            // internal state
            _this.subjectSeg = null; // the seg being selected/dragged
            _this.isDragging = false;
            _this.eventRange = null;
            _this.relevantEvents = null; // the events being dragged
            _this.receivingCalendar = null;
            _this.validMutation = null;
            _this.mutatedRelevantEvents = null;
            _this.handlePointerDown = function (ev) {
                var origTarget = ev.origEvent.target;
                var _a = _this, component = _a.component, dragging = _a.dragging;
                var mirror = dragging.mirror;
                var initialCalendar = component.calendar;
                var subjectSeg = _this.subjectSeg = core.getElSeg(ev.subjectEl);
                var eventRange = _this.eventRange = subjectSeg.eventRange;
                var eventInstanceId = eventRange.instance.instanceId;
                _this.relevantEvents = core.getRelevantEvents(initialCalendar.state.eventStore, eventInstanceId);
                dragging.minDistance = ev.isTouch ? 0 : component.opt('eventDragMinDistance');
                dragging.delay =
                    // only do a touch delay if touch and this event hasn't been selected yet
                    (ev.isTouch && eventInstanceId !== component.props.eventSelection) ?
                        getComponentTouchDelay$1(component) :
                        null;
                mirror.parentNode = initialCalendar.el;
                mirror.revertDuration = component.opt('dragRevertDuration');
                var isValid = component.isValidSegDownEl(origTarget) &&
                    !core.elementClosest(origTarget, '.fc-resizer'); // NOT on a resizer
                dragging.setIgnoreMove(!isValid);
                // disable dragging for elements that are resizable (ie, selectable)
                // but are not draggable
                _this.isDragging = isValid &&
                    ev.subjectEl.classList.contains('fc-draggable');
            };
            _this.handleDragStart = function (ev) {
                var initialCalendar = _this.component.calendar;
                var eventRange = _this.eventRange;
                var eventInstanceId = eventRange.instance.instanceId;
                if (ev.isTouch) {
                    // need to select a different event?
                    if (eventInstanceId !== _this.component.props.eventSelection) {
                        initialCalendar.dispatch({ type: 'SELECT_EVENT', eventInstanceId: eventInstanceId });
                    }
                }
                else {
                    // if now using mouse, but was previous touch interaction, clear selected event
                    initialCalendar.dispatch({ type: 'UNSELECT_EVENT' });
                }
                if (_this.isDragging) {
                    initialCalendar.unselect(ev); // unselect *date* selection
                    initialCalendar.publiclyTrigger('eventDragStart', [
                        {
                            el: _this.subjectSeg.el,
                            event: new core.EventApi(initialCalendar, eventRange.def, eventRange.instance),
                            jsEvent: ev.origEvent,
                            view: _this.component.view
                        }
                    ]);
                }
            };
            _this.handleHitUpdate = function (hit, isFinal) {
                if (!_this.isDragging) {
                    return;
                }
                var relevantEvents = _this.relevantEvents;
                var initialHit = _this.hitDragging.initialHit;
                var initialCalendar = _this.component.calendar;
                // states based on new hit
                var receivingCalendar = null;
                var mutation = null;
                var mutatedRelevantEvents = null;
                var isInvalid = false;
                var interaction = {
                    affectedEvents: relevantEvents,
                    mutatedEvents: core.createEmptyEventStore(),
                    isEvent: true,
                    origSeg: _this.subjectSeg
                };
                if (hit) {
                    var receivingComponent = hit.component;
                    receivingCalendar = receivingComponent.calendar;
                    if (initialCalendar === receivingCalendar ||
                        receivingComponent.opt('editable') && receivingComponent.opt('droppable')) {
                        mutation = computeEventMutation(initialHit, hit, receivingCalendar.pluginSystem.hooks.eventDragMutationMassagers);
                        if (mutation) {
                            mutatedRelevantEvents = core.applyMutationToEventStore(relevantEvents, receivingCalendar.eventUiBases, mutation, receivingCalendar);
                            interaction.mutatedEvents = mutatedRelevantEvents;
                            if (!receivingComponent.isInteractionValid(interaction)) {
                                isInvalid = true;
                                mutation = null;
                                mutatedRelevantEvents = null;
                                interaction.mutatedEvents = core.createEmptyEventStore();
                            }
                        }
                    }
                    else {
                        receivingCalendar = null;
                    }
                }
                _this.displayDrag(receivingCalendar, interaction);
                if (!isInvalid) {
                    core.enableCursor();
                }
                else {
                    core.disableCursor();
                }
                if (!isFinal) {
                    if (initialCalendar === receivingCalendar && // TODO: write test for this
                        isHitsEqual(initialHit, hit)) {
                        mutation = null;
                    }
                    _this.dragging.setMirrorNeedsRevert(!mutation);
                    // render the mirror if no already-rendered mirror
                    // TODO: wish we could somehow wait for dispatch to guarantee render
                    _this.dragging.setMirrorIsVisible(!hit || !document.querySelector('.fc-mirror'));
                    // assign states based on new hit
                    _this.receivingCalendar = receivingCalendar;
                    _this.validMutation = mutation;
                    _this.mutatedRelevantEvents = mutatedRelevantEvents;
                }
            };
            _this.handlePointerUp = function () {
                if (!_this.isDragging) {
                    _this.cleanup(); // because handleDragEnd won't fire
                }
            };
            _this.handleDragEnd = function (ev) {
                if (_this.isDragging) {
                    var initialCalendar_1 = _this.component.calendar;
                    var initialView = _this.component.view;
                    var _a = _this, receivingCalendar = _a.receivingCalendar, validMutation = _a.validMutation;
                    var eventDef = _this.eventRange.def;
                    var eventInstance = _this.eventRange.instance;
                    var eventApi = new core.EventApi(initialCalendar_1, eventDef, eventInstance);
                    var relevantEvents_1 = _this.relevantEvents;
                    var mutatedRelevantEvents = _this.mutatedRelevantEvents;
                    var finalHit = _this.hitDragging.finalHit;
                    _this.clearDrag(); // must happen after revert animation
                    initialCalendar_1.publiclyTrigger('eventDragStop', [
                        {
                            el: _this.subjectSeg.el,
                            event: eventApi,
                            jsEvent: ev.origEvent,
                            view: initialView
                        }
                    ]);
                    if (validMutation) {
                        // dropped within same calendar
                        if (receivingCalendar === initialCalendar_1) {
                            initialCalendar_1.dispatch({
                                type: 'MERGE_EVENTS',
                                eventStore: mutatedRelevantEvents
                            });
                            var transformed = {};
                            for (var _i = 0, _b = initialCalendar_1.pluginSystem.hooks.eventDropTransformers; _i < _b.length; _i++) {
                                var transformer = _b[_i];
                                __assign(transformed, transformer(validMutation, initialCalendar_1));
                            }
                            var eventDropArg = __assign({}, transformed, { el: ev.subjectEl, delta: validMutation.datesDelta, oldEvent: eventApi, event: new core.EventApi(// the data AFTER the mutation
                                initialCalendar_1, mutatedRelevantEvents.defs[eventDef.defId], eventInstance ? mutatedRelevantEvents.instances[eventInstance.instanceId] : null), revert: function () {
                                    initialCalendar_1.dispatch({
                                        type: 'MERGE_EVENTS',
                                        eventStore: relevantEvents_1
                                    });
                                }, jsEvent: ev.origEvent, view: initialView });
                            initialCalendar_1.publiclyTrigger('eventDrop', [eventDropArg]);
                            // dropped in different calendar
                        }
                        else if (receivingCalendar) {
                            initialCalendar_1.publiclyTrigger('eventLeave', [
                                {
                                    draggedEl: ev.subjectEl,
                                    event: eventApi,
                                    view: initialView
                                }
                            ]);
                            initialCalendar_1.dispatch({
                                type: 'REMOVE_EVENT_INSTANCES',
                                instances: _this.mutatedRelevantEvents.instances
                            });
                            receivingCalendar.dispatch({
                                type: 'MERGE_EVENTS',
                                eventStore: _this.mutatedRelevantEvents
                            });
                            if (ev.isTouch) {
                                receivingCalendar.dispatch({
                                    type: 'SELECT_EVENT',
                                    eventInstanceId: eventInstance.instanceId
                                });
                            }
                            var dropArg = __assign({}, receivingCalendar.buildDatePointApi(finalHit.dateSpan), { draggedEl: ev.subjectEl, jsEvent: ev.origEvent, view: finalHit.component // should this be finalHit.component.view? See #4644
                             });
                            receivingCalendar.publiclyTrigger('drop', [dropArg]);
                            receivingCalendar.publiclyTrigger('eventReceive', [
                                {
                                    draggedEl: ev.subjectEl,
                                    event: new core.EventApi(// the data AFTER the mutation
                                    receivingCalendar, mutatedRelevantEvents.defs[eventDef.defId], mutatedRelevantEvents.instances[eventInstance.instanceId]),
                                    view: finalHit.component // should this be finalHit.component.view? See #4644
                                }
                            ]);
                        }
                    }
                    else {
                        initialCalendar_1.publiclyTrigger('_noEventDrop');
                    }
                }
                _this.cleanup();
            };
            var component = _this.component;
            var dragging = _this.dragging = new FeaturefulElementDragging(component.el);
            dragging.pointer.selector = EventDragging.SELECTOR;
            dragging.touchScrollAllowed = false;
            dragging.autoScroller.isEnabled = component.opt('dragScroll');
            var hitDragging = _this.hitDragging = new HitDragging(_this.dragging, core.interactionSettingsStore);
            hitDragging.useSubjectCenter = settings.useEventCenter;
            hitDragging.emitter.on('pointerdown', _this.handlePointerDown);
            hitDragging.emitter.on('dragstart', _this.handleDragStart);
            hitDragging.emitter.on('hitupdate', _this.handleHitUpdate);
            hitDragging.emitter.on('pointerup', _this.handlePointerUp);
            hitDragging.emitter.on('dragend', _this.handleDragEnd);
            return _this;
        }
        EventDragging.prototype.destroy = function () {
            this.dragging.destroy();
        };
        // render a drag state on the next receivingCalendar
        EventDragging.prototype.displayDrag = function (nextCalendar, state) {
            var initialCalendar = this.component.calendar;
            var prevCalendar = this.receivingCalendar;
            // does the previous calendar need to be cleared?
            if (prevCalendar && prevCalendar !== nextCalendar) {
                // does the initial calendar need to be cleared?
                // if so, don't clear all the way. we still need to to hide the affectedEvents
                if (prevCalendar === initialCalendar) {
                    prevCalendar.dispatch({
                        type: 'SET_EVENT_DRAG',
                        state: {
                            affectedEvents: state.affectedEvents,
                            mutatedEvents: core.createEmptyEventStore(),
                            isEvent: true,
                            origSeg: state.origSeg
                        }
                    });
                    // completely clear the old calendar if it wasn't the initial
                }
                else {
                    prevCalendar.dispatch({ type: 'UNSET_EVENT_DRAG' });
                }
            }
            if (nextCalendar) {
                nextCalendar.dispatch({ type: 'SET_EVENT_DRAG', state: state });
            }
        };
        EventDragging.prototype.clearDrag = function () {
            var initialCalendar = this.component.calendar;
            var receivingCalendar = this.receivingCalendar;
            if (receivingCalendar) {
                receivingCalendar.dispatch({ type: 'UNSET_EVENT_DRAG' });
            }
            // the initial calendar might have an dummy drag state from displayDrag
            if (initialCalendar !== receivingCalendar) {
                initialCalendar.dispatch({ type: 'UNSET_EVENT_DRAG' });
            }
        };
        EventDragging.prototype.cleanup = function () {
            this.subjectSeg = null;
            this.isDragging = false;
            this.eventRange = null;
            this.relevantEvents = null;
            this.receivingCalendar = null;
            this.validMutation = null;
            this.mutatedRelevantEvents = null;
        };
        EventDragging.SELECTOR = '.fc-draggable, .fc-resizable'; // TODO: test this in IE11
        return EventDragging;
    }(core.Interaction));
    function computeEventMutation(hit0, hit1, massagers) {
        var dateSpan0 = hit0.dateSpan;
        var dateSpan1 = hit1.dateSpan;
        var date0 = dateSpan0.range.start;
        var date1 = dateSpan1.range.start;
        var standardProps = {};
        if (dateSpan0.allDay !== dateSpan1.allDay) {
            standardProps.allDay = dateSpan1.allDay;
            standardProps.hasEnd = hit1.component.opt('allDayMaintainDuration');
            if (dateSpan1.allDay) {
                // means date1 is already start-of-day,
                // but date0 needs to be converted
                date0 = core.startOfDay(date0);
            }
        }
        var delta = core.diffDates(date0, date1, hit0.component.dateEnv, hit0.component === hit1.component ?
            hit0.component.largeUnit :
            null);
        if (delta.milliseconds) { // has hours/minutes/seconds
            standardProps.allDay = false;
        }
        var mutation = {
            datesDelta: delta,
            standardProps: standardProps
        };
        for (var _i = 0, massagers_1 = massagers; _i < massagers_1.length; _i++) {
            var massager = massagers_1[_i];
            massager(mutation, hit0, hit1);
        }
        return mutation;
    }
    function getComponentTouchDelay$1(component) {
        var delay = component.opt('eventLongPressDelay');
        if (delay == null) {
            delay = component.opt('longPressDelay');
        }
        return delay;
    }

    var EventDragging$1 = /** @class */ (function (_super) {
        __extends(EventDragging, _super);
        function EventDragging(settings) {
            var _this = _super.call(this, settings) || this;
            // internal state
            _this.draggingSeg = null; // TODO: rename to resizingSeg? subjectSeg?
            _this.eventRange = null;
            _this.relevantEvents = null;
            _this.validMutation = null;
            _this.mutatedRelevantEvents = null;
            _this.handlePointerDown = function (ev) {
                var component = _this.component;
                var seg = _this.querySeg(ev);
                var eventRange = _this.eventRange = seg.eventRange;
                _this.dragging.minDistance = component.opt('eventDragMinDistance');
                // if touch, need to be working with a selected event
                _this.dragging.setIgnoreMove(!_this.component.isValidSegDownEl(ev.origEvent.target) ||
                    (ev.isTouch && _this.component.props.eventSelection !== eventRange.instance.instanceId));
            };
            _this.handleDragStart = function (ev) {
                var calendar = _this.component.calendar;
                var eventRange = _this.eventRange;
                _this.relevantEvents = core.getRelevantEvents(calendar.state.eventStore, _this.eventRange.instance.instanceId);
                _this.draggingSeg = _this.querySeg(ev);
                calendar.unselect();
                calendar.publiclyTrigger('eventResizeStart', [
                    {
                        el: _this.draggingSeg.el,
                        event: new core.EventApi(calendar, eventRange.def, eventRange.instance),
                        jsEvent: ev.origEvent,
                        view: _this.component.view
                    }
                ]);
            };
            _this.handleHitUpdate = function (hit, isFinal, ev) {
                var calendar = _this.component.calendar;
                var relevantEvents = _this.relevantEvents;
                var initialHit = _this.hitDragging.initialHit;
                var eventInstance = _this.eventRange.instance;
                var mutation = null;
                var mutatedRelevantEvents = null;
                var isInvalid = false;
                var interaction = {
                    affectedEvents: relevantEvents,
                    mutatedEvents: core.createEmptyEventStore(),
                    isEvent: true,
                    origSeg: _this.draggingSeg
                };
                if (hit) {
                    mutation = computeMutation(initialHit, hit, ev.subjectEl.classList.contains('fc-start-resizer'), eventInstance.range, calendar.pluginSystem.hooks.eventResizeJoinTransforms);
                }
                if (mutation) {
                    mutatedRelevantEvents = core.applyMutationToEventStore(relevantEvents, calendar.eventUiBases, mutation, calendar);
                    interaction.mutatedEvents = mutatedRelevantEvents;
                    if (!_this.component.isInteractionValid(interaction)) {
                        isInvalid = true;
                        mutation = null;
                        mutatedRelevantEvents = null;
                        interaction.mutatedEvents = null;
                    }
                }
                if (mutatedRelevantEvents) {
                    calendar.dispatch({
                        type: 'SET_EVENT_RESIZE',
                        state: interaction
                    });
                }
                else {
                    calendar.dispatch({ type: 'UNSET_EVENT_RESIZE' });
                }
                if (!isInvalid) {
                    core.enableCursor();
                }
                else {
                    core.disableCursor();
                }
                if (!isFinal) {
                    if (mutation && isHitsEqual(initialHit, hit)) {
                        mutation = null;
                    }
                    _this.validMutation = mutation;
                    _this.mutatedRelevantEvents = mutatedRelevantEvents;
                }
            };
            _this.handleDragEnd = function (ev) {
                var calendar = _this.component.calendar;
                var view = _this.component.view;
                var eventDef = _this.eventRange.def;
                var eventInstance = _this.eventRange.instance;
                var eventApi = new core.EventApi(calendar, eventDef, eventInstance);
                var relevantEvents = _this.relevantEvents;
                var mutatedRelevantEvents = _this.mutatedRelevantEvents;
                calendar.publiclyTrigger('eventResizeStop', [
                    {
                        el: _this.draggingSeg.el,
                        event: eventApi,
                        jsEvent: ev.origEvent,
                        view: view
                    }
                ]);
                if (_this.validMutation) {
                    calendar.dispatch({
                        type: 'MERGE_EVENTS',
                        eventStore: mutatedRelevantEvents
                    });
                    calendar.publiclyTrigger('eventResize', [
                        {
                            el: _this.draggingSeg.el,
                            startDelta: _this.validMutation.startDelta || core.createDuration(0),
                            endDelta: _this.validMutation.endDelta || core.createDuration(0),
                            prevEvent: eventApi,
                            event: new core.EventApi(// the data AFTER the mutation
                            calendar, mutatedRelevantEvents.defs[eventDef.defId], eventInstance ? mutatedRelevantEvents.instances[eventInstance.instanceId] : null),
                            revert: function () {
                                calendar.dispatch({
                                    type: 'MERGE_EVENTS',
                                    eventStore: relevantEvents
                                });
                            },
                            jsEvent: ev.origEvent,
                            view: view
                        }
                    ]);
                }
                else {
                    calendar.publiclyTrigger('_noEventResize');
                }
                // reset all internal state
                _this.draggingSeg = null;
                _this.relevantEvents = null;
                _this.validMutation = null;
                // okay to keep eventInstance around. useful to set it in handlePointerDown
            };
            var component = settings.component;
            var dragging = _this.dragging = new FeaturefulElementDragging(component.el);
            dragging.pointer.selector = '.fc-resizer';
            dragging.touchScrollAllowed = false;
            dragging.autoScroller.isEnabled = component.opt('dragScroll');
            var hitDragging = _this.hitDragging = new HitDragging(_this.dragging, core.interactionSettingsToStore(settings));
            hitDragging.emitter.on('pointerdown', _this.handlePointerDown);
            hitDragging.emitter.on('dragstart', _this.handleDragStart);
            hitDragging.emitter.on('hitupdate', _this.handleHitUpdate);
            hitDragging.emitter.on('dragend', _this.handleDragEnd);
            return _this;
        }
        EventDragging.prototype.destroy = function () {
            this.dragging.destroy();
        };
        EventDragging.prototype.querySeg = function (ev) {
            return core.getElSeg(core.elementClosest(ev.subjectEl, this.component.fgSegSelector));
        };
        return EventDragging;
    }(core.Interaction));
    function computeMutation(hit0, hit1, isFromStart, instanceRange, transforms) {
        var dateEnv = hit0.component.dateEnv;
        var date0 = hit0.dateSpan.range.start;
        var date1 = hit1.dateSpan.range.start;
        var delta = core.diffDates(date0, date1, dateEnv, hit0.component.largeUnit);
        var props = {};
        for (var _i = 0, transforms_1 = transforms; _i < transforms_1.length; _i++) {
            var transform = transforms_1[_i];
            var res = transform(hit0, hit1);
            if (res === false) {
                return null;
            }
            else if (res) {
                __assign(props, res);
            }
        }
        if (isFromStart) {
            if (dateEnv.add(instanceRange.start, delta) < instanceRange.end) {
                props.startDelta = delta;
                return props;
            }
        }
        else {
            if (dateEnv.add(instanceRange.end, delta) > instanceRange.start) {
                props.endDelta = delta;
                return props;
            }
        }
        return null;
    }

    var UnselectAuto = /** @class */ (function () {
        function UnselectAuto(calendar) {
            var _this = this;
            this.isRecentPointerDateSelect = false; // wish we could use a selector to detect date selection, but uses hit system
            this.onSelect = function (selectInfo) {
                if (selectInfo.jsEvent) {
                    _this.isRecentPointerDateSelect = true;
                }
            };
            this.onDocumentPointerUp = function (pev) {
                var _a = _this, calendar = _a.calendar, documentPointer = _a.documentPointer;
                var state = calendar.state;
                // touch-scrolling should never unfocus any type of selection
                if (!documentPointer.wasTouchScroll) {
                    if (state.dateSelection && // an existing date selection?
                        !_this.isRecentPointerDateSelect // a new pointer-initiated date selection since last onDocumentPointerUp?
                    ) {
                        var unselectAuto = calendar.viewOpt('unselectAuto');
                        var unselectCancel = calendar.viewOpt('unselectCancel');
                        if (unselectAuto && (!unselectAuto || !core.elementClosest(documentPointer.downEl, unselectCancel))) {
                            calendar.unselect(pev);
                        }
                    }
                    if (state.eventSelection && // an existing event selected?
                        !core.elementClosest(documentPointer.downEl, EventDragging.SELECTOR) // interaction DIDN'T start on an event
                    ) {
                        calendar.dispatch({ type: 'UNSELECT_EVENT' });
                    }
                }
                _this.isRecentPointerDateSelect = false;
            };
            this.calendar = calendar;
            var documentPointer = this.documentPointer = new PointerDragging(document);
            documentPointer.shouldIgnoreMove = true;
            documentPointer.shouldWatchScroll = false;
            documentPointer.emitter.on('pointerup', this.onDocumentPointerUp);
            /*
            TODO: better way to know about whether there was a selection with the pointer
            */
            calendar.on('select', this.onSelect);
        }
        UnselectAuto.prototype.destroy = function () {
            this.calendar.off('select', this.onSelect);
            this.documentPointer.destroy();
        };
        return UnselectAuto;
    }());

    /*
    Given an already instantiated draggable object for one-or-more elements,
    Interprets any dragging as an attempt to drag an events that lives outside
    of a calendar onto a calendar.
    */
    var ExternalElementDragging = /** @class */ (function () {
        function ExternalElementDragging(dragging, suppliedDragMeta) {
            var _this = this;
            this.receivingCalendar = null;
            this.droppableEvent = null; // will exist for all drags, even if create:false
            this.suppliedDragMeta = null;
            this.dragMeta = null;
            this.handleDragStart = function (ev) {
                _this.dragMeta = _this.buildDragMeta(ev.subjectEl);
            };
            this.handleHitUpdate = function (hit, isFinal, ev) {
                var dragging = _this.hitDragging.dragging;
                var receivingCalendar = null;
                var droppableEvent = null;
                var isInvalid = false;
                var interaction = {
                    affectedEvents: core.createEmptyEventStore(),
                    mutatedEvents: core.createEmptyEventStore(),
                    isEvent: _this.dragMeta.create,
                    origSeg: null
                };
                if (hit) {
                    receivingCalendar = hit.component.calendar;
                    if (_this.canDropElOnCalendar(ev.subjectEl, receivingCalendar)) {
                        droppableEvent = computeEventForDateSpan(hit.dateSpan, _this.dragMeta, receivingCalendar);
                        interaction.mutatedEvents = core.eventTupleToStore(droppableEvent);
                        isInvalid = !core.isInteractionValid(interaction, receivingCalendar);
                        if (isInvalid) {
                            interaction.mutatedEvents = core.createEmptyEventStore();
                            droppableEvent = null;
                        }
                    }
                }
                _this.displayDrag(receivingCalendar, interaction);
                // show mirror if no already-rendered mirror element OR if we are shutting down the mirror (?)
                // TODO: wish we could somehow wait for dispatch to guarantee render
                dragging.setMirrorIsVisible(isFinal || !droppableEvent || !document.querySelector('.fc-mirror'));
                if (!isInvalid) {
                    core.enableCursor();
                }
                else {
                    core.disableCursor();
                }
                if (!isFinal) {
                    dragging.setMirrorNeedsRevert(!droppableEvent);
                    _this.receivingCalendar = receivingCalendar;
                    _this.droppableEvent = droppableEvent;
                }
            };
            this.handleDragEnd = function (pev) {
                var _a = _this, receivingCalendar = _a.receivingCalendar, droppableEvent = _a.droppableEvent;
                _this.clearDrag();
                if (receivingCalendar && droppableEvent) {
                    var finalHit = _this.hitDragging.finalHit;
                    var finalView = finalHit.component.view;
                    var dragMeta = _this.dragMeta;
                    var arg = __assign({}, receivingCalendar.buildDatePointApi(finalHit.dateSpan), { draggedEl: pev.subjectEl, jsEvent: pev.origEvent, view: finalView });
                    receivingCalendar.publiclyTrigger('drop', [arg]);
                    if (dragMeta.create) {
                        receivingCalendar.dispatch({
                            type: 'MERGE_EVENTS',
                            eventStore: core.eventTupleToStore(droppableEvent)
                        });
                        if (pev.isTouch) {
                            receivingCalendar.dispatch({
                                type: 'SELECT_EVENT',
                                eventInstanceId: droppableEvent.instance.instanceId
                            });
                        }
                        // signal that an external event landed
                        receivingCalendar.publiclyTrigger('eventReceive', [
                            {
                                draggedEl: pev.subjectEl,
                                event: new core.EventApi(receivingCalendar, droppableEvent.def, droppableEvent.instance),
                                view: finalView
                            }
                        ]);
                    }
                }
                _this.receivingCalendar = null;
                _this.droppableEvent = null;
            };
            var hitDragging = this.hitDragging = new HitDragging(dragging, core.interactionSettingsStore);
            hitDragging.requireInitial = false; // will start outside of a component
            hitDragging.emitter.on('dragstart', this.handleDragStart);
            hitDragging.emitter.on('hitupdate', this.handleHitUpdate);
            hitDragging.emitter.on('dragend', this.handleDragEnd);
            this.suppliedDragMeta = suppliedDragMeta;
        }
        ExternalElementDragging.prototype.buildDragMeta = function (subjectEl) {
            if (typeof this.suppliedDragMeta === 'object') {
                return core.parseDragMeta(this.suppliedDragMeta);
            }
            else if (typeof this.suppliedDragMeta === 'function') {
                return core.parseDragMeta(this.suppliedDragMeta(subjectEl));
            }
            else {
                return getDragMetaFromEl(subjectEl);
            }
        };
        ExternalElementDragging.prototype.displayDrag = function (nextCalendar, state) {
            var prevCalendar = this.receivingCalendar;
            if (prevCalendar && prevCalendar !== nextCalendar) {
                prevCalendar.dispatch({ type: 'UNSET_EVENT_DRAG' });
            }
            if (nextCalendar) {
                nextCalendar.dispatch({ type: 'SET_EVENT_DRAG', state: state });
            }
        };
        ExternalElementDragging.prototype.clearDrag = function () {
            if (this.receivingCalendar) {
                this.receivingCalendar.dispatch({ type: 'UNSET_EVENT_DRAG' });
            }
        };
        ExternalElementDragging.prototype.canDropElOnCalendar = function (el, receivingCalendar) {
            var dropAccept = receivingCalendar.opt('dropAccept');
            if (typeof dropAccept === 'function') {
                return dropAccept(el);
            }
            else if (typeof dropAccept === 'string' && dropAccept) {
                return Boolean(core.elementMatches(el, dropAccept));
            }
            return true;
        };
        return ExternalElementDragging;
    }());
    // Utils for computing event store from the DragMeta
    // ----------------------------------------------------------------------------------------------------
    function computeEventForDateSpan(dateSpan, dragMeta, calendar) {
        var defProps = __assign({}, dragMeta.leftoverProps);
        for (var _i = 0, _a = calendar.pluginSystem.hooks.externalDefTransforms; _i < _a.length; _i++) {
            var transform = _a[_i];
            __assign(defProps, transform(dateSpan, dragMeta));
        }
        var def = core.parseEventDef(defProps, dragMeta.sourceId, dateSpan.allDay, calendar.opt('forceEventDuration') || Boolean(dragMeta.duration), // hasEnd
        calendar);
        var start = dateSpan.range.start;
        // only rely on time info if drop zone is all-day,
        // otherwise, we already know the time
        if (dateSpan.allDay && dragMeta.startTime) {
            start = calendar.dateEnv.add(start, dragMeta.startTime);
        }
        var end = dragMeta.duration ?
            calendar.dateEnv.add(start, dragMeta.duration) :
            calendar.getDefaultEventEnd(dateSpan.allDay, start);
        var instance = core.createEventInstance(def.defId, { start: start, end: end });
        return { def: def, instance: instance };
    }
    // Utils for extracting data from element
    // ----------------------------------------------------------------------------------------------------
    function getDragMetaFromEl(el) {
        var str = getEmbeddedElData(el, 'event');
        var obj = str ?
            JSON.parse(str) :
            { create: false }; // if no embedded data, assume no event creation
        return core.parseDragMeta(obj);
    }
    core.config.dataAttrPrefix = '';
    function getEmbeddedElData(el, name) {
        var prefix = core.config.dataAttrPrefix;
        var prefixedName = (prefix ? prefix + '-' : '') + name;
        return el.getAttribute('data-' + prefixedName) || '';
    }

    /*
    Makes an element (that is *external* to any calendar) draggable.
    Can pass in data that determines how an event will be created when dropped onto a calendar.
    Leverages FullCalendar's internal drag-n-drop functionality WITHOUT a third-party drag system.
    */
    var ExternalDraggable = /** @class */ (function () {
        function ExternalDraggable(el, settings) {
            var _this = this;
            if (settings === void 0) { settings = {}; }
            this.handlePointerDown = function (ev) {
                var dragging = _this.dragging;
                var _a = _this.settings, minDistance = _a.minDistance, longPressDelay = _a.longPressDelay;
                dragging.minDistance =
                    minDistance != null ?
                        minDistance :
                        (ev.isTouch ? 0 : core.globalDefaults.eventDragMinDistance);
                dragging.delay =
                    ev.isTouch ? // TODO: eventually read eventLongPressDelay instead vvv
                        (longPressDelay != null ? longPressDelay : core.globalDefaults.longPressDelay) :
                        0;
            };
            this.handleDragStart = function (ev) {
                if (ev.isTouch &&
                    _this.dragging.delay &&
                    ev.subjectEl.classList.contains('fc-event')) {
                    _this.dragging.mirror.getMirrorEl().classList.add('fc-selected');
                }
            };
            this.settings = settings;
            var dragging = this.dragging = new FeaturefulElementDragging(el);
            dragging.touchScrollAllowed = false;
            if (settings.itemSelector != null) {
                dragging.pointer.selector = settings.itemSelector;
            }
            if (settings.appendTo != null) {
                dragging.mirror.parentNode = settings.appendTo; // TODO: write tests
            }
            dragging.emitter.on('pointerdown', this.handlePointerDown);
            dragging.emitter.on('dragstart', this.handleDragStart);
            new ExternalElementDragging(dragging, settings.eventData);
        }
        ExternalDraggable.prototype.destroy = function () {
            this.dragging.destroy();
        };
        return ExternalDraggable;
    }());

    /*
    Detects when a *THIRD-PARTY* drag-n-drop system interacts with elements.
    The third-party system is responsible for drawing the visuals effects of the drag.
    This class simply monitors for pointer movements and fires events.
    It also has the ability to hide the moving element (the "mirror") during the drag.
    */
    var InferredElementDragging = /** @class */ (function (_super) {
        __extends(InferredElementDragging, _super);
        function InferredElementDragging(containerEl) {
            var _this = _super.call(this, containerEl) || this;
            _this.shouldIgnoreMove = false;
            _this.mirrorSelector = '';
            _this.currentMirrorEl = null;
            _this.handlePointerDown = function (ev) {
                _this.emitter.trigger('pointerdown', ev);
                if (!_this.shouldIgnoreMove) {
                    // fire dragstart right away. does not support delay or min-distance
                    _this.emitter.trigger('dragstart', ev);
                }
            };
            _this.handlePointerMove = function (ev) {
                if (!_this.shouldIgnoreMove) {
                    _this.emitter.trigger('dragmove', ev);
                }
            };
            _this.handlePointerUp = function (ev) {
                _this.emitter.trigger('pointerup', ev);
                if (!_this.shouldIgnoreMove) {
                    // fire dragend right away. does not support a revert animation
                    _this.emitter.trigger('dragend', ev);
                }
            };
            var pointer = _this.pointer = new PointerDragging(containerEl);
            pointer.emitter.on('pointerdown', _this.handlePointerDown);
            pointer.emitter.on('pointermove', _this.handlePointerMove);
            pointer.emitter.on('pointerup', _this.handlePointerUp);
            return _this;
        }
        InferredElementDragging.prototype.destroy = function () {
            this.pointer.destroy();
        };
        InferredElementDragging.prototype.setIgnoreMove = function (bool) {
            this.shouldIgnoreMove = bool;
        };
        InferredElementDragging.prototype.setMirrorIsVisible = function (bool) {
            if (bool) {
                // restore a previously hidden element.
                // use the reference in case the selector class has already been removed.
                if (this.currentMirrorEl) {
                    this.currentMirrorEl.style.visibility = '';
                    this.currentMirrorEl = null;
                }
            }
            else {
                var mirrorEl = this.mirrorSelector ?
                    document.querySelector(this.mirrorSelector) :
                    null;
                if (mirrorEl) {
                    this.currentMirrorEl = mirrorEl;
                    mirrorEl.style.visibility = 'hidden';
                }
            }
        };
        return InferredElementDragging;
    }(core.ElementDragging));

    /*
    Bridges third-party drag-n-drop systems with FullCalendar.
    Must be instantiated and destroyed by caller.
    */
    var ThirdPartyDraggable = /** @class */ (function () {
        function ThirdPartyDraggable(containerOrSettings, settings) {
            var containerEl = document;
            if (
            // wish we could just test instanceof EventTarget, but doesn't work in IE11
            containerOrSettings === document ||
                containerOrSettings instanceof Element) {
                containerEl = containerOrSettings;
                settings = settings || {};
            }
            else {
                settings = (containerOrSettings || {});
            }
            var dragging = this.dragging = new InferredElementDragging(containerEl);
            if (typeof settings.itemSelector === 'string') {
                dragging.pointer.selector = settings.itemSelector;
            }
            else if (containerEl === document) {
                dragging.pointer.selector = '[data-event]';
            }
            if (typeof settings.mirrorSelector === 'string') {
                dragging.mirrorSelector = settings.mirrorSelector;
            }
            new ExternalElementDragging(dragging, settings.eventData);
        }
        ThirdPartyDraggable.prototype.destroy = function () {
            this.dragging.destroy();
        };
        return ThirdPartyDraggable;
    }());

    var main = core.createPlugin({
        componentInteractions: [DateClicking, DateSelecting, EventDragging, EventDragging$1],
        calendarInteractions: [UnselectAuto],
        elementDraggingImpl: FeaturefulElementDragging
    });

    exports.Draggable = ExternalDraggable;
    exports.FeaturefulElementDragging = FeaturefulElementDragging;
    exports.PointerDragging = PointerDragging;
    exports.ThirdPartyDraggable = ThirdPartyDraggable;
    exports.default = main;

    Object.defineProperty(exports, '__esModule', { value: true });

}));

/*!
FullCalendar Bootstrap Plugin v4.1.0
Docs & License: https://fullcalendar.io/
(c) 2019 Adam Shaw
*/
(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@fullcalendar/core')) :
    typeof define === 'function' && define.amd ? define(['exports', '@fullcalendar/core'], factory) :
    (global = global || self, factory(global.FullCalendarBootstrap = {}, global.FullCalendar));
}(this, function (exports, core) { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    /* global Reflect, Promise */

    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };

    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    var BootstrapTheme = /** @class */ (function (_super) {
        __extends(BootstrapTheme, _super);
        function BootstrapTheme() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return BootstrapTheme;
    }(core.Theme));
    BootstrapTheme.prototype.classes = {
        widget: 'fc-bootstrap',
        tableGrid: 'table-bordered',
        tableList: 'table',
        tableListHeading: 'table-active',
        buttonGroup: 'btn-group',
        button: 'btn btn-default',
        buttonActive: 'active',
        today: 'alert alert-info',
        popover: 'card card-primary',
        popoverHeader: 'card-header',
        popoverContent: 'card-body',
        // day grid
        // for left/right border color when border is inset from edges (all-day in timeGrid view)
        // avoid `table` class b/c don't want margins/padding/structure. only border color.
        headerRow: 'table-bordered',
        dayRow: 'table-bordered',
        // list view
        listView: 'card card-primary'
    };
    BootstrapTheme.prototype.baseIconClass = 'fal';
    BootstrapTheme.prototype.iconClasses = {
        close: 'fa-times',
        prev: 'fa-chevron-left',
        next: 'fa-chevron-right',
        prevYear: 'fa-angle-double-left',
        nextYear: 'fa-angle-double-right'
    };
    BootstrapTheme.prototype.iconOverrideOption = 'bootstrapFontAwesome';
    BootstrapTheme.prototype.iconOverrideCustomButtonOption = 'bootstrapFontAwesome';
    BootstrapTheme.prototype.iconOverridePrefix = 'fa-';
    var main = core.createPlugin({
        themeClasses: {
            bootstrap: BootstrapTheme
        }
    });

    exports.BootstrapTheme = BootstrapTheme;
    exports.default = main;

    Object.defineProperty(exports, '__esModule', { value: true });

}));

!function(e,n){"object"==typeof exports&&"object"==typeof module?module.exports=n():"function"==typeof define&&define.amd?define([],n):"object"==typeof exports?exports.cytoscapeEdgeConnections=n():e.cytoscapeEdgeConnections=n()}(window,function(){return function(e){var n={};function o(t){if(n[t])return n[t].exports;var r=n[t]={i:t,l:!1,exports:{}};return e[t].call(r.exports,r,r.exports,o),r.l=!0,r.exports}return o.m=e,o.c=n,o.d=function(e,n,t){o.o(e,n)||Object.defineProperty(e,n,{enumerable:!0,get:t})},o.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},o.t=function(e,n){if(1&n&&(e=o(e)),8&n)return e;if(4&n&&"object"==typeof e&&e&&e.__esModule)return e;var t=Object.create(null);if(o.r(t),Object.defineProperty(t,"default",{enumerable:!0,value:e}),2&n&&"string"!=typeof e)for(var r in e)o.d(t,r,function(n){return e[n]}.bind(null,r));return t},o.n=function(e){var n=e&&e.__esModule?function(){return e.default}:function(){return e};return o.d(n,"a",n),n},o.o=function(e,n){return Object.prototype.hasOwnProperty.call(e,n)},o.p="",o(o.s=0)}([function(e,n){let o,t=10;function r(e){e("core","edgeConnections",d)}function d(e={}){return o=this,e.maxPasses&&(t=e.maxPasses),o.style().selector("node.aux-node").style({"background-color":"data(color)"}),o.on("position","node",e=>(function(e){e.connectedEdges().forEach(f)})(e.target)),o.on("remove","edge",e=>{const n=e.target;!function(e){const n=l(e);n&&n.remove()}(n),s(n)}),o.on("style","edge",e=>(function(e){const n=l(e);n&&n.data("color",e.style("line-color"))})(e.target)),{addEdge:i,addEdges:c,auxNode:l,isAuxNode:p,edgeId:y,edge:x}}function i(e){a(e)||console.warn(`Edge ${e.data.id} not added as source/target not in graph`,e)}function c(e){let n=0;do{if(e=e.filter(e=>!a(e)),++n===t){console.warn(e.length+" edges not added to graph due to missing source/target node (giving up after "+t+" add-edges passes)",e);break}}while(e.length)}function a(e){if(u(e,"source")&&u(e,"target"))return function(e){const n=e.midpoint(),t=o.add({classes:"aux-node",position:m(n)&&n,data:{edgeId:e.id(),color:e.style("line-color")}}).lock();e.scratch("edgeConnections",{auxNodeId:t.id()}),s(e)}(o.add(e)),!0}function u(e,n){const t=e.data[n],r=o.getElementById(t.toString());return!r.empty()&&(r.isEdge()&&(e.data[n]=function(e){const n=g(e);if(!n)throw console.error('Edge has no "auxNodeId" info',e),Error(`edge ${e.id()} has no "auxNodeId" info`);return n}(r)),!0)}function s(e){e.parallelEdges().forEach(f)}function f(e){const n=l(e);if(n){const o=e.midpoint();m(o)&&n.unlock().position(o).lock()}}function l(e){if(!e||!e.isEdge())throw console.error("Invalid auxNode() argument (edge expected):",e),Error("invalid auxNode() argument");const n=g(e);if(!n)return;const t=o.getElementById(n);if(t.empty())throw console.error("Data inconsistency: aux node of edge",e,"not in graph, auxNodeId",n),Error(`data inconsistency: aux node of edge ${e.id()} not in graph`);return t}function g(e){const n=e.scratch("edgeConnections");return n&&n.auxNodeId}function p(e){return void 0!==y(e)}function y(e){if(!e||!e.isNode())throw console.error("Invalid edgeId() argument (node expected):",e),Error("invalid edgeId() argument");return e.data("edgeId")}function x(e){const n=y(e);if(!n)throw console.error("Invalid edge() argument (aux node expected):",e),Error("invalid edge() argument");const t=o.getElementById(n);if(!t.empty())return t}function m(e){return!(isNaN(e.x)||isNaN(e.y))}e.exports=r,"undefined"!=typeof cytoscape&&r(cytoscape)}])});
(function ($) {
  /**
      *	This script should be placed right after the body tag for fast execution 
      *	Note: the script is written in pure javascript and does not depend on thirdparty library
      **/
  'use strict';
  var classHolder = document.getElementsByTagName("BODY")[0];
  /** 
   * Load from localstorage
   **/
  var themeSettings = (localStorage.getItem('themeSettings')) ? JSON.parse(localStorage.getItem('themeSettings')) : {};
  var themeURL = themeSettings.themeURL || '';
  var themeOptions = themeSettings.themeOptions || '';
  /** 
   * Load theme options
   **/
  if (themeSettings.themeOptions) {
    classHolder.className = themeSettings.themeOptions;
    console.log("%c✔ Theme settings loaded", "color: #148f32");
  } else {
    console.log("Heads up! Theme settings is empty or does not exist, loading default settings...");
  }

  if (themeSettings.themeURL && !document.getElementById('mytheme')) {
    var cssfile = document.createElement('link');
    cssfile.id = 'mytheme';
    cssfile.rel = 'stylesheet';
    cssfile.href = themeURL;
    cssfile.type = 'text/css';
    document.getElementsByTagName('head')[0].appendChild(cssfile);

    cssfile = document.createElement('link');
    debugger;

    var wwwPath = $.urlParam('www') || '/www/';
    cssfile.id = myApp.settings.extendedThemeId;
    cssfile.rel = 'stylesheet';
    var href = wwwPath + Url.getBaseUrl(themeURL) + 'ext-' + Url.getFileName(themeURL);
    cssfile.href = href;
    cssfile.type = 'text/css';
    document.getElementsByTagName('head')[0].appendChild(cssfile);
  }

  /** 
   * Save to localstorage 
   **/
  window.saveSettings = function () {
    themeSettings.themeOptions = String(classHolder.className).split(/[^\w-]+/).filter(function (item) {
      return /^(nav|header|mod|display)-/i.test(item);
    }).join(' ');
    if (document.getElementById('mytheme')) {
      themeSettings.themeURL = document.getElementById('mytheme').getAttribute("href");
    };
    localStorage.setItem('themeSettings', JSON.stringify(themeSettings));
  };
  /** 
   * Reset settings
   **/
  var resetSettings = function () {
    localStorage.setItem("themeSettings", "");
  };
})(jQuery);


window.Lookups = {

	frequencyList: [
    "Daily",
    "Monthly",
    "Quarterly",
    "Yearly"
  ],

currenciesList: [
    "AED",
    "USD",
    "EUR",
    "GBP",
    "INR",
    "AUD",
    "CAD",
  ],

  // $scope.currenciesList = [
  //   "AED - United Arab Emirates Dirham",
  //   "USD - US Dollar",
  //   "EUR - Euro",
  //   "GBP - British Pound",
  //   "INR - Indian Rupee",
  //   "AUD - Australian Dollar",
  //   "CAD - Canadian Dollar",
  // ];

	durationUnits: [
    "Day",
    "Week",
    "Month",
    "Year"
  ],

  petTypes: ["Bird", "Cat", "Dog", "Fish", "Rabbit", "Turtle"]
};

(function() {
  initObj("Specto.ui.defaults.Modal");
  initObj("Specto.ui.defaults.ComboEdit");

  Specto.ui.defaults.Modal = {
    //... Specto.ui.defaults.Modal,
    theme: "classic",
    centerFlex: true,
    keyboard: true,
    sizeMode: "large",

  };
  Specto.ui.defaults.ComboEdit = {
    addIcon: "fal fa-plus-circle",
    eraserIcon: "fal fa-eraser",
    editIcon: "fal fa-edit",
    removeIcon: "fal fa-trash-alt"
  }

  function initObj(strFullName) {
    var childsTree = strFullName.split(".");
    if (childsTree.length > 0) {
      var parent = window;
      childsTree.forEach(c => {
        parent = initChild(parent, c);
      });
    }
  }

  function initChild(parentObj, childObj) {
    parentObj[childObj] = parentObj[childObj] || {};
    return parentObj[childObj];
  }

  myApp = {
    settings: {
      extendedThemeId: "mythemeExt"
    }
  };
})();


class Url {
  static getFileName(path) {
    return path ? path.split("/").pop() : "";
  }

  static getBaseUrl(path) {
    return path ? path.substring(0, path.lastIndexOf("/")) + "/" : "";
  }
}

//https://stackoverflow.com/questions/105034/create-guid-uuid-in-javascript?page=2&tab=Votes
class Guid {
  static generate() {
    var guid = "";
    for (var i = 0; i < 32; i++) {
      guid += Math.floor(Math.random() * 0xf).toString(0xf);
    }
    return guid;
  }
}

class Utils {
  static showShareModal(propertyObject) {
    let link = propertyObject.destination;

    const shareInfoDom = $('<div>');
    // $('<h4 class="font-weight-bold mb-1">Share this property...</h4>').appendTo(shareInfoDom);
    // $('<h5>Share this property with friends and family.</h5>').appendTo(shareInfoDom);
    // copy link
    const copyLink = $('<div class="d-flex">')
      .appendTo(shareInfoDom)
      .append($(`
        <div class="input-group">
          <input class="form-control mb-2" value="${link}" disabled="">
          <div id="copyIcon" class="input-group-append cursor-pointer mb-2">
            <span class="input-group-text">
              <i class="fa fa-clone text-secondary" style="font-size: 20px"></i>
            </span>
          </div>
        </div>`));
    copyLink.find('#copyIcon')
      .tooltip({ 'title': 'Copy' })
      .on('click', function () {
        var $temp = $("<input>");
        shareInfoDom.append($temp);
        var input = copyLink.find('input');
        $temp.val(input.val()).select();
        document.execCommand("copy");
        $temp.remove();
        $('.tooltip.show .tooltip-inner:contains("Copy")').text('Copied!');
      });
    const flexDiv = $('<div class="d-flex mb-1">').appendTo(shareInfoDom);
    const popupHeight = 800;
    const popupWidth = 800;
    const left = (screen.width / 2) - (popupWidth / 2);
    const top = (screen.height / 2) - (popupHeight / 2);
    // facebook link
    $(`<button class="btn btn-info w-50 mr-2" style="font-size: 14px; background-color: #446cc1; border-color: #446cc1; padding: 9px 6px;">
      <i class="fa fa-facebook"></i><span style="color: #2f53a7;"> | </span>Share on Facebook
    </button>`).appendTo(flexDiv)
      .on('click', function () {
        let host = window.location.origin;

        let facebookShareLinkProperty = host + '/social-card.html?image=' + host + propertyObject.image +
          '&title=' + encodeURIComponent(propertyObject.title) +
          '&description=' + encodeURIComponent(propertyObject.description) +
          '&destination=' + encodeURIComponent(link);

        debugger;
        FB.ui({
          method: 'share',
          href: facebookShareLinkProperty,
          hashtag: "#keyras"
        }, function (response) { });
      });
    // twitter link
    $(`<button class="btn btn-info w-50" style="font-size: 14px; background-color: #53bcec; border-color: #53bcec; padding: 9px 6px;">
      <i class="fa fa-twitter"></i><span style="color: #37a1d1;"> | </span>Share on Twitter
    </button>`).appendTo(flexDiv)
      .on('click', function () {
        window.open(`https://twitter.com/share?url=${link}`,'popup', 'width='+popupWidth+', height='+popupHeight+', top='+top+', left='+left);
      });
    // show modal
    Specto.ui.Modal.showModal(shareInfoDom, '<i class="fa fa-share-alt mr-2 text-secondary"></i>Share this property',
      [], { 'sizeMode': 'small', 'expandButton': false, 'theme': 'default', 'width': '395px' });
  }
  static setWishList(obj, itemId, account, dom, disableCount) {
    if (obj.length) {
      var iconId = obj.attr('_id')? obj.attr('_id').replace('_', ':'): null;
      var action = '';
      if (account) {
        if (obj.hasClass('active')) {
          if (itemId) {
            // Remove from DB
            WIRE.call('business::remove_favorite', { 'item_id': itemId });
          }
          // Update the UI
          obj.removeClass('active');
          if (!disableCount) {
            Utils.wishItemsCount--;
          }
          action = 'remove';
        } else {
          if (itemId) {
            // Save in DB
            WIRE.call('business::add_favorite', { 'item_id': itemId });
          }
          // Update the UI
          obj.addClass('active');
          if (!disableCount) {
            Utils.wishItemsCount++;
          }
          action = 'add';
        }
      } else {
        // View a popup to login or register
        WIRE.modal('Login or Register', u('AJS', ['login-register']));
      }
      if (iconId) {
        var dropdownItemId = iconId.replace(':', '_');
        dom.find('#wishlistContainer .badge').text(Utils.wishItemsCount);
        var dropdownMenu = dom.find('#wishlistContainer .dropdown-menu');
        // dropdownMenu.empty();

        var selectedItems = $(".wishlist-icon.active").parents(".property-container");
        if (selectedItems.length == 0) {
          $('<span class="dropdown-item" style="white-space: inherit;">')
            .text('0 items selected').addClass('dropdown-item-info-label').appendTo(dropdownMenu);
        } else {
          var dropdownItemInfoLabel = dropdownMenu.find('.dropdown-item-info-label');
          if (dropdownItemInfoLabel) {
            dropdownItemInfoLabel.remove();
          }
        }

        if (action == 'remove') {
          dropdownMenu.find('.dropdown-item#' + dropdownItemId).remove();
        }
        else if (action == 'add') {
          if (selectedItems.length > 0 && !dropdownMenu.find(`#${dropdownItemId}`).length) {
            selectedItems.each(function () {
              var selectedItemId = $(this).closest('.property-container').attr('_id');
              if (selectedItemId == iconId) {
                var btnDetails = $(this).find('.btn-details')[0];
                var btnWishlist = $(this).find('.fa-gratipay')[0];
                var selectedItem = WIRE.d(selectedItemId);
                var priceText = '';
                if (selectedItem['yearly_rent_value'] && selectedItem['yearly_rent_value']['value']) {
                  priceText = (selectedItem['yearly_rent_value']['value']['value'] ?
                    selectedItem['yearly_rent_value']['value']['value'] :
                    selectedItem['yearly_rent_value']['value']) + ' ' +
                    (selectedItem['yearly_rent_value']['currency'] || 'AED') + ' / year'
                }
                var dropdownItem = $('<button class="dropdown-item p-2" type="button"></button>')
                  .html(`<span class="delete-wishlist fal fa-trash-alt"></span>
            <div class="wishlist-flex pr-4">
              <img class="mr-2" src="${getMainPhoto(selectedItem)}">
              <div style="display: grid">
                <span class="f-sm wishlist-text">${selectedItem.name}</span>
                <span class="f-sm wishlist-text text-danger">${priceText}</span>
              </div>
            </div>`)
                  .attr('id', dropdownItemId)
                  .click(function () {
                    $('[data-toggle="tooltip"], .tooltip').tooltip("hide");
                    btnDetails.click();
                  })
                  .prependTo(dropdownMenu);
                dropdownItem.find('.delete-wishlist').click(function (e) {
                  e.stopPropagation();
                  btnWishlist.click();
                });
              }
            });
          }
        }
      }
    }
  }
  static promptInquiry(showContactInfo, itemId, residentialListingId) {
    var jq = $('<div>');
    const item = WIRE.d(itemId);
    const residentialListing = WIRE.d(residentialListingId);
    if (showContactInfo) {
      this.renderPropertyContactInfo(jq, residentialListing, item);
    }
    const account = WIRE.data['account'] ? WIRE.d(WIRE.data['account']) : null;
    // Add contact information field.
    var email = account ? account.email : '';
    var phone = account ? account.phone : '';
    var fields = [
      {
        't': 'email', 'n': 'email', 'd': 'E-mail', 'r': true, 'readonly': email ? true : false
      },
      { 't': 'phone', 'n': 'phone', 'd': 'Phone', 'r': true },
      { 't': 'longtext', 'n': 'message', 'd': 'Message', 'r': true }];
    var panelContent;
    if (showContactInfo) {
      var panel = $('<div class="panel mb-0">').appendTo(jq);
      $(`<div class="panel-hdr bg-primary my-0 cursor-pointer" style="min-height: unset;" data-toggle="collapse" data-target="#inquiryDom">
        <h2 style="height: 38px; color: white">
          <span class="icon-stack fs-xxl mr-2">
            <i class="fal fa-question-circle icon-stack-2x opacity-100"></i>
          </span>Inquiry
        </h2>
        <div class="panel-toolbar ml-auto">
          <div class="group-header-collapse-icon">
            <i class="fa fa-angle-double-up text-black faa-vertical animated-hover"></i>
          </div>
        </div>
      </div>`).tooltip({
        title: "Click to collapse"
      }).click(function () {
        $(this).tooltip('dispose')
        $(this).tooltip({
          title: `Click to ${$(this).hasClass('collapsed') ? 'collapse' : 'expand'}`
        });
        if ($(this).find('.fa').hasClass('fa-angle-double-up')) {
          $(this).find('.fa').removeClass('fa-angle-double-up');
          $(this).find('.fa').addClass('fa-angle-double-down');
        }
        else {
          $(this).find('.fa').removeClass('fa-angle-double-down');
          $(this).find('.fa').addClass('fa-angle-double-up');
        }
      }).appendTo(panel);
      var panelContainer = $(`<div id="inquiryDom" class="panel-container collapse show">`).appendTo(panel);
      panelContent = $('<div class="panel-content py-1 px-2">').appendTo(panelContainer);
    }
    var editableObject = u('EditableObject', ['inquiry', { 'fields': fields }, { email: email, phone: phone }]);
    WIRE.unrollRecursive(editableObject, showContactInfo ? panelContent : jq);

    var modal = Specto.ui.Modal.showModal(jq, 'Contact', [
      {
        label: 'Send', color: 'btn-primary', 'onClick': function () {
          var inquiry = WIRE.getEditableValues('inquiry');
          inquiry['item'] = itemId;
          inquiry['listing'] = residentialListingId;
          WIRE.call('public::send_inquiry', inquiry, function (response) {
            if (response['_closeObjectModal']) {
              modal.close();
            }
          });
        }
      }
    ]);
  }
  static renderPropertyContactInfo(container, residentialListing, item) {
    var panel = $('<div class="panel mb-3">').appendTo(container);
    $(`<div class="panel-hdr bg-primary my-0" style="min-height: unset;" data-toggle="collapse" data-target="#contactinfoDom">
      <h2 style="height: 38px; color: white">
        <span class="icon-stack fs-xxl mr-2">
          <i class="fal fa-user icon-stack-2x opacity-100"></i>
        </span>Leaser Contact Information
      </h2>
      <div class="panel-toolbar ml-auto">
        <div class="group-header-collapse-icon">
          <i class="fa fa-angle-double-up text-black faa-vertical animated-hover"></i>
        </div>
      </div>
    </div>`).tooltip({
      title: "Click to collapse"
    }).click(function () {
      $(this).tooltip('dispose')
      $(this).tooltip({
        title: `Click to ${$(this).hasClass('collapsed') ? 'collapse' : 'expand'}`
      });
      if ($(this).find('.fa').hasClass('fa-angle-double-up')) {
        $(this).find('.fa').removeClass('fa-angle-double-up');
        $(this).find('.fa').addClass('fa-angle-double-down');
      }
      else {
        $(this).find('.fa').removeClass('fa-angle-double-down');
        $(this).find('.fa').addClass('fa-angle-double-up');
      }
    }).appendTo(panel);
    var panelContainer = $(`<div id="contactinfoDom" class="panel-container collapse show">`).appendTo(panel);
    var panelContent = $('<div class="panel-content py-1 px-2">').appendTo(panelContainer);
    var contactPhoto = residentialListing['contact_photo'] || residentialListing['listing_logo'] || '/www/icons/person.svg';

    $(`<div id="c_1" class="card border shadow-0 shadow-sm-hover mt-1 mb-1" data-filter-tags="oliver kopyov">
        <div class="card-body border-faded border-top-0 border-left-0 border-right-0 rounded-top py-2">
            <div class="d-flex flex-row align-items-center">
                <span class="mr-3">
                    <span class="rounded-circle profile-image d-block " style="background-image: url('${contactPhoto}');background-size: contain;
                    background-repeat: no-repeat;background-position: center;"></span>
                </span>
                <div class="info-card-text flex-1">
                    <a class="fs-xl text-truncate text-truncate-lg text-primary">${residentialListing["contact_name"]}</a>
                    <span class="text-truncate text-truncate-xl">${residentialListing['name']}</span>
                </div>  
            </div>
        </div>
        <div class="card-body p-0 collapse show" >
            <div class="contact-container px-3 py-1">         
            </div>
        </div>
    </div>`).appendTo(panelContent);
    var contactContainer = panelContent.find('.contact-container');

    var contactPhoneNumber = residentialListing["contact_phone_number"];
    var contactEmail = residentialListing["contact_email"];
    var contactAddress = residentialListing["contact_address"];
    var contactWhatsappNumber = residentialListing["contact_whatsapp_number"];
    var proItemNumber = item['property_number'];
    var proItemName = item['name'];
    if (contactPhoneNumber) {
      $(`<a href="tel:${contactPhoneNumber}" class="mt-1 d-block fs-lg fw-400 text-dark">
      <i class="fa fa-mobile text-muted mr-2"></i>${contactPhoneNumber}</a>`)
        .appendTo(contactContainer);
    }
    if (contactWhatsappNumber) {
      $(`<a href="https://wa.me/${contactWhatsappNumber.replaceAll('+', '').replaceAll('-', '')}" target="_blank" class="mt-1 d-block fs-lg fw-400 text-dark" style="text-decoration: none !important;">
      <i class="fa fa-whatsapp text-muted mr-2"></i>${contactWhatsappNumber}</a>`)
        .appendTo(contactContainer);
    }
    if (contactEmail) {
      $(`<a href="mailto:${contactEmail}" class="mt-1 d-block fs-lg fw-400 text-dark" target=_blank>
      <i class="fa fa-envelope text-muted mr-2"></i>${contactEmail}</a>`)
        .appendTo(contactContainer);
    }
    if (contactAddress) {
      $(`<address class="fs-lg fw-400 mt-2 mb-0 text-muted">
      <i class="fa fa-map-pin mr-2"></i>${contactAddress.address}</address> <a target=_blank href="https://maps.google.com?q=${encodeURIComponent(contactAddress.address)}">[Google Maps]</a>`)
        .appendTo(contactContainer);
    }

    if(proItemName) {
      $(`<a class="mt-1 d-block fs-lg fw-400 text-dark">
      <i class="fa fa-building-o text-muted mr-2"></i>${proItemName}</a>`)
        .appendTo(contactContainer);
    }

    if(proItemNumber) {
      $(`<a class="mt-1 d-block fs-lg fw-400 text-dark">
      <i class="fa fa-building-o text-muted mr-2"></i>${proItemNumber}</a>`)
        .appendTo(contactContainer);
    }
  }
  static fetchRentals(jq, data, callback) {
    if (data && data['refs']) {
      WIRE.lister.get(`interaction:ref:${data['refs']['list']}`, callback, null, { rawResponse: true });
    } else {
      WIRE.lister.getRentalListings(callback, jq);
    }
  }
  static fixItemDurationAndRentPayments(residentialListing, itemToFix) {
    const listingItem = residentialListing && residentialListing['items'].hasOwnProperty(`!obj!${itemToFix['_id']}`)
    ? residentialListing['items'][`!obj!${itemToFix['_id']}`] : {};
    
    itemToFix['rent_payments'] = (listingItem && listingItem['rent_payments']) ?
      listingItem['rent_payments'] : [];

    if (listingItem && listingItem['duration']) {
      itemToFix['duration'] = listingItem['duration'];
    } else if (residentialListing['duration']) {
      itemToFix['duration'] = residentialListing['duration'];
    }
  }
  static getItemPriceList(item) {
    var priceList = [];
    var yearlyValue = (item['yearly_rent_value'] && item['yearly_rent_value']['value']) ?
      item['yearly_rent_value']['value'] : 0;
    var currency = (item['yearly_rent_value'] && item['yearly_rent_value']['currency']) ?
      item['yearly_rent_value']['currency'] : 'AED';

    (item['rent_payments'] || []).forEach(payment => {
      var amount = yearlyValue;
      if (payment['amount_type'] == 'specified_amount') {
        amount = payment['more_than_annual'];
      } else if (payment['amount_type'] == 'fixed_more' && amount) {
        amount += payment['more_than_annual'];
      } else if (payment['amount_type'] == 'percent_more' && amount) {
        amount *= 1 + (payment['more_than_annual'] / 100.0);
      }

      var frequency = payment['frequency'];
      // if frequency value is "yearly" then its index = 1 
      var frequencyIndex = 1;
      switch (frequency.toLowerCase()) {
        case 'quarter':
          amount = payment['amount_type'] != 'specified_amount' ? Math.round(amount / 4) : amount;
          frequencyIndex = 2;
          break;
        case 'month':
          amount = payment['amount_type'] != 'specified_amount' ? Math.round(amount / 12) : amount;
          frequencyIndex = 3;
          break;
        case 'day':
          amount = payment['amount_type'] != 'specified_amount' ? Math.round(amount / 365) : amount;
          frequencyIndex = 4;
          break;
      }

      if (amount) {
        priceList.push({
          'amount': amount, 'currency': currency.toUpperCase(),
          'frequency': frequency, 'frequencyIndex': frequencyIndex
        });
      }
    });

    // check if the price list has the yearly payment, 
    // and if hasn't, add it if the item has a yerly value
    if (yearlyValue && (!priceList.length || !priceList.find(p => p.frequencyIndex == 1))) {
      priceList.push({
        'amount': yearlyValue, 'currency': currency.toUpperCase(),
        'frequency': 'Year', 'frequencyIndex': 1
      });
    }
    // Sort the price list by 'frequencyIndex'=>(Year/Quarter/Month/Day) 
    priceList.sort((a, b) => (a.frequencyIndex > b.frequencyIndex) ? 1 : -1);
    return priceList;
  }
  static showWorkOrderNavigatingToTab(workOrderId, workOrderDescription) {
    if (!workOrderId) {
      WIRE.errorMessageModal('Work order not created: ' + (workOrderDescription || ''));
      return;
    }
    if (workOrderId.startsWith('!obj!')) {
      workOrderId = workOrderId.substr(5);
    }
    
    window.location.href = '/#Landlord/WorkOrders:Assignedtome/All?o=' + workOrderId;
  }
  static showContractNavigatingToTab(contractId) {
    if (contractId.startsWith('!obj!')) {
      contractId = contractId.substr(5);
    }
    // Which user type am I?
    var selectedWalletType = window.location.href.split('#')[1].split('/')[0];
    // Navigate to contract, keeping user type.
    window.location.href = '/#' + selectedWalletType + '/ActiveLeaseContracts/All?o=' + contractId;
  }
}


Utils.wishItemsCount = 0;
Utils.isMobile = /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|ipad|iris|kindle|Android|Silk|lge |maemo|midp|mmp|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows (ce|phone)|xda|xiino/i.test(navigator.userAgent)
|| /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(navigator.userAgent.substr(0, 4));


class MapUtils {
  //#region render map places (Reference: https://jsfiddle.net/geocodezip/1szec6pj/1/)
  static initializeItemMap(container) {
    if (!container) {
      return;
    }
    var coords = $(container).text().split(",");
    if (coords.length != 2) {
      $(this).display = "none";
      return;
    }
    var latlng = new google.maps.LatLng(parseFloat(coords[0]), parseFloat(coords[1]));
    var myOptions = {
      zoom: 13,
      center: latlng,
      mapTypeId: google.maps.MapTypeId.ROADMAP,
      mapTypeControl: true,
      zoomControl: true,
    };
    this.propertyMap = new google.maps.Map(container, myOptions);
    for (const [key, value] of Object.entries(this.typeIconDic)) {
      this.findPlaces(latlng, key);
    }
    for (const [key, value] of Object.entries(this.typeIconDic)) {
      this.toggleMarkers(key, this.showIcons[key], this.iconsMarkers[key]);
    }

    // Place marker after. Added last to show on top.
    var CustomMarker = this.createCustomMarker();
    new CustomMarker(latlng, this.propertyMap, 'Apartment', '', '', '');
    // new google.maps.Marker({
    //   position: latlng,
    //   map: propertyMap
    // });
  }
  static findPlaces(latLng, type) {
    var request = {
      types: [type],
      location: latLng,
      radius: 1500
    };
    var places = new google.maps.places.PlacesService(this.propertyMap);
    var me = this;
    places.nearbySearch(request, function (results, status) {
      if (status !== 'OK') return;
      if (results && results.length > 0)
        me.createMarkers(results, type);
    });
  }
  static toggleMarkers(type, toggle, array) {
    var btn = $(`<h3 class="mr-2" data-toggle="tooltip" data-placement="right" title="${this.typeDic[type]}">
      <span class="badge badge-secondary" style="min-width: 33px;"><i class="${this.typeIconDic[type]}"></i></span>
      </h3>`).appendTo($('#toggleMarkersDiv')).tooltip();
    var me = this;
    btn.click(function () {
      if (toggle) {
        array.forEach(element => {
          element.setMap(null);
        });
        array = [];
        btn.find('span').removeClass('badge-primary');
        btn.find('span').addClass('badge-secondary');
        toggle = false;
      }
      else {
        me.allNearbyMarkers.forEach(element => {
          if (element.type == type)
            array.push(new google.maps.Marker(element));
        });
        btn.find('span').removeClass('badge-secondary');
        btn.find('span').addClass('badge-primary');
        toggle = true;
      }
    });
  }
  static createMarkers(places, type) {
    var placesList = $('#itemDetails').find('#nearbyPlacesContainer');
    var displayType = (type.charAt(0).toUpperCase() + type.slice(1))
      .replace('_', ' ') + 's';
    var currentType = $(`<div class="col-lg-6">
      <div class="col-lg-12">
        <div style="cursor:pointer">
          <div class="card-header collapsed" data-toggle="collapse" 
            data-target="#${type}" aria-expanded="true" 
              style="background-color: #ffffff !important;">
              <!-- style="background-color: #ffffff !important;"-->
              <span class="${this.typeIconDic[type]} text-primary "></span>
            <a class="card-link">
              ${displayType}
            </a>
            <i class="collapseIcon fa text-primary float-right mt-1"
              style="font-size: 21px;"></i>
          </div>
          <div id="${type}" class="collapse" data-parent="#nearbyPlacesContainer">
            <div class="card-body" style="height: 130px; overflow: auto; 
              margin-bottom: 3px; background: white;">
            </div>
          </div>
        </div>
      </div>
      </div>`)
      .appendTo(placesList);
    var placesUl = $('<ul style="list-style: circle;">');
    for (var i = 0, place; place = places[i]; i++) {
      var image = {
        url: place.icon,
        size: new google.maps.Size(71, 71),
        origin: new google.maps.Point(0, 0),
        anchor: new google.maps.Point(17, 34),
        scaledSize: new google.maps.Size(25, 25)
      };
      var markerOptions = {
        map: this.propertyMap,
        icon: image,
        title: place.name,
        position: place.geometry.location,
        type: type,
      };
      this.allNearbyMarkers.push(markerOptions);
      $('<li>').css('font-size', '15px')
        .text(place.name)
        .appendTo(placesUl);
    }
    $(currentType.find(`#${type} .card-body`)).append(placesUl);
  }
  static createCustomMarker() {
    function CustomMarker(latlng, map, unitType, unitName, unitAddress, unitImagePath, unitId) {
      this.latlng_ = latlng;
      this.map_ = map;
      this.unitType_ = unitType;
      this.unitName_ = unitName;
      this.unitAddress_ = unitAddress;
      this.unitImagePath_ = unitImagePath;
      this.unitId_ = unitId;
      this.setMap(map);
    }

    CustomMarker.prototype = new google.maps.OverlayView();

    CustomMarker.prototype.draw = function () {
      var self = this;
      var marker = this.marker;
      if (!marker) {
        var randomId = Guid.generate();
        var markerId = "marker" + randomId;

        marker = this.marker = $('<div>')
          .addClass('marker unauth-map-marker has-popover')
          .attr({ "id": markerId, "data-toggle": "popover" });

        var iconsContainer = $('<div>')
          .addClass('icon-stack normalized-icon-stack w-100')
          .css('font-size', '51px');
        marker.append(iconsContainer);

        var icon1 = $('<i>')
          .addClass('fal fa-map-marker icon-stack-3x opacity-100')
          .css('color', '#b56086');
        iconsContainer.append(icon1);

        var icon2 = $('<i>')
          .addClass('base base-7 icon-stack-2x opacity-100')
          .css({ 'font-size': '26px'/*, 'margin-bottom': '7px'*/, 'color': '#b56086', 'top': '5px' });
        iconsContainer.append(icon2);

        var icon3 = $('<i>')
          .addClass('opacity-100 color-white')
          .css({ 'font-size': '18px'/*, 'margin-bottom': '7px'*/, 'top': '10px' });
        iconsContainer.append(icon3);

        marker.append(`<div class='pulse-marker'></div>`);

        switch (self.unitType_) {
          case "Building":
            icon3.addClass('fal fa-building icon-stack-1x');
            break;
          case "Apartment":
          case "Town House":
          case "Villa":
            icon3.addClass('fal fa-home icon-stack-1x');
            break;
        }

        // Add the element to the "overlayLayer" pane.
        var panes = this.getPanes();
        panes.overlayImage.append(marker[0]);

        var popoverHTMLContent = `<div class="unauth-popover-content">
           <div class="unauth-popover-img-container">
               <a>
                   <img class="unauth-popover-img">
               </a>
           </div>
           <div class="unauth-title-address-container">
               <a class="unauth-popover-property-title-link">
                   <h2 class="unauth-popover-property-title"></h2>
               </a>
               <div class="unauth-property-address">
                    <i class="fa fa-map-marker unauth-map-marker-icon fnt17-red"></i>
                    <span class="unauth-property-address-tetx">Abu Dhabi - United Arab Emirates</span>
               </div>
           </div>
       </div>`;
        if (self.unitName_) {
          $(this.marker).popover({
            trigger: 'click',
            delay: {
              show: 300,
              hide: 200
            },
            placement: 'top',
            content: popoverHTMLContent,
            html: true,
          })
            .hover(function () {
              $(".property-address").each(function () {
                if ($(this).text().trim() == self.unitAddress_.trim()) {
                  $(this).parents('.property-container')
                    .css("box-shadow", "rgb(164 164 164) 0px 0px 3px");

                }
              });
            })
            // .mouseenter(function () {
            //   var hash = "#" + self.unitName_.trimAll();
            //   dom.find('#listDiv').animate({
            //     scrollTop: $(hash).offset() ? $(hash).offset().top : 0
            //   }, 200);
            // })
            .mouseover(function () {
              $(".property-address").each(function () {
                if ($(this).text().trim() == self.unitAddress_.trim()) {
                  $(this).parents('.property-container')
                    .css("box-shadow", "#886ab5 0px 0px 5px 2px");

                }
              });
            })
          // This event is applied before showing popover
          $(this.marker).on('show.bs.popover', function (event) {
            $('[data-toggle=popover]').not(this).popover('hide');
          });

          // This event is applied after showing popover
          $(this.marker).on('shown.bs.popover', function (event) {
            $('.unauth-popover-img').attr('src', self.unitImagePath_);
            $('.unauth-popover-property-title').text(self.unitName_)
              .on('click', function () {
                if (Utils.isMobile) {
                  const itemUiId = self.unitId_.replace('?o=', '')
                  $(`.property-container[id="${itemUiId}"]`).trigger('click');
                } else {
                  $('.unauth-popover-property-title-link').attr({
                    'href': `/#User/RentProperty/Details${self.unitId_}`,
                    'target': '_blank'
                  });
                }
              });
            $('.unauth-property-address-tetx').text(self.unitAddress_);
            $('.popover').addClass("unauth-popover");
          });
        }
      }

      var point = this.getProjection().fromLatLngToDivPixel(this.latlng_);
      if (point) {
        // (27.5, 55) ==> these values represent marker div (half width, height) sequentially
        marker.css({ 'left': (point.x - 27.5) + 'px', 'top': (point.y - 55) + 'px' });
        marker.attr('item-title', self.unitName_);
      };
      marker.show();
    };

    CustomMarker.prototype.remove = function () {
      if (this.marker) {
        this.marker.parentNode ? this.marker.parentNode.removeChild(this.marker) : null;
        this.marker.hide();
      };
    };

    CustomMarker.prototype.getPosition = function () {
      return this.latlng_;
    };

    return CustomMarker;
  }
  //#endregion render map places
}
MapUtils.propertyMap = null;
MapUtils.allNearbyMarkers = [];
MapUtils.typeIconDic = {
  'mosque': 'kr-ico-islam',
  'restaurant': 'fal fa-utensils',
  'hospital': 'kr-ico-hospital',
  'school': 'kr-ico-school',
  // 'park': 'fal fa-tree',
  'cafe': 'kr-ico-cafe',
  'pharmacy': 'kr-ico-pharmacy',
  'shopping_mall': 'kr-ico-mall',
  // 'zoo': 'fal fa-paw',
};
MapUtils.typeDic = {
  'mosque': 'Mosques',
  'restaurant': 'Restaurants',
  'hospital': 'Hospitals',
  'school': 'Schools',
  'park': 'Parks',
  'cafe': 'Cafes',
  'pharmacy': 'Pharmacies',
  'shopping_mall': 'Malls',
  'zoo': 'Zoo',
};
MapUtils.showIcons = {
  'mosque': false,
  'restaurant': false,
  'hospital': false,
  'school': false,
  'park': false,
  'cafe': false,
  'pharmacy': false,
  'shopping_mall': false,
  'zoo': false,
};
MapUtils.iconsMarkers = {
  'mosque': [],
  'restaurant': [],
  'hospital': [],
  'school': [],
  'park': [],
  'cafe': [],
  'pharmacy': [],
  'shopping_mall': [],
  'zoo': [],
};



// Extension methods
// ************ String extension methods **********//
String.prototype.format = function () {
  var a = this;
  for (var k in arguments) {
    a = a.replace(new RegExp("\\{" + k + "\\}", "g"), arguments[k]);
  }
  return a;
};

String.prototype.trimAll = function () {
  return this.replace(/\s/g, "");
};

String.prototype.equals = function (text, exactEqual) {
  if (
      (this == undefined && text == undefined) ||
      (this == null && text == null) ||
      (this == "" && text == "")
  ) {
    return true;
  }
  if (!this || !text) {
    return false;
  }
  return exactEqual ? text == this : text.toLowerCase() == this.toLowerCase();
};

// ******* End of String extension methods ****** //

// Array extension methods
Array.prototype.groupBy = function (key) {
  var xs = this;
  var ks = key.split(".");
  return xs.reduce(function (rv, x) {
    var v = x;
    ks.forEach(k => {
      v = v[k];
    });
    (rv[v] = rv[v] || []).push(x);
    return rv;
  }, {});
};

Array.prototype.delete = function (element) {
  var removed = this.indexOf(element);
  this.splice(removed, 1);
  return removed;
};

Array.prototype.intersect = function (set2, propertyName) {
  return propertyName ?
      this.filter(e => set2.some(e2 => e[propertyName] == e2[propertyName]))
      : this.filter(e => set2.includes(e));
}

Array.prototype.difference = function (set2, propertyName) {
  return propertyName ?
      this.filter(e => !set2.some(e2 => e[propertyName] == e2[propertyName]))
      : this.filter(e => !set2.includes(e));
}

Array.prototype.remove = function (element, propertyName) {
  var index = -1;
  if (propertyName) {
    var targetElement = this.find(e => e[propertyName] == element[propertyName]);
    if (targetElement) {
      index = this.indexOf(targetElement);
    }
  }
  else {
    index = this.indexOf(element);
  }

  if (index > -1) {
    this.splice(index, 1);
  }

  return this;
}

/**
 * Remove all elements in the array
 * @return returns the array itself after removing the elements
 */
Array.prototype.clear = function () {
  this.splice(0, this.length);
  return this;
}

/**
 * Clones all array elements to another new one
 * @return {Array} return a new cloned array
 */
Array.prototype.clone = function () {
  return clone(this);
}

/**
 * Sorts an array of (key, value) pair object elements.
 *
 * @param {String} propertyName: property name of the object element
 * @param {Boolean} desc: determines whether the sort is descending
 * @return {Array}
 */
Array.prototype.sortBy = function (propertyName, desc) {
  return this.sort((a, b) => desc ? -1 : 1 * (a[propertyName] - b[propertyName]));
}
// Set extension methods
Set.prototype.map = function (func) {
  var mappedSet = new Set();
  var index = 0;
  var values = this.values();
  for (var value of values) {
    mappedSet.add(func(value, index++));
  }
  return mappedSet;
};

Set.prototype.mapToArray = function (func) {
  var mappedArr = [];
  var index = 0;
  var values = this.values();
  for (var value of values) {
    mappedArr.push(func(value, index++));
  }
  return mappedArr;
};

Set.prototype.intersect = function (set2, propertyName) {
  return new Set(Array.from(this).intersect(Array.from(set2)));
}

// Object extension methods
/**
 * Remove all undefined, null or empty property(key) such as {} or [] from object
 * @return the object itself after removing the empty properties(keys)
 */
Object.defineProperty(Object.prototype, 'omitEmptyKeys', {
  value: function () {
    if (!this)
      return this;
    Object.keys(this).forEach(k => {
      if (this[k] instanceof Object)
        this[k].omitEmptyKeys();

      if (this[k] === undefined || this[k] == null ||
          (this[k] instanceof Array && !this[k].length) ||
          (this[k] instanceof Set && !this[k].size)) {
        delete this[k];
      }
      else if (this[k] instanceof Object && this[k].hasNoKeys()) {
        delete this[k];
      }
    });
    return this;
  }
});

/**
 * Checks whether the object(dict) has no defined properties (empty value)
 * @return true if the object(dict) has no defined properties, flase otherwise.
 */
Object.defineProperty(Object.prototype, 'hasNoKeys', {
  value: function () {
    return !Object.keys(this).length;
  }
});

function isEmpty(obj) {
  for (var key in obj) {
    if (obj.hasOwnProperty(key))
      return false;
  }
  return true;
}

function removeEmpty(obj) {
  for (var key in obj) {
    if (obj.hasOwnProperty(key)) {
      if (obj[key] == undefined || obj[key] == null || obj[key] === "" || !obj[key].toString().trim())
        delete obj[key];

      if (obj[key] instanceof Array && !obj[key].length) {
        delete obj[key];
      }
      if (obj[key] instanceof Object) {
        removeEmpty(obj[key]);
      }
    }
  }
  return obj;
}


function mapObj(obj, func) {
  var mappedObj = {};
  var index = 0;
  for (var key in obj) {
    mappedObj[key] = func(key, obj[key], index++);
  }
  return mappedObj;
}

function wildCardFilter(str, filterBy) {
  var filterRule = (filterBy ? filterBy.toLowerCase() : filterBy);
  str = str ? str.toLowerCase() : str;
  return str.indexOf(filterRule) !== -1;
  //return new RegExp('^' + filterRule.replace(/\*/g, '.*') + '$').test(str);
}

function clone(obj) {
  return JSON.parse(JSON.stringify(obj));
}

String.prototype.titleCase = function () {
  return this.charAt(0).toUpperCase() + this.slice(1);
};

String.prototype.capitalizeEachWord = function () {
  var words = this.split(" ");
  for (var i = 0; i < words.length; i++) {
    words[i] = words[i][0].toUpperCase() + words[i].substr(1);
  }
  return words.join(" ");
};

/**
 * @param {Number} intDate Integer like YYYYMMDD
 * @returns {String} string "YYYY-MM-DD"
 */
function dateIntToStr(intDate, isInverse) {
  if (!intDate) {
    return '';
  }
  var full;
  if(intDate.toString().length == 8){ // integer of 8 digits like 20201229
    var day = intDate % 100;
    intDate = Math.floor(intDate / 100);
    var month = intDate % 100;
    intDate = Math.floor(intDate / 100);
    var year = intDate;
    full = isInverse ? [month, day, year].join('/') :
        [year, month, day].join('-');
  }else{ // sometime the intDate is an integer of timestamp which consists of 10 digits
    date = new Date(intDate* 1000)
    full = isInverse ? [date.getDate(), (date.getMonth() + 1), date.getFullYear()].join('/'):
        [date.getFullYear(), (date.getMonth() + 1), date.getDate()].join('-')
  }
  return full;
}

/**
 * @param {Number} intDate Integer like YYYYMMDD
 * or like YYYYMM, in this case the last day of mentioned month will be added to the 'intDate'
 */
function dateIntToTimestamp(intDate) {
  if (intDate.toString().length == 6) {
    // substr => Extracts the characters from a string, 
    // beginning at a specified start position, and through the specified number of character
    var year = intDate.toString().substr(0, 4);
    var month = intDate.toString().substr(4, 2);
    var daysCount = new Date(year, month, 0).getDate();
    intDate = intDate.toString() + '01';
  }
  var date = dateIntToStr(intDate);
  date = date.split("-");
  var newDate = new Date(date[0], date[1] - 1, date[2]);
  return newDate.getTime();
}

/**
 * @param {Number} intDateRange Integer like YYYYMMDDYYYMMDD
 * @returns {Object} object: {full: "YYYY/MM/DD - YYYY/MM/DD", start: "MM/DD/YYYY", end: "MM/DD/YYYY"
 */
function dateRangeIntToStr(intDateRange) {
  if (!intDateRange) {
    return '';
  }
  var stringDateRange = intDateRange.toString();
  var fullDateString = {};
  var startDate = stringDateRange.slice(0, 8);
  var endDate = stringDateRange.slice(8, 16);
  fullDateString['full'] = `${dateIntToStr(startDate).replace('-', '/')} - ${dateIntToStr(endDate).replace('-', '/')}`;
  fullDateString['start'] = dateIntToStr(startDate, true);
  fullDateString['end'] = dateIntToStr(endDate, true);
  return fullDateString;
}

/**
 * 
 * @param {*} date (new Date())
 * get date in this format Thursday, 6 May, 2021 
 */
 function getCustomStringDate(date) {
  var months = ["January", "February", "March", "April", "May", "June",
    "July", "August", "September", "October", "November", "December"];

  var weekdays = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];

  var day = weekdays[date.getDay()];
  var month = months[date.getMonth()];

  var targetFormat = day + ', ' + date.getDate() + ' ' + month + ', ' + date.getFullYear();
  return targetFormat;
}

function promptAddThenReload(multiObject, modalTitle, obj_schema_name, obj_type, interaction_ref) {
  var reRender = function (serverResponse) {
    multiObject.groupListVars.reRender(false, function () {
      try {
        //Select the newly returned object from the server
        //Note: What I basically do here is click the last card (the one before the + card)
        //This card will be the newest item because the cards are being sorted in renderCardView of group_list.js
        //A more complex solution can be implemented if required, where can select the card that have the ID of the serverResponse above
        let contentsDom = document.getElementsByClassName("contents-dom")[0];
        contentsDom.children[contentsDom.children.length - 2].children[1].click();
      } catch (err) {
        console.log("Couldn't select last element %s", err);
      }
    });
  };

  WIRE.modal(modalTitle, u("AJS", ["common/save_object", {"schema": obj_schema_name, "obj_type": obj_type, "fn": "interactions::save_node", "fn_args": {"ref": interaction_ref}, "disableRefresh":true, "callback": reRender}]));
}
(function () {
  this.Specto = this.Specto || {};
  this.Specto.ui = this.Specto.ui || {};
  this.Specto.ui.Modal = this.Specto.ui.Modal || {};
  this.Specto.ui.Modal.openModals = this.Specto.ui.Modal.openModals || [];
  Specto.ui.defaults = Specto.ui.defaults || {};

  var ns = this.Specto.ui.Modal;

  const SizeModeEnum = Object.freeze({
    AUTO: "auto",
    CUSTOM: "custom",
    LARGE: "large",
    X_LARGE: "xLarge",
    FULL: "full"
  });

  const ShowModeEnum = Object.freeze({
    NORMAL: "normal",
    BLOCKED: "blocked",
    BACKDROP: "backdrop"
  });

  // This is the general modal settings, that can be overrided
  Specto.ui.Modal.defaults = $.extend({},
    {
      rtl: false,
      theme: "default", //"default(default)/classic/colorfull",
      centerFlex: false, // Center modal using flex. Note: If you are using bootstrap v4, set this flag to true.
      localizer: { // This the default value of localizer, you can override this object
        OK: "OK",
        CANCEL: "Cancel",
        YES: "Yes",
        NO: "No",
        CONFIRMATION: "Confirmation",
        ERROR: "Error",
        WARNING: "Warning",
        INFORMATION: "Information"
      },
      sizeMode: SizeModeEnum.AUTO,
      showMode: ShowModeEnum.BLOCKED,
    }, Specto.ui.defaults.Modal);

  /*
      options: {
          id:..,
          class:..,
          keyboard: true/false(default), => Closes the modal when escape key is pressed
          closeButton: true(default)/false,
          closeButtonIcon:.., => icon class name. By default, icon is rendered based on selected theme
          expandButton: true(default)/false,
          expandButtonIcon:.., => icon class name, By default, icon is rendered based on selected theme
          compressButtonIcon:.., => icon class name, By default, icon is rendered based on selected theme
          center: true(default)/false, 
          scrollable: true(defualt)/false,
          resizable: true/false(defualt),
          movable: true/false(default),
          sizeMode: "auto(defualt)/custom/large/xLarge/full",
          showMode: "normal/blocked(defualt)/backdrop", backdrop: Closes the modal when press on anywhere outside the modal
          width:.., width value, it is applied when sizeMode is custom
          height:.., height value, it is applied when sizeMode is custom
          onOpening:.., 
          onOpened:.., 
          onBeforeClose:..,
          onClosing:.., 
          onClosed:.., 
          onCloseButtonClick:..,
          onFullscreen:..,
          //onResize:.., TODO_N: Implement this function
          rtl: true/false(defualt), You can set rtl to a specific modal OR set rtl for all modals in Specto.ui.Modal.defaults.rtl
          buttons: [
              { 
                  label:.., 
                  onClick:.., 
                  id:.., 
                  color: "btn-default/btn-primary/btn-success/btn-info/btn-warning/btn-danger", 
                  size: "btn-default/btn-lg/btn-sm/btn-xs",
                  shape: "rectange(default)/square",
                  icon: "fa fa-search/fa fa-check/fa fa-save/fa fa-print" http://fontawesome.io/icons/
                          OR
                  icon: "glyphicon glyphicon-ok/glyphicon glyphicon-remove" http://getbootstrap.com/components/#glyphicons,
                  attr: {},
                  tooltip: ""
              }
          ]
  */

  //TODO:
  /*
      -- Rename some options. //Done
      -- Implement rtl. //Done
      -- Make the modal movable. //Done
      - When enable movable option, we should set this modal in block mode.
      - Customize the modal options like : colors...
      - Add "btn-primary" by default for showModal buttons, when the theme is classic.
      - Create custom scroll.
      - Make all sides resizable.
      - Implement onResize callback.
      - Support all bootstrap versions.
      - Create custom icon, like iconmoon. Remove font-awesome and glyphicon icons. 
      - Remove getIconClassesByTheme object from Modal.js and use the generated fonts directly on css.
      - Fix bug: We should register $(window).resize once not inside the modal.shown event. Or unbind the event when close the modal.
      - When click enter, inside a modal, fire active btn click. //Done
  */

  const ThemeEnum = Object.freeze({
    DEFAULT: "default",
    CLASSIC: "classic",
    COLORFULL: "colorfull"
  });

  var defaults = {
    keyboard: false,
    //backdrop: false,
    closeButton: true,
    expandButton: true,
    center: true,
    scrollable: true,
    resizable: false,
    movable: false,
    //fullscreen: false, // Force to open modal in fullscreen mode
    buttons: [],
  };

  window.lightModals = [];
  window.options = {};

  //#region ___________________________ Private Methods ___________________________
  var subtractObjIdFromHash = function () {
    if (!window.location.href.toLowerCase().contains('details?o=item:')) {
      // subtract object id from currentHash (if exist)
      var currentHash = window.location.hash;
      var objStartsWith = '?o=';
      var account = WIRE.data['account'] ? WIRE.d(WIRE.data['account']) : null;
      if (!account && currentHash.contains('?o=offer')) {
        objStartsWith = 'User/RentProperty'
      }
      var lastIndex = currentHash.lastIndexOf(objStartsWith);
      if (lastIndex > 0 && $('.default-modal').length == 1) {
        window.history.pushState("", "", currentHash.substr(0, lastIndex));
        //window.location.hash = currentHash.substr(0, lastIndex);
      }
    }
  };
  var closeOnOutsideClick = function (e) {
    if ($(e.target) &&
        $(e.target).parents().length &&
        !$(e.target).parents('.modal').length &&
        !$('.wire-spinner').length &&
        !isDynamicElement($(e.target))) {
      const lastOpenedModal = window.lightModals[window.lightModals.length - 1];
      if (lastOpenedModal) {
        lastOpenedModal.close();
        subtractObjIdFromHash();
      }
    }
  };
  var isDynamicElement = function (element) {
    var isDynamic = false;
    const lastBodyChild = $(document).find('body').children().last().attr("class");
    var lastChildSelector;
    if (lastBodyChild) {
      lastChildSelector = `.${lastBodyChild.replaceAll(' ', '.')}`;
    }
    if (lastChildSelector &&
        (element.parents(lastChildSelector).length ||
          element.attr('ng-app') == "mainApp")) {
      isDynamic = true;
    }
    return isDynamic
  }
  var triggerKeyPressEvents = function (e) {
    var $focused = $(':focus');
    var isLightGalleryOpened = (document.getElementsByClassName('lg-backdrop').length>0) ? true : false;
    if (($focused.hasClass('modal') || $focused.length == 0) && !isLightGalleryOpened) { // prevent code execution on all different types of inputs 
      // trigger 'enter' key press
      if (e.keyCode == $.ui.keyCode.ENTER) {
        var currentHeader = $('.modal-header .modal-title').last().parent();
        var currentModal = currentHeader.parent();
        var primaryBtn;
        var footerBtnsCount = currentModal.find('.modal-footer')
          .find('button:not([data-dismiss="modal"], [disabled="disabled"])').length;
        if (footerBtnsCount == 0) {
          return;
        }
        else if (footerBtnsCount == 1) {
          primaryBtn = currentModal.find('.modal-footer')
            .find('button:not([data-dismiss="modal"], [disabled="disabled"])')[0];
        }
        else {
          primaryBtn = currentModal.find('.modal-footer')
            .find('button.btn-primary:not([data-dismiss="modal"], [disabled="disabled"])')[0];
        }
        $(primaryBtn).trigger('click');
      }
      // trigger 'escape' key press
      else if (e.keyCode == $.ui.keyCode.ESCAPE) {
        var lastOpenedModal = window.lightModals[window.lightModals.length - 1];
        if (lastOpenedModal) {
          lastOpenedModal.close();
          subtractObjIdFromHash();
        }
        // set the focus on the previous modal if exists
        if ($('.modal.default-modal').length) {
          setTimeout(() => {
            $('.modal.default-modal').last().focus();
          }, 300);
        }
      }
    }
  }
  var getIconClassesByTheme = function (theme) {
    //TODO_N: Replace font-awesome icons with custom icons for our plugins and then use those fonts directly on css files 

    return {
      close: theme !== ThemeEnum.CLASSIC && theme !== ThemeEnum.DEFAULT ? "fa fa-window-close" : "fa fa-times" /*"fa fa-times-circle"*/,
      expand: "fa fa-expand",
      compress: "fa fa-compress"
    };
  };

  var customizeOptions = function (options) {
    if (options.width || options.height) {
      options.sizeMode = SizeModeEnum.CUSTOM;
    }

    //TODO_N: Use custom fonts
    // If user pass his own theme name without customize button icons, we will show the default icons
    //var iconsKeyName = Object.values(ThemeEnum).indexOf(options.theme) > -1 ? options.theme : "default";
    var iconClasses = getIconClassesByTheme.call(this, options.theme);
    options.closeButtonIcon = options.closeButtonIcon || iconClasses.close;
    options.expandButtonIcon = options.expandButtonIcon || iconClasses.expand;
    options.compressButtonIcon = options.compressButtonIcon || iconClasses.compress;

  };

  var createModal = function (content, title, buttons, optOptions) {
    //var options = optOptions || {};
    //options.center = options.hasOwnProperty("center") ? options.center : true;
    //options.hideCloseButton = options.hasOwnProperty("hideCloseButton") ? options.hideCloseButton : false;
    //options.showExpandButton = options.hasOwnProperty("showExpandButton") ? options.showExpandButton : true;
    //options.scrollable = options.scrollable === undefined || options.scrollable === null ? true : options.scrollable;
    var options = $.extend(true, {}, ns.defaults, defaults, optOptions);
    customizeOptions(options);

    var modal = {
      modalButtons: [],
      create: function () {
        this.modalContainer = $("<div>")
          .addClass("modal")
          .addClass("fade")
          .addClass(options.modalClass)
          .data("keyboard", options.keyboard)
          .attr({ "tabindex": "-1" });

        this._appendModalDialog();

        this._registerEvents();
        //this._setModalAttributes();
        this._setOptions();
        this._resizeModalWidth();
        //this._setModalDefaultMaxHeight();
        this._bindTabClick();
      },
      show: function () {
        this.modalContainer.modal("show");
      },
      hide: function () {
        this.modalContainer.modal("hide");
      },
      /**
       * Adds button to modal's footer.
       * @param {object} buttonOptions with options:
       *   `label`
       *   `onClick` (function),
       *   `color` (e.g. "btn-default", "btn-primary"),
       *   `shape` (e.g. "square"),
       *   `icon`
       */
      appendFooterButton: function (buttonOptions) {
        if (!this.modalFooter) {
          this._appendFooter();
        }

        var $button = this._createFooterButton(buttonOptions);

        this.modalFooter.append($button);
        this.modalButtons.push($button);
      },
      prependFooterButton: function (buttonOptions) {
        if (!this.modalFooter) {
          this._appendFooter();
        }

        var $button = this._createFooterButton(buttonOptions);

        this.modalFooter.prepend($button);
        this.modalButtons.unshift($button);
      },
      _appendModalDialog: function () {
        this.modalDialog = $("<div>")
          .addClass("modal-dialog")
          .appendTo(this.modalContainer);
        if (optOptions['width']) {
          this.modalDialog.css('max-width', optOptions['dialogWidth']);
        }
        this._appendDialogContent();
      },
      _appendDialogContent: function () {
        this.modalContent = $("<div>")
          .addClass("modal-content")
          .appendTo(this.modalDialog); //.addClass(options.modalTypeClass);

        this._appendHeader();
        this._appendBody();

        if (buttons && buttons.length) {
          this._appendFooter();
          buttons.forEach(buttonOptions => this.appendFooterButton(buttonOptions));
        }
      },
      _appendHeader: function () {
        this.modalHeader = $("<div>")
          .addClass("modal-header")
          .appendTo(this.modalContent);

        // a. Create header title
        var titleContainer = $("<h4>")
          .addClass("modal-title")
          .appendTo(this.modalHeader);

        if (title) {
          titleContainer.append(title);
        }

        // b. Create header buttons
        var buttonsContrainer = $("<span>")
          .addClass("modal-header-btns")
          .appendTo(this.modalHeader);

        var headerButtons = [];

        // Create close button
        if (options.closeButton) {
          headerButtons.push(this._createHeaderCloseButton());
        }

        // Create expand button
        if (options.expandButton) {
          headerButtons.push(this._createHeaderExpandButton(options.onResize));
        }

        if (headerButtons.length) {
          for (var i = 0; i < headerButtons.length; i++) {
            var button = headerButtons[i];
            button.addClass("modal-header-btn");
            buttonsContrainer.append(button);
          }
        }
      },
      _appendBody: function () {
        this.modalBody = $("<div>")
          .addClass("modal-body")
          .appendTo(this.modalContent);

        this.modalBody.append(content);
      },
      _appendFooter: function () {
        this.modalFooter = $("<div>")
          .addClass("modal-footer")
          .appendTo(this.modalContent);
      },
      _createHeaderCloseButton: function () {
        var closeButton = $("<button type='button'>")
          .addClass("modal-close-btn")
          .addClass("close")
          .addClass(options.closeButtonIcon)
          .click(function () {
            if (options.onCloseButtonClick && options.onCloseButtonClick instanceof Function) {
              options.onCloseButtonClick.call(this, lightModal);
            }
            else {
              lightModal.close();
            }
            subtractObjIdFromHash();
          });

        return closeButton;
      },
      _createHeaderExpandButton: function (callback) {
        var isExpanded = options.sizeMode === SizeModeEnum.FULL;
        var expandIcon = isExpanded ? options.compressButtonIcon : options.expandButtonIcon;

        var me = this;
        var expandButton = $("<button type='button'>")
          .addClass("modal-expand-btn")
          .addClass(expandIcon)
          .data("is-expanded", isExpanded)
          .click(function () {
            var isExpanded = $(this).data("is-expanded");
            if (!isExpanded) {
              // Set fullscreen mode
              me.modalContainer.addClass("full-screen");
              $(this)
                .removeClass(options.expandButtonIcon)
                .addClass(options.compressButtonIcon)
                .data("is-expanded", true);

              me._expandModalBody();
            }
            else {
              // Minimize the screen
              me.modalContainer.removeClass("full-screen");
              $(this)
                .removeClass(options.compressButtonIcon)
                .addClass(options.expandButtonIcon)
                .data("is-expanded", false);

              me._resetExpandModal();
            }

            if (options.onFullscreen && options.onFullscreen instanceof Function) {
              var isToExpandModal = !isExpanded;
              options.onFullscreen(isToExpandModal);
            }
            // Close modal on outside click
            var isAboutToExpand = !isExpanded;
            if (!isAboutToExpand) {
              document.addEventListener('click', closeOnOutsideClick, true);
            }
            else {
              document.removeEventListener('click', closeOnOutsideClick, true);
            }
            if (callback) {
              callback();
            }
          });

        return expandButton;
      },
      _createFooterButton: function (buttonOptions) {
        var separator = buttonOptions.shape && buttonOptions.shape === "square" ? "<br/>" : " ";

        var icon = $("<i>");
        if (buttonOptions.icon) {
          icon.addClass(buttonOptions.icon);
        }

        var $button = $("<button type='button'>")
          .addClass(this._extractFooterButtonClasses(buttonOptions))
          .append(icon)
          .append(separator)
          .append(buttonOptions.label)
          .on('click', this, function () {
            if (buttonOptions.onClick && buttonOptions.onClick instanceof Function) {
              $(this).attr("disabled", true);
              try {
                buttonOptions.onClick(lightModal);
              } finally {
                $(this).attr("disabled", false);
              }
            }
            else {
              lightModal.close();
            }
          });

        if (buttonOptions.class) {
          $button.addClass(buttonOptions.class);
        }

        if (buttonOptions.id) {
          $button.attr("id", buttonOptions.id);
        }

        if (buttonOptions.attr) {
          $button.attr(buttonOptions.attr);
        }

        if (buttonOptions.tooltip) {
          $button.attr({
            "data-toggle": "tooltip",
            "data-placement": "top",
            "title": buttonOptions.tooltip
          });

          $button.tooltip();
        }

        if (buttonOptions.focus) {
          $button.attr("data-focus", true);
        }

        return $button;
      },
      _extractFooterButtonClasses: function (buttonOptions) {
        var bootstrapClasses = ["btn"];

        var buttonColor = buttonOptions.color || "btn-default";
        bootstrapClasses.push(buttonColor);

        if (buttonOptions.size) {
          bootstrapClasses.push(buttonOptions.size);
        }

        return bootstrapClasses.join(" ");
      },
      _setOptions: function () {
        // We set the backdrop option to true, if showMode is backdrop, otherwise we set false by default
        var modalOptions = { keyboard: options.keyboard, backdrop: false };

        if (options.id) {
          this.modalContainer.attr("id", options.id);
        }

        if (options.class) {
          this.modalContainer.addClass(options.class);
        }

        if (options.rtl) {
          this.modalContainer.addClass("modal-rtl");
        }

        // Center modal
        if (options.center) {
          var centerClassName = options.centerFlex ? "modal-center-flex" : "modal-center";
          this.modalContainer.addClass(centerClassName);
        }

        // Scrollable modal
        if (options.scrollable) {
          //this.modalBody.css("overflow-y", "auto");
          this.modalContainer.addClass("scrollable");
        }

        // Resizable modal
        if (options.resizable) {
          var me = this;

          this.modalContent.resizable({
            //alsoResize: ".modal-body",
            //handles: 'n, e, s, w, se, ne, sw, nw', // Make all sides resizable
            minHeight: 500,
            minWidth: 500
          }).resize(function (e) {
            e.stopPropagation();
            var height = me._getContentBodyHeight();
            me._setBodyHeight(height);
            me._setBodyMaxHeight("");
          });
        }

        // Movable modal
        if (options.movable) {
          $(this.modalContainer).addClass("movable");

          $(this.modalDialog).draggable({
            handle: ".modal-header"
          });
        }

        //var isFullScreen = options.fullscreen && !(options.width || options.height);
        //if (isFullScreen) {
        //    this.modalContainer.addClass("full-screen");
        //}
        // Show mode
        switch (options.sizeMode) {
          case SizeModeEnum.LARGE:
            this.modalDialog.addClass("modal-lg");
            break;
          case SizeModeEnum.X_LARGE:
            this.modalDialog.addClass("modal-xl");
            break;
          case SizeModeEnum.FULL:
            this.modalContainer.addClass("full-screen");
            break;
        }

        switch (options.showMode) {
          case ShowModeEnum.BLOCKED:
            this.modalContainer.addClass("blocked");
            break;
          case ShowModeEnum.BACKDROP:
            modalOptions.backdrop = true;
            break;
        }

        // Modal theme
        if (options.theme) {
          var className;

          switch (options.theme) {
            case ThemeEnum.DEFAULT:
              className = "default-theme";
              break;

            case ThemeEnum.CLASSIC:
              className = "classic-theme";
              break;

            case ThemeEnum.COLORFULL:
              className = "colorfull-theme";
              break;

            default:
              className = options.theme;
              break;
          }

          this.modalContainer.addClass(className);
        }

        // Set modal keyboard and backdrop options
        this.modalContainer.modal(modalOptions);
      },
      _resetExpandModal: function () {
        //me.modalBody.css({ "height": "auto", "max-height": "auto" });
        this._setBodyHeight("");
        this._resizeModalHeight();
      },
      _expandModalBody: function () {
        var modalBodyHeight = this.modalContainer.height() - (this.modalHeader.outerHeight() + (this.modalFooter ? this.modalFooter.outerHeight() : 0));
        modalBodyHeight = modalBodyHeight - 10 + "px";

        this._setBodyHeight(modalBodyHeight);
        this._setBodyMaxHeight("");
        //this.modalBody.css({ "height": modalBodyHeight, "max-height": modalBodyHeight });
      },
      //_setModalDefaultMaxHeight: function () {
      //    //var maxHeight = $(window).height() - 190;
      //    var maxHeight = $(window).height() - (this.modalHeader.outerHeight() + (this.modalFooter ? this.modalFooter.outerHeight() : 0));
      //    maxHeight = maxHeight - 10 + "px";
      //    this.modalBody.css("max-height", maxHeight);
      //},
      _getContentMaxHeightAllowed: function () {
        var $element = $(this.modalContainer);

        var $content = $element.find('.modal-content');
        var borderWidth = $content.outerHeight() - $content.innerHeight();
        var dialogMargin = $(window).width() < 768 ? 90 : 130;
        var contentHeight = $(window).height() - (dialogMargin + borderWidth);
        var headerHeight = $element.find('.modal-header').outerHeight() || 0;
        var footerHeight = $element.find('.modal-footer').outerHeight() || 0;
        var maxHeight = contentHeight - (headerHeight + footerHeight);

        return maxHeight;
      },
      _getContentBodyHeight: function () {
        var $element = $(this.modalContainer);

        var $content = $element.find('.modal-content');
        var contentHeight = $content.innerHeight();
        var headerHeight = $element.find('.modal-header').outerHeight() || 0;
        var footerHeight = $element.find('.modal-footer').outerHeight() || 0;
        var maxHeight = contentHeight - (headerHeight + footerHeight);

        return maxHeight;
      },
      _setBodyHeight: function (height) {
        this.modalBody.css("height", height);
      },
      _setBodyMaxHeight: function (maxHeight) {
        this.modalBody.css({ 'max-height': maxHeight });
      },
      _setBodyMinHeight: function (minHeight) {
        this.modalBody.css({ 'min-height': minHeight });
      },
      _getModalMaxWidthAllowed: function () {
        return $(window).outerWidth() / 1.2;
      },
      _setModalMaxWidth: function (width) {
        //var maxWidth = $(window).outerWidth() / 1.2;
        //this.modalDialog.css({ 'max-width': maxWidth });

        //return maxWidth;
        this.modalDialog.css({ 'max-width': width });
      },
      _resizeModalHeight: function () {
        if (options.resizable) {
          // jQuery ui resizable plugin, adds css width and height properties when user resize the modal itself,
          //  but when user resize the window, we recalculate the max height allowed for modal body.
          //  So for this reason, we remove the height css added by this plugin.
          this._removeModalContentHeight();
        }

        // Get the max height value allowed
        var maxHeightAllowed = this._getContentMaxHeightAllowed();

        if (options.height) {
          var height = options.height <= maxHeightAllowed ? options.height : maxHeightAllowed;
          this._setBodyHeight(height);
          //this._setBodyMaxHeight(maxHeightAllowed);
          //this._setBodyHeight(options.height);
          //options.height === "max" ? this.modalBody.css('height', maxHeightAllowed) : this.modalBody.css("height", options.height);
        }
        else {
          if (this.modalContainer.hasClass("full-screen")) {
            this._expandModalBody();
          }
          else {
            //var contentBodyHeight = this._getContentBodyHeight();
            //this._setBodyMinHeight(contentBodyHeight);

            // Set body max-height
            this._setBodyHeight("");
            this._setBodyMaxHeight(maxHeightAllowed);
          }
        }
      },
      _resizeModalWidth: function () {
        if (options.width) {
          // Important Note: By default, the modal width is responsive, so we need max-width only if user customize the modal width.
          // The modal has a fixed width on large screens (in bootstrap v3). And it has a fixed max-width on large screens (in bootstrap v4).
          var maxWidth = this._getModalMaxWidthAllowed();

          // Set the max-width based on the lowest value
          var customWidth = parseInt(options.width);
          maxWidth = maxWidth < customWidth ? maxWidth : customWidth;

          this._setModalMaxWidth(maxWidth);

          this.modalDialog.css("width", customWidth);
          //if (options.width === "max") {
          //    this.modalDialog.css('width', maxWidth);
          //}
          //else if (options.width === "large") {
          //    this.modalDialog.addClass("modal-lg");
          //}
          //else {
          //    this.modalBody.css("width", options.width);
          //}
        }
      },
      _removeModalContentHeight: function () {
        var $element = $(this.modalContainer);
        var $content = $element.find('.modal-content');
        $content.css('height', '');
      },
      _registerEvents: function () {
        var me = this;

        this.modalContainer.on("show.bs.modal", function (e) {
          // Before show modal

          //NOTE: This is a workaround. "show.bs.modal": This method is called twice.
          $(this).off('show.bs.modal');

          // Fix bug (after modal close the body for html get padding-right)
          //$("body").removeAttr("style");

          if (options.onOpening && options.onOpening instanceof Function) {
            options.onOpening(e);
          }

          //moved from shown.bs.modal to show.bs.modal in order to eliminate a ui hiccup
          me._resizeModalHeight();
        });

        this.modalContainer.on("shown.bs.modal", function (e) {
          // Set focus on the button which have data-focus attribute. If there is no button have this attribute, then set the focus on the close button.
          var focusButton = $('button[data-focus="true"]');
          if (focusButton.length > 0) {
            focusButton.focus();
          } else {
            $('button.modal-close-button').focus();
          }

          // On after show modal
          //me._resizeModalHeight();

          //TODO_N: Register this event once. OR, deatach this event on modal close
          $(window).resize(function () {
            if ($('.modal.in').length !== 0 || $('.modal.show').length !== 0) { //TODO_N: Get in or show based on bs vertion
              me._resizeModalHeight();
              me._resizeModalWidth();
            };
          });

          if (options.onOpened && options.onOpened instanceof Function) {
            options.onOpened(e);
          }

          //TODO: do more investigation to hide the popover when the modal is scrolled
          // When modal is scrolled the position of its content is changed while the popover is still in the same location.
          me.modalBody.scroll(function () {
            $('[data-toggle="popover"]').popover('hide');
          });
        });

        this.modalContainer.on("hide.bs.modal", function (e) {
          // Fix bug (Once the modal is closed the scrollbar of page is hidden) using this line of code
          //$('body').addClass('modal-open');

          var closeModal = true;

          if (options.onBeforeClose && options.onBeforeClose instanceof Function) {
            closeModal = options.onBeforeClose(e);
          }

          if (closeModal === false) {
            // This line of code, prevent closing the modal
            e.preventDefault();
          }
          else {
            // On before hide modal
            if (options.onClosing && options.onClosing instanceof Function) {
              options.onClosing(e);
            }
          }
        });

        this.modalContainer.on("hidden.bs.modal", function (e) {
          // On after hide modal

          // Destroy the modal container after hide it
          me.modalContainer.remove();

          // Remove modal from openModals.
          var indices = [];
          Specto.ui.Modal.openModals.forEach((modal, idx) => {
            if (modal == me) {
              indices.push(idx);
            }
          });
          if (indices.length > 0) {
            Specto.ui.Modal.openModals.splice(indices[0], 1);
          }

          // Propagate event.
          if (options.onClosed && options.onClosed instanceof Function) {
            options.onClosed(e);
          }

          // give the focus for the last opened modal
          //TODO_N: Get "shownModalClassName": "in" or "show" from modal options
          // Use "in" class name to get the shown modal in bootstrap v3
          // Use "show" class name to get the shown modal in bootstrap v4
          $(".modal.in, .modal.show").last().focusFirstChild();
        });
      },
      _bindTabClick: function () {
        var me = this;
        //me.modalContainer.on('focusout', function (e) {
        //    if (e.relatedTarget !== me.modalContainer[0] && me.modalContainer.has(e.relatedTarget).length === 0) {
        //        //e.stopPropagation();
        //        //me.modalContainer.focus();
        //        return false;
        //    }
        //});
        //$(document).on("keydown", function (e) {
        //    var keyCode = e.keyCode || e.which;
        //    if (keyCode == 9) {
        //        if (e.target !== me.modalContainer[0] && me.modalContainer.has(e.target).length === 0) {
        //            e.preventDefault();
        //        }
        //    }
        //});

        //me.modalContainer.on("keydown", function (e) {
        //    var keyCode = e.keyCode || e.which;
        //    if (keyCode == 9) {
        //        alert(e.relatedTarget);
        //    }
        //});

        this.modalContainer.on('keydown', function (e) {
          var keyCode = e.keyCode || e.which;
          // keyCode = 9 ==> tab key
          if (e.shiftKey && keyCode === 9) {
            me._focusPrevious(e.target);
            e.preventDefault();
            e.stopPropagation();
            return false;
          }
          else if (keyCode === 9) {
            me._focusNext(e.target);
            e.preventDefault();
            e.stopPropagation();
            return false;
          }
        });
      },
      _focusNext: function (element) {
        var next = null;

        var fields = $(this.modalContainer).find('button,input,textarea,select');
        var index = fields.index(element);

        if (index === fields.length - 1) {
          next = fields.eq(0);
        }
        else if (index > -1 && (index + 1) < fields.length) {
          next = fields.eq(index + 1);
        }

        if (next)
          $(next).focus();
      },
      _focusPrevious: function (element) {
        var previous = null;

        var fields = $(this.modalContainer).find('button,input,textarea,select');
        var index = fields.index(element);

        if (index === 0) {
          previous = fields.eq(fields.length - 1);
        }
        else if (index - 1 > -1) {
          previous = fields.eq(index - 1);
        }

        if (previous)
          $(previous).focus();
      },
    };

    // Create Modal
    modal.create();

    var lightModal = {
      modalContainer: modal.modalContainer,
      modalButtons: modal.modalButtons,
      close: function () {
        modal.hide();
        window.lightModals.pop();
        setTimeout(() => {
          if (!$('.modal.default-modal').length) {
            document.removeEventListener('keyup', triggerKeyPressEvents, true);
            document.removeEventListener('click', closeOnOutsideClick, true);
          }
        }, 500);
      },
      closeAll: function () {
        $(".modal").modal("hide");
        document.removeEventListener('keyup', triggerKeyPressEvents, true);
        document.removeEventListener('click', closeOnOutsideClick, true);
        window.lightModals = [];
      },
      appendButton: function (buttonOptions) {
        modal.appendFooterButton(buttonOptions);
      },
      appendButtons: function (buttons) {
        buttons.forEach(buttonOptions => modal.appendFooterButton(buttonOptions));
      },
      prependButton: function (buttonOptions) {
        modal.prependFooterButton(buttonOptions);
      },
      prependButtons: function (buttons) {
        for (var i = buttons.length - 1; i >= 0; i--) {
          modal.prependFooterButton(buttons[i]);
        }
      },
    };
    // Close modal on hash change
    window.onhashchange = function () {
      modal.hide();
    };

    // Cache the spectoModal object in modal container data
    $.data(modal.modalContainer[0], "spectoModal", lightModal);

    // Show Modal
    modal.show();

    this.Specto.ui.Modal.openModals.push(modal);

    // Return only neeeded functions and properties
    return lightModal;
  };

  var createMessageModal = function (content, title, buttons, optOptions, iconClass) {
    var options = $.extend(true, { /*width: "500"*/ }, optOptions);

    var messageBody = $("<div>").addClass("modal-msg-body");

    // a. Create message icon
    var iconWrap = $("<div>").addClass("modal-msg-icon-wrap");

    var icon = $("<i>")
      .addClass("modal-msg-icon")
      .addClass(iconClass);

    iconWrap.append(icon);

    // b. Create message content
    var contentWrap = $("<div>")
      .addClass("modal-msg-content-wrap")
      .append(content);

    messageBody.append(iconWrap).append(contentWrap);

    return createModal(messageBody, title, buttons, options);
  }

  //#endregion ________________________ Private Methods ___________________________


  //#region ___________________________ Public Methods ____________________________    


  Specto.ui.Modal.getOpenModals = function () {
    //TODO_N: Get "shownModalClassName": "in" or "show" from modal options
    // Use "in" class name to get the shown modal in bootstrap v3
    // Use "show" class name to get the shown modal in bootstrap v4

    var openedModals = [];

    $(".modal.in, .modal.show").each(function () {
      openedModals.push($(this).data("spectoModal"));
    });

    return openedModals;
  };

  /**
   * Finds the modal that contains a certain child dom
   * @param {jQuery} childDom
   */
  Specto.ui.Modal.findOpenModalUsingChildDom = function (childDom) {
    //var openModals = Specto.ui.Modal.openModals.filter(modal => modal.modalContainer.find(childDom).length);
    //if (openModals.length > 0) {
    //    return openModals[0];
    //} else {
    //    return null;
    //}

    var $modalContainer = $(childDom).closest(".modal");
    if ($modalContainer.length) {
      return $modalContainer.data("spectoModal");
    }
    else {
      return null;
    }
  }

  Specto.ui.Modal.showModal = function (content, title, buttons, optOptions) {
    window.options = optOptions;
    var options = $.extend(true, { modalClass: "default-modal" }, optOptions);
    var lightModal = createModal(content, title, buttons, options);
    setTimeout(() => {
      window.lightModals.push(lightModal);
    }, 500);
    if (!optOptions || (optOptions && (!optOptions['sizeMode'] || !(optOptions['sizeMode'] == "full")))) {
      // Close modal on outside click
      document.addEventListener('click', closeOnOutsideClick, true);
    }
    // Trigger key-press events
    document.addEventListener('keyup', triggerKeyPressEvents, true);
    return lightModal;
  };

  Specto.ui.Modal.showPromptModal = function (content, title, defaultValue, optOptions, optOnOkCallback, optOnCancelCallback) {
    var options = $.extend(true, { modalClass: "prompt-modal", onCloseButtonClick: optOnCancelCallback, expandButton: false }, optOptions);

    var buttons = [
      {
        label: ns.defaults.localizer["OK"], onClick: function (modal) {
          modal.close();
          if (optOnOkCallback && optOnOkCallback instanceof Function) {
            var value = inputText.val();
            optOnOkCallback(value);
          }
        }, color: "btn-primary", focus: true
      },
      { label: ns.defaults.localizer["CANCEL"], onClick: optOnCancelCallback, color: "btn-default" }
    ];

    var inputText = $("<input>")
      .attr("type", "text")
      .addClass("prompt-modal-txt")
      .addClass("form-control")
      .val(defaultValue || "");

    var promptContent = $("<div>")
      .append(content)
      .append(inputText);

    return createModal(promptContent, title, buttons, options);
  };

  Specto.ui.Modal.showConfirmModal = function (content, optOptions, optYesCallback, optNoCallback) {
    var options = $.extend(true, { modalClass: "confirm-modal", onCloseButtonClick: optNoCallback, expandButton: false/*, width: "500"*/ }, optOptions);
    var buttons = [
      { label: ns.defaults.localizer["YES"], onClick: optYesCallback, color: "btn-success", icon: "fa fa-check" },
      { label: ns.defaults.localizer["NO"], onClick: optNoCallback, color: "btn-default", icon: "fa fa-times", focus: true }
    ];

    return createModal(content, ns.defaults.localizer["CONFIRMATION"], buttons, options);
  };

  Specto.ui.Modal.showCustomModal = function (content, optOptions, optYesLabel, optNoLabel, optYesCallback, optNoCallback) {
    var options = $.extend(true, { modalClass: "confirm-modal", onCloseButtonClick: optNoCallback, expandButton: false/*, width: "500"*/ }, optOptions);
    var buttons = [
      { label: optYesLabel, onClick: optYesCallback, color: "btn-success", icon: "fa fa-check" },
      { label: optNoLabel, onClick: optNoCallback, color: "btn-default", icon: "fa fa-times", focus: true }
    ];

    return createModal(content, ns.defaults.localizer["CONFIRMATION"], buttons, options);
  };

  Specto.ui.Modal.showErrorModal = function (content, optOptions, optOkCallback) {
    var options = $.extend(true, { modalClass: "error-modal", onCloseButtonClick: optOkCallback, expandButton: false }, optOptions);
    var buttons = [
      { label: ns.defaults.localizer["OK"], onClick: optOkCallback, color: "btn-danger", focus: true },
    ];

    return createMessageModal(content, ns.defaults.localizer["ERROR"], buttons, options, "fa fa-times-circle");
  };

  Specto.ui.Modal.showWarningModal = function (content, optOptions, optOkCallback) {
    var options = $.extend(true, { modalClass: "warning-modal", onCloseButtonClick: optOkCallback, expandButton: false }, optOptions);
    var buttons = [
      { label: ns.defaults.localizer["OK"], onClick: optOkCallback, color: "btn-warning", focus: true },
    ];

    return createMessageModal(content, ns.defaults.localizer["WARNING"], buttons, options, "fa fa-exclamation-triangle");
  };

  Specto.ui.Modal.showInformationModal = function (content, optOptions, optOkCallback) {
    var options = $.extend(true, { modalClass: "info-modal", onCloseButtonClick: optOkCallback, expandButton: false }, optOptions);
    var buttons = [
      { label: ns.defaults.localizer["OK"], onClick: optOkCallback, color: "btn-info", focus: true },
    ];

    return createMessageModal(content, ns.defaults.localizer["INFORMATION"], buttons, options, "fa fa-info-circle");
  };

  Specto.ui.Modal.closeAll = function () {
    $(".modal").modal("hide");
  }

  Specto.ui.Modal.killAll = function () {
    $(".modal").remove();
  }

  //#endregion ________________________ Public Methods ____________________________


  //#region ________________________ jQuery Modal Plugins _________________________

  //$.fn.nextFocus = function () {
  //    var next = [];
  //    this.each(function () {
  //        var fields = $(this).parents('form:eq(0),body').find('button,input,textarea,select');
  //        var index = fields.index(this);
  //        if (index > -1 && (index + 1) < fields.length) {
  //            next = fields.eq(index + 1);
  //        }
  //    });
  //    return next;

  //};

  $.fn.nextInModal = function (modal) {
    var next = [];
    this.each(function () {
      var fields = $(modal).find('button,input,textarea,select');
      var index = fields.index(this);
      if (index > -1 && (index + 1) < fields.length) {
        next = fields.eq(index + 1);
      }
      else if (index === fields.length - 1) {
        next = fields.eq(0);
      }
    });
    return next;

  };

  $.fn.focusFirstChild = function () {
    this.each(function () {
      var fields = $(this).find('button,input,textarea,select');
      if (fields.length) {
        fields.eq(0).focus();
      }
      else {
        this.focus();
      }
    });
  };

  //#endregion _____________________ jQuery Modal Plugins _________________________
})();
/*
 * bootstrap-tagsinput v0.8.0
 * 
 */

(function ($) {
  "use strict";

  var defaultOptions = {
    tagClass: function(item) {
      return 'label label-info';
    },
    focusClass: 'focus',
    itemValue: function(item) {
      return item ? item.toString() : item;
    },
    itemText: function(item) {
      return this.itemValue(item);
    },
    itemTitle: function(item) {
      return null;
    },
    freeInput: true,
    addOnBlur: true,
    maxTags: undefined,
    maxChars: undefined,
    confirmKeys: [13, 44],
    delimiter: ',',
    delimiterRegex: null,
    cancelConfirmKeysOnEmpty: false,
    onTagExists: function(item, $tag) {
      $tag.hide().fadeIn();
    },
    trimValue: false,
    allowDuplicates: false,
    triggerChange: true
  };

  /**
   * Constructor function
   */
  function TagsInput(element, options) {
    this.isInit = true;
    this.itemsArray = [];

    this.$element = $(element);
    this.$element.hide();

    this.isSelect = (element.tagName === 'SELECT');
    this.multiple = (this.isSelect && element.hasAttribute('multiple'));
    this.objectItems = options && options.itemValue;
    this.placeholderText = element.hasAttribute('placeholder') ? this.$element.attr('placeholder') : '';
    this.inputSize = Math.max(1, this.placeholderText.length);

    this.$container = $('<div class="bootstrap-tagsinput"></div>');
    this.$input = $('<input type="text" placeholder="' + this.placeholderText + '"/>').appendTo(this.$container);

    this.$element.before(this.$container);

    this.build(options);
    this.isInit = false;
  }

  TagsInput.prototype = {
    constructor: TagsInput,

    /**
     * Adds the given item as a new tag. Pass true to dontPushVal to prevent
     * updating the elements val()
     */
    add: function(item, dontPushVal, options) {
      var self = this;

      if (self.options.maxTags && self.itemsArray.length >= self.options.maxTags)
        return;

      // Ignore falsey values, except false
      if (item !== false && !item)
        return;

      // Trim value
      if (typeof item === "string" && self.options.trimValue) {
        item = $.trim(item);
      }

      // Throw an error when trying to add an object while the itemValue option was not set
      if (typeof item === "object" && !self.objectItems)
        throw("Can't add objects when itemValue option is not set");

      // Ignore strings only containg whitespace
      if (item.toString().match(/^\s*$/))
        return;

      // If SELECT but not multiple, remove current tag
      if (self.isSelect && !self.multiple && self.itemsArray.length > 0)
        self.remove(self.itemsArray[0]);

      if (typeof item === "string" && this.$element[0].tagName === 'INPUT') {
        var delimiter = (self.options.delimiterRegex) ? self.options.delimiterRegex : self.options.delimiter;
        var items = item.split(delimiter);
        if (items.length > 1) {
          for (var i = 0; i < items.length; i++) {
            this.add(items[i], true);
          }

          if (!dontPushVal)
            self.pushVal(self.options.triggerChange);
          return;
        }
      }

      var itemValue = self.options.itemValue(item),
          itemText = self.options.itemText(item),
          tagClass = self.options.tagClass(item),
          itemTitle = self.options.itemTitle(item);

      // Ignore items allready added
      var existing = $.grep(self.itemsArray, function(item) { return self.options.itemValue(item) === itemValue; } )[0];
      if (existing && !self.options.allowDuplicates) {
        // Invoke onTagExists
        if (self.options.onTagExists) {
          var $existingTag = $(".tag", self.$container).filter(function() { return $(this).data("item") === existing; });
          self.options.onTagExists(item, $existingTag);
        }
        return;
      }

      // if length greater than limit
      if (self.items().toString().length + item.length + 1 > self.options.maxInputLength)
        return;

      // raise beforeItemAdd arg
      var beforeItemAddEvent = $.Event('beforeItemAdd', { item: item, cancel: false, options: options});
      self.$element.trigger(beforeItemAddEvent);
      if (beforeItemAddEvent.cancel)
        return;

      // register item in internal array and map
      self.itemsArray.push(item);

      // add a tag element

      var $tag = $('<span class="tag ' + htmlEncode(tagClass) + (itemTitle !== null ? ('" title="' + itemTitle) : '') + '">' + htmlEncode(itemText) + '<span data-role="remove"></span></span>');
      $tag.data('item', item);
      self.findInputWrapper().before($tag);
      $tag.after(' ');

      // Check to see if the tag exists in its raw or uri-encoded form
      var optionExists = (
        $('option[value="' + encodeURIComponent(itemValue) + '"]', self.$element).length ||
        $('option[value="' + htmlEncode(itemValue) + '"]', self.$element).length
      );

      // add <option /> if item represents a value not present in one of the <select />'s options
      if (self.isSelect && !optionExists) {
        var $option = $('<option selected>' + htmlEncode(itemText) + '</option>');
        $option.data('item', item);
        $option.attr('value', itemValue);
        self.$element.append($option);
      }

      if (!dontPushVal)
        self.pushVal(self.options.triggerChange);

      // Add class when reached maxTags
      if (self.options.maxTags === self.itemsArray.length || self.items().toString().length === self.options.maxInputLength)
        self.$container.addClass('bootstrap-tagsinput-max');

      // If using typeahead, once the tag has been added, clear the typeahead value so it does not stick around in the input.
      if ($('.typeahead, .twitter-typeahead', self.$container).length) {
        self.$input.typeahead('val', '');
      }

      if (this.isInit) {
        self.$element.trigger($.Event('itemAddedOnInit', { item: item, options: options }));
      } else {
        self.$element.trigger($.Event('itemAdded', { item: item, options: options }));
      }
    },

    /**
     * Removes the given item. Pass true to dontPushVal to prevent updating the
     * elements val()
     */
    remove: function(item, dontPushVal, options) {
      var self = this;

      if (self.objectItems) {
        if (typeof item === "object")
          item = $.grep(self.itemsArray, function(other) { return self.options.itemValue(other) ==  self.options.itemValue(item); } );
        else
          item = $.grep(self.itemsArray, function(other) { return self.options.itemValue(other) ==  item; } );

        item = item[item.length-1];
      }

      if (item) {
        var beforeItemRemoveEvent = $.Event('beforeItemRemove', { item: item, cancel: false, options: options });
        self.$element.trigger(beforeItemRemoveEvent);
        if (beforeItemRemoveEvent.cancel)
          return;

        $('.tag', self.$container).filter(function() { return $(this).data('item') === item; }).remove();
        $('option', self.$element).filter(function() { return $(this).data('item') === item; }).remove();
        if($.inArray(item, self.itemsArray) !== -1)
          self.itemsArray.splice($.inArray(item, self.itemsArray), 1);
      }

      if (!dontPushVal)
        self.pushVal(self.options.triggerChange);

      // Remove class when reached maxTags
      if (self.options.maxTags > self.itemsArray.length)
        self.$container.removeClass('bootstrap-tagsinput-max');

      self.$element.trigger($.Event('itemRemoved',  { item: item, options: options }));
    },

    /**
     * Removes all items
     */
    removeAll: function() {
      var self = this;

      $('.tag', self.$container).remove();
      $('option', self.$element).remove();

      while(self.itemsArray.length > 0)
        self.itemsArray.pop();

      self.pushVal(self.options.triggerChange);
    },

    /**
     * Refreshes the tags so they match the text/value of their corresponding
     * item.
     */
    refresh: function() {
      var self = this;
      $('.tag', self.$container).each(function() {
        var $tag = $(this),
            item = $tag.data('item'),
            itemValue = self.options.itemValue(item),
            itemText = self.options.itemText(item),
            tagClass = self.options.tagClass(item);

          // Update tag's class and inner text
          $tag.attr('class', null);
          $tag.addClass('tag ' + htmlEncode(tagClass));
          $tag.contents().filter(function() {
            return this.nodeType == 3;
          })[0].nodeValue = htmlEncode(itemText);

          if (self.isSelect) {
            var option = $('option', self.$element).filter(function() { return $(this).data('item') === item; });
            option.attr('value', itemValue);
          }
      });
    },

    /**
     * Returns the items added as tags
     */
    items: function() {
      return this.itemsArray;
    },

    /**
     * Assembly value by retrieving the value of each item, and set it on the
     * element.
     */
    pushVal: function() {
      var self = this,
          val = $.map(self.items(), function(item) {
            return self.options.itemValue(item).toString();
          });

      self.$element.val(val, true);

      if (self.options.triggerChange)
        self.$element.trigger('change');
    },

    /**
     * Initializes the tags input behaviour on the element
     */
    build: function(options) {
      var self = this;

      self.options = $.extend({}, defaultOptions, options);
      // When itemValue is set, freeInput should always be false
      if (self.objectItems)
        self.options.freeInput = false;

      makeOptionItemFunction(self.options, 'itemValue');
      makeOptionItemFunction(self.options, 'itemText');
      makeOptionFunction(self.options, 'tagClass');

      // Typeahead Bootstrap version 2.3.2
      if (self.options.typeahead) {
        var typeahead = self.options.typeahead || {};

        makeOptionFunction(typeahead, 'source');

        self.$input.typeahead($.extend({}, typeahead, {
          source: function (query, process) {
            function processItems(items) {
              var texts = [];

              for (var i = 0; i < items.length; i++) {
                var text = self.options.itemText(items[i]);
                map[text] = items[i];
                texts.push(text);
              }
              process(texts);
            }

            this.map = {};
            var map = this.map,
                data = typeahead.source(query);

            if ($.isFunction(data.success)) {
              // support for Angular callbacks
              data.success(processItems);
            } else if ($.isFunction(data.then)) {
              // support for Angular promises
              data.then(processItems);
            } else {
              // support for functions and jquery promises
              $.when(data)
               .then(processItems);
            }
          },
          updater: function (text) {
            self.add(this.map[text]);
            return this.map[text];
          },
          matcher: function (text) {
            return (text.toLowerCase().indexOf(this.query.trim().toLowerCase()) !== -1);
          },
          sorter: function (texts) {
            return texts.sort();
          },
          highlighter: function (text) {
            var regex = new RegExp( '(' + this.query + ')', 'gi' );
            return text.replace( regex, "<strong>$1</strong>" );
          }
        }));
      }

      // typeahead.js
      if (self.options.typeaheadjs) {
          var typeaheadConfig = null;
          var typeaheadDatasets = {};

          // Determine if main configurations were passed or simply a dataset
          var typeaheadjs = self.options.typeaheadjs;
          if ($.isArray(typeaheadjs)) {
            typeaheadConfig = typeaheadjs[0];
            typeaheadDatasets = typeaheadjs[1];
          } else {
            typeaheadDatasets = typeaheadjs;
          }

          self.$input.typeahead(typeaheadConfig, typeaheadDatasets).on('typeahead:selected', $.proxy(function (obj, datum) {
            if (typeaheadDatasets.valueKey)
              self.add(datum[typeaheadDatasets.valueKey]);
            else
              self.add(datum);
            self.$input.typeahead('val', '');
          }, self));
      }

      self.$container.on('click', $.proxy(function(event) {
        if (! self.$element.attr('disabled')) {
          self.$input.removeAttr('disabled');
        }
        self.$input.focus();
      }, self));

        if (self.options.addOnBlur && self.options.freeInput) {
          self.$input.on('focusout', $.proxy(function(event) {
              // HACK: only process on focusout when no typeahead opened, to
              //       avoid adding the typeahead text as tag
              if ($('.typeahead, .twitter-typeahead', self.$container).length === 0) {
                self.add(self.$input.val());
                self.$input.val('');
              }
          }, self));
        }

      // Toggle the 'focus' css class on the container when it has focus
      self.$container.on({
        focusin: function() {
          self.$container.addClass(self.options.focusClass);
        },
        focusout: function() {
          self.$container.removeClass(self.options.focusClass);
        },
      });

      self.$container.on('keydown', 'input', $.proxy(function(event) {
        var $input = $(event.target),
            $inputWrapper = self.findInputWrapper();

        if (self.$element.attr('disabled')) {
          self.$input.attr('disabled', 'disabled');
          return;
        }

        switch (event.which) {
          // BACKSPACE
          case 8:
            if (doGetCaretPosition($input[0]) === 0) {
              var prev = $inputWrapper.prev();
              if (prev.length) {
                self.remove(prev.data('item'));
              }
            }
            break;

          // DELETE
          case 46:
            if (doGetCaretPosition($input[0]) === 0) {
              var next = $inputWrapper.next();
              if (next.length) {
                self.remove(next.data('item'));
              }
            }
            break;

          // LEFT ARROW
          case 37:
            // Try to move the input before the previous tag
            var $prevTag = $inputWrapper.prev();
            if ($input.val().length === 0 && $prevTag[0]) {
              $prevTag.before($inputWrapper);
              $input.focus();
            }
            break;
          // RIGHT ARROW
          case 39:
            // Try to move the input after the next tag
            var $nextTag = $inputWrapper.next();
            if ($input.val().length === 0 && $nextTag[0]) {
              $nextTag.after($inputWrapper);
              $input.focus();
            }
            break;
         default:
             // ignore
         }

        // Reset internal input's size
        var textLength = $input.val().length,
            wordSpace = Math.ceil(textLength / 5),
            size = textLength + wordSpace + 1;
        $input.attr('size', Math.max(this.inputSize, $input.val().length));
      }, self));

      self.$container.on('keypress', 'input', $.proxy(function(event) {
         var $input = $(event.target);

         if (self.$element.attr('disabled')) {
            self.$input.attr('disabled', 'disabled');
            return;
         }

         var text = $input.val(),
         maxLengthReached = self.options.maxChars && text.length >= self.options.maxChars;
         if (self.options.freeInput && (keyCombinationInList(event, self.options.confirmKeys) || maxLengthReached)) {
            // Only attempt to add a tag if there is data in the field
            if (text.length !== 0) {
               self.add(maxLengthReached ? text.substr(0, self.options.maxChars) : text);
               $input.val('');
            }

            // If the field is empty, let the event triggered fire as usual
            if (self.options.cancelConfirmKeysOnEmpty === false) {
                event.preventDefault();
            }
         }

         // Reset internal input's size
         var textLength = $input.val().length,
            wordSpace = Math.ceil(textLength / 5),
            size = textLength + wordSpace + 1;
         $input.attr('size', Math.max(this.inputSize, $input.val().length));
      }, self));

      // Remove icon clicked
      self.$container.on('click', '[data-role=remove]', $.proxy(function(event) {
        if (self.$element.attr('disabled')) {
          return;
        }
        self.remove($(event.target).closest('.tag').data('item'));
      }, self));

      // Only add existing value as tags when using strings as tags
      if (self.options.itemValue === defaultOptions.itemValue) {
        if (self.$element[0].tagName === 'INPUT') {
            self.add(self.$element.val());
        } else {
          $('option', self.$element).each(function() {
            self.add($(this).attr('value'), true);
          });
        }
      }
    },

    /**
     * Removes all tagsinput behaviour and unregsiter all event handlers
     */
    destroy: function() {
      var self = this;

      // Unbind events
      self.$container.off('keypress', 'input');
      self.$container.off('click', '[role=remove]');

      self.$container.remove();
      self.$element.removeData('tagsinput');
      self.$element.show();
    },

    /**
     * Sets focus on the tagsinput
     */
    focus: function() {
      this.$input.focus();
    },

    /**
     * Returns the internal input element
     */
    input: function() {
      return this.$input;
    },

    /**
     * Returns the element which is wrapped around the internal input. This
     * is normally the $container, but typeahead.js moves the $input element.
     */
    findInputWrapper: function() {
      var elt = this.$input[0],
          container = this.$container[0];
      while(elt && elt.parentNode !== container)
        elt = elt.parentNode;

      return $(elt);
    }
  };

  /**
   * Register JQuery plugin
   */
  $.fn.tagsinput = function(arg1, arg2, arg3) {
    var results = [];

    this.each(function() {
      var tagsinput = $(this).data('tagsinput');
      // Initialize a new tags input
      if (!tagsinput) {
          tagsinput = new TagsInput(this, arg1);
          $(this).data('tagsinput', tagsinput);
          results.push(tagsinput);

          if (this.tagName === 'SELECT') {
              $('option', $(this)).attr('selected', 'selected');
          }

          // Init tags from $(this).val()
          $(this).val($(this).val());
      } else if (!arg1 && !arg2) {
          // tagsinput already exists
          // no function, trying to init
          results.push(tagsinput);
      } else if(tagsinput[arg1] !== undefined) {
          // Invoke function on existing tags input
            if(tagsinput[arg1].length === 3 && arg3 !== undefined){
               var retVal = tagsinput[arg1](arg2, null, arg3);
            }else{
               var retVal = tagsinput[arg1](arg2);
            }
          if (retVal !== undefined)
              results.push(retVal);
      }
    });

    if ( typeof arg1 == 'string') {
      // Return the results from the invoked function calls
      return results.length > 1 ? results : results[0];
    } else {
      return results;
    }
  };

  $.fn.tagsinput.Constructor = TagsInput;

  /**
   * Most options support both a string or number as well as a function as
   * option value. This function makes sure that the option with the given
   * key in the given options is wrapped in a function
   */
  function makeOptionItemFunction(options, key) {
    if (typeof options[key] !== 'function') {
      var propertyName = options[key];
      options[key] = function(item) { return item[propertyName]; };
    }
  }
  function makeOptionFunction(options, key) {
    if (typeof options[key] !== 'function') {
      var value = options[key];
      options[key] = function() { return value; };
    }
  }
  /**
   * HtmlEncodes the given value
   */
  var htmlEncodeContainer = $('<div />');
  function htmlEncode(value) {
    if (value) {
      return htmlEncodeContainer.text(value).html();
    } else {
      return '';
    }
  }

  /**
   * Returns the position of the caret in the given input field
   * http://flightschool.acylt.com/devnotes/caret-position-woes/
   */
  function doGetCaretPosition(oField) {
    var iCaretPos = 0;
    if (document.selection) {
      oField.focus ();
      var oSel = document.selection.createRange();
      oSel.moveStart ('character', -oField.value.length);
      iCaretPos = oSel.text.length;
    } else if (oField.selectionStart || oField.selectionStart == '0') {
      iCaretPos = oField.selectionStart;
    }
    return (iCaretPos);
  }

  /**
    * Returns boolean indicates whether user has pressed an expected key combination.
    * @param object keyPressEvent: JavaScript event object, refer
    *     http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
    * @param object lookupList: expected key combinations, as in:
    *     [13, {which: 188, shiftKey: true}]
    */
  function keyCombinationInList(keyPressEvent, lookupList) {
      var found = false;
      $.each(lookupList, function (index, keyCombination) {
          if (typeof (keyCombination) === 'number' && keyPressEvent.which === keyCombination) {
              found = true;
              return false;
          }

          if (keyPressEvent.which === keyCombination.which) {
              var alt = !keyCombination.hasOwnProperty('altKey') || keyPressEvent.altKey === keyCombination.altKey,
                  shift = !keyCombination.hasOwnProperty('shiftKey') || keyPressEvent.shiftKey === keyCombination.shiftKey,
                  ctrl = !keyCombination.hasOwnProperty('ctrlKey') || keyPressEvent.ctrlKey === keyCombination.ctrlKey;
              if (alt && shift && ctrl) {
                  found = true;
                  return false;
              }
          }
      });

      return found;
  }

  /**
   * Initialize tagsinput behaviour on inputs and selects which have
   * data-role=tagsinput
   */
  $(function() {
    $("input[data-role=tagsinput], select[multiple][data-role=tagsinput]").tagsinput();
  });
})(window.jQuery);

(function () {
  this.Specto = this.Specto || {};
  this.Specto.ui = this.Specto.ui || {};
  Specto.ui.defaults = Specto.ui.defaults || {};
  var ns = this.Specto.ui;

  /***************************************************************************************************/
  /******************************************* Combo Edit ********************************************/

  /*
      Note: This control avoid rendering options with empty "value" attribute.

      function ComboEdit(element, options) {
      }

      *********************
      
      element (<select><option>..</option>....</select>)

      *********************

      options: {
          placeholder:..,
          multiple: true/false/undefined(default),
          allowAdd: true/false(default),
          allowEdit: true/false(default),
          allowDelete: true/false(default),
          onAddBtnClick:..,
          onEditBtnClick:..,
          onDeleteBtnClick:..,
          onValueChanged:..,
          checkable: true/(default),
          showSelectionActions: true(default)/false,
          search: true(default)/false,
          isReadOnly: false(default)/ true
          ///////////TODO_N:
          editing: {
              allowUpdating: true, 
              allowAdding: true, 
              allowDeleting: true,
              mode: "row"|"batch"|"cell"|"form"|"popup",
              texts: {
                  confirmDeleteMessage: null
              }
          },
          customActions: [{ icon:.., text:.., onClick:.. }],          
          optionsIcons: { optionId: icon-class-name, ... },

          TODO_N:
          sortItems: true/false(default),
          minimumResultsForSearch: 1(default),
          isReadOnly: true/false(default),
          dir: "ltr"(default)/"rtl", 
          attr: {},
          onSearchKeypressCallback:..,
      }

      IMPORTANT NOTE: (The following js files are required and must be imported before this class)
        jqueryExtensions.js

      TODO_N:
        - On update option, merge option attributes and edit only passed properties. Ex, update only the text, or, disable an option, etc...
        - KeyNav: arrows navigation.
        - Implement multiple option.
        - //// Add Search box.
        - Add message if search box returns zero result "No results found".
        - Add search icon in search box.
        - Implement isReadOnly and rtl.
        - Allow option grouping.
        - Create custom icons.
        - Work on control css design.
        - Scrollable dropdown.
        - Create unique ids for custom options like select2 (data-select2-id ==> data-combo-id) to map the original select with the custom one.
          The reason why, sometimes some options haven't value attribute.
        - Refactor creation of empty select option.
        - Create pagination.
        - Implement input validation.
        - When re-open the control, reset the serach field and search result.
        - Add event monitor on select attribute change; when disabled attribute is added close to control if its opened.
        - Add enable method, to enable or disable the control.
        - If original option/choice is disabled reflect disable attribute on custom list choice.
  */
  ns.ComboEdit = (function () {
    const EditingMode = Object.freeze({
      NONE: "none",
      CELL: "cell",
      FORM: "form",
      POPUP: "popup"
    });

    var defaults = $.extend({}, {
      allowClear: false,
      allowAdd: false,
      allowEdit: false,
      allowDelete: false,
      //addIcon: FontAwesomeKey.addCircle,
      //eraserIcon: FontAwesomeKey.eraser,
      //editIcon: FontAwesomeKey.edit,
      //removeIcon: FontAwesomeKey.trash,
      //settingsIcon: FontAwesomeKey.settings,
      addIcon: "fa fa-plus-circle",
      eraserIcon: "fa fa-eraser",
      editIcon: "fa fa-pencil-square-o",
      removeIcon: "fa fa-trash-o",
      settingsIcon: "fa fa-cog", //fas fa-cog
      editingMode: EditingMode.NONE,
      //selectable: true,
      checkable: false,
      showSelectionActions: true,
      search: true,
      customActions: [],
      optionsIcons: {},
      isReadOnly: false
    }, Specto.ui.defaults.ComboEdit);

    var priv = new WeakMap();
    var _ = function (instance) { return priv.get(instance); };

    function ComboEdit(element, options) {
      // Original Select
      var $select = $(element);

      // When use $.extend, if the second object contains null or 0, those two values override the default values from the first object, but the undefined does not. 
      // So, for this reason, we use our created $.customExtend instead of $.extend.
      this.options = $.customExtend(true, {}, defaults, options);

      var privateMembers = {
        $select: $select,
        checkableInputsRandomName: Guid.generate(),
        $control: null, // This element represents the ComboEdit control (Main container)
        $selection: $("<span>").addClass("combo-ed-selection__selected-choices"), // Selection area
        $comboDropdown: $("<div>").addClass("combo-ed-dropdown"), // ComboEdit Dropdown area
        $customSelect: $("<ul>").addClass("combo-ed-select"), // Create custom select list
      };

      priv.set(this, privateMembers);

      // Initialize the ComboEdit
      init.call(this);
    }

    var init = function () {
      // 1. Prepare original select element settings:
      //    Hide select element.
      //    Set select element attributes from options. Like: disabled, multiple.
      //    Register change event.
      prepareSelectSettings.call(this);

      // 2. Create ComboEdit control
      //    The ComboEdit control consists of:
      //      1. Selection area:
      //         a. Placeholder/Selected items.
      //         b. Add new choice icon.
      //      2. Dropdown area:
      //         a. Search input field.
      //         b. Select results (options).
      var $control = _(this).$control = createControl.call(this);
      // Append the created ComboEdit control (custom select) after select input
      _(this).$select.after($control);

      if (this.options.checkable && !this.options.multiple) {
        var me = this;
        $(document).on("change", ":radio[name='" + _(this).checkableInputsRandomName + "']",
          function () {
            var value = $(this).val();
            setValue.call(me, value);
          });
      }
    };

    //#region ___________________________ Private Methods ___________________________


    //#region _______________ Shared Methods ______________

    var hasActions = function () {
      return this.options.allowEdit || this.options.allowDelete || this.options.customActions.length;
    };

    var allowClear = function () {
      return this.options.allowClear;// && !this.options.isReadOnly;
    };

    var addNewValue = function (option) {
      if (this.options.multiple) {
        appendValue.call(this, option.id);
      }
      else {
        setValue.call(this, option.id);
      }
    };

    var setValue = function (value) {
      // Note: The change() event handler is not being run when the value is set by val(), but it does run when 
      //  user selects a value with their mouse. So, for this reason we use .trigger("change");
      _(this).$select.val(value).trigger("change");
    };

    var appendValue = function (value) {
      var selectedValues = _(this).$select.val();

      if (selectedValues.indexOf(value) === -1) {
        selectedValues.push(value);
        setValue.call(this, selectedValues);
      }
    };

    var removeValue = function (value) {
      var selectedValues = _(this).$select.val();
      index = selectedValues.indexOf(value);
      selectedValues.splice(index, 1);

      setValue.call(this, selectedValues);
    };

    var getValue = function () {
      return _(this).$select.val();
    };

    var generateOptionObject = function (options) {
      // Convert <option> attributes to option object
      // this: is a jquery element
      var id = $(this).attr("value") ? $(this).attr("value") : 'o' + Guid.generate();

      return {
        id: id,
        text: $(this).text(),
        disabled: $(this).attr("disabled"),
        icon: $(this).attr("data-icon") || options.optionsIcons[id],
      };
    };

    //#endregion ____________ Shared Methods ______________


    //#region ____________ Select List Element ____________

    /**
     * Prepare original select element settings:
     *   Hide select element.
     *   Set select element attributes from options. Like: disabled, multiple.
     *   Register change event.
     */
    var prepareSelectSettings = function () {
      var $select = _(this).$select;

      // Hide the original select input
      $select.addClass("combo-ed-hidden");

      // Set select element attributes from options. Like: disabled, multiple.
      setSelectAttributes.call(this);

      // Register on change event
      var me = this;
      $select.change(function () {
        // The change event of the original select list element is triggered in two cases:
        //   1. User action: When user selects an option from ComboEdit control.
        //   2. Trigger the select change event directly outside this class. Ex: Inside the html page.
        // Then, this event must reflect this change on ComboEdit control.
        var value = $(this).val();
        onSelectElementChange.call(me, value);
      });
    };

    /**
     * Set select element attributes from options. Like: disabled, multiple.
     */
    var setSelectAttributes = function () {
      var $select = _(this).$select;

      // Add disabled attribute
      if (this.options.isReadOnly) {
        // If the select element does not has disabled attribute, add disabled attibute.
        !$select.attr("disabled") && $select.attr("disabled", "disabled");
      }

      // Add multiple attribute
      if (typeof (this.options.multiple) === "undefined") {
        this.options.multiple = !!$select.attr("multiple"); // Has multiple attribute
      }
      else {
        if (this.options.multiple) {
          !$select.attr("multiple") && $select.attr("multiple", "multiple");
        }
        else {
          !!$select.attr("multiple") && $select.removeAttr("multiple");
        }
      }
    };

    //#endregion _________ Select List Element ____________


    //#region ______________ Control Creation _____________

    /**
     * Create ComboEdit control.
     *   The ComboEdit control consists of:
     *     1. Selection area:
     *        a. Placeholder/Selected items.
     *        b. Add new choice icon.
     *     2. Dropdown area:
     *        a. Search input field.
     *        b. Select results (Choices).        
     * @returns {element} Return Dom Element. Representing the created ComboEdit control.
     */
    var createControl = function () {
      // Create ComboEdit control (Main container)
      var $control = $("<div>")
        .addClass("combo-ed")
        .click(function (e) {
          // When clicks on combo edit control, this event will be propagated
          //   to it's ancestor and child elements. 
          // Be carefull, the document element has a click event, that closes
          //   all combo controls opened.
          // Prevent closing the clicked combo control (prevent calling the document's click event).
          e.stopPropagation();
        });

      // Mark the control as selectable, if checkable option is false
      !this.options.checkable && $control.addClass("selectable");

      // a. Render selection area
      var $selection = createSelection.call(this);
      $control.append($selection);

      // b. Render dropdown area
      var $dropdown = createDropdown.call(this);
      $control.append($dropdown);

      return $control;
    };

    /**
     * Create selection area.  
     *   Selection area consists of:
     *     1. Placeholder/Selected items.
     *     2. Add new choice icon.
     * @returns {element} Return Dom Element. Representing the created selection area.
     */
    var createSelection = function () {
      var me = this;
      var $selection = $("<div>")
        .addClass("combo-ed-selection")
        .click(function () {
          toggleSelectList.call(me);
        });

      // 1. Append selected choices container
      $selection.append(_(this).$selection);

      // 2. Create add option icon
      if (this.options.allowAdd) {
        var addIcon = createIcon.call(this, {
          className: "add-icon", icon: this.options.addIcon, onClick: this.options.onAddBtnClick, stopPropagation: true
        });
        $selection.append(addIcon);
      }

      return $selection;
    };

    /**
     * Create custom dropdown area.
     *   Dropdown area consists of:
     *     1. Search input field.
     *     2. Select results (Choices).  
     * @returns {element} Return Dom Element. Representing the created dropdown area.
     */
    var createDropdown = function () {
      var $comboDropdown = _(this).$comboDropdown;

      // 1. Render search input
      if (this.options.search) {
        var $searchContainer = createSearchInput.call(this);
        $comboDropdown.append($searchContainer);
      }

      // 2. Render dropdown custom select list
      if (this.options.multiple) {
        var value = getValue.call(this);
        if (value && value.length) {
          if (!value[0]) {
            value.shift();
            _(this).$select.val(value);
          }
        }
      }
      var $customSelect = createDropdownCustomList.call(this);
      $comboDropdown.append($customSelect);

      return $comboDropdown;
    };

    var createDropdownCustomList = function () {
      var $customSelect = _(this).$customSelect;

      // 1. Render custom select options
      renderDropdownListChoices.call(this);

      var value = getValue.call(this);
      // 2. Reflect the value on custom select control for the first time
      renderSelectionOnUI.call(this, value); //$select.change(); (Prevent calling any other change event)

      if (this.options.checkable) {
        var selectedValues = this.options.multiple ? value : [value];

        $customSelect.find(".checkable-input").each(function () {
          if (selectedValues.indexOf($(this).val()) !== -1) {
            $(this).prop("checked", true);
          }
        });

      }


      return $customSelect;
    };

    var renderDropdownListChoices = function () {
      var $options = _(this).$select.find("option");

      var me = this;
      $options.each(function () {
        var value = $(this).attr("value");

        // For some browsers, `attr` is undefined; for others, `attr` is false.  Check for both.
        var hasValueAttr = typeof value !== typeof undefined && value !== false;

        //var text = $(this).text();

        // Avoid rendering empty options
        if (hasValueAttr && !value) {
          //return false; /* This statement breaks the loop */
          return; // This statement skips only the current
        }

        // Convert <option> attributes to option object
        var option = generateOptionObject.call($(this), me.options);
        renderDropdownChoice.call(me, option);
      });
    };

    var renderDropdownChoice = function (option) {
      var me = this;
      var li = $("<li>")
        .addClass("combo-ed-select-option")
        .attr("data-val", option.id)
        .click(function () {
          // Prevent closing the list, if the option is in edit mode
          //if ($(this).hasClass("editable")) {
          //    return;
          //}

          // Close the select list
          if (!me.options.checkable) {
            closeComboDropdown.call(me);
          }
        });

      _(this).$customSelect.append(li);

      if (this.options.checkable) {
        var $checkableInput = this.options.multiple ? createCheckbox.call(this, option.id, option.text) :
          createRadioButton.call(this, option.id);

        $checkableInput.addClass("checkable-input");

        li.append($checkableInput);
      }

      appendCustomOption.call(this, option, li);
    };

    var createCheckbox = function (value, text) {
      var me = this;
      var inputValue = "";
      if (value) {
        //inputValue = value.replace(' ', '_')
      }
      var container = $(`<div class="custom-control custom-checkbox mt-1">
        <input type="checkbox" class="custom-control-input" id="${value}" value="${value}" ${value.contains('checked') ? 'checked' : ''} ${text ? '' : 'disabled', value}>
        <label class="custom-control-label" for="{4}"></label>
      </div>`);
      if (value.contains('checked')) {
        appendValue.call(this, value);
      }
      container.find(`#${value}`)
        //.attr({ name: _(this).checkableInputsRandomName })
        .click(function () {
          var value = $(this).val();

          if ($(this).is(":checked")) {
            appendValue.call(me, value);
          }
          else {
            removeValue.call(me, value);
          }
        });
      return container;
    };

    var createRadioButton = function (value) {
      var me = this;
      return $("<input type='radio'>")
        .attr({ name: _(this).checkableInputsRandomName, "value": value });
    };

    var getchoiceCheckableInput = function (id) {
      var choice = getDropdownChoice.call(this, id);
      return choice.find(".checkable-input");
    };

    var renderOpenActionsBtn = function (container) {
      // This button is shown on mobile screens

      // Create open actions button
      var openActionsBtn = $("<label>")
        .addClass("combo-ed-actions-btn")
        .click(function (e) {
          var actionsContainer = $(this).parent().find(".combo-ed-actions-inner");

          var isOpened = $(this).hasClass("opened");
          if (!isOpened) {
            $(this).addClass("opened");
            //actionsContainer.show("slide", { direction: "right" }, 1000);
          }
          else {
            $(this).removeClass("opened");
            //actionsContainer.hide("slide", { direction: "right" }, 1000);
          }

          e.stopPropagation();
          e.preventDefault();
        });

      container.append(openActionsBtn);

      // Create a settings icon inside openActionsBtn
      var settingsIcon = createIcon.call(this, { className: "settings-icon", icon: this.options.settingsIcon });

      openActionsBtn.append(settingsIcon);
    };

    var closeActionsBar = function () {
      $(".combo-ed-actions-btn.opened").removeClass("opened");
    };

    var onSelectElementChange = function (value) {
      renderSelectionOnUI.call(this, value);

      if (this.options.onValueChanged) {
        var callback = this.options.onValueChanged instanceof Function ?
          this.options.onValueChanged : window[this.options.onValueChanged];

        callback(value);
      }
    };

    //#endregion ___________ Control Creation _____________


    //#region ______________ Icons Creation _______________

    var createOptionActions = function (option) {
      // Array of jquery elements
      var actions = [];

      // a. Create edit icon
      if (this.options.allowEdit) {
        var $editIcon = createEditIcon.call(this, option);
        actions.push($editIcon);
      }

      // b. Create remove icon
      if (this.options.allowDelete) {
        var $removeIcon = createRemoveIcon.call(this, option);
        actions.push($removeIcon);
      }

      // c. Create custom icons
      if (this.options.customActions) {
        for (var i = 0; i < this.options.customActions.length; i++) {
          var iconOptions = $.customExtend(true, { data: option.id }, this.options.customActions[i]);
          var $icon = createIcon.call(this, iconOptions);
          actions.push($icon);
        }
      }

      return actions;
    };

    var renderActions = function (actions, container) {
      // Create actions wrap
      var actionsWrap = $("<span>").addClass("combo-ed-actions");
      container.append(actionsWrap);

      // Create settings button for mobile screens
      renderOpenActionsBtn.call(this, actionsWrap);

      // Create option actions container
      var actionsInner = $("<span>").addClass("combo-ed-actions-inner");
      actionsWrap.append(actionsInner);

      // Render option actions
      for (var i = 0; i < actions.length; i++) {
        actionsInner.append(actions[i]);
      }
    };

    var createClearIcon = function () {
      var me = this;

      var clearIconOptions = {
        className: "clear-icon", icon: this.options.eraserIcon, onClick: function (e) {
          if (me.options.checkable) {
            // Unselect
            $(":radio[name='" + _(me).checkableInputsRandomName + "']").prop("checked", false);
          }

          setValue.call(me, null);
          openComboDropdown.call(me);
        },
        stopPropagation: true
      };

      return createIcon.call(this, clearIconOptions);
    };

    var createEditIcon = function (option) {
      var me = this;

      var editIconOptions = {
        data: option.id, className: "edit-icon", icon: this.options.editIcon, onClick: function (e, id) {
          if (me.options.onEditBtnClick) {
            var callback = me.options.onEditBtnClick instanceof Function ?
              me.options.onEditBtnClick : window[me.options.onEditBtnClick];

            callback(e, id);
          }

          switch (me.options.editingMode) {
            case EditingMode.CELL:
              var $customOption = getDropdownChoice.call(me, option.id);
              $customOption.addClass("editable");

              var $optionText = $customOption.find("> .combo-ed-option-txt");
              $optionText.attr("contenteditable", true);

              e.stopPropagation();
              break;
          }
        }
      };

      return createIcon.call(this, editIconOptions);
    };

    var createRemoveIcon = function (option) {
      var me = this;

      var removeIconOptions = { data: option.id, className: "remove-icon", icon: this.options.removeIcon, onClick: me.options.onDeleteBtnClick };
      return createIcon.call(this, removeIconOptions);
    };

    var createIcon = function (obj) {
      var icon = $("<i>")
        .addClass("combo-ed-icon")
        .addClass(obj.className)
        .addClass(obj.icon)
        .click(function (e) {
          if (obj.onClick) {
            var callback = obj.onClick instanceof Function ? obj.onClick : window[obj.onClick];
            callback(e, obj.data);
          }

          if (obj.stopPropagation) {
            e.stopPropagation();
          }
        });

      //var icon = $("<img>")
      //    .attr({ "src": obj.icon, "width": "25", "height": "25" })
      //    .addClass("combo-ed-icon")
      //    .addClass(obj.className)
      //    .click(function (e) {
      //        //e.stopPropagation();

      //        if (obj.onClick && obj.onClick instanceof Function) {
      //            obj.onClick(e, obj.data);
      //        }
      //    });

      return icon;
    };

    //#endregion ___________ Icons Creation _______________


    //#region _______________ Selected Area _______________

    var setSelection = function (option) {
      var $selection = _(this).$selection;

      // 1. Create selected item
      var selectedItem = createSelectedItem.call(this, option);
      $selection.append(selectedItem);

      if (this.options.multiple) {
        selectedItem.addClass("combo-ed-selection-selected--multiple");

        var me = this;
        var $removeIcon = $("<span>")
          .addClass("remove-selected-choice")
          .text("x").click(function () {
            if (me.options.checkable) {
              var $checkableInput = getchoiceCheckableInput.call(me, option.id);
              $checkableInput.prop("checked", false);
            }
            removeValue.call(me, option.id);
          });

        //selectedItem.append($removeIcon);
      }
      else {
        selectedItem.addClass("combo-ed-selection-selected--single");

        // 2. Append selection actions
        if (this.options.showSelectionActions) {
          renderSelectedItemActions.call(this, option, selectedItem);
        }
      }
    };

    var createSelectedItem = function (option) {
      // Create selected option container
      var selectedItem = $("<span>")
        .addClass("combo-ed-selection-selected")
        .attr("data-selected-val", option.id);

      // 1. Append option text
      var optionText = $("<span>")
        .addClass("combo-ed-selection-txt")
        .addClass("ellipsis-text");

      selectedItem.append(optionText);

      // a. Append option icon
      if (option.icon) {
        optionText.append($("<i>")
          .addClass("combo-ed-selection-icon")
          .addClass(option.icon));

        //var imageIcon = $("<img>").attr({ "src": option.icon, "width": "25", "height": "25" });
        //optionText.before(imageIcon);
      }

      // b. Append option text
      optionText.append(option.text);

      return selectedItem;
    };

    var renderSelectedItemActions = function (option, selectedItem) {
      if (allowClear.call(this) || hasActions.call(this)) {
        var actions = [];
        // a. Create clear icon
        if (allowClear.call(this)) {
          var clearIcon = createClearIcon.call(this);
          actions.push(clearIcon);
        }

        // b. Append option actions
        if (hasActions.call(this)) {
          actions = actions.concat(createOptionActions.call(this, option));
        }

        renderActions.call(this, actions, selectedItem);

        // c. Prevent all selection icons from toggle the select list control
        selectedItem.find(".combo-ed-actions-inner > .combo-ed-icon").click(function (e) {
          //e.stopPropagation();
        });
      }
    };

    var updateSelection = function (option) {
      //removeSelection.call(this);
      setSelection.call(this, option);
    };

    /*
    var removeSelection = function () {
        getSelection.call(this).empty();
        refreshSelection.call(this);
    };
    */

    var isOptionSelected = function (id) {
      var selectedItem = _(this).$selection.find(".combo-ed-selection-selected");

      return selectedItem.length && selectedItem.attr("data-selected-val") === id.toString();
    };

    var hasPlaceholder = function () {
      return this.options.placeholder;
    };

    var setPlaceholder = function () {
      var placeholder = $("<span>")
        .addClass("combo-ed-selection-placeholder")
        .text(this.options.placeholder);

      _(this).$selection.html(placeholder);
    };

    var selectOption = function (id) {
      // 1. Mark the custom option as selected
      var $selectedOption = getDropdownChoice.call(this, id);
      $selectedOption.addClass("selected");

      // 2. Select the new value
      var $option = getSelectOption.call(this, id);

      // Convert <option> attributes to option object
      var option = generateOptionObject.call($option, this.options);
      setSelection.call(this, option);
    };

    var setCounter = function (counter) {
      var $selection = _(this).$selection;
      var selectedItem = $("<span>").append(`<span>${counter} selected</span>`);
      $selection.append(selectedItem);
    };

    //var unSelectOption = function (id) {
    //    // 1. Remove selected class from custom option
    //    var $selectedOption = getDropdownChoice.call(this, id);
    //    $selectedOption.removeClass("selected");

    //    // Create selected option container
    //    var selectedItem = _(this).$selection.find("combo-ed-selection-selected[data-selected-val='" + id + "']");
    //    selectedItem.remove();
    //};

    var renderSelectionOnUI = function (value) {
      // 1. Unselect the previous value
      _(this).$customSelect.find(".combo-ed-select-option.selected").removeClass("selected");

      // 2. Empty selection container
      _(this).$selection.empty();

      if (!this.options.multiple) {
        // 3. Reflect the selected value on selection area, or show the placeholder if the value is empty.
        if (value) {
          selectOption.call(this, value);
        } else if (hasPlaceholder.call(this)) {
          setPlaceholder.call(this);
        }
      }
      else {
        if (value && value.length) {
          if (this.options.showCounter) {
            setCounter.call(this, value.length)
          }
          else {
            for (var i = 0; i < value.length; i++) {
              selectOption.call(this, value[i]);
            }
          }
        }
        else if (hasPlaceholder.call(this)) {
          setPlaceholder.call(this);
        }
      }
    };

    //#endregion ____________ Selected Area _______________


    //#region _______________ Search Input ________________

    var createSearchInput = function () {
      var $searchContainer = $("<span>").addClass("combo-ed-search-wrap");

      var me = this;
      var searchInput = $("<input>")
        .addClass("combo-ed-search-inp")
        .attr({ type: "search", autocomplete: "off", autocorrect: "off", autocapitalize: "none", spellcheck: "false" })
        .keyup(function (e) {
          var searchText = $(this).val().toLocaleLowerCase();

          _(me).$customSelect.find(".combo-ed-select-option")
            .removeClass("hidden")
            .each(function () {
              if ($(this).text().toLocaleLowerCase().indexOf(searchText) === -1) {
                $(this).addClass("hidden");
              }
            });
        });

      $searchContainer.append(searchInput);

      return $searchContainer;
    };

    //#endregion ____________ Search Input ________________


    //#region ________________ Select List ________________

    var toggleSelectList = function () {
      var isOpened = _(this).$control.hasClass("combo-ed--open");
      if (!isOpened) {
        openComboDropdown.call(this);
      }
      else {
        closeComboDropdown.call(this);
      }
    };

    var openComboDropdown = function () {
      var $control = _(this).$control;

      $control.addClass("combo-ed--open");
      _(this).$comboDropdown.slideDown();

      var me = this;
      setTimeout(function () {
        $control.find(".combo-ed-search-inp").focus();
      }, 200);
    };

    var closeComboDropdown = function () {
      _(this).$control.removeClass("combo-ed--open");
      _(this).$comboDropdown.slideUp();

      // This feature is shown only on small screens
      closeActionsBar.call(this);
    };

    //#endregion _____________ Select List ________________


    //#region _______________ Select Option _______________

    var getSelectOption = function (id) {
      return _(this).$select.find("option[value='" + id + "']");
    };

    var getDropdownChoice = function (id) {
      return _(this).$customSelect.find("li[data-val='" + id + "']");
    };

    var appendOption = function (option) {
      var $option = $("<option>")
        .attr("value", option.id)
        .text(option.text);

      _(this).$select.append($option);
    };

    var appendCustomOption = function (option, customOption) {
      // 1. Create option text
      var me = this;
      var hasText = !!option.text;

      var optionText = $("<span>")
        .addClass("combo-ed-option-txt");

      if (!this.options.checkable) {
        optionText.click(function () {
          addNewValue.call(me, option);
        });
      }

      if (!hasText) {
        optionText.addClass("combo-ed-option-empty-txt");
      }

      customOption.append(optionText);

      // a. Append option icon
      if (option.icon) {
        optionText.append($("<i>")
          .addClass("combo-ed-option-icon")
          .addClass(option.icon));
        //var imageIcon = $("<img>").attr({ "src": option.icon, "width": "25", "height": "25" });
        //optionText.before(imageIcon);
      }

      // b. Append option text
      optionText.append(option.text);

      // 2. Append option actions (Append actions only if there is an option text)
      if (hasText && hasActions.call(this)) {
        var actions = createOptionActions.call(this, option);
        renderActions.call(this, actions, customOption);
      }
    };

    var updateOption = function (option) {
      var $option = getSelectOption.call(this, option.id);
      $option.text(option.text);
    };

    var updateCustomOption = function (option) {
      var $customOption = getDropdownChoice.call(this, option.id);
      $customOption.empty();
      appendCustomOption.call(this, option, $customOption);
    };

    var removeOption = function (id) {
      getSelectOption.call(this, id).remove();
    };

    var removeCustomOption = function (id) {
      getDropdownChoice.call(this, id).remove();
    };

    //#endregion ____________ Select Option _______________


    //#endregion ________________________ Private Methods ___________________________


    ComboEdit.prototype.renderOn = function (container) {
      container
        .append(_(this).$select)
        .append(_(this).$control);
    };

    ComboEdit.prototype.open = function () {
      openComboDropdown.call(this);
    };

    ComboEdit.prototype.close = function () {
      closeComboDropdown.call(this);
    };

    ComboEdit.prototype.destroy = function () {
      var $select = _(this).$select;

      $select.unbind("change", onSelectElementChange);
      _(this).$control.remove();
      $select.removeClass("combo-ed-hidden");
    };

    //TODO_N
    ComboEdit.prototype.val = function (value) {
      if (!value) {
        // Get
        return getValue.call(this);
      }
      else {
        // Set
        setValue.call(this, value);
      }
    };

    //TODO_N
    ComboEdit.prototype.add = function (option) {
      // Append the option on the original list
      appendOption.call(this, option);

      // Reflect this option on custom list
      renderDropdownChoice.call(this, option);

      // Select the added option
      addNewValue.call(this, option.id);

      // Open select list
      openComboDropdown.call(this);
    };

    //TODO_N
    ComboEdit.prototype.edit = function (option) {
      // Update the original list option
      updateOption.call(this, option);

      // Reflect this update on the custom list option
      updateCustomOption.call(this, option);

      // If this option is selected, reflect the update on the selection area
      if (isOptionSelected.call(this, option.id)) {
        updateSelection.call(this, option);
      }
    };

    //TODO_N
    ComboEdit.prototype.delete = function (id) {
      // Delete the option from the original list
      removeOption.call(this, id);

      // Delete the option from the custom list
      removeCustomOption.call(this, id);

      // If this option is selected, only trigger the change event after delete it, to reflect the new selected 
      //  value on ui. Note: After delete an option, the selected value becomes either empty value if there is an 
      //  empty option created '<option></option>' in the select list, or the first option in the list. Select 
      //  element marks the first option as selected, if there is no empty option exist in the list.
      if (isOptionSelected.call(this, id)) {
        _(this).$select.trigger("change");
      }
    };

    return ComboEdit;
  })();

  //*****************************************************************************//
  //****************************** Document Events ******************************//

  // Register this event once for all controls of type ComboEdit on a page
  $(document).click(function () {
    // Get all opened controls and close them
    $(".combo-ed.combo-ed--open")
      .removeClass("combo-ed--open")
      .find(".combo-ed-dropdown").slideUp();

    // Get all opened actions bars (This feature is shown only on small screens)
    $(".combo-ed-actions-btn.opened").removeClass("opened");
  });

  //*****************************************************************************//
  //******************************* jQuery Plugin *******************************//

  /*
      $(selector).comboEdit(options);
      $(selector).comboEdit("open"); // Open the combo list
      $(selector).comboEdit("close"); // Close the combo list
      $(selector).comboEdit("destroy"); // Destroy comboEdit created
      $(selector).comboEdit("val"); // Get selected value
      $(selector).comboEdit("val", newValue); // Set value
      $(selector).comboEdit("add", { id:.., text:.., .... }); // Add a new option
      $(selector).comboEdit("edit", { id:.., text:.., .... }); // Update option
      $(selector).comboEdit("delete", id); // Delete an option by id
  */

  var pluginName = "comboEdit";

  $.fn[pluginName] = function (param) {
    // All methods that should return the element
    var thisMethods = ['open', 'close', 'destroy', 'add'];

    if (typeof param === 'object') {
      return this.each(function () {
        // Destroy created combo edit
        if ($.data(this, pluginName)) {
          var instance = $(this).data(pluginName);
          instance.destroy();
        }
        // Create a new instance of comboEdit
        $.data(this, pluginName, new Specto.ui.ComboEdit(this, param));
      });
    }
    else if (typeof param === 'string') {
      // Get  main function argument values
      var args = Array.prototype.slice.call(arguments, 1);

      var returnValue;

      this.each(function () {
        var instance = $(this).data(pluginName);

        //if (instance == null && window.console && console.error) {
        if (instance === null) {
          console.error('The ' + pluginName + '(\'' + param + '\') method was called on an ' + 'element that is not using ' + pluginName + '.');
        }

        // Remove the instance from element data
        if (param === 'destroy') {
          $.data(this, pluginName, null);
        }

        // Call the method
        returnValue = instance[param].apply(instance, args);
      });

      // Check if we should be returning `this`
      if ($.inArray(param, thisMethods) > -1) {
        return this;
      }

      return returnValue;
    }
    else {
      throw new Error('Invalid arguments for ' + pluginName + ': ' + param);
    }
  };

  //*****************************************************************************//
})();

/*!
 * Signature Pad v3.0.0-beta.3 | https://github.com/szimek/signature_pad
 * (c) 2020 Szymon Nowak | Released under the MIT license
 */

(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    (global = global || self, global.SignaturePad = factory());
}(this, (function () { 'use strict';

    var Point = (function () {
        function Point(x, y, time) {
            this.x = x;
            this.y = y;
            this.time = time || Date.now();
        }
        Point.prototype.distanceTo = function (start) {
            return Math.sqrt(Math.pow(this.x - start.x, 2) + Math.pow(this.y - start.y, 2));
        };
        Point.prototype.equals = function (other) {
            return this.x === other.x && this.y === other.y && this.time === other.time;
        };
        Point.prototype.velocityFrom = function (start) {
            return this.time !== start.time
                ? this.distanceTo(start) / (this.time - start.time)
                : 0;
        };
        return Point;
    }());

    var Bezier = (function () {
        function Bezier(startPoint, control2, control1, endPoint, startWidth, endWidth) {
            this.startPoint = startPoint;
            this.control2 = control2;
            this.control1 = control1;
            this.endPoint = endPoint;
            this.startWidth = startWidth;
            this.endWidth = endWidth;
        }
        Bezier.fromPoints = function (points, widths) {
            var c2 = this.calculateControlPoints(points[0], points[1], points[2]).c2;
            var c3 = this.calculateControlPoints(points[1], points[2], points[3]).c1;
            return new Bezier(points[1], c2, c3, points[2], widths.start, widths.end);
        };
        Bezier.calculateControlPoints = function (s1, s2, s3) {
            var dx1 = s1.x - s2.x;
            var dy1 = s1.y - s2.y;
            var dx2 = s2.x - s3.x;
            var dy2 = s2.y - s3.y;
            var m1 = { x: (s1.x + s2.x) / 2.0, y: (s1.y + s2.y) / 2.0 };
            var m2 = { x: (s2.x + s3.x) / 2.0, y: (s2.y + s3.y) / 2.0 };
            var l1 = Math.sqrt(dx1 * dx1 + dy1 * dy1);
            var l2 = Math.sqrt(dx2 * dx2 + dy2 * dy2);
            var dxm = m1.x - m2.x;
            var dym = m1.y - m2.y;
            var k = l2 / (l1 + l2);
            var cm = { x: m2.x + dxm * k, y: m2.y + dym * k };
            var tx = s2.x - cm.x;
            var ty = s2.y - cm.y;
            return {
                c1: new Point(m1.x + tx, m1.y + ty),
                c2: new Point(m2.x + tx, m2.y + ty)
            };
        };
        Bezier.prototype.length = function () {
            var steps = 10;
            var length = 0;
            var px;
            var py;
            for (var i = 0; i <= steps; i += 1) {
                var t = i / steps;
                var cx = this.point(t, this.startPoint.x, this.control1.x, this.control2.x, this.endPoint.x);
                var cy = this.point(t, this.startPoint.y, this.control1.y, this.control2.y, this.endPoint.y);
                if (i > 0) {
                    var xdiff = cx - px;
                    var ydiff = cy - py;
                    length += Math.sqrt(xdiff * xdiff + ydiff * ydiff);
                }
                px = cx;
                py = cy;
            }
            return length;
        };
        Bezier.prototype.point = function (t, start, c1, c2, end) {
            return (start * (1.0 - t) * (1.0 - t) * (1.0 - t))
                + (3.0 * c1 * (1.0 - t) * (1.0 - t) * t)
                + (3.0 * c2 * (1.0 - t) * t * t)
                + (end * t * t * t);
        };
        return Bezier;
    }());

    function throttle(fn, wait) {
        if (wait === void 0) { wait = 250; }
        var previous = 0;
        var timeout = null;
        var result;
        var storedContext;
        var storedArgs;
        var later = function () {
            previous = Date.now();
            timeout = null;
            result = fn.apply(storedContext, storedArgs);
            if (!timeout) {
                storedContext = null;
                storedArgs = [];
            }
        };
        return function wrapper() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            var now = Date.now();
            var remaining = wait - (now - previous);
            storedContext = this;
            storedArgs = args;
            if (remaining <= 0 || remaining > wait) {
                if (timeout) {
                    clearTimeout(timeout);
                    timeout = null;
                }
                previous = now;
                result = fn.apply(storedContext, storedArgs);
                if (!timeout) {
                    storedContext = null;
                    storedArgs = [];
                }
            }
            else if (!timeout) {
                timeout = window.setTimeout(later, remaining);
            }
            return result;
        };
    }

    var SignaturePad = (function () {
        function SignaturePad(canvas, options) {
            var _this = this;
            if (options === void 0) { options = {}; }
            this.canvas = canvas;
            this.options = options;
            this._handleMouseDown = function (event) {
                if (event.which === 1) {
                    _this._mouseButtonDown = true;
                    _this._strokeBegin(event);
                }
            };
            this._handleMouseMove = function (event) {
                if (_this._mouseButtonDown) {
                    _this._strokeMoveUpdate(event);
                }
            };
            this._handleMouseUp = function (event) {
                if (event.which === 1 && _this._mouseButtonDown) {
                    _this._mouseButtonDown = false;
                    _this._strokeEnd(event);
                }
            };
            this._handleTouchStart = function (event) {
                event.preventDefault();
                if (event.targetTouches.length === 1) {
                    var touch = event.changedTouches[0];
                    _this._strokeBegin(touch);
                }
            };
            this._handleTouchMove = function (event) {
                event.preventDefault();
                var touch = event.targetTouches[0];
                _this._strokeMoveUpdate(touch);
            };
            this._handleTouchEnd = function (event) {
                var wasCanvasTouched = event.target === _this.canvas;
                if (wasCanvasTouched) {
                    event.preventDefault();
                    var touch = event.changedTouches[0];
                    _this._strokeEnd(touch);
                }
            };
            this.velocityFilterWeight = options.velocityFilterWeight || 0.7;
            this.minWidth = options.minWidth || 0.5;
            this.maxWidth = options.maxWidth || 2.5;
            this.throttle = ('throttle' in options ? options.throttle : 16);
            this.minDistance = ('minDistance' in options
                ? options.minDistance
                : 5);
            this.dotSize =
                options.dotSize ||
                    function dotSize() {
                        return (this.minWidth + this.maxWidth) / 2;
                    };
            this.penColor = options.penColor || 'black';
            this.backgroundColor = options.backgroundColor || 'rgba(0,0,0,0)';
            this.onBegin = options.onBegin;
            this.onEnd = options.onEnd;
            this._strokeMoveUpdate = this.throttle
                ? throttle(SignaturePad.prototype._strokeUpdate, this.throttle)
                : SignaturePad.prototype._strokeUpdate;
            this._ctx = canvas.getContext('2d');
            this.clear();
            this.on();
        }
        SignaturePad.prototype.clear = function () {
            var _a = this, ctx = _a._ctx, canvas = _a.canvas;
            ctx.fillStyle = this.backgroundColor;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            this._data = [];
            this._reset();
            this._isEmpty = true;
        };
        SignaturePad.prototype.fromDataURL = function (dataUrl, options, callback) {
            var _this = this;
            if (options === void 0) { options = {}; }
            var image = new Image();
            var ratio = options.ratio || window.devicePixelRatio || 1;
            var width = options.width || this.canvas.width / ratio;
            var height = options.height || this.canvas.height / ratio;
            this._reset();
            image.onload = function () {
                _this._ctx.drawImage(image, 0, 0, width, height);
                if (callback) {
                    callback();
                }
            };
            image.onerror = function (error) {
                if (callback) {
                    callback(error);
                }
            };
            image.src = dataUrl;
            this._isEmpty = false;
        };
        SignaturePad.prototype.toDataURL = function (type, encoderOptions) {
            if (type === void 0) { type = 'image/png'; }
            switch (type) {
                case 'image/svg+xml':
                    return this._toSVG();
                default:
                    return this.canvas.toDataURL(type, encoderOptions);
            }
        };
        SignaturePad.prototype.on = function () {
            this.canvas.style.touchAction = 'none';
            this.canvas.style.msTouchAction = 'none';
            if (window.PointerEvent) {
                this._handlePointerEvents();
            }
            else {
                this._handleMouseEvents();
                if ('ontouchstart' in window) {
                    this._handleTouchEvents();
                }
            }
        };
        SignaturePad.prototype.off = function () {
            this.canvas.style.touchAction = 'auto';
            this.canvas.style.msTouchAction = 'auto';
            this.canvas.removeEventListener('pointerdown', this._handleMouseDown);
            this.canvas.removeEventListener('pointermove', this._handleMouseMove);
            document.removeEventListener('pointerup', this._handleMouseUp);
            this.canvas.removeEventListener('mousedown', this._handleMouseDown);
            this.canvas.removeEventListener('mousemove', this._handleMouseMove);
            document.removeEventListener('mouseup', this._handleMouseUp);
            this.canvas.removeEventListener('touchstart', this._handleTouchStart);
            this.canvas.removeEventListener('touchmove', this._handleTouchMove);
            this.canvas.removeEventListener('touchend', this._handleTouchEnd);
        };
        SignaturePad.prototype.isEmpty = function () {
            return this._isEmpty;
        };
        SignaturePad.prototype.fromData = function (pointGroups) {
            var _this = this;
            this.clear();
            this._fromData(pointGroups, function (_a) {
                var color = _a.color, curve = _a.curve;
                return _this._drawCurve({ color: color, curve: curve });
            }, function (_a) {
                var color = _a.color, point = _a.point;
                return _this._drawDot({ color: color, point: point });
            });
            this._data = pointGroups;
        };
        SignaturePad.prototype.toData = function () {
            return this._data;
        };
        SignaturePad.prototype._strokeBegin = function (event) {
            var newPointGroup = {
                color: this.penColor,
                points: []
            };
            if (typeof this.onBegin === 'function') {
                this.onBegin(event);
            }
            this._data.push(newPointGroup);
            this._reset();
            this._strokeUpdate(event);
        };
        SignaturePad.prototype._strokeUpdate = function (event) {
            var x = event.clientX;
            var y = event.clientY;
            var point = this._createPoint(x, y);
            var lastPointGroup = this._data[this._data.length - 1];
            var lastPoints = lastPointGroup.points;
            var lastPoint = lastPoints.length > 0 && lastPoints[lastPoints.length - 1];
            var isLastPointTooClose = lastPoint
                ? point.distanceTo(lastPoint) <= this.minDistance
                : false;
            var color = lastPointGroup.color;
            if (!lastPoint || !(lastPoint && isLastPointTooClose)) {
                var curve = this._addPoint(point);
                if (!lastPoint) {
                    this._drawDot({ color: color, point: point });
                }
                else if (curve) {
                    this._drawCurve({ color: color, curve: curve });
                }
                lastPoints.push({
                    time: point.time,
                    x: point.x,
                    y: point.y
                });
            }
        };
        SignaturePad.prototype._strokeEnd = function (event) {
            this._strokeUpdate(event);
            if (typeof this.onEnd === 'function') {
                this.onEnd(event);
            }
        };
        SignaturePad.prototype._handlePointerEvents = function () {
            this._mouseButtonDown = false;
            this.canvas.addEventListener('pointerdown', this._handleMouseDown);
            this.canvas.addEventListener('pointermove', this._handleMouseMove);
            document.addEventListener('pointerup', this._handleMouseUp);
        };
        SignaturePad.prototype._handleMouseEvents = function () {
            this._mouseButtonDown = false;
            this.canvas.addEventListener('mousedown', this._handleMouseDown);
            this.canvas.addEventListener('mousemove', this._handleMouseMove);
            document.addEventListener('mouseup', this._handleMouseUp);
        };
        SignaturePad.prototype._handleTouchEvents = function () {
            this.canvas.addEventListener('touchstart', this._handleTouchStart);
            this.canvas.addEventListener('touchmove', this._handleTouchMove);
            this.canvas.addEventListener('touchend', this._handleTouchEnd);
        };
        SignaturePad.prototype._reset = function () {
            this._lastPoints = [];
            this._lastVelocity = 0;
            this._lastWidth = (this.minWidth + this.maxWidth) / 2;
            this._ctx.fillStyle = this.penColor;
        };
        SignaturePad.prototype._createPoint = function (x, y) {
            var rect = this.canvas.getBoundingClientRect();
            return new Point(x - rect.left, y - rect.top, new Date().getTime());
        };
        SignaturePad.prototype._addPoint = function (point) {
            var _lastPoints = this._lastPoints;
            _lastPoints.push(point);
            if (_lastPoints.length > 2) {
                if (_lastPoints.length === 3) {
                    _lastPoints.unshift(_lastPoints[0]);
                }
                var widths = this._calculateCurveWidths(_lastPoints[1], _lastPoints[2]);
                var curve = Bezier.fromPoints(_lastPoints, widths);
                _lastPoints.shift();
                return curve;
            }
            return null;
        };
        SignaturePad.prototype._calculateCurveWidths = function (startPoint, endPoint) {
            var velocity = this.velocityFilterWeight * endPoint.velocityFrom(startPoint) +
                (1 - this.velocityFilterWeight) * this._lastVelocity;
            var newWidth = this._strokeWidth(velocity);
            var widths = {
                end: newWidth,
                start: this._lastWidth
            };
            this._lastVelocity = velocity;
            this._lastWidth = newWidth;
            return widths;
        };
        SignaturePad.prototype._strokeWidth = function (velocity) {
            return Math.max(this.maxWidth / (velocity + 1), this.minWidth);
        };
        SignaturePad.prototype._drawCurveSegment = function (x, y, width) {
            var ctx = this._ctx;
            ctx.moveTo(x, y);
            ctx.arc(x, y, width, 0, 2 * Math.PI, false);
            this._isEmpty = false;
        };
        SignaturePad.prototype._drawCurve = function (_a) {
            var color = _a.color, curve = _a.curve;
            var ctx = this._ctx;
            var widthDelta = curve.endWidth - curve.startWidth;
            var drawSteps = Math.floor(curve.length()) * 2;
            ctx.beginPath();
            ctx.fillStyle = color;
            for (var i = 0; i < drawSteps; i += 1) {
                var t = i / drawSteps;
                var tt = t * t;
                var ttt = tt * t;
                var u = 1 - t;
                var uu = u * u;
                var uuu = uu * u;
                var x = uuu * curve.startPoint.x;
                x += 3 * uu * t * curve.control1.x;
                x += 3 * u * tt * curve.control2.x;
                x += ttt * curve.endPoint.x;
                var y = uuu * curve.startPoint.y;
                y += 3 * uu * t * curve.control1.y;
                y += 3 * u * tt * curve.control2.y;
                y += ttt * curve.endPoint.y;
                var width = Math.min(curve.startWidth + ttt * widthDelta, this.maxWidth);
                this._drawCurveSegment(x, y, width);
            }
            ctx.closePath();
            ctx.fill();
        };
        SignaturePad.prototype._drawDot = function (_a) {
            var color = _a.color, point = _a.point;
            var ctx = this._ctx;
            var width = typeof this.dotSize === 'function' ? this.dotSize() : this.dotSize;
            ctx.beginPath();
            this._drawCurveSegment(point.x, point.y, width);
            ctx.closePath();
            ctx.fillStyle = color;
            ctx.fill();
        };
        SignaturePad.prototype._fromData = function (pointGroups, drawCurve, drawDot) {
            for (var _i = 0, pointGroups_1 = pointGroups; _i < pointGroups_1.length; _i++) {
                var group = pointGroups_1[_i];
                var color = group.color, points = group.points;
                if (points.length > 1) {
                    for (var j = 0; j < points.length; j += 1) {
                        var basicPoint = points[j];
                        var point = new Point(basicPoint.x, basicPoint.y, basicPoint.time);
                        this.penColor = color;
                        if (j === 0) {
                            this._reset();
                        }
                        var curve = this._addPoint(point);
                        if (curve) {
                            drawCurve({ color: color, curve: curve });
                        }
                    }
                }
                else {
                    this._reset();
                    drawDot({
                        color: color,
                        point: points[0]
                    });
                }
            }
        };
        SignaturePad.prototype._toSVG = function () {
            var _this = this;
            var pointGroups = this._data;
            var ratio = Math.max(window.devicePixelRatio || 1, 1);
            var minX = 0;
            var minY = 0;
            var maxX = this.canvas.width / ratio;
            var maxY = this.canvas.height / ratio;
            var svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.setAttribute('width', this.canvas.width.toString());
            svg.setAttribute('height', this.canvas.height.toString());
            this._fromData(pointGroups, function (_a) {
                var color = _a.color, curve = _a.curve;
                var path = document.createElement('path');
                if (!isNaN(curve.control1.x) &&
                    !isNaN(curve.control1.y) &&
                    !isNaN(curve.control2.x) &&
                    !isNaN(curve.control2.y)) {
                    var attr = "M " + curve.startPoint.x.toFixed(3) + "," + curve.startPoint.y.toFixed(3) + " " +
                        ("C " + curve.control1.x.toFixed(3) + "," + curve.control1.y.toFixed(3) + " ") +
                        (curve.control2.x.toFixed(3) + "," + curve.control2.y.toFixed(3) + " ") +
                        (curve.endPoint.x.toFixed(3) + "," + curve.endPoint.y.toFixed(3));
                    path.setAttribute('d', attr);
                    path.setAttribute('stroke-width', (curve.endWidth * 2.25).toFixed(3));
                    path.setAttribute('stroke', color);
                    path.setAttribute('fill', 'none');
                    path.setAttribute('stroke-linecap', 'round');
                    svg.appendChild(path);
                }
            }, function (_a) {
                var color = _a.color, point = _a.point;
                var circle = document.createElement('circle');
                var dotSize = typeof _this.dotSize === 'function' ? _this.dotSize() : _this.dotSize;
                circle.setAttribute('r', dotSize.toString());
                circle.setAttribute('cx', point.x.toString());
                circle.setAttribute('cy', point.y.toString());
                circle.setAttribute('fill', color);
                svg.appendChild(circle);
            });
            var prefix = 'data:image/svg+xml;base64,';
            var header = '<svg' +
                ' xmlns="http://www.w3.org/2000/svg"' +
                ' xmlns:xlink="http://www.w3.org/1999/xlink"' +
                (" viewBox=\"" + minX + " " + minY + " " + maxX + " " + maxY + "\"") +
                (" width=\"" + maxX + "\"") +
                (" height=\"" + maxY + "\"") +
                '>';
            var body = svg.innerHTML;
            if (body === undefined) {
                var dummy = document.createElement('dummy');
                var nodes = svg.childNodes;
                dummy.innerHTML = '';
                for (var i = 0; i < nodes.length; i += 1) {
                    dummy.appendChild(nodes[i].cloneNode(true));
                }
                body = dummy.innerHTML;
            }
            var footer = '</svg>';
            var data = header + body + footer;
            return prefix + btoa(data);
        };
        return SignaturePad;
    }());

    return SignaturePad;

})));
//# sourceMappingURL=signature_pad.umd.js.map

window.mkd = {
  P_VIEW: 'pvu',
  P_EDIT: 'pe',
  P_REMOVE: 'pr',
  P_ADD: 'pa',
};

/**
 * All editable fields inherit this.
 */
 class BaseEditableField {
  constructor(field, renderOn, onChangeCallback) {
    this.field = field;
    this.renderOn = renderOn;
    this.onChangeCallback = onChangeCallback || function () { };
  }

  render(value, allFieldsValues) {
    this.onBeforeRender(value);
    this._render(value, allFieldsValues);
    if (!this.field['readonly']) {
      if (value == undefined) {
        value = this.value || '';
      }
      this.onAfterRender(value);
    }
  }

  onBeforeRender(value) {
    if (this.field['readonly']) {
      if (this.renderOn.parent('tr').length > 0) {
        var div = $('<div class="readonly-box-inside p-2 mt-3">');
        var label = `<span class="hidden-sm-down form-label text-muted readonly-label-inside">${this.field['d'] || this.field['n']}</span>`;
        this.renderOn.append(div);
        this.renderOn = div;
        $(label).appendTo(this.renderOn.parent());
      } else {
        this.renderOn.addClass('readonly-box mb-2 pl-2 mt-2');
        var label = `<label class="form-label text-muted readonly-label">${this.field['d'] || this.field['n']}</label>`;
        this.renderOn.append(label);
      }
    }
  }

  _render(value, allFieldsValues) {
    if (this.field['readonly']) {
      BaseEditableField.renderReadOnlyValue(this.renderOn, value, this.field);
      return;
    }
    this.container = $('<div class="form-group w-100">');

    // Add input field to container
    this.input = $('<input class="form-control">').attr("id", this.field["n"]);
    this.input.appendTo(this.container);

    if (this.field['class']) {
      this.input.addClass(this.field['class']);
    }

    // Add prefix/suffix input group if exist
    var sideLabel = this.field["prefix"] || this.field["suffix"];
    if (sideLabel) {
      this.dFlex = $('<div style="display:flex"></div>')
        .appendTo(this.renderOn);

      this.container.appendTo(this.dFlex);
      if (this.field["prefix"]) {
        var prefixInput = $(
          `<div>
          <span class="input-group-text">${this.field["prefix"]}</span>
          </div>`);
        prefixInput.addClass("input-group-prepend");
        this.dFlex.prepend(prefixInput);
        prefixInput
          .find(".input-group-text")
          .css("border-radius", "4px 0px 0px 4px");
        this.input.css("border-radius", "0px 4px 4px 0px");
      }
      if (this.field["suffix"]) {
        var suffixInput = $(
          `<div>
          <span class="input-group-text">${this.field["suffix"]}</span>
          </div>`);
        suffixInput.addClass("input-group-append mb-0");
        this.dFlex.append(suffixInput);
        suffixInput
          .find(".input-group-text")
          .css("border-radius", "0px 4px 4px 0px");
        this.input.css("border-radius", "4px 0px 0px 4px");
        this.container.removeClass("form-group");
      }
    } else {
      this.container.appendTo(this.renderOn);
    }

    var me = this;
    this.input.on("input", function () {
      this.setAttribute("data-val", this.value);
      me.onChangeCallback();
    });

    if (value != undefined) {
      this.setValue(value);
      this.input.change();
    } else {
      this.input.attr("data-val", "");
    }

    this.labelContainer = this.blurbContainer = this.container;
    this.labelInput = this.input;

    return this.input;
  }

  onAfterRender(value = '') {
    if (this.field['inline']) {
      this.renderOn.removeClass(function (index, className) {
        return (className.match(/(^|\s)col-\S+/g) || []).join(' ');
      });
      this.renderOn.addClass('mx-1');
      this.renderOn.prevAll('.editingDiv:first').removeClass(function (index, className) {
        return (className.match(/(^|\s)col-\S+/g) || []).join(' ');
      });
    }
    var blurbContainer = this.blurbContainer || this.renderOn;
    var focusoutInput = this.focusoutInput || this.input;

    // Add label to container
    var display = this.display || this.field["d"] || this.field["n"];
    var label = $(`<label class="form-label"><span>${display}</span></label>`);
    var labelPosition = this.field["d_pos"] || this.defaultLabelPosition || 'floating';
    if (labelPosition && (this.labelContainer || this.labelInput)) {
      switch (labelPosition) {
        case "floating":
          if (this.labelContainer)
            this.labelContainer.addClass("form-group-wrap");
          if (this.labelInput) {
            this.labelInput.addClass("has-float-label");
            label.insertAfter(this.labelInput);
          }
          else label.appendTo(this.labelContainer);

          break;
        case "above":
          if (this.labelContainer)
            label.prependTo(this.labelContainer);
          break;
        case "beneath":
          if (this.labelContainer)
            label.appendTo(this.labelContainer);
          break;
        case "placeholder":
          if (this.labelInput)
            this.labelInput.attr("placeholder", display);
          break;
        case "none":
          break;
      }
    }

    if (this.field["focusout_fn"]) {
      focusoutInput.blur(
        function () {
          var fn = eval(this.field["focusout_fn"]);
          fn(this);
        }.bind(this));
    }

    // extra_blurb
    if (this.field["extra_blurb"]) {
      var preblurb = $(`<div class="preblurb ml-1">`);
      var blurbBtn = $(`<button type="button" class="fa fa-question-circle p-0 mr-1 border-0
            text-info" style="font-size: 21px; background: none;" data-template="<div class='tooltip'
            role='tooltip'> <div class='tooltip-inner bg-info'></div></div>" data-toggle="tooltip"
            title="" data-original-title="Click to Learn More" data-placement="left"></button>`)
        .tooltip()
        .appendTo(preblurb)
        .click(function () {
          var tooltipId = blurbBtn.attr("aria-describedby");
          var tooltip = $(document).find(`#${tooltipId}`);
          tooltip
            .find(".tooltip-inner")
            // .text("{0}"
            .html(`<p class="mb-0 text-left">${this.field["extra_blurb"]}</p>`);
        }.bind(this));

      if (labelPosition && (labelPosition === "above" || labelPosition === "beneath")) {
        label.after(preblurb);
        preblurb.css("display", "inline");
        blurbBtn.css("font-size", "18px");
        labelPosition === "beneath" ? blurbBtn.addClass("pt-1") : null;
      } else {
        blurbContainer.css("display", "flex");
        preblurb.appendTo(blurbContainer);
      }
    }
  }

  setValue(value) {
    var finalValue = value;
    if (this.field["prefix"] && typeof finalValue == "string") {
      finalValue = finalValue.replace(this.field["prefix"], "");
    }
    if (this.field["suffix"] && typeof finalValue == "string") {
      finalValue = finalValue.replace(this.field["suffix"], "");
    }
    this.input.val(finalValue);
    this.input.attr("data-val", finalValue);
  }

  static renderReadOnlyValue(renderOn, fieldValue, fieldSchema) {
    var popoverContent = WIRE.getTooltipContent(fieldSchema);
    var popover = `
    <i id ="readOnlyTooltip" class="fal fa-question-square ml-2 text-primary" data-html="true"
    data-toggle="popover"  data-placement="right"
    ></i>`;

    $("<div>").html(fieldValue).appendTo(renderOn); //.append(popover);

    $("body").on("click", function (e) {
      $(".popover:visible").each(function () {
        if (!$(this).is(e.target) &&
          $(this).has(e.target).length === 0 &&
          $(".popover").has(e.target).length === 0 &&
          !$(".popover").is(e.target)) {
          $(this).popover("hide");
        }
      });
    });
    $('[data-toggle="popover"]').popover({ content: popoverContent });
  }

  /**
   * Populates field value in valueDict. Returns error if it happens but
   * returns null if no errors.
   */
  getValue(valueDict, value) {
    value = value || this.readValue();

    if (this.field["validate_fn"]) {
      var fn = eval(this.field["validate_fn"]);
      var result = fn(this, value);
      if (result && typeof result === "string") {
        return result;
      }
    }
    if (!value && this.field["r"]) {
      if (!$(this.renderOn.children().find('input')).hasClass('is-invalid')) {
        this.renderOn.find('input').addClass('is-invalid');
        this.renderOn.find('select').addClass('is-invalid');
        this.renderOn.find('textarea').addClass('is-invalid');
      }
      // Add error msg if it is not exists 
      if (this.renderOn.find('.err-msg').length == 0) {
        this.renderOn.append($(`<span class="text-danger err-msg"
        style="position: relative;">`).html('Field is required'));
      }
      this.onChangeCallback = function () {
        this.removeErrors_(this.renderOn);
      };
      return "Field is required";
    } else {
      this.removeErrors_(this.renderOn);
    }

    var finalValue = value;
    if (this.field["prefix"]) {
      finalValue = this.field["prefix"] + finalValue;
    }
    if (this.field["suffix"]) {
      finalValue + this.field["suffix"];
    }

    valueDict[this.field["n"]] = finalValue;
  }

  readValue() {
    if (this.field['readonly']) {
      return this.startValue;
    } else {
      return this.readValue_();
    }
  }

  readValue_() {
    return this.input ? this.input.val() : '';
  }

  removeErrors_(container) {
    // Removing any red lines or required lines when changeCallBack fired to avoid any confusing issues
    container.children().find('input').removeClass('is-invalid');
    container.children().find('select').removeClass('is-invalid');
    container.children().find('textarea').removeClass('is-invalid');
    // Removing any requied msgz
    if (container.find('.err-msg').length > 0) {
      container.find('.err-msg').remove();
    };
  };
}

class EditableDictField extends BaseEditableField {
  _render(value, allFieldsValues) {
    if (this.field['readonly']) {
      EditableDictField.renderReadOnlyValue(this.renderOn, value, this.field)
      return;
    }
    throw "EditableDictField._render() is not implemented";
  }

  static renderReadOnlyValue(renderOn, fieldValue, fieldSchema) {
    WIRE.depictor.renderFlatObject(fieldValue, renderOn, { schema: fieldSchema });
  }
}

/**
 * Lists field instances that belong to the same form.
 */
class FieldSiblings {
  constructor() {
    this.instances = [];
  }

  searchAll(fieldName) {
    var matches = [];
    this.instances.forEach(function (instance) {
      if (instance.field.n == fieldName) {
        matches.push(instance);
      }
      if (this != instance.siblings) {
        matches.append(...instance.siblings.searchAll(fieldName));
      }
    }.bind(this));
    return matches;
  }
}
/**
 * value: HTML content. ex. '<div><table></table><p></p></div>'
 * OR this.field['value']: HTML content. ex. '<div><table></table><p></p></div>'
 */
class EditableBlurbField extends BaseEditableField {
  render(value) {
    var htmlDom = value ? value : this.field['value'];
    if (htmlDom)
      $("<div>").html(htmlDom).appendTo(this.renderOn);
  }
}

class EditableScheduledPaymentsField extends BaseEditableField {
  _render(value, allFieldsValues) {
    this.scheduleFn = eval(this.field['schedule_fn']);
    this.div = $('<div>').appendTo(this.renderOn);

    if (this.field['readonly']) {
      EditableScheduledPaymentsField.renderReadOnlyValue(this.renderOn, value, this.field)
      return;
    }

    if (value && value['presets']) {
      // Calculate button.
      $('<button>').addClass('btn btn-primary mb-1')
        .appendTo(this.div)
        .html('Calculate Payments')
        .click(function () {
          var formName = Guid.generate();
          var presetChoicesField = {
            'n': 'preset',
            't': 'radiolist',
            'r': 1,
            'choices': value['presets'].map(function (preset, idx) {
              var numOccurances = preset['num_payments'] || preset['numberofpayments'];
              var display = `${preset['amount']} ${preset['currency']} per ${preset['per']}. Total of ${numOccurances} payment(s)`;

              return { 'n': idx, 'd': display };
            }),
          };
          WIRE.modal('Payment Amount and Frequency', u('EditableObject', [formName, { 'fields': [presetChoicesField] }]), [{
            label: 'Re-calculate',
            color: 'btn-primary',
            onClick: function () {
              var values = WIRE.getEditableValues(formName);
              if (values['preset'] == undefined) {
                WIRE.errorMessageModal('You must select payment option to re-calculate.');
                return;
              }
              var idx = Number(values['preset']);
              var selectedPreset = value['presets'][idx];

              var payments = this.scheduleFn(this, selectedPreset);
              this.paymentsTableField.setValue(payments);
            }.bind(this),
          }]);
        }.bind(this));
    }

    // Payments table.
    var tableField = EditableScheduledPaymentsField.getTableFieldSchema();
    this.paymentsTableField = new EditableTableField(tableField, this.div, this.onChangeCallback.bind(this));
    // this.paymentsTableField.render(value['payments'] || []);
    this.paymentsTableField.render(value ? value['presets'] || [] : []);
  }

  onAfterRender(value) {
    this.blurbContainer = this.div;
    super.onAfterRender(value || this.value || '');
  }

  getValue(valueDict) {
    var payments = this.paymentsTableField.readValue();
    if (this.field['r'] && payments.length == 0) {
      return 'You must schedule payments.';
    }
    valueDict[this.field['n']] = payments;
  }

  static getTableFieldSchema() {
    return {
      'n': 'scheduled_payments',
      'fields': [
        { 'n': 'day', 'd': 'Day', 't': 'date', 'r': 1 },
        { 'n': 'amount', 'd': 'Amount', 't': 'number', 'r': 1 },
        {
          'n': 'currency', 'd': 'Currency', 't': 'categorical',
          "choices": [{ "n": "aed", "d": "AED", "is_default": true }]
        },
      ]
    };
  }

  static renderReadOnlyValue(renderOn, fieldValue, fieldSchema) {
    //WIRE.depictor.renderFlatObject(fieldValue, renderOn, {schema: fieldSchema});
    if (fieldValue && fieldValue.length > 0) {
      EditableTableField.renderReadOnlyValue(renderOn, fieldValue,)
    } else {
      renderOn.append($('<span>').html('No payments configured.'));
    }
  }
}

class EditableList4LeaseField extends BaseEditableField {
  _render(value, allFieldValues) {
    this.itemId = allFieldValues._id;
    this.renderOn.append($('<span>Loading...</span>'));
    this.wire.call('business::get_listings_for_item', { 'item': this.itemId }, function (response) {
      if (response['_objs'].length > 0) {
        this.renderOn.empty().append($('<span>Property is listed under the following.</span><br>'));
        response['_objs'].forEach(function (listingId) {
          var listing = this.wire.d(listingId);
          var card = this.wire.depictor.createItemDom(listing);
          card.appendTo(this.renderOn);
          card.click(function () {
            this.wire.popupObjectView(listing, null, true);
          }.bind(this));
        }.bind(this));
      } else {
        this.renderOn.empty().append($('<span>').html('Property is not listed for lease. Would you like to lease it?'));
        this.renderOn.append($('<button class="btn btn-primary">List for rent</button>').click(function () {
          var objValues = { 'items': {} };
          objValues['items']['!obj!' + this.itemId] = {};
          this.wire.modal('New Residential Listing', u('AJS', ['common/save_object', {
            'schema': 'residential_rental_listing',
            'obj_type': 'residential_rental_listing',
            'values': objValues,
            'fn': "interactions::save_node",
            'fn_args': { ref: "landlord-residential-listing" },
            'disableRefresh': true,
            'callback': function () {
              this._render(null, allFieldValues);
            }.bind(this),
          }]), [], { sizeMode: 'full' });
        }.bind(this)));
      }
    }.bind(this));
  }

  getValue(valueDict) { }
}

class EditablePasswordField extends BaseEditableField {
  _render(value, allFieldsValues) {
    if (this.field['readonly']) {
      EditablePasswordField.renderReadOnlyValue(this.renderOn, value, this.field)
      return;
    }
    this.input = super._render(value, allFieldsValues).attr("type", "password");
    this.input.closest('.form-group').css('margin-bottom', '9px');
    if (this.field["repeat"]) {
      // var display = this.field["d"] || this.field["n"];
      // $("<br>").appendTo(this.renderOn);
      // this.repeatInput = $(
      //   '<input class="form-control has-float-label" type="password">'
      // )
      //   .attr("placeholder", "repeat " + display)
      //   .appendTo(this.renderOn);

      this.repeatInputContainer = $('<div class="form-group">');
      this.repeatInputContainer.appendTo(this.renderOn);
      // Add input field to container
      this.repeatInput = $(
        '<input class="has-float-label form-control" type="password">'
      );
      this.repeatInput.appendTo(this.repeatInputContainer);

      this.repeatInput.attr("data-val", "");
      var $this = this;

      this.repeatInput.on("input", function () {
        this.setAttribute("data-val", this.value);
        $this.onChangeCallback();
      });
    }
    return this.input;
  }

  onAfterRender(value) {
    // This for "Password" field
    super.onAfterRender(value || this.value || '');

    // This for "Repeat Password field"
    if (this.field["repeat"]) {
      this.display = "Repeat " + (this.field["d"] || this.field["n"]);
      this.labelContainer = this.blurbContainer = this.repeatInputContainer;
      this.labelInput = this.repeatInput;
      super.onAfterRender(value || this.value || '');
    }
  }

  getValue(valueDict) {
    if (this.field["repeat"]) {
      if (this.input.val() != this.repeatInput.val()) {
        return "Password not correctly repeated.";
      }
    }
    return super.getValue(valueDict);
  }

  static renderReadOnlyValue(renderOn, fieldValue, fieldSchema) {
    var popoverContent = WIRE.getTooltipContent(fieldSchema);
    var popover = `
    <i id ="readOnlyTooltip" class="fal fa-question-square ml-2 text-primary" data-html="true"
    data-toggle="popover"  data-placement="right"
    ></i>`;
    $("<div>")
      .html(
        `
      <i class="fa fa-circle fs-xs"></i>
      <i class="fa fa-circle fs-xs"></i>
      <i class="fa fa-circle fs-xs"></i>
      <i class="fa fa-circle fs-xs"></i>`
      )
      .appendTo(renderOn)
      .append(popover);

    $('[data-toggle="popover"]').popover({ content: popoverContent });
  }
}

class EditableEmailField extends BaseEditableField {
  _render(value, allFieldsValues) {
    var fieldDom = super._render(value);
    if (fieldDom)
      fieldDom.attr("type", "email");
  }
}


class EditableNumericField extends BaseEditableField {
  _render(value, allFieldsValues) {
    if (this.field['readonly']) {
      BaseEditableField.renderReadOnlyValue(this.renderOn, value, this.field);
      return;
    }
    
    var $element = super._render(value, allFieldsValues)
      .attr("type", "number")
      .attr("min", "0")
      .keypress(function (evt) {
        return (/^[0-9]*\.?[0-9]*$/).test($(this).val() + evt.key);
      });

    if (this.field["max"]) {
      let max = parseInt(this.field["max"]);
      $element.attr("max", max);

      $element[0].oninput = function () {
        if (parseInt(this.value) > max) {
            this.value = max; 
        }
      }
    }

    return $element;
  }

  getValue(valueDict) {
    var valueStr = String(this.readValue());
    if (valueStr.trim() == "") {
      if (this.field["r"]) {
        return "Field is required";
      }
      else
        return;
    }

    var num = Number(valueStr);
    if (isNaN(num)) {
      return "Not a number.";
    }
    return super.getValue(valueDict, num);
  }
}

class EditableTextField extends BaseEditableField { }

class EditableBooleanField extends BaseEditableField {
  _render(value, allFieldsValues) {
    if (this.field['readonly']) {
      EditableBooleanField.renderReadOnlyValue(this.renderOn, value, this.field)
      return;
    }
    var rnd = Guid.generate();
    var display = this.field["d"] || this.field["n"];
    this.inputGroup = $('<div class="input-group">').appendTo(this.renderOn);
    this.customControl = $('<div class="custom-control custom-checkbox">').appendTo(this.inputGroup);
    this.input = $('<input type="checkbox" class="custom-control-input">').attr("id", this.field["n"] + '-' + rnd).appendTo(this.customControl);

    this.input.on("change", function (e) {

      this.onChangeCallback();
    }.bind(this));
    this.labeledInput = $("<label class='custom-control-label'>").html(display + " ").attr("for", this.field["n"] + '-' + rnd).appendTo(this.customControl);

    if (value != undefined) {
      this.setValue(value);
    }
    return this.labeledInput;
  }

  setValue(value) {
    this.input.prop("checked", value);
  }

  readValue_() {
    return Number(this.input.prop("checked"));
  }

  static renderReadOnlyValue(renderOn, fieldValue, fieldSchema) {
    var jqElement = fieldValue ? $('<span>&#x2714;<span>') : $('<i class="fa fa-times" aria-hidden="true"></i>');

    if (fieldSchema && fieldSchema['display_format']) {
      // display = fieldSchema['d'] || fieldSchema['n'];
      switch (fieldSchema['display_format']) {
        case 'yes/no':
          jqElement = $(`<span class="col-12 primary-border-1"> ${fieldValue ? 'Yes' : 'No'} </span>`);
          break;
        case 'true/false':
          jqElement = $(`<span class="col-12 primary-border-1"> ${fieldValue ? 'True' : 'False'} </span>`);
          break;
        case 'checkbox':
          var inputGroup = $('<div class="input-group">');
          var customControl = $('<div class="custom-control custom-checkbox">').appendTo(inputGroup);
          var input = $(`<input type="checkbox" class="custom-control-input" ${fieldValue ? 'checked' : ''} disabled>`)
            .appendTo(customControl);
          var labeledInput = $("<label class='custom-control-label'>").appendTo(customControl);
          jqElement = inputGroup;
      }
    }

    $("<div>").append(jqElement).appendTo(renderOn);
  }
}

class EditableCategoricalField extends BaseEditableField {
  _render(value, allFieldsValues) {
    if (this.field['readonly']) {
      EditableCategoricalField.renderReadOnlyValue(this.renderOn, value, this.field)
      return;
    }
    this.options = {
      minimumResultsForSearch: this.field['searchBox'] || -1,
      dropdownParent: $('body')//this.renderOn,
    };
    this.container = $('<div>').appendTo(this.renderOn);
    this.floatingLabel = $(`<div style="overflow: hidden;
    text-overflow: ellipsis; display: inline; position: relative;top:${value != undefined ? '-50px' : '-31px'};width: fit-content;
    z-index: 1;margin-left: 10px; color: #afbdcf;background: white;"><span>${this.field['d'] || this.field['n']}</span></div>`);
    this.inputContainer = $('<div style="min-width:120px;">').appendTo(this.container);
    // Add input field to container
    this.input = $('<select>').attr("id", this.field["n"]);
    this.input.appendTo(this.inputContainer);

    var $this = this;
    this.input.on("change", function (e) {

      this.setAttribute("data-val", this.value);
      $this._isValueSelected(this, $this.floatingLabel);
      $this.onChangeCallback();
    });

    $("<option>")
      .val("")
      .appendTo(this.input);

    var drawChoices = function (choices) {
      (choices || []).forEach(choice => {
        var isDefault = choice['is_default'];
        if (isDefault && value == undefined) {
          $this.floatingLabel.css('top', '-48px');
        }
        var isChoiceString = typeof choice == "string";
        var htmlText = isChoiceString ? choice : (choice["d"] || choice["n"]);
        var valText = isChoiceString ? choice : choice["n"];
        $(`<option ${isDefault ? 'selected' : ''}>`)
          .html(htmlText)
          .val(valText)
          .appendTo($this.input);
      });

      if (value != undefined) {  //  && value != ''  looks like (0 != '') == true.. Javascript is strange?
        $this.setValue(value);
      } else {
        $this.input.attr("data-val", "");
      }
    };

    if (this.field["db_key"]) {
      WIRE.fetchChoices(this.field["db_key"], function (response) {
        var choices = response["choices"].map(c => {
          c = WIRE.d(c);
          return c.en_name;
        });
        drawChoices(choices);
      }.bind(this));
    }
    else {
      var choices = this.field["choices"];
      drawChoices(choices);
    }
    this.input.select2(this.options);
    var me = this;
    this.input.on("change", function (e) {

      me._isValueSelected(this, me.floatingLabel);
    });
    this.input.on("select2:open", function () {
      me.floatingLabel.css('display', 'none');
    });
    this.input.on("select2:close", function () {
      me.floatingLabel.css('display', 'block');
    });
    return this.input;
  }

  onAfterRender(value) {
    this.blurbContainer = this.container;
    super.onAfterRender(value);
    // Add label to container
    var display = this.field["d"] || this.field["n"];
    var label = $('<label class="form-label">').text(display);
    var labelPosition = this.field['d_pos'] || 'floating';
    switch (labelPosition) {
      case 'floating':
        this.floatingLabel.appendTo(this.container);
        if (this.floatingLabel.css('top') == '-31px') {
          this.floatingLabel.click(function () {
            this.input.select2('open');
          }.bind(this));
        };
        break;
      case 'above':
        label.prependTo(this.container);
        this.options['placeholder'] = '';
        break;
      case 'beneath':
        label.appendTo(this.container);
        this.options['placeholder'] = '';
        break;
      case 'placeholder':
      case 'floating':
        this.options['placeholder'] = display;
        break;
      case 'none':
        break;
    }
  }

  _isValueSelected(input, label) {
    if ($(input).val() == '') {
      label.css('top', '-31px');
    }
    else {
      label.css('top', '-50px');
    }
  }

  readValue_() {
    var value = super.readValue_();
    // If this value corresponds to {"n"}, use the "n" type.
    for (var i = 0; i < this.field['choices'].length; i += 1) {
      var choice = this.field['choices'][i];
      var choiceValue = choice;
      if (typeof choice == 'object' && 'n' in choice) {
        choiceValue = choice['n'];
      }
      if (value == choiceValue) {
        value = choiceValue;  // Use native type rather than string.
      }
    }
    return value;
  }

  static renderReadOnlyValue(renderOn, fieldValue, fieldSchema) {
    var nameToDesc = {};
    (fieldSchema["choices"] || []).forEach(function (choice) {
      if (typeof (choice) == 'string') {
        nameToDesc[choice] = choice;
      } else {
        nameToDesc[choice['n']] = choice['d'];
      }
    });
    renderOn.append($('<span>').html(nameToDesc[fieldValue] || ''));
  }
}

class EditableRadioButtonsField extends BaseEditableField {
  _render(value, allFieldsValues) {
    if (this.field['readonly']) {
      EditableRadioButtonsField.renderReadOnlyValue(this.renderOn, value, this.field)
      return;
    }
    var container = this.container = $('<div class="row">');
    container.appendTo(this.renderOn);
    var me = this;
    var drawChoices = function (choices) {
      choices.forEach(choice => {
        var radioInput = $('<input type="radio" name="item" class="hidden-radio-input">');
        if (value == choice.n) {
          me.value = value;
          radioInput.attr('checked', true);
        }
        var label = $('<label class="form-label">').appendTo(container).append(radioInput);
        var entryCard = $(`<div class="entry-radio-input entry"></div>`).appendTo(label);
        $(`<img class='icon' src='${choice.icon}'>`).appendTo(entryCard);
        $("<div class='label'>").html(choice.d || choice.n).appendTo(entryCard);
        entryCard.on("click", function () {
          // set isSelected value to true
          me.value = choice.n;
          me.onChangeCallback();
        });
      });
    }

    var choices = this.field["choices"];
    drawChoices(choices);

    return container;
  }

  onAfterRender(value) {
    this.blurbContainer = this.container;
    super.onAfterRender(value || this.value || '');
  }

  static renderReadOnlyValue(renderOn, fieldValue, fieldSchema) {
    var selectedChoice = fieldSchema['choices'].filter(c => c.n == fieldValue);
    if (selectedChoice.length > 0) {
      selectedChoice = selectedChoice[0];
      const entryDom = $(
        `<div class="card border entry">
             <div>
                 <img class="icon" draggable="false"></img>
                 <div class="label" data-toggle="tooltip" data-placement="bottom" title=""></div>
             </div>
        </div>`).appendTo(renderOn);
      entryDom.find('img.icon').attr('src', selectedChoice.icon);
      entryDom.find('.label').html(selectedChoice.d || selectedChoice.n);
    } else {
      // Nothing selected
    }
  }

  readValue_() {
    return this.value;
  }
}

class EditableCheckListField extends BaseEditableField {
  _render(value, allFieldsValues) {
    // These fields should not group; only search when the length of choices arrays exceeds 15.
    // The amenities makes a very nested structure on the UI: too slow!
    if (this.field['choices'].length > 15)
      this.field['groupable'] = false;

    if (this.field['readonly']) {
      EditableCheckListField.renderReadOnlyValue(this.renderOn, value, this.field)
      return;
    }

    this.container = $(`<div class="checklist-field ${this.field['wrap'] ? 'mw-410' : ''}">`);
    this.container.appendTo(this.renderOn);

    if (this.field['overflow']) {
      this.container.css({ 'max-height': '100px', 'overflow': 'auto' })
    };

    this.constructor._renderValue(this.container, this.field["choices"], value,
      this.onChangeCallback, this.field["inline"], false, this);
    return this.container;
  }

  onAfterRender(value) {
    this.defaultLabelPosition = 'above';
    this.blurbContainer = this.container;
    this.labelContainer = this.field['render_label'] ? this.renderOn : '';
    super.onAfterRender(value || this.value || '');
  }

  static renderReadOnlyValue(renderOn, fieldValue, fieldSchema) {
    this._renderValue(renderOn, fieldSchema["choices"], fieldValue, null, fieldSchema["inline"], true);
  }

  static _renderValue(renderOn, choices, value, onChangeCallback, inline, readonly, caller) {
    value = value || [];

    var isWrap = false;
    if (caller) {
      isWrap = caller['field']['wrap'];
    }
    var choicesContainer = $(`
      <div style="margin-left: ${isWrap ? '15' : '0'}px">
        <div class="choices-container ${isWrap ? 'row col-12 no-gutters' : ''}">
        </div>
      </div>`).appendTo(renderOn);
    var name = `${Guid.generate()}[]`;
    (choices || []).forEach(function (c) {
      if (typeof c === 'string' || typeof c === 'int') {
        c = { 'n': c, 'd': c };
      }
      c['d'] = c['d'] || c['n'];
      var entryDom = $(
        `<div class="custom-control custom-checkbox mb-2 ${isWrap ? 'col-6' : ''}" style="${isWrap ? 'padding-right: 30px;' : ''}">
            <input type="checkbox" class="custom-control-input ">
            <label class="custom-control-label"></label>
        </div>`);
      var choiceVal, choiceText;
      if (typeof c == "string" || typeof c === 'int') {
        choiceVal = choiceText = c;
      } else {
        choiceVal = c['n'];
        choiceText = c['d'];
      }

      var id = Guid.generate();
      entryDom.addClass(inline ? "custom-control-inline" : "")
        .find(":checkbox")
        .attr('name', name)
        .attr("id", id)
        // .attr("data-val", choiceVal)
        .val(choiceVal)
        .prop("checked", value ? Array.from(value).includes(choiceVal) : false)
        .prop("disabled", readonly ? readonly : false)
        .on('input', function () {
          if (!readonly && onChangeCallback && $.isFunction(onChangeCallback)) {
            onChangeCallback.call(caller);
          }
        }.bind(this));
      entryDom.find("label").attr("for", id).html(choiceText);
      choicesContainer.find('.choices-container').append(entryDom);
    });
  }

  readValue_() {
    return this.container.find("input:checkbox:checked").map(function () {
      //return $(this).attr("data-val");
      var value = $(this).val();
      return isNaN(value) ? value : parseInt(value);
    }).get();
  }
}

class EditableRadioListField extends BaseEditableField {
  _render(value, allFieldsValues) {
    if (this.field['readonly']) {
      EditableRadioListField.renderReadOnlyValue(this.renderOn, value, this.field)
      return;
    }
    this.container = $('<div class="frame-wrap">');
    this.container.appendTo(this.renderOn);
    this.constructor._renderValue(this.container, this.field["choices"], value, this.onChangeCallback, this.field["inline"], false, this.field["default_value"]);
    return this.container;
  }

  onAfterRender(value) {
    this.blurbContainer = this.container;
    super.onAfterRender(value || this.value || '');
  }

  static renderReadOnlyValue(renderOn, fieldValue, fieldSchema) {
    this._renderValue(renderOn, fieldSchema["choices"], fieldValue, null,
      fieldSchema["inline"], true, fieldSchema["default_value"]);
  }

  static _renderValue(renderOn, choices, value, onChangeCallback, inline, readonly, defaultValue) {
    const preValue = value || defaultValue;
    inline = true;
    var name = `${Guid.generate()}[]`;
    (choices || []).forEach(function (c) {
      var entryDom = $(
        `<div class="custom-control custom-radio">
              <input type="radio" class="custom-control-input">
              <label class="custom-control-label"></label>
          </div>`
      );
      var id = Guid.generate();
      var value = c;
      var display = c;
      if (typeof (c) == 'object' && 'n' in c) {
        display = c['d'] || c['n'];
        value = c['n'];
      }
      entryDom.addClass(inline ? "custom-control-inline" : "")
        .find(":radio")
        .attr("name", name)
        .attr("id", id)
        .val(value)
        .attr("checked", preValue !== null && preValue === display)
        .prop("disabled", readonly ? readonly : false)
        .click(function () {
          if (!readonly && onChangeCallback && $.isFunction(onChangeCallback)) {
            onChangeCallback();
          }
        });
      entryDom.find("label").attr("for", id).html(display);
      renderOn.append(entryDom);
    });
  }

  readValue_() {
    return this.container.find("input:radio:checked").map(function () {
      //return $(this).attr("data-val");
      return $(this).val();
    }).get()[0];
  }
}

class EditableDefaultRadioButtonsField extends BaseEditableField {
  _render(value, allFieldsValues) {
    if (this.field['readonly']) {
      EditableDefaultRadioButtonsField.renderReadOnlyValue(this.renderOn, value, this.field)
      return;
    }
    var renderOn = this.renderOn;
    var me = this;
    var isVertical = this.field["isVertical"];
    var drawChoices = function (choices) {
      var rnd = Math.round(Math.random() * 100);
      choices.forEach(choice => {
        var customControl = $('<div class="custom-control custom-radio">')
          .appendTo(renderOn)
          .addClass(isVertical ? 'mb-3' : 'custom-control-inline');
        var radioInput = $(`<input type="radio" class="custom-control-input" name="inlineDefaultRadiosExample${rnd}">`)
          .attr("id", choice.n)
          .appendTo(customControl);
        var label = $('<label class="custom-control-label">')
          .html(choice.d + " ")
          .attr("for", choice.n)
          .appendTo(customControl);

        if (value == choice.n) {
          radioInput.attr('checked', true);
        }
        radioInput.on("click", function () {
          me.value = choice.n;
          me.onChangeCallback();
        });
      });
    }
    var choices = this.field["choices"];
    drawChoices(choices);

    return renderOn;
  }

  readValue_() {
    return this.value;
  }
}

class PhotoUploadField extends BaseEditableField {
  _render(value, allFieldsValues) {
    if (this.field['readonly']) {
      PhotoUploadField.renderReadOnlyValue(this.renderOn, value, this.field)
      return;
    }
    /** @type {string} photo URI from server. */
    this.value = value;

    // https://github.com/josefrichter/resize/blob/master/public/preprocess.js
    this.container = $("<div>");
    this.container.appendTo(this.renderOn);
    this.container.append($(`
      <input type="file" class="file" accept="image/png, image/jpeg"/>
      <div class="input-group">
        <input
          type="text"
          class="file-input form-control"
          readonly="" style="border-right: none;"
        />
        <div class="input-group-append mb-0 browse-tools-container">
          <button type="button" class="browse btn btn-primary">Browse...</button>
        </div>
      </div>`));
    var rnd = Math.round(Math.random() * 100);

    this.canvas = null;
    var fileInputName = "upload" + rnd;
    this.fileUpload = this.container.find(".file");
    this.fileUpload.attr("name", fileInputName);

    var display = this.field["d"] || this.field["n"];
    this.container
      .find(".file-input")
      .attr("placeholder", "Choose a " + display + "...");
    //$(document).on("click", ".browse",
    this.container.find('button.browse').click(function () {
      var file = $(this)
        .parent().parent().parent()
        .find(".file");
      file.trigger("click");
    });
    var $this = this;
    this.fileUpload.change(function (e) {
      var fileInput = $(this)
        .parent()
        .find(".file-input");
      var fileName = e.target.files[0].name;
      fileInput.val(fileName);
      $this.handleFileSelect();
    });

    if (value) {
      this.setValue(value, false);
    }
  }

  setValue(value, fireOnChangeEvent = true) {
    this.value = value;
    this.canvas = null;
    this.renderOn.find('.form-control-border').remove();
    this.renderOn.find('.collapse-photo').remove();

    if (value) {
      var img = new Image();
      img.onload = this.drawOnCanvas.bind(this, img);
      img.src = value;
    }
    if (fireOnChangeEvent) {
      this.onChangeCallback();
    }
  }

  onAfterRender(value) {
    this.blurbContainer = this.container;
    super.onAfterRender(value || this.value || '');
  }

  handleFileSelect() {
    // Read the file
    var filename = this.fileUpload.val();
    this.curFilename = filename;
    var file = this.fileUpload[0].files[0];
    var reader = new FileReader();
    reader.readAsDataURL(file);
    this.fileType = file.type;
    this.fileSize = file.size;

    //reader.readAsArrayBuffer(filename);
    reader.onload = function (event) {
      console.log(this.fileUpload.val());
      var url = event.target.result;

      // Image object
      var img = new Image();
      img.src = url; // Load image.
      img.onload = function () {
        // Resize image.
        if (this.curFilename != filename) {
          return; // User changed image already.
        }
        $(img).attr('file-size', file.size);
        this.canvas = null;
        this.renderOn.find('.form-control-border').remove();
        this.renderOn.find('.collapse-photo').remove();
        this.drawOnCanvas(img);
        this.uploadCanvas(this.handleUploaded.bind(this, filename));
      }.bind(this);
    }.bind(this);
  }

  drawOnCanvas(img) {
    var me = this;
    if (this.canvas == null) {
      var imgContainer = $('<div class="show form-control-border px-2" id="collapsePhotoContainer">').appendTo(this.renderOn);
      this.container.find('.input-group').append(`
      <div class="collapse-photo input-group-append mb-0">
        <button type="button" class="collapse-photo btn btn-xs btn-primary" data-toggle="collapse"
          href="#collapsePhotoContainer">
          <i class="fa fa-angle-double-up"></i></button>
      </div>`);

      this.container.find('button.collapse-photo').click(function () {
        var arrowBtn = $(this).find('.fa');
        if (arrowBtn.hasClass('fa-angle-double-down')) {
          arrowBtn.removeClass('fa-angle-double-down');
          arrowBtn.addClass('fa-angle-double-up');
        }
        else {
          arrowBtn.removeClass('fa-angle-double-up');
          arrowBtn.addClass('fa-angle-double-down');
        }
      });
      this.container.find('.download-img').remove();
      var downloadBtn = $(`<span style=" background-color: #f3f3f3; border: 1px solid #E5E5E5; ">
           <span class="download-img fa fa-cloud-download text-primary" style="font-size: 20px;margin-top: 12px;margin-left: 2px;margin-right: 4px;"></span>
       </span>`).prependTo(this.container.find('.browse-tools-container'));

      if (!this.field['thumbnail']) {
        var row = $('<div class="d-flex py-2">').appendTo(imgContainer);
        var thumbnail = $('<div class="flex-1">').appendTo(row);
        $('<img style="width: 100%" class="img-thumb-field"  >')
          .attr({ 'src': img.src, 'data-zoom-image': img.src }).appendTo(thumbnail);

        if (this.field['zoomable']) {
          thumbnail.find('img').ezPlus({
            zoomWindowPosition: 1,
            scrollZoom: true
          });
        };

        downloadBtn.on('click', function () {
          if (me.value) {
            // create a temp link on the document to download the file
            var link = document.createElement('a');
            link.href = window.location.origin + me.value;
            link.download = 'download.jpg';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
          };
        });
      }
      else {
        $('<img style="width: 100%;max-width:920px; margin: auto; display: block">')
          .attr('src', img.src).appendTo(imgContainer);
      }
    }
    else {
      this.renderOn.find('.file-size').text(`${$(img).attr('file-size')} KB`);
    }
    this.canvas = $("<canvas>");
    var width = img.width;
    var height = img.height;
    var maxDim = Math.max(width, height);
    if (maxDim > 500 && this.fileSize > 500000) {
      var resizeRatio = 500 / maxDim;
      width *= resizeRatio;
      height *= resizeRatio;
    }
    this.canvas.attr("width", width).attr("height", height);
    var ctx = this.canvas[0].getContext("2d");
    ctx.drawImage(img, 0, 0, width, height);
    autoResizeOwnerPopup(this.renderOn);
  }

  uploadCanvas(callback) {
    this.uploadingData = this.canvas[0].toDataURL(this.fileType, 0.95);
    //var hash = hex_md5(this.uploadingData);
    WIRE.uploadImage(this.uploadingData, callback);
  }

  handleUploaded(filename, imageId) {
    if (filename == this.fileUpload.val()) {
      this.value = imageId;
      this.onChangeCallback();
    }
  }

  readValue_() {
    return this.value;
  }

  static renderReadOnlyValue(renderOn, fieldValue, fieldSchema) {
    var popoverContent = fieldSchema ? WIRE.getTooltipContent(fieldSchema) : '';
    var img = new Image();
    if (fieldValue) {
      img.src = fieldValue;
    }
    img.onload = function () {
      $('<img>').css('max-width', '200px').attr('src', img.src).appendTo(renderOn);
      if (popoverContent) {
        var popover = `
          <i id ="readOnlyTooltip" class="fal fa-question-square ml-2 text-primary" data-html="true"
          data-toggle="popover"  data-placement="right"
          ></i>`;
        //renderOn.append(popover)
        autoResizeOwnerPopup(renderOn);
        $('[data-toggle="popover"]').popover({ content: popoverContent });
      }
    };
    //$('<div>').html(fieldValue).appendTo(renderOn);
  }
}

class EditableAddressLatLangField extends BaseEditableField {
  _render(value, allFieldsValues) {
    if (this.field['readonly']) {
      EditableAddressLatLangField.renderReadOnlyValue(this.renderOn, value, this.field)
      return;
    }
    /** @type <object> */
    this.value = value;

    this.container = $('<div class="form-group">');
    this.container.appendTo(this.renderOn);

    this.addressInput = $('<input class="has-float-label form-control">');
    this.addressInput.appendTo(this.container);

    this.addressPreview = $("<div class=addressPreview>")
      .addClass("addressPreview")
      .addClass("editable")
      .addClass("wordwrap");

    /** @type {google.maps.Map} */
    this.mapObject = null; // Google maps
    /** @type {Object<string, google.maps.Marker>} */
    this.markers = {};
    this.mapDiv = null;

    onInitGoogleMaps(this.load.bind(this));
  }

  onAfterRender(value) {
    this.blurbContainer = this.labelContainer = this.container;
    this.labelInput = this.addressInput;
    super.onAfterRender(value || this.value || '');
  }

  readValue_() {
    return this.value;
  }

  load() {
    // if (this.value && this.value["address"]) {
    if (this.value) {
      if (this.value["address"]) {
        this.addressInput.val(this.value["address"]);
      }
      // this.addressPreview.html(this.value["address"]);
      this.addressPreview.appendTo(this.container);
      this.container.removeClass('form-group');
      this.setMapPosition(this.value["l"]);
      if (!this.value["address"]) {
        this.geocodeLatLng(this.geocoder, this.value["l"]);
      }
    }
    // Start: Init auto complete
    this.autocomplete = new google.maps.places.Autocomplete(
      this.addressInput[0],
      //{ types: ["geocode"] }
    );
    // https://developers.google.com/maps/documentation/javascript/reference/places-service
    this.autocomplete.setFields(["formatted_address", "geometry"]);
    this.autocomplete.addListener(
      "place_changed",
      this.addressCallback.bind(this)
    );
    // End: Init auto complete

    // Start: Geo-location.
    if (navigator.geolocation) {
      navigator.geolocation.getCurrentPosition(
        function (position) {
          var geolocation = {
            lat: position.coords.latitude,
            lng: position.coords.longitude
          };
          var circle = new google.maps.Circle({
            center: geolocation,
            radius: position.coords.accuracy
          });
          this.autocomplete.setBounds(circle.getBounds());
        }.bind(this)
      );
    }
    // End: Geo-location.
  }

  addressCallback() {
    var place = this.autocomplete.getPlace();
    var address = place["formatted_address"];
    if (address) {
      var lat = place["geometry"]["location"]["lat"]();
      var lng = place["geometry"]["location"]["lng"]();
      var latLng = { lat: lat, lng: lng };
      this.value = { address: address, l: latLng };
      //
      this.addressPreview.html(address);
      this.setMapPosition(latLng);
      this.onChangeCallback();
    }
  }

  // Add map
  setMapPosition(latLng) {
    if (!this.mapObject) {
      this.createMapObject(latLng);
    } else {
      console.log("should set map position");
      this.mapObject.setCenter(latLng);
    }
    this.setMarker("Location", latLng);
  }

  setMarker(title, latLng) {
    let lngLat = EditableAddressLatLangField.changeStringLngLatToFloat(latLng);
    if (!this.markers[title]) {
      this.markers[title] = new google.maps.Marker({
        position: lngLat,
        map: this.mapObject,
        title: title
      });
    } else {
      this.markers[title].setPosition(lngLat);
    }
  }

  createMapObject(latLng) {
    this.mapContainer = $('<div class="smallMapContainer">').appendTo(this.renderOn);
    this.mapDiv = $('<div class="smallMap">').appendTo(this.mapContainer);
    // Resize
    autoResizeOwnerPopup(this.renderOn, true);
    let lngLat = EditableAddressLatLangField.changeStringLngLatToFloat(latLng);
    this.mapObject = new google.maps.Map(this.mapDiv[0], {
      center: lngLat,
      zoom: 17
    });
    this.geocoder = new google.maps.Geocoder();
  }

  geocodeLatLng(geocoder, latLng) {
    geocoder.geocode(
      { location: latLng },
      function (results, status) {
        if (status === "OK") {
          if (results[0]) {
            // Set field's address value
            if (!this.value["address"]) {
              this.value["address"] = results[0].formatted_address;
              this.addressInput.val(this.value["address"]);
            }
          } else {
            console.log("No results found related to given lat/lng");
          }
        } else {
          console.log("Geocoder failed due to: " + status);
        }
      }.bind(this)
    );

  }

  static changeStringLngLatToFloat(addressObj) {
    if(!addressObj || !addressObj["lat"] || !addressObj["lng"]) return null;
    let lngLat = {};
    lngLat['lat'] = parseFloat(addressObj["lat"]);
    lngLat['lng'] = parseFloat(addressObj["lng"]);
    return lngLat;
  }

  static renderReadOnlyValue(renderOn, fieldValue) {
    var mapDiv = $('<div class="smallerMap">');
    if (!window.google) {
      return;
    }
    if (fieldValue && fieldValue["l"]) {
      var lngLat = this.changeStringLngLatToFloat(fieldValue["l"]);
      var mapObject = new google.maps.Map(mapDiv[0], {
        center: lngLat,
        zoom: 16
      });
      new google.maps.Marker({
        position: lngLat,
        map: mapObject,
        title: fieldValue["address"]
      });
      var popover = `<div id="address" class="address"> ${fieldValue["address"]}
              <i id ="readOnlyTooltip" class="fal fa-question-square ml-2 text-primary" data-html="true"
              data-toggle="popover"  data-placement="right" ></i></div>`;
      //var addressDiv = $('<div class="address">').html(popover);
      $("<div>")
        .addClass("addressView")
        .append(popover)
        .appendTo(renderOn);
      $('[data-toggle="popover"]').popover({ content: mapDiv });
    }
  }
}

class EditablePhoneField extends BaseEditableField {
  _render(value, allFieldsValues) {
    if (this.field['readonly']) {
      EditablePhoneField.renderReadOnlyValue(this.renderOn, value, this.field)
      return;
    }
    var me = this;
    this.input = super._render(value, allFieldsValues).attr("type", "tel");

    this.input.intlTelInput({
      utilsScript: "js/intlTelInput.utils.js",
      initialCountry: "ae",
      preferredCountries: ["ae", "jo"],
      autoPlaceholder: "off"
      // nationalMode: false,
      // formatOnDisplay: true
    });

    // var reset = function() {
    //   this.input.removeClass("error");
    //   $("#tel_error").css("background", "url(../image_site/cross.png) no-repeat 10px 9px");
    // }.bind(this);
    //
    // // on blur: validate
    // this.input.blur(function() {
    //   debugger;
    //   reset();
    //   if ($.trim(this.input.val())) {
    //     if (this.input.intlTelInput("isValidNumber")) {
    //       $("#tel_error").css("background", "url(../image_site/check.png) no-repeat 10px 9px");
    //     } else {
    //       $("#tel_error").css("background", "url(../image_site/cross.png) no-repeat 10px 9px");
    //     }
    //   }
    // }.bind(this));
    //
    // this.input.on("countrychange", function(e, countryData) {
    //   debugger;
    //   $("#dial").val("+"+countryData.dialCode);
    //   $(".tel").val('');
    //   $(".tel").mask($(this).attr('placeholder').replace(/[0-9]/g, "9"));
    // });
    // set the flags' list z-index to a higher value than the floating label
    $('.iti__flag-container').css('z-index', '10');

    // There is a bug in the country list (intlTelInput) plugin
    // when clicking on flag drop-down to hide the country list,
    // the list will not be hidden, 
    // and we can't input on any input field in the same container
    this.renderOn.parent().on('click', function (e) {
      var countryList = $(me.input.prev()).find("ul");
      if (e.target.className.contains("iti") ||
        (!e.target.className.contains("iti") && !countryList.hasClass('iti__hide'))) {
        var clicks = countryList.data('countryListclicks');
        if (clicks) {
          if (clicks % 2 !== 0) {
            // will be hidden
            if (e.target.className.contains('iti__selected-flag') ||
              ($(e.target).parent().hasClass('iti__selected-flag')) ||
              (!e.target.className.contains("iti") && !countryList.hasClass('iti__hide'))) {
              var activedescendant = countryList.attr('aria-activedescendant');
              var activeElement = $(me.input.prev()).find(`#${activedescendant}`);
              activeElement.click();
            }
          }
          clicks = clicks + 1;
        } else {
          clicks = 1;
        }
        countryList.data("countryListclicks", clicks);
      }
    });

    // This is to move label from 'form-group-wrap' to 'iti--allow-dropdown'
    var label = this.label = this.input.closest(".form-group-wrap").find("label");
    this.input.closest(".iti--allow-dropdown").append(label);

    if (value != undefined) {
      this.setValue(value);
      this.input.change();
    }

    return this.input;
  }

  readValue_() {
    return this.input.intlTelInput("getNumber");
  }

  setValue(value) {
    // value = value ? value.substring(2, value.length) : value;
    // if (this.input) this.input.intlTelInput("setNumber", value);
    this.input.intlTelInput("setNumber", value);
  }
}

class EditableDateField extends BaseEditableField {
  _render(value, allFieldsValues) {
    if (this.field['readonly']) {
      EditableDateField.renderReadOnlyValue(this.renderOn, value, this.field)
      return;
    }
    //value = 20200916;
    this.datePicker = $('<div class="input-group date mt-1">');
    this.input = $('<input type="text" class="form-control">');
    this.floatingLabel = $(`<div style="display: -webkit-inline-box; position: relative;top: ${value ? '14px' : '33px'};z-index:14;width:fit-content;margin-left: 10px;
      color: #afbdcf;background: white;pointer-events: none;"><span>${this.field['d']}</span></div>`)
    this.datePicker.append(this.input);
    this.datePicker.append(`
    <div class="input-group-addon input-group-prepend">
        <div class="input-group-text">
          <i class="glyphicon glyphicon-calendar fa fa-calendar"></i>
        </div>
      </div>
    `);

    this.container = $('<div class="form-group">');
    this.datePicker.appendTo(this.container);
    this.container.appendTo(this.renderOn);
    var controls = {
      leftArrow: '<i class="fal fa-angle-left text-primary" style="font-size: 1.25rem"></i>',
      rightArrow: '<i class="fal fa-angle-right text-primary" style="font-size: 1.25rem"></i>'
    };
    if (this.field["disable-past"]) {
      this.datePicker.datepicker({
        todayBtn: "linked",
        format: 'yyyy-mm-dd',
        startDate: new Date(),
        templates: controls
      });
    } else {
      this.datePicker.datepicker({
        todayBtn: "linked",
        format: 'yyyy-mm-dd',
        templates: controls,
      });
    }

    var me = this;
    // this.datePicker.on('changeDate', function (ev) {
    //   me.datePicker.datepicker('hide');
    //   me.input.change();
    //   me.input.blur();
    //   me.onChangeCallback();
    // });

    this.input.on('change', function () {
      this.setAttribute("data-val", Number(this.value.replace(/-/g, '')));
      me.datePicker.datepicker('hide');
      me.input.blur();
      me.onChangeCallback();
      me.moveFloatingLabelToTop(me.floatingLabel);
    });

    if (('default_value_fn' in this.field) && !value) {
      var fn = eval(this.field["default_value_fn"]);
      value = fn(this);
    }
    if (value) {
      this.setValue(value);
      this.input.change();
      this.input.blur();
      this.onChangeCallback();
      this.moveFloatingLabelToTop(this.floatingLabel);
    }

    return this.input;
  }

  moveFloatingLabelToTop(floatingLabel) {
    floatingLabel.css('display', '-webkit-inline-box');
    if (this.input.val()) {
      floatingLabel.css('top', '14px');
    } else {
      floatingLabel.css('top', '33px');
    }
  }

  onAfterRender(value) {
    this.blurbContainer = this.container;
    super.onAfterRender(value || this.value || '');
    // Add label
    var display = this.field["d"] || this.field["n"];
    var label = $('<label class="form-label">').text(display);
    var labelPosition = this.field['d_pos'] || 'floating';
    switch (labelPosition) {
      case 'floating':
        this.floatingLabel.prependTo(this.container);
        // if (this.floatingLabel.css('top') == '33px') {
        //   this.floatingLabel.click(function () {
        //     this.datePicker.datepicker("show");
        //   }.bind(this));
        // }
        // var me = this;
        // this.input.on("focusout", function() {
        //   debugger;
        //   me.moveFloatingLabelToTop(me.floatingLabel);
        // });
        // this.input.on("focusin", function () {
        //   debugger;
        //   me.floatingLabel.css('display', '-webkit-inline-box');
        // });
        break;
      case 'above':
        label.prependTo(this.container);
        break;
      case 'beneath':
        label.appendTo(this.container);
        break;
      case 'placeholder':
        this.input.attr("placeholder", `Select a ${this.field["d"] || this.field["n"]}`);
        break;
    }
  }

  readValue_() {
    if (this.input.val()) {
      return Number(this.input.val().replace(/-/g, ''));
    }
  }

  setValue(value) {
    this.datePicker.datepicker('setDate', dateIntToStr(value));
    //this.input.val(dateIntToStr(value));
  }

  static renderReadOnlyValue(renderOn, fieldValue) {
    if (fieldValue) {
      $("<div>").html(dateIntToStr(fieldValue)).appendTo(renderOn);
    }
  }
}

class EditableDateRangeField extends BaseEditableField {
  _render(value, allFieldsValues) {
    if (this.field['readonly']) {
      EditableDateRangeField.renderReadOnlyValue(this.renderOn, value, this.field)
      return;
    }
    // value = {startDate: '20200919', endDate: '20200926'};
    var me = this;
    this.container = $('<div class="form-group">').appendTo(this.renderOn);
    var datePicker = $('<div class="input-group date mt-1">').appendTo(this.container);
    this.input = $('<input type="text" class="form-control" value="">');
    this.floatingLabel = $(`<div style="position: relative;top: ${value ? '14px' : '33px'};z-index: 1;width:fit-content;margin-left: 10px;
      color: gray;background: white;"><span>${this.field['d']}</span></div>`)
    datePicker.append(this.input);
    var prependIcon = $(`
    <div class="input-group-addon input-group-prepend">
        <div class="input-group-text">
          <i class="glyphicon glyphicon-calendar fa fa-calendar"></i>
        </div>
      </div>
    `).click(function () {
      me.input.trigger('click');
    });
    datePicker.append(prependIcon);

    this.input.daterangepicker({
      parentEl: datePicker,
      autoUpdateInput: false,
      locale: {
        cancelLabel: 'Clear'
      },
      format: 'YYYY/MM/DD'
    });

    this.input.on('apply.daterangepicker', function (ev, picker) {
      me.floatingLabel.css('top', '14px');
      $(this).val(picker.startDate.format('YYYY/MM/DD') + ' - ' +
        picker.endDate.format('YYYY/MM/DD'));
      me.onChangeCallback();
    });

    this.input.on('cancel.daterangepicker', function (ev, picker) {
      $(this).val('');
      me.floatingLabel.css('top', '33px');
    });

    if ('default_value_fn' in this.field) {
      var fn = eval(this.field["default_value_fn"]);
      value = fn(this);
    }

    this.setValue(value);
    this.input.change();
    this.input.blur();
    this.onChangeCallback();

    return this.input;
  }

  onAfterRender(value) {
    this.blurbContainer = this.container;
    super.onAfterRender(value || this.value || '');
    // Add label
    var display = this.field["d"] || this.field["n"];
    var label = $('<label class="form-label">').text(display);
    var labelPosition = this.field['d_pos'] || 'floating';
    switch (labelPosition) {
      case 'floating':
        this.floatingLabel.prependTo(this.container);
        var me = this;
        this.input.on("focusout", function () {
          me.floatingLabel.css('display', 'block');
          if ($(this).val()) {
            me.floatingLabel.css('top', '14px');
          }
          else {
            me.floatingLabel.css('top', '33px');
          }
        });
        this.input.on("focusin", function () {
          me.floatingLabel.css('display', 'none');
        });
        break;
      case 'above':
        label.prependTo(this.container);
        break;
      case 'beneath':
        label.appendTo(this.container);
        break;
      case 'placeholder':
        this.input.attr("placeholder", `Select a ${this.field["d"] || this.field["n"]}`);
        break;
    }
  }

  readValue_() {
    if (this.input.val()) {
      var intValue = Number(this.input.val()
        .replace(/\//g, '')
        .replace(/-/g, '')
        .replace(/\s/g, ''));
      return {
        startDate: intValue.toString().slice(0, 8),
        endDate: intValue.toString().slice(8, 16)
      };
    }
  }

  setValue(value) {
    if (value) {
      var startDate = value['startDate'] || "";
      var endDate = value['endDate'] = value['endDate'] || "";
      var intValue = `${startDate}${endDate}`;
      this.input.val(dateRangeIntToStr(intValue)['full']);
      this.input.data('daterangepicker').setStartDate(dateRangeIntToStr(intValue)['start']);
      this.input.data('daterangepicker').setEndDate(dateRangeIntToStr(intValue)['end']);
    }
  }

  static renderReadOnlyValue(renderOn, fieldValue) {
    if (fieldValue) {
      $("<div>").html(`From: ${dateIntToStr(fieldValue['startDate'])}, To: ${dateIntToStr(fieldValue['endDate'])}`)
        .appendTo(renderOn);
    }
  }
}

class EditableMultipleObjectGroupField extends BaseEditableField {

  _render(value, allFieldsValues) {
    if (this.field['readonly']) {
      EditableMultipleObjectGroupField.renderReadOnlyValue(this.renderOn, value, this.field)
      return;
    }
    this.cardDiv = $('<div class="card">').appendTo(this.renderOn);
    this.itemsDisplay = $(`<div class="card-header d-table">
      <div data-toggle="collapse" data-target="#collapseSelectedItems" class="d-table-cell align-middle" style="width: 90%;">
        <span id="iItemsCount" class="mb-0 pull-left">
        </span>
      </div>
    </div>
    <div id="collapseSelectedItems" class="collapse show">
      <div class="card-body multi-obj-Field-Body">
      </div>
    </div>
  `).appendTo(this.cardDiv);

    this.addButton = $(`
    <button class="btn btn-primary btn-sm pull-right" style="display: flex">
      <i class="fa fa-pencil-square-o mr-1 mt-1"></i>
      <span>Edit</span></button>`)
      .appendTo(this.cardDiv.find(".card-header"));

    this.selectedGroupsTable = $('<table>')
      .addClass("table table-bordered table-hover m-0")
      .css({ 'border-collapse': 'collapse' })
      .appendTo(this.cardDiv.find('.card-body'));

    this.value = value;
    this._renderValue();

    this.getSelectedGroupedItemsFn = null;
    var modalAddButton = {
      css: 'btn btn-primary',
      label: "Use selection and Grouping",
      onClick: function () {
        if (this.getSelectedGroupedItems) {
          this.value = this.getSelectedGroupedItems();
          this._renderValue();
          this.onChangeCallback();
        }
        this.modal.close();
      }.bind(this)
    };
    this.addButton.click(
      function () {
        this.modal = WIRE.modal(
          "Add " + this.fieldDisplay,
          u("AJS", [
            "common/group_list",
            {
              listFnName: this.field["listFnName"],
              selectable: true,
              initCallback: function (r) {
                this.getSelectedGroupedItems = r.getSelectedGroupedItems;
              }.bind(this)
            }
          ]),
          [modalAddButton],
          { sizeMode: "full" }
        );
      }.bind(this)
    );

    //this.setValue(value);
  }

  _renderValue() {
    EditableMultipleObjectGroupField._renderCommon(this.value, this.selectedGroupsTable);
  }

  static renderReadOnlyValue(renderOn, fieldValue, fieldSchema) {
    var table = $('<table>')
      .addClass("table table-bordered table-hover m-0").appendTo(renderOn);
    EditableMultipleObjectGroupField._renderCommon(fieldValue, table);
  }

  static _renderCommon(value, tableJq) {
    tableJq.empty();
    if (!value) {
      return;
    }

    if (value.length > 0) {
      tableJq.append(
        $('<tr>').append($('<td><b>Category</b></td>')).append($('<td><b>Count</b></td>')));
    }

    value.forEach(function (entry) {
      var hierarchyStr = entry['hierarchyPath'].join('; ');
      var countTd = $('<td>').css({ 'cursor': 'pointer', 'text-align': 'inherit', 'padding': '4px', 'padding-left': '0.75rem' }).html(entry.items.length);
      countTd.click(function () {
        ObjectListRenderer.popupObjectList(WIRE, entry.items, hierarchyStr);
      });
      tableJq.append(
        $('<tr>').append($('<td>').css({ 'padding': '4px', 'padding-left': '0.75rem' }).html(hierarchyStr)).append(countTd));
    });
  }

  readValue_() {
    return this.value;
  }
}

class EditableMultipleObjectField extends BaseEditableField {
  constructor(field, renderOn, onChangeCallback) {
    super(field, renderOn, onChangeCallback);
    this.currentSelected = new Set();
  }
  _render(value, allFieldsValues) {
    if (this.field['readonly']) {
      EditableMultipleObjectField.renderReadOnlyValue(this.renderOn, value, this.field)
      return;
    }

    var addFn = this.field["+"];
    if (typeof (addFn) == 'string') {
      addFn = eval(addFn);
    }

    if (addFn) {
      addFn = addFn.bind(this);
    }
    this.fieldDisplay = this.field["d"] || this.field["n"];
    this.cardDiv = $('<div class="card">').appendTo(this.renderOn);
    this.itemsDisplay = $(`<div class="card-header d-table narrow-card-header">
      <div data-toggle="collapse" data-target="#collapseSelectedItems" class="d-table-cell align-middle" style="width: 90%;">
        <span id="iItemsCount" class="mb-0 pull-left">
        </span>
      </div>
    </div>
    <div id="collapseSelectedItems" class="collapse show">
      <div class="card-body multi-obj-Field-Body">
      </div>
    </div>`).appendTo(this.cardDiv);
    this.count = $("<span>").appendTo(this.cardDiv.find("#iItemsCount"));
    this._printSelectedCount();
    this.addButton = $(`<button class="btn btn-primary btn-sm pull-right"><span>Browse...</span></button>`)
      .appendTo(this.cardDiv.find(".card-header"));

    this.selectedItemsFn = null;
    var modalAddButton = {
      label: "Add Selected",
      onClick: function () {
        var hasError = false;
        if (this.selectedItemsFn) {
          var newSelected = this.selectedItemsFn();
          newSelected = newSelected.map(s => {
            if (s.startsWith('!obj!')) {
              return s;
            } else {
              return '!obj!' + s;
            }
          });
          var prevSelected = Array.from(this.currentSelected);
          if ('max' in this.field) {
            // Selected objects + currently selected. Do they exceed max?
            var totalSelected = prevSelected.concat(newSelected);
            if ((new Set(totalSelected)).size > this.field['max']) {
              WIRE.errorMessageModal('Can select at most ' + this.field['max'] + ' entries');
              hasError = true;
              return;
            }
          }
          // Remove previously-selected items (duplicates).
          var prevSelectedSet = new Set(prevSelected);
          newSelected = newSelected.filter(item => !prevSelectedSet.has(item));

          newSelected.forEach(function (objId) {
            var obj = WIRE.d(objId);
            this._addItem(obj);
          }.bind(this));
          this.onChangeCallback();
        }
        if (!hasError) {
          this.modal.close();
        }
      }.bind(this)
    };
    this.addButton.click(
      function () {
        var ajsArgs = {
          listFnName: this.field["listFnName"],
          selectable: true,
          addFn: addFn,
          initCallback: function (r) {
            this.groupListVars = r;
            this.selectedItemsFn = r["getSelectedItems"];
          }.bind(this)
        };
        if (this.field.ajsArgs) {
          ajsArgs = { ...ajsArgs, ...this.field.ajsArgs };
        }
        this.modal = WIRE.modal(
          "Add " + this.fieldDisplay,
          u("AJS", ["common/group_list", ajsArgs]),
          [modalAddButton],
          { sizeMode: "full" }
        );
        // show collapsed panel
        $(this.cardDiv).find("#collapseSelectedItems").addClass("show");
      }.bind(this)
    );

    this.setValue(value);
  }
  _printSelectedCount() {
    this.count.html(
      this.fieldDisplay + ": " + this.currentSelected.size + " selected"
    );
    if (this.currentSelected.size == 0) {
      $(this.itemsDisplay).find(".multi-obj-Field-Body").css("padding", "0px");
    }
    else {
      $(this.itemsDisplay).find(".multi-obj-Field-Body").css("padding", "1rem");
    }
  }

  _addItem(obj) {
    var objId;
    if (obj._id) {
      objId = obj._id;
    }
    else {
      objId = obj;
    }
    if (!objId.startsWith('!obj!')) {
      objId = "!obj!" + objId;
    }
    this.currentSelected.add(objId);
    this._createItemCard(obj);
  }

  _createItemCard(obj) {
    var objDom = WIRE.depictor.createItemDom(obj)
      .click(function () {
        WIRE.popupObjectView(obj, {}, true);
      });
    var btnRemove = $("<div class='fa fa-times-circle position-absolute' style='z-index: 1;right: -8px;top: -9px; color: red; background-image: radial-gradient(at center, white 40%, transparent 40%); font-size: 20px;'></div>");
    btnRemove.prependTo(objDom.find('.card').length ? objDom.find('.card') : objDom);
    this.cardDiv.find(".card-body").append(objDom);
    btnRemove.on("click", function (e) {
      if (obj._id) {
        var objId = obj._id;
        if (!objId.startsWith('!obj!')) {
          objId = "!obj!" + objId;
        }
        this.currentSelected.delete(objId);
      }
      else {
        this.currentSelected.delete(obj);
      }
      this._printSelectedCount();
      objDom.remove();
      this.onChangeCallback();
    }.bind(this));

    this._printSelectedCount();
  }

  readValue_() {
    return Array.from(this.currentSelected);
  }

  getValue(valueDict) {
    var values = this.readValue();
    if (!values.length && this.field["r"]) {
      return "Field is required";
    }
    return super.getValue(valueDict, values);
  }

  setValue(value) {
    this.currentSelected.clear();
    if (value) {
      value.map(WIRE.d.bind(WIRE)).forEach(function (obj) {
        this._addItem(obj);
      }.bind(this));
    }
  }

  static renderReadOnlyValue(renderOn, fieldValue, fieldSchema) {
    fieldValue = fieldValue || [];
    if (typeof (fieldValue) == 'string') {
      fieldValue = [fieldValue];
    }
    var fieldDisplay = (fieldSchema['d'] || fieldSchema['n']);
    var divCss = {
      "border": "1px solid #ddd",
      "border-radius": "4px",
      "background": "#f7f7f7"
    }
    var toolBarDiv = $('<div class="p-2">').css(divCss).appendTo(renderOn);
    // items' count span
    $('<span>').html(fieldValue.length + ' ' + fieldDisplay).appendTo(toolBarDiv);
    // collapse icon
    var collapseIconSpan = $('<span class="fa fa-chevron-down text-primary float-right">').appendTo(toolBarDiv);
    var panelCss = {
      "overflow": "auto",
      "border-radius": "0px",
      "margin-top": "-2px",
      "opacity": 0,
      "max-height": 0,
      "transition": "max-height 0.5s ease-out"
    };
    var panel = $(`<div class="panel p-2 d-block">`).css(panelCss).appendTo(renderOn);
    fieldValue.map(WIRE.d.bind(WIRE)).forEach(function (obj) {
      var objDom = WIRE.depictor.createItemDom(obj);
      objDom.click(function () {
        WIRE.popupObjectView(obj, null, true);
      });
      panel.append(objDom);
    });
    toolBarDiv.click(function () {
      togglePanel(panel, toolBarDiv);
    });
    var togglePanel = function () {
      if (panel.css("opacity") == "0") {
        showItemsContainer()
      }
      else {
        hideItemsContainer();
      }
    }
    var showItemsContainer = function () {
      panel.css({ 'opacity': 1, 'max-height': '250px', 'transition': 'max-height 0.5s ease-in' });
      collapseIconSpan.removeClass("fa fa-chevron-down");
      collapseIconSpan.addClass("fa fa-chevron-up");
    }
    var hideItemsContainer = function () {
      panel.css({ 'opacity': 0, 'max-height': 0, 'transition': 'max-height 0.5s ease-out' });
      collapseIconSpan.removeClass("fa fa-chevron-up");
      collapseIconSpan.addClass("fa fa-chevron-down");
    }
  }
}

class EditableAdvancedMultipleObjectField extends BaseEditableField {
  constructor(field, renderOn, onChangeCallback) {
    super(field, renderOn, onChangeCallback);
    this.currentSelected = new Set();
  }
  _render(value, allFieldsValues) {
    if (this.field['readonly']) {
      EditableAdvancedMultipleObjectField.renderReadOnlyValue(
        this.renderOn,
        value,
        this.field
      );
      return;
    }
    this.defaultDomText = this.field["defaultDomText"];
    var addFn = this.field["+"];
    if (typeof (addFn) == 'string') {
      addFn = eval(addFn);
    }

    if (addFn) {
      addFn = addFn.bind(this);
    }

    this.fieldDisplay = this.field["d"] || this.field["n"];
    this.mainContainer = $('<div class="card">').appendTo(this.renderOn);
    this.itemsCardsContainer = $('<div class="card border-0">')
      .attr({
        style:
          "-webkit-box-shadow: none !important;box-shadow: none !important;",
      })
      .appendTo(this.mainContainer);
    this.itemsDisplay = $(`<div class="card-header d-table narrow-card-header">
      <div data-toggle="collapse" data-target="#collapseSelectedItems" class="d-table-cell align-middle" style="width: 90%;">
        <span id="iItemsCount" class="mb-0 pull-left">
        </span>
      </div>
    </div>
    <div id="collapseSelectedItems" class="collapse show">
      <div class="card-body multi-obj-Field-Body carousel-container">
      </div>
    </div>`).appendTo(this.itemsCardsContainer);
    this.itemFieldsContainer = $(
      '<div class="card mx-3 border-0 mb-2 p-3 item-fields-container d-none">'
    )
      .attr({
        style:
          "box-shadow: none !important;border: 5px rgba(154, 128, 192, 0.5) solid !important; margin-top: -22px !important;",
      })
      .appendTo(this.mainContainer.find("#collapseSelectedItems"));
    this.itemsCountSpan = $("<span>").appendTo(
      this.itemsCardsContainer.find("#iItemsCount")
    );
    this._printSelectedItemsCount();
    this.addButton = $(
      `<button class="btn btn-primary btn-sm pull-right"><span>Browse...</span></button>`
    ).appendTo(this.itemsCardsContainer.find(".card-header"));

    this.selectedItemsFn = null;
    this.addButton.click(
      function () {
        var ajsArgs = {
          listFnName: this.field["listFnName"],
          selectable: true,
          addFn: addFn,
          initCallback: function (r) {
            this.groupListVars = r;
            this.selectedItemsFn = r["getSelectedItems"];
          }.bind(this),
        };
        if (this.field.ajsArgs) {
          ajsArgs = { ...ajsArgs, ...this.field.ajsArgs };
        }
        this.modal = WIRE.modal(
          "Add " + this.fieldDisplay,
          u("AJS", ["common/group_list", ajsArgs]),
          [modalAddButton],
          { sizeMode: "full" }
        );
        // show collapsed panel
        $(this.itemsCardsContainer)
          .find("#collapseSelectedItems")
          .addClass("show");
      }.bind(this)
    );
    var modalAddButton = {
      label: "Add Selected",
      onClick: function () {
        this.itemFieldsContainer.removeClass("d-none");
        var hasError = false;
        if (this.selectedItemsFn) {
          var newSelected = this.selectedItemsFn();
          newSelected = newSelected.map(id => getFullObjId(id));
          var prevSelected = Array.from(this.currentSelected);
          if ("max" in this.field) {
            // Selected objects + currently selected. Do they exceed max?
            var totalSelected = prevSelected.concat(newSelected);
            if (new Set(totalSelected).size > this.field["max"]) {
              WIRE.errorMessageModal(
                "Can select at most " + this.field["max"] + " entries"
              );
              hasError = true;
              return;
            }
          }
          // Remove previously-selected items (duplicates).
          var prevSelectedSet = new Set(prevSelected);
          newSelected = newSelected.filter(
            (item) => !prevSelectedSet.has(item)
          );
          var cards = [];
          newSelected.forEach(function (objId) {
            objId = getFullObjId(objId);
            var obj = WIRE.d(objId);
            cards.push({
              id: objId,
              element: this._addItem(obj, true, true),
            });

          }.bind(this));
          if (cards.length > 0) {
            this.carouselInstance.addCards(cards);
            this.carouselInstance.selectCard(newSelected[newSelected.length - 1]);
            this.carouselInstance.slideToCard(
              newSelected[newSelected.length - 1]
            );
          }
          this.onChangeCallback();
        }
        if (!hasError) {
          this.modal.close();
        }
      }.bind(this),
      color: "btn btn-primary",
    };

    this.value = value || {};
    var cards = this.setValue(this.value);
    this.itemsDisplay.find(".carousel-container").responsiveCarousel({
      cards: cards,
      selectedCardClass: "residential-listing-selected-card",
      onSelect: function (e, id) {
        this.itemFieldsContainer.empty()
          .css({ 'display': 'block' });
        this._renderItemFields(WIRE.d(id), id, true);
      }.bind(this),
      selectOnNavigate: true,
    });
    this.carouselInstance = this.itemsDisplay
      .find(".carousel-container")
      .responsiveCarousel("instance");
    if (value && Object.keys(value).length) {
      this.carouselInstance.selectCard(Object.keys(value)[0]);
    }
  }

  _printSelectedItemsCount() {
    this.itemsCountSpan.html(
      this.fieldDisplay + ": " + this.currentSelected.size + " selected"
    );
    if (this.currentSelected.size == 0) {
      $(this.itemsDisplay).find(".multi-obj-Field-Body").css("padding", "0px");
    } else {
      $(this.itemsDisplay).find(".multi-obj-Field-Body").css("padding", "1rem");
    }
  }

  _addItem(obj, slideToCard = false) {
    var objId = getFullObjId(obj._id ? obj._id : obj);
    this.currentSelected.add(objId);
    this._setItemFieldsValue(obj, objId);
    //TODO whats about the obj in else statement??
    return this._createItemCard(obj, objId, slideToCard);
  }

  _createItemCard(obj, objId) {
    this.itemFieldsContainer.removeClass("d-none");
    if (!objId.startsWith("!obj!")) {
      objId = "!obj!" + objId;
    }
    var uiObjId = objId.replace("!obj!", "").replace(":", "_");

    var defaultDomText = typeof obj != 'string' ? '' : this.field["defaultDomText"] || 'Item is no longer available!';
    var objDom = WIRE.depictor.createItemDom(obj, true, defaultDomText).click(
      function () {
        this.itemFieldsContainer.removeClass("d-none");
        // Show objDom(ItemCard) related fields
        var targetObjFieldsContainer = this.itemFieldsContainer.find(`#${uiObjId}`);
        targetObjFieldsContainer
          .siblings(".obj-fields-container")
          .css({ visibility: "hidden", opacity: 0, "max-height": 0 });
        targetObjFieldsContainer.css({
          visibility: "visible",
          opacity: 1,
          "max-height": "100%",
        });

      }.bind(this)
    );

    var btnRemove = $(
      "<div class='fa fa-times-circle position-absolute' style='z-index: 1;right: -8px;top: -9px; color: red; background-image: radial-gradient(at center, white 40%, transparent 40%); font-size: 20px;'></div>"
    );
    btnRemove.prependTo(objDom.find('.card').length ? objDom.find('.card') : objDom);
    btnRemove.on(
      "click",
      function (e) {
        this.currentSelected.delete(objId);
        delete this.value[objId];
        this.carouselInstance.removeCard(objId);
        if (this.carouselInstance.isEmpty()) {
          this.itemFieldsContainer.empty()
            .css({ 'display': 'none' });
        }
        this._printSelectedItemsCount();
        this.onChangeCallback({
          instance: this,
        });
      }.bind(this)
    );

    var btnView = $(
      "<div class='position-absolute' style='z-index: 1;right: -8px; top:7px; font-size:17px!important;'></div>"
    ).append(`<div class='icon-stack'>
                  <i class="base base-7 icon-stack-3x opacity-100 color-primary-500"></i> <i class="fa fa-search icon-stack-2x opacity-100 color-white fa-flip-horizontal"></i>
                  </div>`);
    btnView.insertBefore(objDom.find(".icon"));
    btnView.on(
      "click",
      function (e) {
        WIRE.popupObjectView(obj, {}, true);
      }.bind(this)
    );

    objDom.attr("id", uiObjId);
    objDom.css("margin-top", "7px");
    this._printSelectedItemsCount();
    return objDom;
  }

  _renderItemFields(obj, objId) {
    if (!objId.startsWith("!obj!")) {
      objId = "!obj!" + objId;
    }
    var uiObjId = objId.replace("!obj!", "").replace(":", "_");

    if (this.field.fields) {
      var objFieldsContainer = $("<div>")
        .addClass("obj-fields-container")
        .addClass(this.field['vertical-flex'] ? 'd-flex align-items-start flex-column' : '')
        .attr("id", uiObjId)
        .css({ "max-height": "100%" })
        .appendTo(this.itemFieldsContainer);

      var objValues = this.value[objId] || {};

      this.field.fields.forEach(
        function (f) {
          var fieldClass = getEditableFieldClass(f);
          var fieldInstance = new fieldClass(
            f,
            objFieldsContainer,
            function () {
              this.value[objId][f["n"]] = fieldInstance.readValue();
              this.onChangeCallback({
                instance: this,
                field: fieldInstance,
              });
            }.bind(this)
          );

          var fieldValue = this.field[f["n"]];
          if ("default_value" in f) {
            fieldValue = f["default_value"];
          }
          if ("default_value" in this.field) {
            fieldValue = this.field["default_value"][f["n"]];
          }
          if ("default_value_ref" in f) {
            fieldValue = obj[f["default_value_ref"]];
          }
          if (f["n"] in objValues) {
            fieldValue = objValues[f["n"]];
          }
          if (typeof obj !== "string" && f["n"] in obj) {
            fieldValue = obj[f["n"]];
          }
          if (f['pre_blurb']) {
            objFieldsContainer.append($('<div class="preblurb col-12">').html(f['pre_blurb']));
          }
          fieldInstance.render(fieldValue);
          if (f['post_blurb']) {
            objFieldsContainer.append($('<div class="postblurb">').html(f['post_blurb']));
          }
          if (fieldValue !== undefined) {
            objValues[f["n"]] = fieldValue;
            this.onChangeCallback({
              instance: this,
              field: fieldInstance,
            });
          }
          this.value[objId] = objValues;
          this.onChangeCallback({
            instance: this,
          });
          objFieldsContainer.children().last().addClass("mb-2");
          // return fieldInstance;
        }.bind(this)
      );
    }
  }

  _setItemFieldsValue(obj, objId) {
    objId = getFullObjId(objId);
    if (this.field.fields) {
      var objValues = this.value[objId] || {};
      this.field.fields.forEach(function (f) {
        //fieldValue = objValues[f["n"]] || obj[f["default_value_ref"]] ||
        var fieldValue = this.field[f["n"]];
        if ("default_value" in f) {
          fieldValue = f["default_value"];
        }
        if ("default_value" in this.field) {
          fieldValue = this.field["default_value"][f["n"]];
        }
        if ("default_value_ref" in f) {
          fieldValue = obj[f["default_value_ref"]];
        }
        if (f["n"] in objValues) {
          fieldValue = objValues[f["n"]];
        }
        if (typeof obj !== "string" && f["n"] in obj) {
          fieldValue = obj[f["n"]];
        }
        if (fieldValue !== undefined) {
          objValues[f["n"]] = fieldValue;
        }
        this.value[objId] = objValues;
      }.bind(this)
      );
    }
  }

  readValue_() {
    return this.value;
  }

  getValue(valueDict) {
    var values = this.readValue();
    if (!Object.keys(values).length && this.field["r"]) {
      return "Field is required";
    }
    valueDict[this.field["n"]] = values;
  }

  setValue(value) {
    var cards = [];
    this.currentSelected.clear();
    if (value && !value.hasNoKeys()) {
      Object.keys(value).forEach(
        function (key, index) {
          if (value.hasOwnProperty(key)) {
            var obj = WIRE.d(key);
            // if (typeof obj != 'string') {
            var selected = index == 0 ? true : false;
            cards.push({ id: key, element: this._addItem(obj, selected) });
            // }
          }
        }.bind(this)
      );
    }
    return cards;
  }

  static renderReadOnlyValue(renderOn, fieldValue, fieldSchema) {
    fieldValue = fieldValue || {};
    var fieldDisplay = fieldSchema["d"] || fieldSchema["n"];

    var cards = [];
    for (var key in fieldValue || {}) {
      (function (key) {
        if (fieldValue.hasOwnProperty(key)) {
          var obj = WIRE.d(key);
          // if (typeof obj != 'string') {
          var defaultDomText = typeof obj != 'string' ? '' : 'Item is no longer available!';
          var objDom = WIRE.depictor.createItemDom(obj, true, defaultDomText);
          var objId = obj._id ? obj._id : obj;
          if (!objId.startsWith("!obj!")) {
            objId = "!obj!" + objId;
          }
          var uiObjId = objId.replace("!obj!", "").replace(":", "_");
          objDom.attr("id", uiObjId);

          var btnView = $(
            "<div class='position-absolute' style='z-index: 1;right: -8px;top: -9px; color: #826baf;  font-size: 22px;'></div>"
          ).append(`<div class='icon-stack'>
                         <i class="base base-7 icon-stack-3x opacity-100 color-primary-500"></i> <i class="fa fa-search icon-stack-2x opacity-100 color-white fa-flip-horizontal"></i>
                         </div>`);
          btnView.insertBefore(objDom.find(".icon"));
          btnView.on(
            "click",
            function (e) {
              WIRE.popupObjectView(obj, null, true);
            }.bind(this)
          );
          cards.push({ id: objId, element: objDom });
          // }
        }
      })(key);
    }

    var itemsCardsAndFieldsPanel = $(`<div class="panel">
        <div class="panel-hdr" role="heading" data-action="panel-collapse" data-toggle="tooltip" data-offset="0,10" data-original-title="Collapse" style='background: #f7f7f7;'>
          <h2 class="ui-sortable-handle">
            ${Object.keys(fieldValue).length + " " + fieldDisplay}
          </h2>
          <div class="panel-toolbar">
            <button class="btn btn-panel fa fa-chevron-up text-primary custom-chevron-btn"></button>
          </div>
        </div>
        <div class="panel-container show">
          <div class="panel-content">
          </div>
        </div>
      </div>`)
      .appendTo(renderOn);

    var panelContentElement = itemsCardsAndFieldsPanel.find('.panel-content');
    var itemFieldsContainer = $("<div class='pills-container'>");

    panelContentElement.responsiveCarousel({
      cards: cards,
      selectedCardClass: 'residential-listing-selected-card',
      onSelect: function (e, cardId) {
        itemFieldsContainer.empty();
        EditableDictField.renderReadOnlyValue(
          itemFieldsContainer,
          fieldValue[cardId],
          fieldSchema
        );
      },
      selectOnNavigate: true,
    });
    var panelHeader = itemsCardsAndFieldsPanel.find('.panel-hdr');
    //panelHeader.click();
    var carouselInstance = panelContentElement.responsiveCarousel('instance');
    if (Object.keys(fieldValue).length) {
      carouselInstance.selectCard(Object.keys(fieldValue)[0]);
      // IMPORTANT NOTE: Append 'itemFieldsContainer' to 'panelContentElement' "AFTER" rendering the items cards
      itemFieldsContainer.appendTo(panelContentElement);
    }

    panelHeader.on('click', function () {
      //setTimeout(function () { panelContentElement.responsiveCarousel('instance').refreshVisibleItems();}, 500);
      var chevronBtn = $(this).find('.custom-chevron-btn');
      if (chevronBtn.hasClass('fa fa-chevron-down')) {
        chevronBtn.removeClass('fa fa-chevron-down').addClass('fa fa-chevron-up');
      }
      else {
        chevronBtn.removeClass('fa fa-chevron-up').addClass('fa fa-chevron-down');
      }
    });
  }
}

class EditableAdvancedMultipleObjectFieldV2 extends BaseEditableField {
  constructor(field, renderOn, onChangeCallback) {
    super(field, renderOn, onChangeCallback);
    this.currentSelected = new Set();

    renderOn.on("remove", function (e) {
      this._slider.destroy();
    }.bind(this));
  }
  _render(value, allFieldsValues) {
    if (this.field['readonly']) {
      EditableAdvancedMultipleObjectFieldV2.renderReadOnlyValue(
        this.renderOn,
        value,
        this.field
      );
      return;
    }
    this.defaultDomText = this.field["defaultDomText"];
    var addFn = this.field["+"];
    if (typeof (addFn) == 'string') {
      addFn = eval(addFn);
    }

    if (addFn) {
      addFn = addFn.bind(this);
    }

    this.fieldDisplay = this.field["d"] || this.field["n"];
    this.mainContainer = $('<div class="card">').appendTo(this.renderOn);
    this.itemsCardsContainer = $('<div class="card border-0">')
      .attr({
        style:
          "-webkit-box-shadow: none !important;box-shadow: none !important;",
      })
      .appendTo(this.mainContainer);
    this.itemsDisplay = $(`<div class="card-header d-table narrow-card-header">
      <div data-toggle="collapse" data-target="#collapseSelectedItems" class="d-table-cell align-middle" style="width: 90%;">
        <span id="iItemsCount" class="mb-0 pull-left">
        </span>
      </div>
    </div>
    <div id="collapseSelectedItems" class="collapse show">
      <div class="search-box mt-3 d-flex">
      </div>
      <div class="card-body multi-obj-Field-Body carousel-container tiny-slider-container">
      </div>
    </div>`).appendTo(this.itemsCardsContainer);
    this.itemFieldsContainer = $(
        '<div class="card mx-3 border-0 mb-2 p-3 item-fields-container d-none">'
    )
        .attr({
          style:
              "box-shadow: none !important;border: 5px rgba(154, 128, 192, 0.5) solid !important; margin-top: -22px !important;",
        })
        .appendTo(this.mainContainer.find("#collapseSelectedItems"));

    this.itemsCountSpan = $("<span>").appendTo(
      this.itemsCardsContainer.find("#iItemsCount")
    );

    this._printSelectedItemsCount();
    this.addButton = $(
      `<button class="btn btn-primary btn-sm pull-right"><span>Browse...</span></button>`
    ).appendTo(this.itemsCardsContainer.find(".card-header"));

    this.selectedItemsFn = null;
    this.addButton.click(
      function () {
        var ajsArgs = {
          listFnName: this.field["listFnName"],
          selectable: true,
          addFn: addFn,
          initCallback: function (r) {
            this.groupListVars = r;
            this.selectedItemsFn = r["getSelectedItems"];
          }.bind(this),
        };
        if (this.field.ajsArgs) {
          ajsArgs = { ...ajsArgs, ...this.field.ajsArgs };
        }
        this.modal = WIRE.modal(
          "Add " + this.fieldDisplay,
          u("AJS", ["common/group_list", ajsArgs]),
          [modalAddButton],
          { sizeMode: "full" }
        );
        // show collapsed panel
        $(this.itemsCardsContainer)
          .find("#collapseSelectedItems")
          .addClass("show");
      }.bind(this)
    );
    var modalAddButton = {
      label: "Add Selected",
      onClick: function () {
        var hasError = false;
        if (this.selectedItemsFn) {
          var newSelected = this.selectedItemsFn();
          newSelected = newSelected.map(id => getFullObjId(id));
          var prevSelected = Array.from(this.currentSelected);
          if ("max" in this.field) {
            // Selected objects + currently selected. Do they exceed max?
            var totalSelected = prevSelected.concat(newSelected);
            if (new Set(totalSelected).size > this.field["max"]) {
              WIRE.errorMessageModal(
                "Can select at most " + this.field["max"] + " entries"
              );
              hasError = true;
              return;
            }
          }
          // Remove previously-selected items (duplicates).
          var prevSelectedSet = new Set(prevSelected);
          newSelected = newSelected.filter(
            (item) => !prevSelectedSet.has(item)
          );
          var cards = [];
          newSelected.forEach(function (objId) {
            objId = getFullObjId(objId);
            var obj = WIRE.d(objId);

            let $element = $("<div style='text-align: center;'>").append(this._addItem(obj, false));
            //items.push({ id: key, obj: obj, $element: $element });
            cards.push({
              id: objId,
              obj: obj,
              $element: $element
            });

          }.bind(this));

          if (cards.length > 0) {
            cards.forEach(card => this._items.push(card));
            this._resetTinySlider();
          }
          this.onChangeCallback();
        }
        if (!hasError) {
          this.modal.close();
        }
      }.bind(this),
      color: "btn btn-primary",
    };

    this.value = value || {};
    this._items = this.setValue(this.value);

    this._renderSearchbox();
    this._createTinySlider(this._items);
  }

  _renderSearchbox() {
    var me = this;
    let searchValues = {};

    var $searchboxContainer = this.itemsDisplay.find(".search-box");

    // Create property number field
    // var $propertyNumberContainer = $("<div>").appendTo($searchboxContainer);
    // var propertyNumberInstance = new EditableTextField({ t: "text", n: "propertyNumberSearchField", d: "Property Number" }, $propertyNumberContainer,
    //   function () {
    //     propertyNumberInstance.getValue(searchValues);
    //     me._filterTinySlider(searchValues);
    //   });
    // propertyNumberInstance.render();

    // Create name field
    var $nameContainer = $("<div>").appendTo($searchboxContainer);
    var searchFieldInstance = new EditableTextField({ t: "text", n: "searchField", d: "Name", class: 'ml-1' }, $nameContainer,
      function () {
        // searchFieldInstance.getValue(searchValues);
        // me._filterTinySlider(searchValues);
      });
    searchFieldInstance.render();

    //Create search button field
    var buttonInstance = new ReadonlyButtonField({ t: "button", n: "search", d: "Search", class: 'ml-1', click: function () {
        searchFieldInstance.getValue(searchValues);
        me._filterTinySlider(searchValues);
      } }, $searchboxContainer);
    buttonInstance.render();

    // Create clear button field
    var buttonInstance = new ReadonlyButtonField({ t: "button", n: "clear", d: "Clear", class: 'ml-1', click: function () {
      // propertyNumberInstance.setValue("");
      searchFieldInstance.setValue("");
      me._resetTinySlider();
    } }, $searchboxContainer);
    buttonInstance.render();
  }

  _createTinySlider(items) {
    let $carouselContainer = this.itemsDisplay.find(".carousel-container");
    if(items.length > 0) {
      $carouselContainer.append(
          `<ul class="controls" id="customize-controls" aria-label="Carousel Navigation" tabindex="0">
        <li class="prev" data-controls="prev" aria-controls="customize" tabindex="-1"><i class="fa fa-angle-left fa-3x"></i></li> 
        <li class="next" data-controls="next" aria-controls="customize" tabindex="-1"><i class="fa fa-angle-right fa-3x"></i></li>
      </ul>`);
    }

    let $slider = $("<div class='slider'>")
      .appendTo($carouselContainer);

    if (items && items.length) {
      for (let i = 0; i < items.length; i++) {
        // let $slideItemContainer = $("<div style='text-align: center;'>").appendTo($slider);
        // $slideItemContainer.append(cards[i].element);
        $slider.append(items[i].$element);
      }
    }

    this._slider = tns({
      container: '.tiny-slider-container > .slider',
      // loop: true,
      items: 1,
      slideBy: 'page',
      nav: false,
      // autoplay: true,
      speed: 400,
      // autoplayButtonOutput: false,
      mouseDrag: true,
      // lazyload: true,
      controlsContainer: ".tiny-slider-container > #customize-controls",
      responsive: {
          640: {
              items: 2,
          },
          768: {
              items: 4,
          },
          992: {
            items: 6,
          },
          1140: {
            items: 9,
          },
          1700: {
            items: 13,
          }
      }
    });

    // Select the first item
    if (this.value && Object.keys(this.value).length) {
      //this.carouselInstance.selectCard(Object.keys(value)[0]);
      this._items[0].$element.find(".card").click();
    }
  }

  _filterTinySlider(values) {
    if (!values['searchField']) {
      this._resetTinySlider();
      return;
    }

    let items = $.extend(true, [], this._items);
    let filteredItems = items.filter(i => 
      (values['searchField'] && i.obj['name'].toLowerCase().trim().indexOf(values['searchField'].toLowerCase()) !== -1) ||
      (values['searchField'] && i.obj['property_number'].toLowerCase().trim().indexOf(values['searchField'].toLowerCase()) !== -1));

    this._destroyTinySlider();
    this._createTinySlider(filteredItems);
  }

  _resetTinySlider() {
    this._destroyTinySlider();
    this._createTinySlider(this._items);
  }

  _destroyTinySlider() {
    if (this._slider) {
      this._slider.destroy();
    }
    this.itemsDisplay.find(".tiny-slider-container").empty();
  }

  _printSelectedItemsCount() {
    this.itemsCountSpan.html(
      this.fieldDisplay + ": " + this.currentSelected.size + " selected"
    );
    if (this.currentSelected.size == 0) {
      $(this.itemsDisplay).find(".multi-obj-Field-Body").css("padding", "0px");
    } else {
      $(this.itemsDisplay).find(".multi-obj-Field-Body").css("padding", "1rem 1.4rem");
    }
  }

  _addItem(obj, slideToCard = false) {
    var objId = getFullObjId(obj._id ? obj._id : obj);
    this.currentSelected.add(objId);
    this._setItemFieldsValue(obj, objId);
    //TODO whats about the obj in else statement??
    return this._createItemCard(obj, objId, slideToCard);
  }

  _createItemCard(obj, objId) {
    this.itemFieldsContainer.removeClass("d-none");
    if (!objId.startsWith("!obj!")) {
      objId = "!obj!" + objId;
    }
    var uiObjId = objId.replace("!obj!", "").replace(":", "_");

    var defaultDomText = typeof obj != 'string' ? '' : this.field["defaultDomText"] || 'Item is no longer available!';
    var objDom = WIRE.depictor.createItemDom(obj, true, defaultDomText).click(
      function () {
        this.itemFieldsContainer.removeClass("d-none");
        this.mainContainer.find(".residential-listing-selected-card")
          .removeClass("residential-listing-selected-card");

        objDom.addClass("residential-listing-selected-card");

        this.itemFieldsContainer.empty()
            .css({ 'display': 'block' });
        this._renderItemFields(obj, obj['_id'], true);
        // Show objDom(ItemCard) related fields
        // var targetObjFieldsContainer = this.itemFieldsContainer.find(`#${uiObjId}`);
        // targetObjFieldsContainer
        //   .siblings(".obj-fields-container")
        //   .css({ visibility: "hidden", opacity: 0, "max-height": 0 });
        // targetObjFieldsContainer.css({
        //   visibility: "visible",
        //   opacity: 1,
        //   "max-height": "100%",
        // });

      }.bind(this)
    );

    var btnRemove = $(
      "<div class='fa fa-times-circle position-absolute' style='z-index: 1;right: -8px;top: -9px; color: red; background-image: radial-gradient(at center, white 40%, transparent 40%); font-size: 20px;'></div>"
    );
    btnRemove.prependTo(objDom.find('.card').length ? objDom.find('.card') : objDom);
    btnRemove.on(
      "click",
      function (e) {
        e.stopPropagation();
        this._removeItem(e, objId);
        // if (this.carouselInstance.isEmpty()) {
        //   this.itemFieldsContainer.empty()
        //     .css({ 'display': 'none' });
        // }
        this._printSelectedItemsCount();
        this.onChangeCallback({
          instance: this,
        });

      }.bind(this)
    );

    var btnView = $(
      "<div class='position-absolute' style='z-index: 1;right: -8px; top:7px; font-size:17px!important;'></div>"
    ).append(`<div class='icon-stack'>
                  <i class="base base-7 icon-stack-3x opacity-100 color-primary-500"></i> <i class="fa fa-search icon-stack-2x opacity-100 color-white fa-flip-horizontal"></i>
                  </div>`);
    btnView.insertBefore(objDom.find(".icon"));
    btnView.on(
      "click",
      function (e) {
        WIRE.popupObjectView(obj, {}, true);
      }.bind(this)
    );

    objDom.attr("id", uiObjId);
    objDom.css("margin-top", "7px");
    this._printSelectedItemsCount();
    return objDom;
  }

  _removeItem(e, objId) {
    this.currentSelected.delete(objId);

    // Remove the item from value object
    // delete this.value[objId];

    // Remove the item from items array
    let index = this._items.findIndex(i => i.id === objId);
    this._items.splice(index, 1);
    
    // Get the current card and sliderItem
    // var $card = $(e.toElement).closest(".card");
    // var $sliderItem = $(e.toElement).closest(".tns-item");

    var $card = $(e.currentTarget.parentElement);
    var $sliderItem = $(e.currentTarget.parentElement.parentElement)  ;

    // If current item selected, select the next item
    if ($card.hasClass("residential-listing-selected-card")) {
      let $itemToBeActive = $sliderItem.nextAll(".tns-item").not(".tns-transparent");
      if($itemToBeActive.length > 0) {
        $itemToBeActive.find(".card").first().addClass("residential-listing-selected-card");
      } else {
        $itemToBeActive = $sliderItem.prevAll(".tns-item").not(".tns-transparent");
        if($itemToBeActive.length > 0) {
          $itemToBeActive.find(".card").last().addClass("residential-listing-selected-card");
        }
      }
    }

    // Remove the item from UI
    // this.carouselInstance.removeCard(objId);
    $sliderItem.remove();

    // Refresh the slider
    this._slider.refresh();
  }

  _renderItemFields(obj, objId) {
    if (!objId.startsWith("!obj!")) {
      objId = "!obj!" + objId;
    }
    var uiObjId = objId.replace("!obj!", "").replace(":", "_");
    if (this.field.fields) {
      var objFieldsContainer = $("<div>")
        .addClass("obj-fields-container")
        .addClass(this.field['vertical-flex'] ? 'd-flex align-items-start flex-column' : '')
        .attr("id", uiObjId)
        .css({ "max-height": "100%" })
        .appendTo(this.itemFieldsContainer);

      var objValues = this.value[objId] || {};

      this.field.fields.forEach(
        function (f) {
          var fieldClass = getEditableFieldClass(f);
          var fieldInstance = new fieldClass(
            f,
            objFieldsContainer,
            function () {
              this.value[objId][f["n"]] = fieldInstance.readValue();
              this.onChangeCallback({
                instance: this,
                field: fieldInstance,
              });
            }.bind(this)
          );

          var fieldValue = this.field[f["n"]];
          if ("default_value" in f) {
            fieldValue = f["default_value"];
          }
          if ("default_value" in this.field) {
            fieldValue = this.field["default_value"][f["n"]];
          }
          if ("default_value_ref" in f) {
            fieldValue = obj[f["default_value_ref"]];
          }
          if (f["n"] in objValues) {
            fieldValue = objValues[f["n"]];
          }
          if (typeof obj !== "string" && f["n"] in obj) {
            fieldValue = obj[f["n"]];
          }
          if (f['pre_blurb']) {
            objFieldsContainer.append($('<div class="preblurb col-12">').html(f['pre_blurb']));
          }
          fieldInstance.render(fieldValue);
          if (f['post_blurb']) {
            objFieldsContainer.append($('<div class="postblurb">').html(f['post_blurb']));
          }
          if (fieldValue !== undefined) {
            objValues[f["n"]] = fieldValue;
            this.onChangeCallback({
              instance: this,
              field: fieldInstance,
            });
          }
          this.value[objId] = objValues;
          this.onChangeCallback({
            instance: this,
          });
          objFieldsContainer.children().last().addClass("mb-2");
          // return fieldInstance;
        }.bind(this)
      );
    }
  }

  _setItemFieldsValue(obj, objId) {
    objId = getFullObjId(objId);
    if (this.field.fields) {
      var objValues = this.value[objId] || {};
      this.field.fields.forEach(function (f) {
        //fieldValue = objValues[f["n"]] || obj[f["default_value_ref"]] ||
        var fieldValue = this.field[f["n"]];
        if ("default_value" in f) {
          fieldValue = f["default_value"];
        }
        if ("default_value" in this.field) {
          fieldValue = this.field["default_value"][f["n"]];
        }
        if ("default_value_ref" in f) {
          fieldValue = obj[f["default_value_ref"]];
        }
        if (f["n"] in objValues) {
          fieldValue = objValues[f["n"]];
        }
        if (typeof obj !== "string" && f["n"] in obj) {
          fieldValue = obj[f["n"]];
        }
        if (fieldValue !== undefined) {
          objValues[f["n"]] = fieldValue;
        }
        this.value[objId] = objValues;
      }.bind(this)
      );
    }
  }

  readValue_() {
    return this.value;
  }

  getValue(valueDict) {
    var values = this.readValue();
    if (!Object.keys(values).length && this.field["r"]) {
      return "Field is required";
    }
    valueDict[this.field["n"]] = values;
  }

  setValue(value) {
    var items = [];
    this.currentSelected.clear();
    if (value && !value.hasNoKeys()) {
      Object.keys(value).forEach(
        function (key, index) {
          if (value.hasOwnProperty(key)) {
            var obj = WIRE.d(key);
            // if (typeof obj != 'string') {
            var selected = index == 0 ? true : false;
            // items.push({ id: key, element: this._addItem(obj, selected) });
            let $element = $("<div style='text-align: center;'>").append(this._addItem(obj, selected));
            items.push({ id: key, obj: obj, $element: $element });
            // }
          }
        }.bind(this)
      );
    }
    return items;
  }

  static renderReadOnlyValue(renderOn, fieldValue, fieldSchema) {
    fieldValue = fieldValue || {};
    var fieldDisplay = fieldSchema["d"] || fieldSchema["n"];

    var cards = [];
    for (var key in fieldValue || {}) {
      (function (key) {
        if (fieldValue.hasOwnProperty(key)) {
          var obj = WIRE.d(key);
          // if (typeof obj != 'string') {
          var defaultDomText = typeof obj != 'string' ? '' : 'Item is no longer available!';
          var objDom = WIRE.depictor.createItemDom(obj, true, defaultDomText);
          var objId = obj._id ? obj._id : obj;
          if (!objId.startsWith("!obj!")) {
            objId = "!obj!" + objId;
          }
          var uiObjId = objId.replace("!obj!", "").replace(":", "_");
          objDom.attr("id", uiObjId);

          var btnView = $(
            "<div class='position-absolute' style='z-index: 1;right: -8px;top: -9px; color: #826baf;  font-size: 22px;'></div>"
          ).append(`<div class='icon-stack'>
                         <i class="base base-7 icon-stack-3x opacity-100 color-primary-500"></i> <i class="fa fa-search icon-stack-2x opacity-100 color-white fa-flip-horizontal"></i>
                         </div>`);
          btnView.insertBefore(objDom.find(".icon"));
          btnView.on(
            "click",
            function (e) {
              WIRE.popupObjectView(obj, null, true);
            }.bind(this)
          );
          cards.push({ id: objId, element: objDom });
          // }
        }
      })(key);
    }

    var itemsCardsAndFieldsPanel = $(`<div class="panel">
        <div class="panel-hdr" role="heading" data-action="panel-collapse" data-toggle="tooltip" data-offset="0,10" data-original-title="Collapse" style='background: #f7f7f7;'>
          <h2 class="ui-sortable-handle">
            ${Object.keys(fieldValue).length + " " + fieldDisplay}
          </h2>
          <div class="panel-toolbar">
            <button class="btn btn-panel fa fa-chevron-up text-primary custom-chevron-btn"></button>
          </div>
        </div>
        <div class="panel-container show">
          <div class="panel-content">
          </div>
        </div>
      </div>`)
      .appendTo(renderOn);

    var panelContentElement = itemsCardsAndFieldsPanel.find('.panel-content');
    var itemFieldsContainer = $("<div class='pills-container'>");

    panelContentElement.responsiveCarousel({
      cards: cards,
      selectedCardClass: 'residential-listing-selected-card',
      onSelect: function (e, cardId) {
        itemFieldsContainer.empty();
        EditableDictField.renderReadOnlyValue(
          itemFieldsContainer,
          fieldValue[cardId],
          fieldSchema
        );
      },
      selectOnNavigate: true,
    });
    var panelHeader = itemsCardsAndFieldsPanel.find('.panel-hdr');
    //panelHeader.click();
    var carouselInstance = panelContentElement.responsiveCarousel('instance');
    if (Object.keys(fieldValue).length) {
      carouselInstance.selectCard(Object.keys(fieldValue)[0]);
      // IMPORTANT NOTE: Append 'itemFieldsContainer' to 'panelContentElement' "AFTER" rendering the items cards
      itemFieldsContainer.appendTo(panelContentElement);
    }

    panelHeader.on('click', function () {
      //setTimeout(function () { panelContentElement.responsiveCarousel('instance').refreshVisibleItems();}, 500);
      var chevronBtn = $(this).find('.custom-chevron-btn');
      if (chevronBtn.hasClass('fa fa-chevron-down')) {
        chevronBtn.removeClass('fa fa-chevron-down').addClass('fa fa-chevron-up');
      }
      else {
        chevronBtn.removeClass('fa fa-chevron-up').addClass('fa fa-chevron-down');
      }
    });
  }
}

/** start of Tree Select Field */
// Field takes keys:
//   data: Array of dicts with keys ('n', 'd', 'parent')
//   levels: Array of dicts with keys ('n', 'd').
// Number of levels must match max number of ancestors in `data`.
class EditableSelectTreeField2 extends BaseEditableField {
  _render(value, allFieldsValues) {
    if (this.field['readonly']) {
      EditableSelectTreeField2.renderReadOnlyValue(this.renderOn, value || {}, this.field);
      return;
    }
    this.selects = [];
    this.value = {};
    this.addSelect_(0, undefined);

    if (value) {
      for (var idx = 0; idx < this.field['levels'].length; idx += 1) {
        var levelName = this.field['levels'][idx]['n'];
        if (!(levelName in value)) {
          continue;
        }
        this.selects[idx].val(value[levelName]);
        this.selects[idx].change();
      }
    }
  }

  renderReadOnlyValue(renderOn, fieldValue, fieldSchema) {
    var parts = [];
    fieldSchema['levels'].forEach(level => {
      var levelDisplay = level['d'] || level['n'];
      var levelValueDisplay = '<i>empty</i>';
      if (level['n'] in fieldValue) {
        levelValueDisplay = fieldValue[level['n']];
        var dataItemMatchingValue = fieldSchema['data'].filter(item => item['n'] == fieldValue[level['n']]);
        if (dataItemMatchingValue.length > 0 && dataItemMatchingValue[0]['d']) {
          levelValueDisplay = dataItemMatchingValue[0]['d'];
        }
      }
      parts.push(levelDisplay + ': ' + levelValueDisplay);
    })
    renderOn.append($('<div>').html(parts.join('; ')));
  }

  /**
   * Discards selects after a given index
   * @param {number} startingIndex
   */
  discardLaterSelects_(startingIndex) {
    while (this.selects.length > startingIndex) {
      var removingLevelId = this.selects.length - 1;
      var removingLevelName = this.field['levels'][removingLevelId]['n'];
      delete this.value[removingLevelName];
      var lastEntry = this.selects.pop();
      lastEntry.remove();
    }
  }

  getValue(valueDict) {
    if (this.field['r']) {
      for (var idx = 0; idx < this.field['levels'].length; idx += 1) {
        var level = this.field['levels'][idx];
        if (!(level['n'] in this.value)) {
          return 'Field is required. Missing: ' + (level['d'] || level['n']);
        }
      }
    }
    valueDict[this.field['n']] = this.readValue();
  }

  readValue_() {
    return this.value;
  }

  addSelect_(index, parent) {
    if (index >= this.field['levels'].length) {
      return;
    }
    this.discardLaterSelects_(index);

    var items = this.field['data'].filter(item => item.parent == parent);
    var select = $('<select class="form-control mb-2">').appendTo(this.renderOn);
    this.selects.push(select);
    select.append($('<option>').html('Select ' + (this.field['levels'][index]['d'] || this.field['levels'][index]['n'])));
    items.forEach(function (item) {
      select.append($('<option>').val(item['n']).html(item['d'] || item['n']));
    }.bind(this));
    select.change(function () {
      var selectedValue = select.val();
      this.discardLaterSelects_(index + 1);
      if (selectedValue) {
        this.addSelect_(index + 1, selectedValue);
        this.value[this.field['levels'][index]['n']] = selectedValue;
      }
      this.onChangeCallback();
    }.bind(this));
  }
}

// DEPRECATED
class EditableSelectTreeField extends BaseEditableField {
  _render(value, allFieldsValues) {
    if (value) {
      throw "EditableSelectTreeField._render() does not take default values."
    }
    if (this.field['readonly']) {
      EditableSelectTreeField.renderReadOnlyValue(this.renderOn, value, this.field)
      return;
    }
    var container = this.container = $('<form>')
      .attr({
        'id': this.field["n"] + "SelectsContainer"
      })
      .addClass('form-horizontal panel')
      .css({ 'border': 'solid', 'padding': '6px', 'margin': ' 0px' });
    container.appendTo(this.renderOn);
    this.levels = this.field["levels"];
    this.data = this.field['data'];
    this.selectedValues = [];
    this.currentLevel = 0;
    var parentFormGroup = $('<div></div>')
      .addClass('mb-2')
      .attr({ 'id': this.field["n"] });
    var parentLabel = $('<label></label>')
      .addClass('control-label')
      .attr({ 'for': ('parentSelect' + this.field["n"]) })
      .html((this.levels[this.currentLevel]['d']) + ':')
    var div = $('<div>');
    var select = $('<select></select>')
      .addClass('form-control')
      .attr({ 'id': ('parentSelect' + this.field["n"]) });
    parentFormGroup.append(parentLabel).append(div);
    div.append(select);
    var childrens = this.getRootsLevel(this.data);
    var options = this.drawOptions(childrens);
    select.append(options);
    container.append(parentFormGroup);
    var $this = this;
    select.on('change', function () {
      parentFormGroup.nextAll().remove();
      if (select.val()) {
        var selectChildrens = select.children();
        var label = select[0].labels[0].innerText;
        var val = select.val();
        selectChildrens.map(index => {
          var childIndex = $this.selectedValues.findIndex(item => item.value === selectChildrens[index].text);
          if (childIndex > -1) { $this.selectedValues.splice(childIndex, $this.selectedValues.length - 1); }
        });
        $this.selectedValues.push({ name: label, value: val, level: $this.currentLevel });
        $this.drawSelect(select.val(), $this.levels, container, $this.currentLevel, $this.data, $this.selectedValues);
      }
      $this.onChangeCallback();
    });
    return container;
  }
  readValue_() {
    return this.selectedValues;
  }
  getRootsLevel(tree) {
    var parents = [];
    tree.map(function (node) {
      if (!node.parentId) {
        parents.push(node.name);
      }
    });
    return parents;
  };
  drawSelect(selectValue, levels, container, currentLevel, tree, selectedValues) {
    var parentObj = this.getObjFromName(selectValue, tree);
    var childrens = this.getChildren(parentObj, tree);
    if (childrens.length > 0) {
      currentLevel = currentLevel + 1;
      var formGroup = $('<div>')
        .addClass('mb-2')
        .attr({ id: 'control' + parentObj.name });
      var label = $('<label></label>')
        .addClass('control-label')
        .html(levels[currentLevel]['d'] + ':')
        .attr({ 'for': parentObj.name });
      var div2 = $('<div>');
      formGroup.append(label).append(div2);
      var innerSelect = $('<select>')
        .addClass('form-control')
        .attr({ id: parentObj.name });
      var optionsHtml = this.drawOptions(this.getOptionsSelect(childrens));
      innerSelect.append(optionsHtml).appendTo(div2);
      container.append(formGroup);
      var $this = this;
      innerSelect.on('change', function () {
        var parent = $this.getParentObj(innerSelect.val(), tree);
        if (parent) {
          container.find($('#control' + parent.name)).nextAll().remove();
        }
        if (innerSelect.val()) {
          var innerSelectChildrens = innerSelect.children();
          var label = innerSelect[0].labels[0].innerText;
          var val = innerSelect.val();
          innerSelectChildrens.map(index => {
            var innerChildIndex = $this.selectedValues.findIndex(item => item.value === innerSelectChildrens[index].text);
            if (innerChildIndex > -1) { $this.selectedValues.splice(innerChildIndex, $this.selectedValues.length - 1); }
          });
          $this.selectedValues.push({ name: label, value: val, level: currentLevel });
          $this.drawSelect(innerSelect.val(), levels, container, currentLevel, tree, selectedValues);

        }

        $this.onChangeCallback();
      });
    }
  };
  getOptionsSelect(arr) {
    var options = [];
    arr.map(function (item) {
      options.push(item.name);
    });
    return options;
  };
  getChildren(obj, tree) {
    var childrens = [];
    tree.map(function (child) {
      if (child.parentId == obj.id) {
        childrens.push(child);
      };
    });
    return childrens;
  };
  getObjFromName(parentName, tree) {
    var obj = {};
    tree.map(function (item) {
      if (item.name == parentName) {
        obj = item
      };
    });
    return obj;
  };
  getParentObj(childName, tree) {
    var obj = this.getObjFromName(childName, tree);
    var newObj = {};
    tree.map(function (item) {
      if (item.id == obj.parentId) {
        newObj = item
      };
    });
    return newObj;
  };
  drawOptions(options) {
    var html = options.map(function (op) {
      return '<option value="' + op + '">' + op + '</option>'
    }).join('');
    var newHtml = '<option value="">-- Choose option --</option>' + html;
    return newHtml;
  };
  static renderReadOnlyValue(renderOn, fieldValue, fieldSchema) {
    var selectTree = fieldSchema['selectedValues'];
    var div = $('<div></div>').attr({ 'id': fieldSchema['n'] + 'ReadOnly' });
    var ul = $('<ul></ul>');
    selectTree.forEach((value, index) => {
      if (index = 0) {
        var root = $('<li>')
          .attr({ 'id': root + (value[index].name) })
          .html(value[index].name + value[index].value);
        ul.append(root);
      } else {
        var ulLevel = $('<ul></ul>');
        var levelData = $('<li>')
          .html(value[index].name + value[index].value);
        ulLevel.append(levelData);
        root.append(ulLevel);
      }
    });
    renderOn.append(div);
  }
}
/** End of Tree Select Field */

class LabelField extends BaseEditableField {
  _render(value, allFieldsValues) {
    LabelField.renderReadOnlyValue(this.renderOn, null, this.field);
  }

  getValue(valueDict) { }
  static renderReadOnlyValue(renderOn, fieldValue, fieldSchema) {
    renderOn.append($('<span class="mr-1" style="display: inline-flex; align-items: center;">')
      .html(fieldSchema['label']));
  }
}

class EditableLongTextField extends BaseEditableField {
  _render(value, allFieldsValues) {
    if (this.field['readonly']) {
      EditableLongTextField.renderReadOnlyValue(this.renderOn, value, this.field);
      return;
    }
    this.container = $('<div class="form-group">');
    this.container.appendTo(this.renderOn);
    // Add input field to container
    this.input = $('<textarea class="has-float-label form-control" style="min-height: 75px">');
    this.input.appendTo(this.container);

    var $this = this;
    this.input.on("input", function () {
      this.setAttribute("data-val", this.value);
      $this.onChangeCallback();
    });

    if (value != undefined) {
      this.setValue(value);
      this.input.change();
    } else {
      this.input.attr("data-val", "");
    }

    return this.input;
  }

  onAfterRender(value) {
    this.labelContainer = this.blurbContainer = this.container;
    this.labelInput = this.input;
    super.onAfterRender(value || this.value || '');
  }

  static renderReadOnlyValue(renderOn, value, fieldSchema) {
    BaseEditableField.renderReadOnlyValue(
      renderOn, (value || '').replace(/\n/g, '<br>\n'), fieldSchema);
  }
}

class EditableTableField extends BaseEditableField {
  _render(value, allFieldsValues) {
    // set label to placeholder regardless its field's label position
    $.each($(this.field['fields']), function (index, value) {
      value['d_pos'] = 'none';
    });
    this.input = $('<div>').appendTo(this.renderOn);
    if (this.field['title_dom']) {
      $(this.field['title_dom']).html(this.field['d'] || this.field['n']).appendTo(this.input);
    }
    this.table = $('<table width=100%>')
      .css({ 'border-collapse': 'collapse' })
      .addClass('table-bordered table-hover m-0')
      .appendTo(this.input);
    this.table.parent().addClass('table-responsive');

    var thead = $('<thead class="thead-themed">').appendTo(this.table);
    var headTr = $('<tr>').css({ 'border-bottom': '1pt solid black' }).appendTo(thead);
    this.tbody = $('<tbody>').appendTo(this.table);

    if (!this.field['readonly']) {
      var toolsCell = $('<td>').appendTo(headTr);
      this.addButton = $('<i class="fa fa-plus-circle text-center align-middle d-block"></i>')
        .css({ 'font-size': '21px', 'color': '#1dc9b7' })
        .appendTo(toolsCell);


      if (this.field['add_caption']) {
        this.addButton.attr({
          'data-template': '<div class="tooltip" role="tooltip"><div class="tooltip-inner bg-success-500"></div></div>',
          'data-toggle': "tooltip",
          'data-original-title': 'Add ' + this.field['add_caption']
        });
        this.addButton.tooltip();
      }

      this.addButton.click(function () {
        this.addRow();
        this.onChangeCallback();
      }.bind(this));
    }
    this.field['fields'].forEach(subfield => {
      headTr.append($("<td>").css({ 'padding': '8px 8px 10px 8px' }).html(subfield['d'] || subfield['n']));
    });

    this.value = [];
    this.errors = [];
    if (value && value.length) {
      value.forEach(this.addRow.bind(this));
    }
  }

  onAfterRender(value) {
    this.blurbContainer = this.input;
    super.onAfterRender(value || this.value || '');
  }

  empty() {
    this.value = [];
    this.tbody.empty();
  }

  setValue(value) {
    this.empty();
    value.forEach(this.addRow.bind(this));
  }

  addRow(valueDict) {
    valueDict = valueDict || {};
    var entry = {};
    (this.field['fields'] || []).forEach(function (field) {
      if ('default_value' in field && !(field['n'] in valueDict)) {
        entry[field['n']] = JSON.parse(JSON.stringify(field['default_value']));
        valueDict[field['n']] = JSON.parse(JSON.stringify(field['default_value']));
      }
    });

    this.value.push(entry);
    this.errors.push(null);

    var tr = $('<tr>').css({ 'border-bottom': '1pt solid black' }).appendTo(this.tbody);
    if (!this.field['readonly']) {
      var deleteButton = $('<img width=25px src="/www/icons/red-trash.svg">');
      tr.append($('<td class="text-center">').append(deleteButton));
      deleteButton.click(function () {
        var entryIdx = this.value.indexOf(entry);
        this.value.splice(entryIdx, 1);
        this.errors.splice(entryIdx, 1);
        tr.remove();
        this.onChangeCallback();
      }.bind(this));
    }
    var fieldSiblings = new FieldSiblings();
    this.field['fields'].forEach(function (subfield) {
      var fieldAndClass = getFieldAndClass(subfield);
      var fieldClass = fieldAndClass[1];
      subfield = fieldAndClass[0];
      var fieldTd = $('<td>').css({ 'padding': '2px' }).appendTo(tr);
      var fieldInstance = new fieldClass(subfield, fieldTd, function () {
        var d = {};
        fieldTd.find('td.err-msg').remove();
        var errorMessage = fieldInstance.getValue(d);
        var entryIdx = this.value.indexOf(entry);
        this.errors[entryIdx] = errorMessage
        if (errorMessage) {
          const fieldTBody = fieldTd.find('tbody').last();
          if (fieldTBody.length) {
            fieldTBody.append(`<td colspan="${fieldTBody.find('tr:last-child td').length}" class="text-danger err-msg p-1">
              ${errorMessage}</span>`);
          }
          else {
            fieldTd.append(`<span class="text-danger err-msg"
              style="position: relative; top: -25px;">${errorMessage}</span>`);
          }
        }
        entry[subfield['n']] = d[subfield['n']];
        this.onChangeCallback();
      }.bind(this));
      fieldInstance.siblings = fieldSiblings;
      fieldSiblings.instances.push(fieldInstance);
      fieldInstance.render(valueDict[subfield['n']]);
      if (subfield['n'] in valueDict) {
        entry[subfield['n']] = valueDict[subfield['n']];
      }
      const groupFieldDom = fieldTd.find('.input-group-field');
      if (groupFieldDom.length) {
        groupFieldDom.closest('td').addClass('pt-3');
      }
    }.bind(this));
  }

  readValue() {
    // Whether or not readonly. Child fields might be editable.
    return this.readValue_();
  }

  readValue_() {
    return this.value;
  }

  getValue(valueDict) {
    var value = this.readValue();

    if (this.field['r'] && !value.length) {
      return 'Field is required';
    }
    // Check on errors.
    var errors = this.errors.filter(x => x);
    if (errors.length > 0) {
      return errors.join("; ");
    }
    return super.getValue(valueDict, value);
  }

  static renderReadOnlyValue(renderOn, fieldValue, fieldSchema) {
    //if (fieldSchema['title_dom']) {
    //  $(fieldSchema['title_dom']).html(fieldSchema['d'] || fieldSchema['n']).appendTo(this.input);
    //}
    renderOn.addClass('table-responsive');
    var table = $('<table>')
      .addClass("table mx-0 my-2 table-bordered table-sm table-striped table-hover")
      .appendTo(renderOn);

    // render table header
    if (fieldSchema['fields'] && fieldSchema['show_thead']) {
      var thead = $('<thead>')
        .attr({ 'style': 'background-color: #e6e6e6;' })
        .appendTo(table);
      var tr = $('<tr>').appendTo(thead);
      fieldSchema['fields'].forEach(field => {
        var th = $('<th>')
          .html(field['d'] || field['n'])
          .appendTo(tr);
      });
    }

    // render table body
    var tbody = $('<tbody>').appendTo(table);
    (fieldValue || []).forEach(record => {
      var tr = $('<tr>').appendTo(tbody);
      fieldSchema['fields'].forEach(field => {
        var td = $('<td class="align-middle">').appendTo(tr);
        var fieldAndClass = getFieldAndClass(field);
        var fieldClass = fieldAndClass[1];
        field = fieldAndClass[0];
        fieldClass.renderReadOnlyValue(td, record[field['n']], field);
      })
    });
  }
}

class ReadOnlySingleObjectField extends BaseEditableField {
  _render(value, allFieldsValues) {
    if (this.field['readonly']) {
      ReadOnlySingleObjectField.renderReadOnlyValue(this.renderOn, value);
      return;
    }
    throw "ReadOnlySingleObjectField._render() is not implemented";
  }
  static renderReadOnlyValue(renderOn, fieldValue, fieldSchema) {
    if (fieldValue) {
      WIRE.depictor.createItemDom(WIRE.d(fieldValue)).appendTo(renderOn);
    } else {
      renderOn.append($('<span>').html('None'));
    }
  }
}

class ReadonlyButtonField extends BaseEditableField {
  _render(value, allFieldValues) {
    ReadonlyButtonField.renderReadOnlyValue(this.renderOn, value, this.field, allFieldValues, this);
  }
  getValue(valueDict) { }

  static renderReadOnlyValue(renderOn, fieldValue, fieldSchema, obj, thisObj) {
    var button = $('<button class="btn btn-secondary">').html(fieldSchema['d'] || fieldSchema['n']);
    var fn = fieldSchema['click'];
    if (typeof (fn) == 'string') {
      fn = eval(fn);
    }

    if (fieldSchema['class']) {
      button.addClass(fieldSchema['class']);
    }

    if (fn) {
      button.click(function () { fn(thisObj, fieldValue, fieldSchema, obj) });
    }

    renderOn.append(button);
  }
}

class ReadOnlyTimeField extends BaseEditableField {
  _render(value, allFieldsValues) {
    if (this.field['readonly']) {
      ReadOnlyTimeField.renderReadOnlyValue(this.renderOn, value);
      return;
    }
    throw "ReadOnlyTimeField._render() is not implemented";
  }
  static renderReadOnlyValue(renderOn, fieldValue, fieldSchema) {
    if (!fieldValue) {
      return;
    }

    let date = new Date(fieldValue * 1000);
    renderOn.append($('<span>').html(date.toDateString() + ' @ ' + date.toLocaleTimeString()));
  }
}

/** DEPRECATED */
class EditableSingleObjectField extends BaseEditableField {
  _render(value, parentValue) {
    console.log(parentValue);
    var fetchFn;
    if (this.field.fetchFn) {
      if (typeof (this.field.fetchFn) == 'string') {
        fetchFn = eval(this.field.fetchFn);
      } else {
        fetchFn = this.field.fetchFn;
      }
    } else if (this.field.getFn) {
      var getFn;
      if (typeof (this.field.getFn) == 'string') {
        getFn = eval(this.field.getFn);
      } else {
        getFn = this.field.getFn;
      }
      fetchFn = function (callback) {
        callback(getFn(parentValue));
      }
    }
    this.span = $('<span>');
    this.value = value;
    fetchFn(function (choices) {
      if (choices.items) {
        choices = choices.items;
      }
      this.choices = choices;
      this.renderValue();
    }.bind(this));
  }

  renderValue() {
    this.span.empty();
    if (this.value) {
      var objDom = WIRE.depictor.createItemDom(this.value);
      var btnRemove = $("<div class='fa fa-times-circle position-absolute' style='z-index: 1;right: -8px;top: -9px; color: red; background-image: radial-gradient(at center, white 40%, transparent 40%); font-size: 20px;'></div>");
      btnRemove.prependTo(objDom.find('.card').length ? objDom.find('.card') : objDom);
      this.span.append(objDom);
      btnRemove.on("click", function (e) {
        this.value = null;
        this.renderValue();
      }.bind(this));
      this.span.append(objDom);
    } else {
      this.span.html('select')
      ObjectListRenderer.popupObjectList(WIRE, this.choices, 'Select ' + (this.field['d'] || this.field['n']), function (obj, modal) {
        this.value = obj;
        //modal.close();
        this.renderValue();
      }.bind(this));
    }
  }
}


class EditableSchemaField extends BaseEditableField {
  _render(value, allFieldsValues) {
    if (('object' == typeof value) && ('_config' in value)) {
      this.config = value['_config'];
      delete (value['_config']);
      this.schemaName = this.config['schema_name'];
      this.schema = this.config['schema'];  // may be undefined
    }
    this.value = value;
    this.schema = this.schema || this.field['schema'];
    this.schemaName = this.schemaName || this.field['schema_name'];

    var schema;
    if (this.schema && this.schemaName) {
      throw "Receiving both schema and schemaName";
    } else if (this.schema) {
      schema = this.schema;
    } else if (this.schemaName) {
      schema = WIRE.schemaManager.schema[this.schemaName];
    } else {
      console.log("Neither schema nor schemaName is set. Schema field will not render.");
      // HACK.
      this.getValue = function () { }.bind(this);
      return;
    }

    this.formName = 'sfield-' + Guid.generate();
    this.editableObject = u('EditableObject', [this.formName, schema, this.value]);
    WIRE.unrollRecursive(this.editableObject, this.renderOn);
  }

  readValue_() {
    return WIRE.getEditableValues(this.formName);
  }

  static renderReadOnlyValue(renderOn, fieldValue, fieldSchema) {
    if (typeof (fieldValue) != 'object') {
      console.error('EditableSchemaField.renderReadOnlyValue received a value that is not an object.');
      return;
    }
    var schemaName = null;
    var schema = null;
    if ('_config' in fieldValue) {
      schemaName = fieldValue['_config']['schema_name'];
      schema = fieldValue['_config']['schema'];
    }
    schemaName = schemaName || fieldSchema['schema_name'];
    schema = schema || fieldSchema['schema'];
    if (schemaName && schema) {
      throw "Expecting one of schemaName or schema";
    } else if (schemaName) {
      schema = WIRE.schemaManager.schema[schemaName];
    } else if (schema) {
    } else {
      throw "Expecting one of schemaName or schema";
    }
    WIRE.depictor.renderFlatObject(fieldValue, renderOn, { 'schema': schema });
    //renderOn.append($('<pre>'));
  }
}


class EditableSignatureField extends BaseEditableField {
  _render(value, allFieldsValues) {
    if (this.field['readonly']) {
      EditableSignatureField.renderReadOnlyValue(this.renderOn, value, this.field)
      return;
    }
    /** @type {string} photo URI from server. */
    this.value = value || this.field['default_value'];

    var container = this.container = $(`
    <div class="signature-container">
      <div id="signature-pad" class="signature-pad">
        <div class="signature-pad-body">
          <canvas></canvas>
        </div>
        <div class="signature-pad-footer">
          <div class="description">Sign above</div>

          <div class="signature-pad-actions">
            <div>
              <button type="button" class="btn btn-primary btn-pills waves-effect waves-themed signature-clear">Clear</button>
              <button type="button" class="btn btn-primary btn-pills waves-effect waves-themed signature-undo">Undo</button>
            </div>
          </div>
        </div>
      </div>
    </div>`);

    container.appendTo(this.renderOn);
    var wrapper = this.wrapper = container.find('#signature-pad')
    var clearButton = wrapper.find('.signature-clear');
    var undoButton = wrapper.find('.signature-undo');

    var canvas = this.canvas = wrapper[0].querySelector("canvas");

    var me = this;
    this.signaturePad = new SignaturePad(canvas, {
      // It's Necessary to use an opaque color when saving image as JPEG;
      // this option can be omitted if only saving as PNG or SVG
      backgroundColor: 'rgb(255, 255, 255)',
      onEnd: function () {
        me.onChangeCallback();
      }
    });

    // On mobile devices it might make more sense to listen to orientation change,
    // rather than window resize events.
    window.onresize = this.resizeCanvas;
    this.resizeCanvas();

    clearButton.on("click", function () {
      this.signaturePad.clear();
      this.onChangeCallback();
    }.bind(this));

    undoButton.on("click", function () {
      var data = this.signaturePad.toData();
      if (data) {
        data.pop(); // remove the last dot or line
        this.signaturePad.fromData(data);
      }
      this.onChangeCallback();
    }.bind(this));

    if (this.value) {
      var img = new Image();
      img.width = 700;
      img.height = 350;
      var parser = new DOMParser();
      var xmlDoc = parser.parseFromString(this.value, "text/xml");
      var targetTag = xmlDoc.getElementsByTagName("svg")[0];
      if (targetTag) {
        var width = targetTag.getAttribute("width");
        var height = targetTag.getAttribute("height");
        if (width) {
          img.width = width;
        }
        if (height) {
          img.height = height;
        }
      }
      // Encodes a string(xml) in base-64.
      var encodedData = window.btoa(this.value);
      img.src = 'data:image/svg+xml;base64,' + encodedData;
      img.onload = this.drawOnCanvas(img);
      this.onChangeCallback();
    }
    return this.container;
  }

  onAfterRender(value) {
    this.blurbContainer = this.container;
    super.onAfterRender(value || this.value || '');
  }

  static renderReadOnlyValue(renderOn, fieldValue, fieldSchema) {
    var img = new Image();
    // Encodes a string(xml) in base-64.
    var encodedData = window.btoa(fieldValue);
    img.src = 'data:image/svg+xml;base64,' + encodedData;
    img.onload = function () {
      // Resize image.
      var canvas = $("<canvas>").appendTo(renderOn);
      var width = img.width;
      var height = img.height;
      var maxDim = Math.max(width, height);
      if (maxDim > 300) {
        var resizeRatio = 300 / maxDim;
        width *= resizeRatio;
        height *= resizeRatio;
      }
      canvas.attr("width", width).attr("height", height);
      var ctx = canvas[0].getContext("2d");
      ctx.drawImage(img, 0, 0, width, height);
    };
  }

  readValue_() {
    // if (this.signaturePad.isEmpty()) {
    //   alert("Please provide a signature first.");
    // } else {
    //Save as SVG
    var dataURL = this.signaturePad.toDataURL('image/svg+xml');
    //Save as PNG
    // var dataURL = this.signaturePad.toDataURL();
    //Save as JPG
    // var dataURL = this.signaturePad.toDataURL("image/jpeg");
    // var blob = this.dataURLToBlob(dataURL);
    // var url = window.URL.createObjectURL(blob);

    // Decode a base-64 encoded string.
    var parts = dataURL.split(';base64,');
    var xmlVal = window.atob(parts[1]);
    this.value = xmlVal;
    // }
    return this.value;
  }

  drawOnCanvas(img) {
    var width = img.width;
    var height = img.height;
    var maxDim = Math.max(width, height);
    if (maxDim > 500) {
      var resizeRatio = 500 / maxDim;
      width *= resizeRatio;
      height *= resizeRatio;
    }
    this.canvas.width = width;
    this.canvas.height = height;
    var ctx = this.canvas.getContext("2d");
    ctx.drawImage(img, 0, 0, width, height);
    autoResizeOwnerPopup(this.renderOn);
  }

  // Adjust canvas coordinate space taking into account pixel ratio,
  // to make it look crisp on mobile devices.
  // This also causes canvas to be cleared.
  resizeCanvas() {
    if (this.canvas) {
      // This part causes the canvas to be cleared
      // When zoomed out to less than 100%, for some very strange reason,
      // some browsers report devicePixelRatio as less than 1
      // and only part of the canvas is cleared then.
      let ratio = Math.max(window.devicePixelRatio || 1, 1);
      this.canvas.width = this.canvas.offsetWidth * ratio;
      this.canvas.height = this.canvas.offsetHeight * ratio;
      this.canvas.getContext("2d").scale(ratio, ratio);
      // This library does not listen for canvas changes, so after the canvas is automatically
      // cleared by the browser, SignaturePad#isEmpty might still return false, even though the`
      // canvas looks empty, because the internal data of this library wasn't cleared. To make sure
      // that the state of this library is consistent with visual state of the canvas, you
      // have to clear it manually.
      this.signaturePad.clear();
    }
  }
}

class EditableMarkdownField extends BaseEditableField {
  _render(value, allFieldsValues) {
    if (this.field['readonly']) {
      EditableMarkdownField.renderReadOnlyValue(this.renderOn, value, this.field)
      return;
    }
    /** @type {string} photo URI from server. */
    this.value = value || this.field['default_value'];

    var container = this.container = $(`<textarea></textarea>`);
    container.appendTo(this.renderOn);

    this.markdownInput = new SimpleMDE({ element: this.container[0] });

    if (this.value) {
      this.markdownInput.value(this.value);
      this.onChangeCallback();
    }

    this.markdownInput.codemirror.on("change", function (e) {

      this.onChangeCallback();
    }.bind(this));

    return this.markdownInput;
  }

  onAfterRender(value) {
    this.blurbContainer = this.container;
    super.onAfterRender(value || this.value || '');
  }

  readValue_() {
    return this.markdownInput.value();
  }

  static renderReadOnlyValue(renderOn, fieldValue, fieldSchema) {
    var converter = new showdown.Converter();
    var html = converter.makeHtml(fieldValue);
    var showdownElement = $("<div>").appendTo(renderOn);
    showdownElement.html(html);
  }
}

class EditableTagField extends BaseEditableField {
  _render(value, allFieldsValues) {
    this.container = $(`
    <div class="form-group search-group-select-container">
      <select class="form-control search-group-select-control"
          multiple="multiple">
      </select>
      <span class="help-block">
      </span>
    </div>`);

    this.container.appendTo(this.renderOn);
    this.input = this.container.find('select');

    this.input.attr(`data-placeholder', 'Select ${this.field['d'] || this.field['n']}`);

    this.container.find('span.help-block').text(this.field['hint'] || `Selected values will be highlighted.
    You can drag selected values to rearrange them for grouping purposes.`);

    this.input.select2({
      templateResult: iconTemplate,
      templateSelection: iconTemplate,
      escapeMarkup: function (elm) {
        return elm;
      }
    });

    function iconTemplate(e) {
      if (e.element) {
        var iconClasses = $(e.element).data('icon') ? $(e.element).data('icon').trim().split(';') : [];
        var icons = iconClasses.map(i => `<i class="${i} mr-2"></i>`);
        return `${icons.join('')}${e.text}`;
      }
    }

    // When user selects many items (tags),
    // they are automatically sorted based on their order in main list,
    // so we prevent tags sorting by moving the user's selected item to the end
    var me = this;
    this.input.on('select2:select', function (e) {
      var $selectedOption = $(e.params.data.element);
      $selectedOption.detach();
      $(this).append($selectedOption);

      me.onChangeCallback({
        instance: me,
        action: 'select',
        targetField: me.field.choices.find(f => f.n == e.params.data.id)
      });
      //$(this).trigger('change');
    });

    this.input.on('select2:unselect', function (e) {
      this.onChangeCallback({
        instance: this,
        action: 'unselect',
        targetField: this.field.choices.find(f => f.n == e.params.data.id)
      });
    }.bind(this));

    this.container
      .find("ul.select2-selection__rendered")
      .sortable({
        containment: 'parent',
        stop: function (event) {
          // Rearrange (select2) options based on tags order
          var tagsList = Array.from($(event.target).find('li:not(.select2-search)').map(function () {
            return $(this).data('data').text;
          }));
          for (var i = 0; i < tagsList.length; i++) {
            var $targetOption = me.input.find('option').filter(function (index, option) {
              if (option.value == tagsList[i] || option.label == tagsList[i]) {
                return option;
              }
            });
            $targetOption.detach();
            me.input.append($targetOption);
          }

          //TODO i don't like this, maybe we should find an alternative
          var targetField = me.field.choices.find(f => f.n == event.target.firstChild['title'].toLowerCase());
          if(!targetField) {
            targetField = me.field.choices.find(f => f.n == event.target.firstChild['title']);
          }
          //TODO

          me.onChangeCallback({
            instance: me,
            action: 'select',
            targetField: targetField
          });
        }
      });

    var options = [];
    this.field.choices.forEach(c => {
      options.push(`<option value="${c['n']}" class="${(c['class'] || '')}" data-icon="${(c['iconClasses'] || []).join(';')}">${(c['d'] || c['n'] || '')}</option>`);
    });

    this.input.append(options.join(''));
    this.input.val(value || []);

    //var hasValue = (Array.isArray(value) && value.length) || (!Array.isArray(value) && value);
    var selectedChoices = Array.isArray(value) ? value : (value ? [value] : []);
    selectedChoices.forEach(s => {
      var targetField = this.field.choices.find(c => c['n'] == s || c == s);
      if (!targetField) {
        console.log('No target field.', s);
        return;
      }
      // debugger;
      // this.onChangeCallback({
      //   instance: this,
      //   action: 'select',
      //   targetField: targetField,
      // });
    });
    return this.input;
  }

  onAfterRender(value) {
    this.defaultLabelPosition = 'above';
    this.labelContainer = this.blurbContainer = this.container;
    this.labelInput = this.input;
    super.onAfterRender(value || this.value || '');
  }

  readValue_() {
    return this.input.val();
  }
}

class InlineObjectField extends BaseEditableField {
  _render(value, allFieldsValues) {
    // Render with "EDIT".
    if (this.field['readonly']) {
      InlineObjectField.renderReadOnlyValue(this.renderOn, value, this.field);
      return this.renderOn;
    } else {
      console.log('NOT READONLY InlineObjectField');
    }
  }

  static renderReadOnlyValue(renderOn, fieldValue, fieldSchema) {
    if (fieldValue) {
      if (isObjectId(fieldValue)) {
        fieldValue = WIRE.d(fieldValue);
      }
      WIRE.depictor.renderObjectOnDom(fieldValue, renderOn);
    }
    else {
      console.log('NULL VALUE');
    }
  }
}

/**
 * To customize the container of each field
 * you need to pass 'container' : dom.find('#container') to EACH one
 * @attribute {bool} multiline default value is false, when its value is true, each field will be added in seperated line
 * @attribute {bool} inline,
 * @attribute {bool} noHeader
 * @attribute {bool} no_panel if its true, so the fields will not added in a panel container
 * @attribute {list} iconClasses, classes of icon that will be included in a header of a panel container
 */
class EditableMultiField extends BaseEditableField {
  _initialValueCache = {}; // Cache the initial values
  _fieldsInstancesCahce = {}; // Cache the fields instances
  _render(value, allFieldsValues) {
    this.value = value || {};
    // Get a new copy of initial values
    this._initialValueCache = $.extend(true, {}, this.value);
    let showResetButton = this.field["showResetButton"] || false;

    if (this.field['readonly']) {
      EditableMultiField.renderReadOnlyValue(this.renderOn, value, this.field)
      return;
    };

    this.mainContainer = $(`<div id="${this.field['n']}" class="panel multifield-field m-0" >
        <div class="w-100 panel-hdr ${this.field['no_collapse'] ? '' : 'cursor-pointer'} ${this.field['noHeader'] ? 'd-none' : ''}" data-action="panel-collapse">
            <h5 class="m-0 p-2 flex-1"><i class="${this.field['iconClasses'] ? this.field['iconClasses'].join(' ') : ''} mr-1"></i>${this.field['d'] || this.field['n']}</h5>
            <a id="resetBtn" class="cursor-pointer h3 mb-0 d-none" data-original-title="" title="">
              <i class="fal fa-undo-alt"></i>
            </a>
            <div class="panel-toolbar">
            </div>
        </div>
        <div class="${this.field['no_collapse'] ? 'p-2' : 'panel-container show'}" style="overflow-x: auto;">
            <div class="panel-content">
                <div class="fields-container"></div>
            </div>
        </div>
    </div>`);

    if (showResetButton) {
      this.mainContainer.find('#resetBtn').removeClass("d-none")
        .click(function () {
          this._reset();
        }.bind(this));
    }

    if ('no_panel' in this.field && this.field['no_panel']) {
      this.mainContainer = $(`<div id="${this.field['n']}"><div class="fields-container"></div></div>`);
    }

    this.mainContainer
      .addClass(this.field['class'] || '')
      .appendTo(this.renderOn);

    this.fieldsContainer = this.mainContainer.find('.fields-container')
      .addClass(this.field.multiline ? '' : 'form-row');

    this.field['default_value'] = this.field['default_value'] || {};
    this.fieldSiblings = new FieldSiblings();
    this.fieldSiblings.parent = this;
    this._addFields();
    // this._hideIfRequired();

    return this.fieldsContainer;
  }

  onAfterRender(value) {
    this.blurbContainer = this.mainContainer;
    super.onAfterRender(value || this.value || '');
  }

  addField(field) {
    this._add(field);
    this.field.fields.push(field);
    this._showIfRequired();
  }

  _reset() {
    (this.field.fields || []).forEach(f => {
      // Remove the field from the DOM
      this._removeFieldFromUI(f);
      // Delete the field instance from memory
      delete this._fieldsInstancesCahce[f['n']];
    });

    // Get a new copy of initial values
    this.value = $.extend(true, {}, this._initialValueCache);

    // Re-adding the fields after removing the old ones and reset its values
    this._addFields();

    // Refresh the UI
    this.onChangeCallback({
      instance: this,
      action: 'Reset'
    });
  }

  removeField(field) {
    this.onChangeCallback({
      instance: this,
      action: 'FieldRemoved'
    });
    
    this.field.fields.remove(field, 'n');
    this._removeFieldFromUI(field);
    this._hideIfRequired();
  }

  _removeFieldFromUI(field) {
    this.fieldsContainer.find(`.multifield-child[data-name="${field['n']}"]`).remove();
  }

  _addFields() {
    (this.field.fields || []).forEach(f => {
      this._add(f);
    });
  }

  _add(f) {
    f['d_pos'] = f['d_pos'] || 'floating';
    var fieldClass = getEditableFieldClass(f);
    var fieldDom = f['container'] ? f['container'] : $('<div class="multifield-child">')
      .attr('data-name', f['n'])
      .addClass(!this.field.multiline && f['inline'] ? 'col-xl-4 col-lg-4 col-md-6 col-sm-6 col-12 mb-1' : 'col-12 mb-1')
      .appendTo(this.fieldsContainer);
    //var me = this;
    var fieldInstance = new fieldClass(f, fieldDom, function () {
      this.value[f['n']] = fieldInstance.readValue();
      this.onChangeCallback({
        instance: this,
        action: 'FieldSelected',
        field: fieldInstance
      });
    }.bind(this));
    fieldInstance.siblings = this.fieldSiblings;
    this.fieldSiblings.instances.push(fieldInstance);

    var fieldValue = this.value[f['n']] = this.value[f['n']] || f['default_value'] ||
      this.field['default_value'][f['n']];
    fieldInstance.render(fieldValue);

    // if (fieldValue) {
    //   debugger;
    //   this.onChangeCallback({
    //     instance: this,
    //     action: 'FieldSelected'
    //   });
    // }

    this.onChangeCallback({
      instance: this,
      action: 'FieldAdded'
    });

    // Cache the created field instance
    this._fieldsInstancesCahce[f['n']] = fieldInstance;

    return fieldInstance;
  }

  _showIfRequired() {
    if (this.field.hideIfEmpty && this.field.fields.length) {
      this.mainContainer.show();
    }
  }

  _hideIfRequired() {
    if (this.field.hideIfEmpty && !this.field.fields.length) {
      this.mainContainer.hide();
    }
  }

  readValue_() {
    return this.value;
  }

  static renderReadOnlyValue(renderOn, fieldValue, fieldSchema) {
    var mainContainer = $(`
        <div class="panel col-12" id="${fieldSchema['n']}">
          <div class="panel-hdr cursor-pointer" data-action="panel-collapse">
              <h5 class="m-0 p-2"><i class="${fieldSchema['iconClasses'] ? fieldSchema['iconClasses'].join(' ') : ''} mr-1"></i>${fieldSchema['d'] || fieldSchema['n']}</h5>
              <div class="panel-toolbar">
              </div>
          </div>
          <div class="panel-container show" style="max-height: 250px; overflow-x: auto;">
              <div class="panel-content">
                  <div class="fields-container"></div>
              </div>
          </div>
        </div>`);

    if ('no_panel' in fieldSchema && fieldSchema['no_panel']) {
      mainContainer = $(`<div id="${fieldSchema['n']}"><div class="fields-container"></div></div>`);
    }

    mainContainer.appendTo(renderOn);

    var fieldsContainer = mainContainer.find('.fields-container')
      .addClass(fieldSchema.multiline ? '' : 'form-row');

    // var fieldContainer = $('<div>').appendTo(renderOn);
    ([fieldValue] || []).forEach(val => {
      fieldSchema['fields'].forEach(field => {
        var fieldAndClass = getFieldAndClass(field);
        var fieldClass = fieldAndClass[1];
        field = fieldAndClass[0];
        fieldClass.renderReadOnlyValue(fieldsContainer, val[field['n']], field);
      });
    });

  }
}

class EditableSideNavigatorField extends BaseEditableField {
  _render(value, allFieldsValues) {
    if (this.field['readonly']) {
      EditableSideNavigatorField.renderReadOnlyValue(this.renderOn, value, this.field);
      return;
    };

    this.value = value || {};

    var navigatorContainer = this.navigatorContainer = $(`
    <div>
      <div class="sidenav sidenav-field">
        <h4 class="text-center text-white mt-0">${this.field['d'] || this.field['n']}</h4>

      </div>
      <span id="hamburgerButton">&raquo;</span>
    </div>`)
      .appendTo(this.renderOn);

    var navigatorFieldsContainer = this.navigatorFieldsContainer = $('<div>')
      .addClass('row terms-container')
      .appendTo(this.renderOn);

    this.navigator = navigatorContainer.find('.sidenav');
    var fieldSiblings = new FieldSiblings();

    (this.field['fields'] || []).forEach(function (field) {
      var id = field['n'];
      // Render nav. item
      var navItemContainer = $('<div>').appendTo(this.navigator);

      var navItemLink = $(`<a id="${'#' + field['n']}" style="${(field['r'] || this.value[field['n']]) ? "color:	#ddd; border-left:10px solid #ddd" : "color: white; border-left:0px"}"> ${field['caption']} </a>`)
        .appendTo(navItemContainer);

      // Render its related element
      var fieldClass = getEditableFieldClass(field);

      var fieldDom = $('<div>').addClass("col-12 mb-2")
        .appendTo(navigatorFieldsContainer);

      if ((field['r'] && 'default_value' in field) || this.value[field['n']]) {  // Initialize to default value (if value is not set).
        this.value[field['n']] = this.value[field['n']] || field['default_value'];
        this.onChangeCallback();
      }
      // Just view field dom If it is required or if it has a value
      if (!field['r'] && !this.value[field['n']]) {
        fieldDom.hide();
        delete this.value[field['n']];
        this.onChangeCallback();
      }

      var fieldInstance = new fieldClass(field, fieldDom, function () {
        if (fieldDom.is(':visible')) {
          this.value[field['n']] = fieldInstance.readValue();
        }
        this.onChangeCallback();
      }.bind(this));
      fieldInstance.siblings = fieldSiblings;
      fieldSiblings.instances.push(fieldInstance);
      // var renderedField = fieldInstance.render(value[field['n']] || "");
      fieldInstance.render(this.value[field['n']]);

      navItemLink.on('click', function () {
        if (!field['r']) {
          // 1. addTerm or removeTerm
          // 2. Change style of side nav. item
          if (fieldDom.is(':hidden')) {
            fieldDom.show();
            this.value[field['n']] = fieldInstance.readValue();
            this.onChangeCallback();
            navItemLink.css({ 'color': '#ddd', 'border-left': '10px solid #ddd' });
          } else {
            fieldDom.hide();
            delete this.value[field['n']];
            this.onChangeCallback();
            navItemLink.css({ 'color': 'white', 'border-left': '0px' });
          }
          // match navigator and fields container heights
          this.navigator.css('height', this.navigatorFieldsContainer.innerHeight());
        }
      }.bind(this));
    }.bind(this));

    // match navigator and fields container heights
    this.navigator.css('height', this.navigatorFieldsContainer.innerHeight());
    this.isNavBarOpened = true;
    this.hamburgerButton = navigatorContainer.find('#hamburgerButton');
    this.hamburgerButton.on('click', function () {
      // Set Nav Bar Status
      this.isNavBarOpened = !(this.isNavBarOpened);

      if (this.isNavBarOpened) {
        this.hamburgerButton.html('&raquo;');
        // this.navigator.css('width', '200px');
        this.navigator.addClass('sidenav-field');
        this.hamburgerButton.removeClass('collapsed-hamburgerButton');
      } else {
        this.hamburgerButton.html('&laquo;');
        this.navigator.css('width', '0');
        this.navigator.removeClass('sidenav-field');
        this.hamburgerButton.addClass('collapsed-hamburgerButton');
      };
    }.bind(this));

    return this.navigator;
  }

  onAfterRender(value) {
    this.blurbContainer = this.navigatorContainer;
    super.onAfterRender(value || this.value || '');
  }

  readValue_() {
    return this.value
  }

  static renderReadOnlyValue(renderOn, fieldValue, fieldSchema) {
    var fieldContainer = $('<div>').appendTo(renderOn);
    ([fieldValue] || []).forEach(val => {
      fieldSchema['fields'].forEach(field => {
        if (val !== undefined && val[field['n']] !== undefined) {
          var fieldAndClass = getFieldAndClass(field);
          var fieldClass = fieldAndClass[1];
          field = fieldAndClass[0];
          fieldClass.renderReadOnlyValue(fieldContainer, val[field['n']], field);
        }
      });
    });
  }
}

class EditableInputGroupField extends BaseEditableField {
  _render(value, allFieldsValues) {
    if (this.field['readonly']) {
      EditableInputGroupField.renderReadOnlyValue(this.renderOn, value, this.field)
      return;
    }
    this.value = isNaN(value) ? (value || {}) : {};
    this.container = $('<div class="input-group-field mt-1">');
    this.container.appendTo(this.renderOn);
    this.inputGroup = $('<div class="input-group">').appendTo(this.container);
    if (this.field['button_label']) {
      const inputGroup = $(`<div class="input-group-prepend">
        <span class="input-group-text field-group-text text-primary text-wrap mb-2">${this.field['d'] || this.field['n']}</span>
      </div>`).appendTo(this.inputGroup);
      inputGroup.find(":header").addClass('mb-0');
    }
    var fieldSiblings = new FieldSiblings();
    var subFields = this.field['fields'] || [];
    var i = 0;
    subFields.forEach(function (field) {
      var fieldClass = getEditableFieldClass(field);

      var fieldDom = this.inputGroup;
      if (field.isAppended) {
        var appendedElementContainer = $("<div class='input-group-append'>");
        appendedElementContainer.appendTo(this.inputGroup);
        fieldDom = appendedElementContainer;
      }

      var fieldInstance = new fieldClass(field, fieldDom, function () {
        fieldInstance.getValue(this.value)
        this.onChangeCallback();
      }.bind(this));
      fieldInstance.siblings = fieldSiblings;
      fieldSiblings.instances.push(fieldInstance);

      if ('default_value' in field) {  // Initialize to default value (if value is not set).
        this.value[field['n']] = this.value[field['n']] || field['default_value'];
        this.onChangeCallback();
      }

      fieldInstance.render(this.value[field['n']]);
      fieldInstance.getValue(this.value);
      if (fieldInstance.input) {
        fieldInstance.input.css({
          'border-radius': this.field['button_label'] ? '0px' : '4px 0px 0px 4px',
          'min-height': '40px'
        });
        // check if that input is the last field within the group
        if (i == subFields.length - 1 || !this.field['button_label']) {
          fieldInstance.input.addClass('left-radius');
        }
        else {
          fieldInstance.input.removeClass('left-radius');
        }
      }
      i++;
    }.bind(this));

    // // extra_blurb
    // if (this.field['extra_blurb']) {
    //   var me = this;
    //   var preblurb = $(`<div class="preblurb ml-1">`);
    //   $(`<button type="button" class="fa fa-question-circle p-0 mr-1 border-0
    //     text-danger" style="font-size: 21px; background: none;" data-template="<div class='tooltip'
    //     role='tooltip'> <div class='tooltip-inner bg-danger'></div></div>" data-toggle="tooltip"
    //     title="" data-original-title="Click to Learn More" data-placement="left"></button>`)
    //     .tooltip()
    //     .appendTo(preblurb)
    //     .click(function () {
    //       var tooltipId = $(this).attr('aria-describedby');
    //       var tooltip = $(document).find(`#${tooltipId}`);
    //       tooltip.find('.tooltip-inner').html(`<p class="mb-0 text-left">${me.field['extra_blurb']}</p>`);
    //     });
    //   this.inputGroup.append(preblurb);
    // };

    return this.inputGroup;
  }

  onAfterRender(value) {
    this.blurbContainer = this.inputGroup;
    super.onAfterRender(value || this.value || '');
  }

  readValue_() {
    return this.value;
  }

  static renderReadOnlyValue(renderOn, fieldValue, fieldSchema) {
    // var mainContainer = $(`
    // <div class="row">
    //   <label class="form-label col-12">${fieldSchema['d'] || fieldSchema['n']}</label>
    //   <div class="fields-container col-12 row ml-1"> </div>
    // </div>`)
    //   .appendTo(renderOn);
    var mainContainer = $(`
    <div class="row no-gutters">
      <div class="fields-container col-12 row ml-1"> </div>
    </div>`)
      .appendTo(renderOn);

    var fieldsContainer = mainContainer.find('.fields-container');

    ([fieldValue] || []).forEach(val => {
      fieldSchema['fields'].forEach(field => {
        if (val !== undefined && val[field['n']] !== undefined) {
          var fieldContainer = $('<div>').appendTo(fieldsContainer);
          var fieldAndClass = getFieldAndClass(field);
          var fieldClass = fieldAndClass[1];
          field = fieldAndClass[0];
          fieldClass.renderReadOnlyValue(fieldContainer, val[field['n']], field);
        }
      });
    });

  }
}


/*
To view EditableUserLookupField field :
1) WIRE.modal("Items", u('EditableObject', ['test', {
'fields': [{ n: 'userLookup', t: 'userlookup'
 }]}]),null,{"sizeMode":"full"});
2) This field can understand single value and multiple value :
   by default is recieve multiple value if you want single value
   you need to pass  d : 'single-value'
3) render value method recieve one value (one email) and array of emails like :
   _render("admin@admin.com") and _render(["admin@admin.com" , "guest@guest.com"])
*/
class EditableUserLookupField extends BaseEditableField {
  _render(value, allFieldsValues) {
    // if (this.field['readonly']) {
    //   EditableUserLookupField.renderReadOnlyValue(this.renderOn, value, this.field)
    //   return;
    // }
    this.value = value || [];
    var domContainer = this.renderOn;
    this.rndSelectId = Guid.generate();
    this.container = $('<div>').addClass('form-group userLookupField').appendTo(domContainer);
    this.select = $(
      `<label class="form-label" for="${this.rndSelectId}">
      Type email to select user :
      </label>
      <select multiple="" class=" form-control select2-hidden-accessible"
      id="${this.rndSelectId}" data-select2-id="single-placeholder" tabindex="-1" aria-hidden="true">
      </select>`).appendTo(this.container);

    var $this = this;
    $(document).ready(function () {
      $('#' + $this.rndSelectId).select2({
        dropdownParent: $this.container,
        placeholder: 'Type user email to select...'
      });
      $this.container.find('.select2-search__field').keydown(function () {
        if ($this.container.find('.select2-results__message').hasClass('d-none')) {
          $this.container.find('.select2-results__message').removeClass('d-none')
        }
        $this.container.find('.select2-results__message').text("Searching..");
      });
      if ($this.value != null || $this.value != undefined) {
        if (Array.isArray($this.value)) {
          $this.value.forEach(function (email) {
            $this.checkAndDrawUser(email);
          });
        } else {
          $this.checkAndDrawUser($this.value);
        }
      }
      $this.container.find('.select2-search__field').keyup($this.delay(function (e) {
        $this.container.find('.select2-results__message').addClass('d-none');
        var email = $this.container.find('.select2-search__field').val();
        if ($this.validateEmail(email)) {
          WIRE.call('business::resolve_user', {
            'email': email
          },
            function (data) {
              if (data._invalid_email != 1) {
                $this.result(data);
                $this.value.push($this.container.find('.select2-search__field').val());
              } else {
                if ($this.container.find('.sendInvite').length == 0) {
                  $this.container.find('.select2-results__message').removeClass('d-none')
                    .html("No results found!");
                  var sendInventationBtn = $(`<button type="button" class="btn btn-sm btn-outline-primary waves-effect waves-themed ml-1">
                    <span class="fa fa-envelope"></span> ${'Send Inventation to ' + $this.container.find('.select2-search__field').val()} </button>`);
                  sendInventationBtn.click(function () {
                    console.log(`send inventation to ${$this.container.find('.select2-search__field').val()} button is clicked!`);
                  });
                  $this.container.find('.select2-results__options').append(sendInventationBtn);
                }
              }
            });
        } else {
          $this.container.find('.select2-results__message').removeClass('d-none')
            .text("Please enter valid email!");
        }

      }, 1000));
    });
  }

  validateEmail(email) {
    const re = /^(([^<>()[\]\\.,;:\s@\"]+(\.[^<>()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
    return re.test(email);
  }
  checkAndDrawUser(value) {
    var email = value;
    var $this = this;
    WIRE.call('business::resolve_user', {
      'email': value
    },
      function (data) {
        if (data._invalid_email != 1) {
          $this.drawValue(data, email)
        } else {
          if ($this.container.find('.sendInvite').length == 0) {
            $this.container.find('.select2-results__message').removeClass('d-none')
              .html(`No results found! <br> Send inventation to ${$this.container.find('.select2-search__field').val()}`);
            $this.container.find('.select2-results__options').append(sendInventationBtn);
          }
        }
      });
  }
  drawValue(response, email) {
    var $this = this;
    $this.container.find('.select2-results__message').val("");
    response._user['email'] = email;
    var selectedOption = this.formatUser(response._user);
    var inputSlection = $this.container.find('.select2-selection__rendered');
    var selectedTag = $('<li>').addClass('select2-selection__choice').prependTo(inputSlection);
    var removeIcon = $('<span class="select2-selection__choice__remove" role="presentation">×</span>').appendTo(selectedTag);
    removeIcon.click(function () {
      var removedValue = $(this.closest('li')).find('.select2-result-user__email').text();
      this.closest('li').remove();
      var removedIndex = null;
      $this.value.map(function (value) {
        if (removedValue == value) {
          removedIndex = $this.value.indexOf(value)
        }
      });
      if (removedIndex > -1) {
        $this.value.splice(removedIndex, 1);
      }

    });
    $(selectedOption).appendTo(selectedTag);
  }
  result(response) {
    var $this = this;
    $this.container.find('.select2-results__message').val("");
    var option = this.formatUser(response._user);
    this.container.find('.select2-results__options').append(option);

    this.container.find('.select2-result-email-user').click(function () {
      $this.container.find('.select2-results__message').text("");
      var selectedOption = this;
      this.remove();
      var inputSlection = $this.container.find('.select2-selection__rendered');
      if ($this.field.d == "single-value") {
        inputSlection.find('.select2-selection__choice').remove();
      }
      if (inputSlection.find(`#${$this.container.find('.select2-search__field').val().replace('@', '').replace('.', '').trim()}`).length == 0) {
        var selectedTag = $('<li>').addClass('select2-selection__choice').prependTo(inputSlection);
        var removeIcon = $('<span class="select2-selection__choice__remove" role="presentation">×</span>').appendTo(selectedTag);
        removeIcon.click(function () {
          var removedValue = $(this.closest('li')).find('.select2-result-user__email').text();
          this.closest('li').remove();
          var removedIndex = null;
          $this.value.map(function (value) {
            if (removedValue == value) {
              removedIndex = $this.value.indexOf(value)
            }
          });
          if (removedIndex > -1) {
            $this.value.splice(removedIndex, 1);
          }

        });
        $(selectedOption).appendTo(selectedTag);
        $this.container.find('.select2-search__field').val("");
      }
    });
  }
  delay(callback, ms) {
    var timer = 0;
    return function () {
      var context = this,
        args = arguments;
      clearTimeout(timer);
      timer = setTimeout(function () {
        callback.apply(context, args);
      }, ms || 0);
    };
  }
  formatUser(user) {
    var email = (WIRE.d(user.id).email) ? WIRE.d(user.id).email : this.container.find('.select2-search__field').val() || user.email;
    var option = '<li>' + "<div class='select2-result-email-user  clearfix d-flex' id='" + email.replace('@', '').replace('.', '').trim() + "'>" +
      "<div class='select2-result-user__avatar mr-2'><img src='" + user.photo + "' class='width-2 height-2 mt-1 rounded' /></div>" +
      "<div class='select2-result-user__meta'>" +
      "<div class='select2-result-user__title fs-lg fw-500'>" + user.name + "</div>" +
      "<div class='select2-result-user__email fs-sm fw-500'>" + email + "</div>" + '</li>';
    return option;
  }
  readValue() {
    return this.value;
  }

}

/**
 To view EditableCheckableDropdownField field :
1) WIRE.modal("Items", u('EditableObject', ['test', {
'fields': [{ n: 'select Items .. ', t: 'checkabledropdown' ,
 choices : [{d:'item1' , n:'i1'} , {d : 'item2',n :'i2'} ] or
 choices : ["item1","item2".....]
 }]}]),null,{"sizeMode":"full"});
2) Choices : is represent the choices tha is need to be filled as options in the CheckableDropdownField
3) Render value method recieve one value (one option) and array of options to be selected Ex :
   _render(["item1","item2"]) or if choices is ([{n:'item1' , d:'item1'}, {n:'item2' , d:'item2'}]) then
   _render([array of choices['n']]) ;
   - If you want to sent the value as array of strings while the choices is array
   of objects you need to pass the n attribute
 */
class EditableCheckableDropdownField extends BaseEditableField {
  _render(value, allFieldsValues) {
    this.value = value || [];
    this.domContainer = this.renderOn;
    var formGroup = $('<div>')
      .addClass('')
      .appendTo(this.domContainer);
    var rndID = Guid.generate();
    this.select = $('<select>')
      .addClass('form-control')
      .attr({ 'multiple': 'multiple', 'id': rndID })
      .appendTo(formGroup);
    this.choices = this.field['choices'];

    this.choices.forEach(element => {
      if (typeof element == 'string') {
        $(`<option value="${element}">${element}</option>`).appendTo(this.select);
      }
      else {
        $(`<option value="${element['n']}">${element['d']}</option>`).appendTo(this.select);
      }
    });

    this.select.multiselect({
      includeSelectAllOption: true,
      buttonWidth: '100%',
      //container : this.select,
      //buttonContainer: this.domContainer,
      templates: {
        // button: '<button type="button" class=" dropdown-toggle" data-toggle="dropdown"></button>',
        ul: ` <ul class="dropdown-menu p-1" x-placement="bottom-start"
        style="width: inherit;">`,

      },
      buttonText: function (options, select) {
        if (options.length === 0) {
          return this.field['d'] || this.field['n'];
        }
        else {
          return options.length + ' selected';
        }
      }.bind(this),
      onChange: function (options, checked) {
        if (checked) {
          if (typeof this.choices[0] == 'string') {
            // prevent duplicates of value
            if (this.value.indexOf(options.text()) === -1) {
              this.value.push(options.text());
            }
          } else {
            // prevent duplicates of value
            if (this.value.indexOf(options.attr('value')) === -1) {
              this.value.push(options.attr('value'));
            }
          }
        }
        else {
          $.each(this.value, function (index, value) {
            if (value == ((typeof this.choices[0] == 'string') ? options.text() : options.attr('value'))) {
              this.value.splice(index, 1);
            }
          }.bind(this));
        }
        this.onChangeCallback();
      }.bind(this),
      onSelectAll: function () {
        this.value = [];
        if (typeof this.choices[0] == 'string') {
          this.value = [...this.choices];
        } else {
          this.value = this.choices.map(item => item['n']);
        }
        this.onChangeCallback();
      }.bind(this),
      onDeselectAll: function () {
        this.value = [];
        this.onChangeCallback();
      }.bind(this)
    });
    if (this.value) {
      var selectedValues = [];
      this.value.forEach(element => {
        if (typeof element == 'string') {
          selectedValues.push(element);
        } else {
          selectedValues.push(element['n']);
        }
      });
      this.select.multiselect('select', selectedValues, true);
    }
  }

  readValue_() {
    return this.value;
  }
}

class EditableComboBoxField extends BaseEditableField {
  _render(value, allFieldsValues) {
    if (this.field['readonly']) {
      EditableComboBoxField.renderReadOnlyValue(this.renderOn, value, this.field)
      return;
    }
    this.uniqueId = Guid.generate();
    this.container = $('<div id="itCoursesContainer">').appendTo(this.renderOn);
    this.constructor._renderValue(this.container, this.uniqueId, this.field["choices"],
      value, this.onChangeCallback, false, this);
    return this.container;
  }

  onAfterRender(value) {
    this.blurbContainer = this.container;
    super.onAfterRender(value || this.value || '');
  }

  static renderReadOnlyValue(renderOn, fieldValue, fieldSchema) {
    this._renderValue(renderOn, this.uniqueId, fieldSchema["choices"], fieldValue, null, true);
  }

  static _renderValue(renderOn, uniqueId, choices, value, onChangeCallback, readonly, caller) {
    value = value || [];
    this.select = $(`<select id="itCoursesInp"><option></option></select>`)
      .appendTo(renderOn);
    var me = this;
    (choices || []).forEach(function (c) {
      if (typeof c === 'string') {
        c = { 'n': c, 'd': c };
      }
      c['d'] = c['d'] || c['n'];
      var choiceText, choiceVal;
      if (typeof c == "string") {
        choiceVal = choiceText = c;
      } else {
        choiceVal = c['n'];
        choiceText = c['d'];
      }
      value.forEach(choice => {
        if (choiceVal == choice) {
          // Hack: send attributes within the val
          choiceVal = 'checked' + choiceVal;
        }
      });
      var entryDom = $(`<option value='${uniqueId + 'obj' + choiceVal}'>${choiceText}</option>`);
      entryDom.appendTo(me.select);
    });
    this.select.comboEdit({
      placeholder: caller.field['d'],
      multiple: true,
      checkable: true,
      showCounter: true,
      isReadOnly: readonly,
    });
    // Callback
    for (var i = 0; i < $('.checkable-input').length; i++) {
      var inputContainer = $('.checkable-input')[i];
      $(inputContainer).on('input', function () {
        if (!readonly && onChangeCallback && $.isFunction(onChangeCallback)) {
          onChangeCallback.call(caller);
        }
      }.bind(me));
    }
  }
  readValue_() {
    return this.container.find("input:checkbox:checked").map(function () {
      var val = $(this).attr("value");
      // Hack: extract attributes from value
      if (val.contains("checked")) {
        return val.substring(val.indexOf("checked") + 7);
      }
      else {
        return val.substring(val.indexOf("obj") + 3);
      }

    }).get();
  }
}

class EditableWalletChooserField extends BaseEditableField {
  _render(value, allFieldsValues) {
    if (this.field['readonly']) {
      EditableWalletChooserField.renderReadOnlyValue(this.renderOn, value, this.field);
      return;
    };
    if ('account' in WIRE.data) {
      this._renderLoggedInAccount(value);
    } else {
      //this.error = 'You must register or login';
      // Needs to register.
      this.container = $(`
      <div class="text-center m-auto">
        <img src="img/logo.png" style="width: 100px; margin-bottom:-9px;margin-top: -18px; cursor: default"/>
        <h4 class="mt-0" style="font-size:15px">You need an account on KeyRas. You can either
          <span>
            <button id="login" class="btn btn-sm btn-primary">
              <i class="fa fa-sign-in"></i> Login
            </button>
          </span>
          <span style="font-size: 14px">
            or <a id="register" class="text-primary" target="_blank">Register</a>
          </span>
        </h4>
      </div>
      `).appendTo(this.renderOn);
      this.container.appendTo(this.renderOn);
      var loginBtn = this.container.find('#login');
      loginBtn.on('click', function () {
        var editableObject = u('EditableObject', ['login1', WIRE.schemaManager.schema['login_auth']]);
        var container = $('<div class="card p-4 rounded-plus bg-faded">');
        container.append(`<div class="text-center m-auto">
        <img src="img/logo.png" style="width: 100px; margin-bottom:-9px;margin-top: -18px; cursor: default"/></div>`);
        WIRE.unrollRecursive(editableObject, container);
        var login = $(`<button class="btn btn-primary btn-block mt-1 text-light text-center w-100 p-0" style="height: 38px;">
        <span>Login</span>
       </button`).appendTo(container).click(function () {
          var loginValues = WIRE.getEditableValues('login1');
          var loginObj = {
            'email': loginValues["login_email"].toLowerCase(),
            'password': loginValues["login_password"]
          };
          loginBtn.attr({ 'disabled': '' });
          // Post Login Message
          try {
            // flutter channel communication (send message from javascript to flutter)
            Login.postMessage(JSON.stringify({
              username: loginObj["email"],
              password: loginObj["password"]
            }));
          } catch { }
          WIRE.call('login', loginObj, function () {
            if ('account' in WIRE.data) {
              this._renderLoggedInAccount(value);
              this.modal.close();
              // Specto.ui.Modal.closeAll();
            }
          }.bind(this), function (response) {
            if (response['error']) {
              // Post Logout Message
              try {
                // flutter channel communication (send message from javascript to flutter)
                Login.postMessage(JSON.stringify({ username: null, password: null }));
              } catch (err) { }
              var passInput = this.modal.modalContainer.find('#password');
              var emailInput = this.modal.modalContainer.find('#email');
              passInput.parent().find('.invalid-feedback').remove();
              passInput.addClass('is-invalid');
              emailInput.addClass('is-invalid');

              if (!passInput.val() || !emailInput.val()) {
                passInput.parent()
                  .append(`<div class="invalid-feedback">${'Email and password are required!'}</div>`);
              } else {
                passInput.parent()
                  .append(`<div class="invalid-feedback">${response['error']}</div>`);
              }
              loginBtn.removeAttr('disabled');
            }
          }.bind(this));
        }.bind(this));
        $(`<div class="position-relative">
        <hr class="my-3" style="border: 0; border-top: 1px solid rgba(0, 0, 0, 0.1);">
        <span class="or-login-with-inner position-absolute text-secondary">or</span>
        </div>`).appendTo(container);
        $(`<button class="btn btn-block google-signin text-light w-100 p-0">
        <div class="d-flex" style="align-items: center;">
        <img src="img/google-signin.png" width="37">
        <div class="w-100 text-center"><span>Sign in with Google</span></div>
        </div>
        </button`).appendTo(container);
        //login with facebook
        $(`<button class="btn btn-block fb-signin text-white w-100 p-0 mt-1 waves-effect waves-themed">
           <div class="d-flex" style="align-items: center;">
            <img src="img/fb-logo.png" width="37">
            <div class="w-100 text-center"><span>Sign in with Facebook</span></div>
           </div>
          </button>`).appendTo(container)
          .on('click', function () {
            FB.login(function (response) {
              console.log(response);
              if (response.authResponse) {
                // Get and display the user profile data
                getFbUserData();
              } else {
                status.innerHTML = 'User cancelled login or did not fully authorize.';
              }
            }, { scope: 'email' });
          });
        this.modal = Specto.ui.Modal.showModal(container, 'Login', [], { 'sizeMode': 'small', 'expandButton': false, 'theme': 'default', 'width': '395px' });
        $(document).keypress(function (e) {
          if ($(this.modal.modalContainer).hasClass('show') && (e.keycode == 13 || e.which == 13)) {
            login.click();
          }
        }.bind(this));
        startApp(this.modal.modalContainer);
      }.bind(this));

      var registerBtn = this.container.find('#register');
      registerBtn.on('click', function () {
        var editableObject = u('EditableObject', ['register1', WIRE.schemaManager.schema['account']]);
        var container = $('<div class="card p-2 rounded-plus bg-faded">');
        container.append(`<div class="text-center m-auto">
        <img src="img/logo.png" style="width: 100px; margin-bottom:-9px;margin-top: -18px; cursor: default"/></div>`);
        WIRE.unrollRecursive(editableObject, container);
        var register = $(`<button class="btn btn-primary btn-block mt-1 text-light text-center w-100 p-0" style="height: 38px;">
         <span>Register</span>
        </button`).appendTo(container).click(function () {
          try {
            var registerValues = WIRE.getEditableValues('register1');
          } catch (ex) {
            this.modal.modalContainer.find('.err-msg').parent().find('.form-group').find('.invalid-feedback').remove();
            this.modal.modalContainer.find('.err-msg').parent().find('.form-group').find('input').addClass('is-invalid');
          };
          if (registerValues && !this.modal.modalContainer.find('.invalid-feedback:visible').length) {
            registerValues["email"] = registerValues["email"].toLowerCase();
            // Post Login Message
            try {
              // flutter channel communication (send message from javascript to flutter)
              Login.postMessage(JSON.stringify({
                username: registerValues["email"],
                password: registerValues["password"]
              }));
            } catch { }
            WIRE.call('new_account', registerValues, function () {
              if ('account' in WIRE.data) {
                this._renderLoggedInAccount(value);
                this.modal.close();
                // Specto.ui.Modal.closeAll();
              }
            }.bind(this), function (response) {
              this.modal.modalContainer.find('.err-msg').remove();
              this.modal.modalContainer.find('.invalid-feedback').remove();
              if (response['error'].toLowerCase().contains('email')) {
                var emailInput = this.modal.modalContainer.find('input#email');
                emailInput.addClass('is-invalid');
                emailInput.parent()
                  .append(`<div class="invalid-feedback">${response['error']}</div>`);
              } else {
                this.modal.modalContainer.find('.custom-modal')
                  .prepend(`<div class="text-danger err-msg p-2">${response['error']}</div>`);
              }
            }.bind(this));
          }
        }.bind(this));
        $(`<div class="position-relative">
         <hr class="my-3" style="border: 0; border-top: 1px solid rgba(0, 0, 0, 0.1);">
         <span class="or-login-with-inner position-absolute text-secondary">or</span>
         </div>`).appendTo(container);
        $(`<button class="btn btn-block google-signin text-light w-100 p-0">
        <div class="d-flex" style="align-items: center;">
        <img src="img/google-signin.png" width="37">
        <div class="w-100 text-center"><span>Sign up with google</span></div>
        </div>
        </button`).appendTo(container);
        //sign up with facebook
        $(`<button class="btn btn-block fb-signup text-white w-100 p-0 mt-1 waves-effect waves-themed">
         <div class="d-flex" style="align-items: center;">
          <img src="img/fb-logo.png" width="37">
          <div class="w-100 text-center"><span>Sign up with Facebook</span></div>
         </div>
         </button>`).appendTo(container);

        this.modal = Specto.ui.Modal.showModal(container, 'Register', [], { 'sizeMode': 'small', 'expandButton': false, 'theme': 'default', 'width': '395px' });
        $(document).keypress(function (e) {
          if ($(this.modal.modalContainer).hasClass('show') && (e.keycode == 13 || e.which == 13)) {
            register.click();
          }
        }.bind(this));
        startApp(this.modal.modalContainer);
        var passwordInput = this.modal.modalContainer.find('input#password');
        passwordInput.parent().next()
          .find('input[type="password"]')
          .attr({ 'id': 'confirmPassword' });

        validateRegiterFormInputs(this.modal.modalContainer);
      }.bind(this));
      // $('#login_email').parents().find('.custom-modal').addClass('card p-4 rounded-plus bg-faded');

      return;
    }
  }

  onAfterRender(value) {
    this.blurbContainer = this.container;
    super.onAfterRender(value || this.value || '');
  }

  getValue(valueDict) {
    if (this.error) {
      return this.error;
    }
    if (this.value) {
      valueDict[this.field['n']] = this.value;
    }
  }
  static renderReadOnlyValue(renderOn, value, field) {
    WIRE.depictor.createItemDom(WIRE.d(value)).appendTo(renderOn);
  }

  _renderLoggedInAccount(value) {
    this.error = null;
    if (value) {
      // Rendering someone's wallet.
      var jq = $('<div><span id="label"></span><span id="walletDisplay"></span></div>').appendTo(this.renderOn);
      jq.find('#label').html(this.field['d'] || this.field['n']);
      jq.find('#walletDisplay').html(value);
    } else {
      if (this.field['accounts']) {
        // Check if account has required wallet type.
        var walletTypeSet = new Set(this.field['accounts']);
        var loggedInWalletsWithType = WIRE.data['wallets'].map(WIRE.d.bind(WIRE)).filter(w => walletTypeSet.has(w['type']));
        if (loggedInWalletsWithType.length == 0) {
          var noRequiredWalletTypeJq = 'To access this, you must be registered as';
          if (loggedInWalletsWithType.length > 1) {
            noRequiredWalletTypeJq += ' one of';
          }
          var humanWalletTypes = this.field['accounts'].map(walletType => walletType.substr(0, walletType.length - 3));
          noRequiredWalletTypeJq += ': ' + humanWalletTypes.join(', ');
          this.error = noRequiredWalletTypeJq;
          noRequiredWalletTypeJq += ' <button id="register" class="btn btn-primary">Register</button>';
          noRequiredWalletTypeJq = $('<span>' + noRequiredWalletTypeJq + '</span>');

          noRequiredWalletTypeJq.find('#register').click(function () {
            popupRegisterWalletWizard(humanWalletTypes);
          }.bind(this));
          this.renderOn.empty().append(noRequiredWalletTypeJq);
        } else {
          // Logged-in. Wallet required and found.
          // TODO: Allow user to select.
          var chosenWallet = loggedInWalletsWithType[0];
          var account = WIRE.d(WIRE.data['account']);
          // this.renderOn.empty().append($(`<span>We have identified you as ${account['name']} (${chosenWallet['type'].substr(0, chosenWallet['type'].length - 3)}; ${account['email']})</span>`));
          this.container = $(`
            <div class="text-center m-auto">
              <h4 class="mb-0" style="font-size: 15px">
                We have identified you as ${account['name']}
                <img src="img/check.gif" style="width: 32px; cursor: default"/>
              </h4>
              <div class="account-card mt-1"></div>
            </div>`);
          this.renderOn.empty().append(this.container);
          this.value = '!obj!' + chosenWallet._id;
          WIRE.depictor.createItemDom(WIRE.d(this.value))
            .appendTo(this.container.find('.account-card'));
        }
      } else {
        // No wallet types required. Display account.
        // TODO(Hadeel) TODO(Razan): make and use account card.
        var account = WIRE.d(WIRE.data['account']);
        //this.renderOn.empty().append($(`<span>We have identified you as ${account['name']} (${account['email']})</span>`));
        this.container = $(`
          <div class="text-center m-auto" style="width: 300px">
          <h4>We have identified you as ${account['name']} (${account['email']})</h4>
            <div class="account-card mt-3 mb-1 faa-float animated"></div>
          </div>`);
        this.renderOn.empty().append(this.container);
        this.value = WIRE.data['account'];
        WIRE.depictor.createItemDom(WIRE.d(this.value))
          .appendTo(this.container.find('.account-card'));
      }
    }
  }
}

class EditableRangeSliderField extends BaseEditableField {
  _render(value, allFieldsValues) {
    if (this.field['readonly']) {
      EditableSideNavigatorField.renderReadOnlyValue(this.renderOn, value, this.field);
      return;
    };

    var container = this.container = $('<div class="form-group rangeslider-field">');
    container.appendTo(this.renderOn)
      .addClass(this.field['class'] || '');

    var hideLabel = this.field['hide_label'];
    $(`<label class="form-label ${hideLabel ? '' : 'mb-3'}">`)
      .html(hideLabel ? '' : (this.field['d'] || this.field['n']))
      .appendTo(container);
    var isNarrow = this.renderOn.width() && this.renderOn.width() < 215;
    this.controls = $(`
      <div class="extra-controls position-relative ${isNarrow ? 'mb-3' : ''}">
        <input type="text" class="js-input-from ${isNarrow ? 'w-100 mb-1' : ''}"/>
        <input type="text" class="js-input-to float-right ${isNarrow ? 'w-100 mb-1' : ''}"/>
      </div>
      <div class="range-slider">
        <input type="text" class="js-range-slider" value="" />
      </div>`).appendTo(container);
    this.input = this.controls.find('.js-range-slider');

    var options = {
      skin: "round",
      type: "double",
      grid: false,
      hide_from_to: true,
      hide_min_max: true,
      min: this.field['min'] || 0,
      onStart: updateInputs,
      onChange: updateInputs,
    };

    if (this.field['max']) {
      options['max'] = this.field['max'];
    }

    if (this.field['step']) {
      options['step'] = this.field['step'];
    }

    options['postfix'] = ` ${this.field['blurb'] || ''}`;

    if (value) {
      options = $.extend({}, options, value || this.field['default_value']);
    }

    if ($.isFunction(this.onChangeCallback)) {
      options.onChange = function () {
        this.onChangeCallback();
      }.bind(this);
    }

    var $inputFrom = this.inputFrom = this.controls.find(".js-input-from");
    var $inputTo = this.inputTo = this.controls.find(".js-input-to");
    var instance;
    var min = options['min'];
    var max = options['max'];
    var from = 0;
    var to = 0;

    this.input.ionRangeSlider(options);
    instance = this.input.data("ionRangeSlider");
    function updateInputs(data) {
      from = data.from;
      to = data.to;
      $inputFrom.prop("value", from);
      $inputTo.prop("value", to);
    }

    function minValueUpdate() {
      var val = $(this).prop("value");
      if (val) {
        // validate
        if (val < min) {
          val = min;
        } else if (val > to) {
          val = to;
        }
        instance.update({
          from: val
        });
        options.onChange();
      }
    }

    function maxValueUpdate() {
      var val = $(this).prop("value");
      if (val) {
        // validate
        if (val < from) {
          val = from;
        } else if (val > max) {
          val = max;
        }
        instance.update({
          to: val
        });
        options.onChange();
      }
    }

    // rangeValuesUpdate happens on inputs keyup, but only after
    // the user has stopped typing for 550ms.
    $inputFrom.keyup($.debounce(750, minValueUpdate));

    $inputTo.keyup($.debounce(750, maxValueUpdate));

    $inputFrom.on('focusout', function () {
      var val = $(this).prop("value");
      if (!val) {
        instance.update({
          from: min
        });
        options.onChange();
      }
    });

    $inputTo.on('focusout', function () {
      var val = $(this).prop("value");
      if (!val) {
        instance.update({
          to: max
        });
        options.onChange();
      }
    });

    return this.input;
  };

  onAfterRender(value) {
    this.blurbContainer = this.container;
    super.onAfterRender(value || this.value || '');
  }

  readValue_() {
    var value = this.input.data("ionRangeSlider").result;
    if (value['from'] >= 0) {
      value['to'] = value['to'] >= 0 ? value['to'] : value['max'];
      this.inputTo.prop("value", value['to']);
    }

    if (value['to'] >= 0) {
      value['from'] = value['from'] >= 0 ? value['from'] : value['min'];
      this.inputFrom.prop("value", value['from']);
    }
    return { 'from': value['from'], 'to': value['to'] };
  }

  static renderReadOnlyValue(renderOn, fieldValue, fieldSchema) {
    $('<div>').text(`From: ${fieldValue['from']} - To: ${fieldValue['to']}`).appendTo(renderOn);
  }

}

class EditableIntRangeField extends BaseEditableField {
  _render(value, allFieldsValues) {
    if (this.field['readonly']) {
      EditableIntRangeField.renderReadOnlyValue(this.renderOn, value, this.field)
      return;
    }
    // value = {from: 13, to: 20};
    this.container = $('<div>').addClass('input-group').appendTo(this.renderOn);
    // 'from' prefix
    $(`<div class="input-group-prepend">
      <span class="input-group-text text-primary">From</span>
      </div>`).appendTo(this.container);
    this.fromInput = $(`<input type="number" class="form-control" min="0">`)
      .appendTo(this.container);
    // field['d'] suffix
    $(`<div class="input-group-prepend">
      <span class="input-group-text text-primary">${this.field['d']}</span>
      </div>`).appendTo(this.container);
    // 'to' prefix
    $(`<div class="input-group-prepend">
      <span class="input-group-text text-primary">To</span>
      </div>`).appendTo(this.container);
    this.toInput = $(`<input type="number" class="form-control" min="0">`)
      .appendTo(this.container);
    // field['d'] suffix
    $(`<div class="input-group-prepend">
      <span class="input-group-text text-primary">${this.field['d']}</span>
      </div>`).appendTo(this.container);

    this.fromFloatingLbl = $(`<div style="position: absolute;top: ${value ? '-9px' : '10px'};z-index: 1;width:fit-content;left: 72px;
      color: gray;background: white;"><span>${'Min'}</span></div>`);

    this.toFloatingLbl = $(`<div style="position: relative;top: ${value ? '-9px' : '10px'};z-index: 1;width:0px;left: 54px;
      color: gray;background: white;"><span>${'Max'}</span></div>`);

    this.fromInput.on('change', function () {
      this.onChangeCallback();
    }.bind(this));

    this.toInput.on('change', function () {
      this.onChangeCallback();
    }.bind(this));


    this.setValue(value);
    this.fromInput.change();
    this.fromInput.blur();
    this.toInput.change();
    this.toInput.blur();
    this.onChangeCallback();
    return {
      from: this.fromInput,
      to: this.toInput
    };
  }

  onAfterRender() {
    // var labelPosition = this.field["d_pos"] || this.defaultLabelPosition || 'floating';
    this.fromFloatingLbl.prependTo(this.container);
    this.toFloatingLbl.insertBefore(this.toInput.prev());
    var me = this;
    this.fromInput.on("focusout", function () {
      me.fromFloatingLbl.css('display', 'block');
      if ($(this).val()) {
        me.fromFloatingLbl.css('top', '-9px');
      }
      else {
        me.fromFloatingLbl.css('top', '10px');
      }
    });
    this.fromInput.on("focusin", function () {
      me.fromFloatingLbl.css('display', 'none');
    });
    this.toInput.on("focusout", function () {
      me.toFloatingLbl.css('display', 'block');
      if ($(this).val()) {
        me.toFloatingLbl.css('top', '-9px');
      }
      else {
        me.toFloatingLbl.css('top', '10px');
      }
    });
    this.toInput.on("focusin", function () {
      me.toFloatingLbl.css('display', 'none');
    });
  }

  readValue_() {
    var value = {
      from: 0,
      to: 0
    };
    if (this.fromInput.val()) {
      value['from'] = this.fromInput.val();
    }
    if (this.toInput.val()) {
      value['to'] = this.toInput.val();
    }
    return value;
  }

  setValue(value) {
    if (value) {
      this.fromInput.val(value['from']);
      this.toInput.val(value['to']);
    }
  }

  static renderReadOnlyValue(renderOn, fieldValue) {
    if (fieldValue) {
      $("<div>").html(`from: ${fieldValue['from']}, to: ${fieldValue['to']}`)
        .appendTo(renderOn);
    }
  }
}

/*
To view EditableSummaryTagsListField field :
1) WIRE.modal("Items", u('EditableObject', ['test', {
'fields': [{ n: 'tags', t: 'summarytagslist' , enable_delete : true,
 data : ["tag1","tag2","tag3"]
 }]}]),null,{"sizeMode":"full"});
2) Data : is represent all tags.
*/
class EditableSummaryTagsListField extends BaseEditableField {
  _render(value, allFieldsValues) {
    EditableSummaryTagsListField.__render(this.renderOn, this.field, this.onChangeCallback);
  }

  static renderReadOnlyValue(renderOn, fieldValue, fieldSchema) {
    __render(renderOn, fieldSchema);
  }

  static __render(renderOn, field, callback) {
    var formGroup = $('<div class="summarytag-field">')
      .addClass('d-flex overflow-y')
      .css({ 'flex-wrap': 'wrap' })
      .appendTo(renderOn);

    field['data'].forEach(function (item, index) {
      EditableSummaryTagsListField._addTag(item, field['readonly'], callback).appendTo(formGroup);
    });
  }

  add(item) {
    this.field.data.push(item);
    this.renderOn
      .find('.summarytag-field')
      .append(this._addTag(item, this.field['readonly'], this.onChangeCallback));
  }

  static _addTag(item, readonly, callback) {
    if (typeof item === 'string') {
      item = { 'n': item, 'd': item };
    }
    var tag = $('<div>')
      .addClass("d-inline-flex alert alert-primary alert-dismissible fade show ml-2 mt-1 m-0 ")
      .attr({ 'role': 'alert' })
      .css({ 'width': 'fit-content', 'padding': '2px 25px 2px 7px', 'border': '2px solid #7a59ad', 'color': 'black' })
      .append('<strong class="mr-4">')
      .html(item['d'] || item['n']);

    if (!readonly) {
      $('<button>')
        .addClass('close text-primary')
        .attr({ 'type': 'button', 'data-dismiss': 'alert', 'aria-label': 'Close' })
        .css({ 'padding': '2px 5px 2px 2px', 'opacity': '1', 'font-size': '17px' })
        .append('<span aria-hidden="true"><i class="fa fa-times-circle"></i></span>')
        .appendTo(tag)
        .on('click', function () {
          if ($.isFunction(callback)) {
            callback({ 'action': 'remove', 'item': item });
          }
        });
    }

    callback({ 'action': 'add', 'item': item });
    return tag;
  }
}


/**
* view :  WIRE.modal("Items", u('EditableObject', ['test', {
         'fields': [{ n: 'iFrameField', d: 'Enter a URL to upload' , t :'iframe'  ,
          'url':'https://my.matterport.com/show/?m=SEWuUFDvJvi&title=0&f=0&mls=1&play=0&qs=0&brand=0&dh=1&gt=0&hr=0&vr=0&pin=0',
         }]}]),null,{"sizeMode":"full"});
* url : any url to be rendered in the i frame field
*/
class EditableIFrameField extends BaseEditableField {
  _render(value, allFieldsValues) {
    if (this.field['readonly']) {
      EditableIFrameField.renderReadOnlyValue(this.renderOn, value, this.field)
      return;
    };
    var me = this;
    this.value = value;
    var id = Guid.generate();
    var inputGroup = $('<div>').addClass('iframe-main-container row no-gutters').attr({ 'id': id }).appendTo(this.renderOn);
    this.urlInput = $('<input  style="border-radius: 4px 0px 0px 4px;">').addClass('has-float-label url-text file-input form-control')
      .attr({ 'type': 'text', 'placeholder': this.field['d'] ? this.field['d'] : "Enter a Url to upload" });
    var groupWrap = $('<div>').addClass('w-75 form-group-wrap').appendTo(inputGroup);
    var embedBtnDom = $('<div>').addClass("input-group-append");
    var embedBtn = $('<button style="border-radius: 0px 4px 4px 0px;">')
      .prop('disabled', !this.value)
      .addClass('w-25 browse btn btn-primary')
      .attr({ 'id': 'EmbedUrlBtn', 'type': 'button' })
      .text('Embed');
    this.urlInput.appendTo(groupWrap);
    var fixedLabel = this.field['fixed_label'] || this.field['d'];
    var formLabel = $('<label>').addClass('form-label').text(fixedLabel).appendTo(groupWrap);

    embedBtn.appendTo(embedBtnDom).appendTo(inputGroup);
    this.closeBtn = $(`<span class="close-btn fa fa-times-circle text-${this.value ? 'danger' : 'secondary'}" style="position: absolute;
    top: 10px; right:6px; background: white; font-size: 19px">`)
      .prependTo(groupWrap)
      .click(function () {
        me.urlInput.val('');
        me.value = null;
        iframContainer.addClass('d-none');
        iframe.attr({ 'src': '' });
        me.closeBtn.removeClass('text-danger');
        me.closeBtn.addClass('text-secondary');
        embedBtn.prop('disabled', true);
        me.onChangeCallback();
      }.bind(this));
    var iframContainer = $('<div class="iframe-container embed-responsive embed-responsive-16by9 d-none">').appendTo(inputGroup);
    var iframe = $('<iframe>').addClass('w-100 embed-responsive-item')
      .attr({ 'allowfullscreen': 'allowfullscreen', 'style': 'border: dashed 1px #886ab5;', 'frameborder': '0' });
    iframe.appendTo(iframContainer);

    if (this.value || this.field['url']) {
      $(this.urlInput).val(this.value || this.field['url']);
      iframContainer.removeClass('d-none');
      iframe.attr({ src: this.value || this.field['url'] });
    };
    this.urlInput.focusout(function () {
      embedBtn.prop('disabled', !$(this).val());
    });
    var field = this;
    embedBtn.click(function () {
      field.embedUrl();
      this.onChangeCallback();
    }.bind(this));

    this.urlInput.keydown(function () {
      groupWrap.find('.close-btn').removeClass('text-secondary');
      groupWrap.find('.close-btn').addClass('text-danger');
    });
    this.urlInput.on('change', function () {
      field.embedUrl();
      this.onChangeCallback();
    }.bind(this));
    this.urlInput.keyup(function (e) {
      embedBtn.prop('disabled', false);
      if (e.keyCode == 13) {
        if (this.urlInput.val()) {
          this.value = this.urlInput.val();
          iframContainer.removeClass('d-none');
          iframe.attr({ 'src': this.value });
          me.closeBtn.removeClass('text-secondary');
          me.closeBtn.addClass('text-danger');
          // embedBtn.prop('disabled', true);
        };
        this.onChangeCallback();
      }
    }.bind(this));

  };

  embedUrl() {
    if (this.urlInput.val()) {
      this.value = this.urlInput.val();
      this.renderOn.find('.iframe-container').removeClass('d-none');
      this.renderOn.find('.iframe-container').find('iframe').attr({ 'src': this.value });
      this.renderOn.find('.iframe-container').find('.close-btn').removeClass('text-secondary');
      this.renderOn.find('.iframe-container').find('.close-btn').addClass('text-danger');
    }
    else {
      this.value = null;
      this.renderOn.find('.iframe-container').addClass('d-none');
      this.renderOn.find('.iframe-container').find('iframe').attr({ 'src': '' });
      this.renderOn.find('.iframe-container').find('.close-btn').removeClass('text-danger');
      this.renderOn.find('.iframe-container').find('.close-btn').addClass('text-secondary');
    };
  };
  readValue() {
    return this.readValue_();
  };
  readValue_() {
    return this.value;
  };
  static renderReadOnlyValue(renderOn, fieldValue) {
    var id = Guid.generate();
    var inputGroup = $('<div>').addClass('input-group').attr({ 'id': id }).appendTo(renderOn);
    var iframContainer = $('<div class="embed-responsive embed-responsive-16by9">').appendTo(inputGroup);
    var iframe = $('<iframe>').addClass('w-100 embed-responsive-item')
      .attr({
        'allowfullscreen': 'allowfullscreen',
        'style': 'border: dashed 1px #886ab5;',
        'frameborder': '0',
        src: fieldValue
      });
    iframe.appendTo(iframContainer);
  };
}

/**
  * view :  WIRE.modal("Items", u('EditableObject', ['test', {
           'fields': [
            { n: 'FieldRadioSelector',
           "d" :'Select Field to view' ,
           "t": "fieldradioselector",
           "fields":[
             { "n": "photo", "d": "Browse Photo", "t": "photo", checked:true , thumbnail : true},
             { "n": "iframe", "d": "Embed Url", "t": "iframe"},
           ]
           }]}]),null,{"sizeMode":"full"});
 * fields : all fields that will rendered in the radio selector.
 * checked: true / false deafault selected option .
 * IMPORTANT NOTE: To be discuessed wit Sami : this field read just one value at a time
 *  which represents the checked one!! 
*/
class EditableFieldRadioSelector extends BaseEditableField {
  _render(value, allFieldsValues) {
    var id = Guid.generate();
    var mainContainer = this.mainContainer = $('<div>')
      .addClass('panel')
      .attr({ id: id });
    mainContainer.appendTo(this.renderOn);
    var panelHeader = $('<div>')
      .addClass('panel-hdr')
      .attr({ 'role': 'heading' })
      .html(`<h2>${this.field['d'] || this.field['n']}</h2>`);
    mainContainer.append(panelHeader);
    var panelToolBar = $('<div>')
      .addClass('panel-toolbar');
    panelHeader.append(panelToolBar);
    var panelContainer = $('<div>')
      .addClass('panel-container show')
      .attr({ "role": "content" });
    var fieldsContainer = $('<div>')
      .addClass('panel-content p-2')
      .attr({ 'style': 'background-color: #f7f4fb;color: rgba(0, 0, 0, 0.8);' });
    fieldsContainer.appendTo(panelContainer).appendTo(mainContainer);
    this.renderFields(fieldsContainer, panelToolBar, this.field['fields'], mainContainer);
  };

  onAfterRender(value) {
    this.blurbContainer = this.mainContainer;
    super.onAfterRender(value || this.value || '');
  }

  renderFields(renderOnJq, toolbarJq, fields, mainContainer) {
    toolbarJq.empty();
    renderOnJq.empty();
    fields.forEach(function (field) {
      var id = Guid.generate();
      var radio = $(`<div class="custom-control custom-radio custom-control-inline">
       <input type="radio"  class="custom-control-input" id="${id}" name="radioGroup" field-type ="${field['t']}" >
       <label class="custom-control-label" for="${id}">${field['d']}</label>
       </div>`);
      radio.appendTo(toolbarJq);
      if (field['checked'] == true) {
        radio.find("input").attr({ 'checked': '' });
        renderOnJq.empty();
        var fieldClass = getEditableFieldClass(field);
        var fieldInstance = new fieldClass(field, renderOnJq, function () {
          $this.value = fieldInstance.readValue();
          $this.onChangeCallback();
        });
        fieldInstance.render();
      };
    });

    var $this = this;
    mainContainer.find("input[type='radio'][name='radioGroup']").change(function () {
      fields.forEach(function (field) {
        if ($(this).attr('field-type') == field['t']) {
          renderOnJq.empty();
          var fieldClass = getEditableFieldClass(field);
          var fieldInstance = new fieldClass(field, renderOnJq, function () {
            $this.value = fieldInstance.readValue();
            $this.onChangeCallback();
          });
          fieldInstance.render();
        };
      }.bind(this));
      $this.onChangeCallback();
    });
  };
  readValue() {
    return this.readValue_();
  };
  readValue_() {
    return this.value;
  };
};


class FileUploadField extends BaseEditableField {
  _render(value, allFieldsValues) {
    if (this.field['readonly']) {
      FileUploadField.renderReadOnlyValue(this.renderOn, value, this.field)
      return;
    }
    /** @type {string} file URI from server. */
    this.value = value;

    this.accepted_mime_types = this.field['accepted_mime_types'] || [];
    // https://github.com/josefrichter/resize/blob/master/public/preprocess.js
    this.container = $("<div>");
    this.container.appendTo(this.renderOn);
    this.container.append($(`
      <input type="file" class="file" accept="${this.accepted_mime_types.join(',') || ''}"/>
      <div class="input-group">
        <input
          type="text"
          class="file-input form-control"
          readonly="" style="border-right: none;"
        />
        <div class="input-group-append mb-0 browse-tools-container">
          <button type="button" class="browse btn btn-primary">Browse...</button>
        </div>
      </div>`));

    var rnd = Math.round(Math.random() * 100);
    this.canvas = null;
    var fileInputName = "upload" + rnd;
    this.fileUpload = this.container.find(".file");
    this.fileUpload.attr("name", fileInputName);

    var display = this.field["d"] || this.field["n"];
    var vowelLetters = ["a", "e", "i", "o", "u"];
    var startWithVowels = false;
    vowelLetters.forEach(v => {
      if (display.toLowerCase().startsWith(v)) {
        startWithVowels = true;
        return true;
      }
    });

    this.container
      .find(".file-input")
      .attr("placeholder", (startWithVowels ? "Upload an " : "Upload a ") + display + "...");

    this.container.find('button.browse').on('click', function () {
      var file = $(this)
        .parent().parent().parent()
        .find(".file");
      file.trigger("click");
    });
    var $this = this;

    this.fileUpload.on('change', function (e) {
      var fileInput = $(this)
        .parent()
        .find(".file-input");
      var fileName = e.target.files[0].name;
      fileInput.val(fileName);
      var fileExtension = fileName.split('.').pop();
      if ($this.accepted_mime_types.find(t =>
        t.toLowerCase().contains(fileExtension.toLowerCase()))) {
        $this.handleFileSelect();
      } else {
        WIRE.errorMessageModal("The uploaded file's type is not accepted.");
      }
    });

    if (value) {
      var inputField = this.container.find('input.file-input');
      var fileName = value.replace(/^.*[\\\/]/, '');
      inputField.val(fileName);
      var fileExtension = value.split('.').pop();
      var isFileImage = fileExtension == 'png' || fileExtension == 'jpg';
      var img = new Image();
      img.src = isFileImage ? value : '/img/copy.png'
      img.onload = this.drawOnCanvas.bind(this, img, isFileImage);
    }
  }

  onAfterRender(value) {
    this.blurbContainer = this.container;
    super.onAfterRender(value || this.value || '');
  }

  handleFileSelect() {
    // Read the file
    var filename = this.fileUpload.val();
    this.curFilename = filename;
    var file = this.fileUpload[0].files[0];
    var reader = new FileReader();
    this.fileType = file.type;
    this.fileExtension = file.name.split('.').pop();
    this.isFileImage = this.fileExtension == 'png' || this.fileExtension == 'jpg';
    this.fileSize = file.size;
    reader.readAsDataURL(file);

    //reader.readAsArrayBuffer(filename);
    reader.onload = function (event) {
      // console.log(this.fileUpload.val());
      this.url = event.target.result;

      // Image object
      var container = new Image();
      container.src = this.isFileImage ? this.url : '/img/copy.png';
      container.onload = function () {
        // Resize image.
        if (this.curFilename != filename) {
          return; // User changed image already.
        }
        $(container).attr('file-size', file.size);
        this.canvas = null;
        this.renderOn.find('.form-control-border').remove();
        this.renderOn.find('.collapse-photo').remove();
        this.drawOnCanvas(container, this.isFileImage);
        this.uploadCanvas(this.handleUploaded.bind(this, filename), this.isFileImage);
      }.bind(this);
    }.bind(this);
  }

  drawOnCanvas(container, isImage) {
    var me = this;
    if (this.canvas == null) {
      var imgContainer = $('<div class="show form-control-border px-2" id="collapsePhotoContainer">').appendTo(this.renderOn);
      this.container.find('.input-group').append(`
      <div class="collapse-photo input-group-append mb-0">
        <button type="button" class="collapse-photo btn btn-xs btn-primary" data-toggle="collapse"
          href="#collapsePhotoContainer">
          <i class="fa fa-angle-double-up"></i></button>
      </div>`);

      this.container.find('button.collapse-photo').click(function () {
        var arrowBtn = $(this).find('.fa');
        if (arrowBtn.hasClass('fa-angle-double-down')) {
          arrowBtn.removeClass('fa-angle-double-down');
          arrowBtn.addClass('fa-angle-double-up');
        }
        else {
          arrowBtn.removeClass('fa-angle-double-up');
          arrowBtn.addClass('fa-angle-double-down');
        }
      });
      this.container.find('.download-img').remove();
      var downloadBtn = $(`<span class="cursor-pointer" style="background-color: #f3f3f3; border: 1px solid #E5E5E5; ">
           <span class="download-img fa fa-cloud-download text-primary" style="font-size: 20px;margin-top: 12px;margin-left: 2px;margin-right: 4px;"></span>
       </span>`).prependTo(this.container.find('.browse-tools-container'));
      downloadBtn.on('click', function () {
        if (me.value) {
          // create a temp link on the document to download the file
          var link = document.createElement('a');
          link.href = window.location.origin + me.value;
          var fileExtension = me.value.split('.').pop().split('.').pop();
          link.download = `download.${fileExtension}`;
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);
        };
      });

      if (!this.field['thumbnail']) {
        var row = $('<div class="d-flex py-2">').appendTo(imgContainer);
        var thumbnail = $('<div class="flex-1">').appendTo(row);
        $(`<img style="width: ${isImage ? '100%' : '60px'}" class="img-thumb-field">`)
          .attr({ 'src': container.src, 'data-zoom-image': container.src }).appendTo(thumbnail);

        if (this.field['zoomable']) {
          thumbnail.find('img').ezPlus({
            zoomWindowPosition: 1,
            scrollZoom: true
          });
        };
      }
      else {
        $(`<img style="width: ${isImage ? '100%' : '60px'};max-width:920px; margin: auto; display: block">`)
          .attr('src', img.src).appendTo(imgContainer)
          .appendTo(imgContainer);
      }
    }
    else {
      this.renderOn.find('.file-size').text(`${$(container).attr('file-size')} KB`);
    }
    this.canvas = $("<canvas>");
    var width = container.width;
    var height = container.height;
    var maxDim = Math.max(width, height);
    if (maxDim > 500 && this.fileSize > 500000) {
      var resizeRatio = 500 / maxDim;
      width *= resizeRatio;
      height *= resizeRatio;
    }
    this.canvas.attr("width", width).attr("height", height);
    var ctx = this.canvas[0].getContext("2d");
    ctx.drawImage(container, 0, 0, width, height);
    autoResizeOwnerPopup(this.renderOn);
  }

  uploadCanvas(callback, isImage) {
    if (isImage) {
      this.uploadingData = this.canvas[0].toDataURL(this.fileType, 0.95);
      WIRE.uploadImage(this.uploadingData, callback);
    }
    else {
      WIRE.uploadFile({
        'file_url': this.url,
        'file_extension': this.fileExtension
      }, callback);
    }
    // WIRE.uploadImage(this.url, callback);
  }

  handleUploaded(filename, fileId) {
    if (filename == this.fileUpload.val()) {
      this.value = fileId;
      this.onChangeCallback();
    }
  }

  readValue_() {
    return this.value;
  }

  static renderReadOnlyValue(renderOn, fieldValue, fieldSchema) {
    var popoverContent = fieldSchema ? WIRE.getTooltipContent(fieldSchema) : '';
    if (fieldValue) {
      var downloadBtn = $(
        `<div class="mb-2 cursor-pointer">
        <span class="download-img fa fa-cloud-download text-primary" style="font-size: 20px;">
        Download</span>
        </div>`).appendTo(renderOn);
      downloadBtn.on('click', function () {
        if (fieldValue) {
          // create a temp link on the document to download the file
          var link = document.createElement('a');
          link.href = window.location.origin + fieldValue;
          var fileExtension = fieldValue.split('.').pop().split('.').pop();
          link.download = `download.${fileExtension}`;
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);
        };
      });
    }
    var img = new Image();
    var fileExtension = fieldValue ? fieldValue.split('.').pop() : "";
    var isFileImage = fileExtension == 'png' || fileExtension == 'jpg';
    img.src = isFileImage ? fieldValue : '/img/copy.png';
    img.onload = function () {
      var imgJq = $('<img>').attr('src', img.src).appendTo(renderOn);
      isFileImage ? imgJq.css('max-width', '200px') : imgJq.css('width', '60px');
      if (popoverContent) {
        var popover = `
          <i id ="readOnlyTooltip" class="fal fa-question-square ml-2 text-primary" data-html="true"
          data-toggle="popover"  data-placement="right"
          ></i>`;
        //renderOn.append(popover)
        autoResizeOwnerPopup(renderOn);
        $('[data-toggle="popover"]').popover({ content: popoverContent });
      }
    };
  }
}

/**
 * A field that represent dropZone upload - (Documentation: https://www.dropzonejs.com/)
 * @param {Array<Object>} fields array of dicts containing key "n"
 * @param {String} fieldName must match an "n" of one of the fields.
 * @param {String} fieldType represent the "t" of the field type "dropzone"
 */
class EditableDropzoneField extends BaseEditableField {
  static defaultOptions = {
    uploadMultiple: false,
    addRemoveLinks: true,
  };

  _render(value) {
    // 1. Extend the options
    let options = $.extend(true, {}, EditableDropzoneField.defaultOptions, this.field);

    // 2. Create the uploader container
    let $dropzoneUploader = $(`<div class="dropzone dz-clickable">`).appendTo(this.renderOn);

    // 3. Convert the created container to dropzone component
    this._initializeDropzone($dropzoneUploader, options);

    // 4. Cache the dropzone component instance
    this._dropzoneUploaderInstance = $dropzoneUploader[0].dropzone;
  }

  _initializeDropzone($dropzoneUploader, options) {
    $dropzoneUploader.dropzone({
      url: options.url,
      maxFiles: options.maxFiles,
      uploadMultiple: options.uploadMultiple,
      addRemoveLinks: options.addRemoveLinks,
      acceptedFiles: options.acceptedFiles,
      // parallelUploads: options.parallelUploads,
      removedfile: function (file) {
        // If you override removedFile function, then need to manually remove preview of image. Dropzone will not automatically remove file preview.
        file.previewElement.remove();

        // TODO_: Remove the file from server
        this._removeFileFromSever(file);
      },
    });
  }

  _removeFileFromSever(file) {

  }

  readValue_() {
    return this.value;
  }
}

class ReadonlyQRCode extends BaseEditableField {
  _render(value, allFieldsValues) {
    ReadonlyQRCode.renderReadOnlyValue(this.renderOn, value, this.field);
  }

  static renderReadOnlyValue(renderOn, fieldValue, fieldSchema) {
    if (!fieldValue) { return; }
    var objUrl = location.protocol + '//' + location.hostname + (location.port ? ':' + location.port : '');
    objUrl += '/view/' + fieldValue.replace(':', '/');
    new QRCode(renderOn[0], objUrl);
  }
}

/**
 * this.field['data'] is an array of objects
 * { id: 'date&formattedTime', date: 'dateString', time: { start: '', end: '' } }
 */
class EditableAppointmentChooserField extends BaseEditableField {
  _render(value, allFieldsValues) {
    var $appointmentChooser = $("<div>").addClass("appointment-chooser");
    $appointmentChooser.appendTo(this.renderOn);

    this._$appointementLabel = $("<span>")
      .addClass("appointment-lbl")
      .appendTo($appointmentChooser);

    var $calendarWrap = $("<div>").appendTo($appointmentChooser);

    var calendarEvents = this.field['data'].map(datetimeObject => {
      var start = '{0} {1}'.format(datetimeObject.date, datetimeObject.time.start);
      var end = '{0} {1}'.format(datetimeObject.date, datetimeObject.time.end);

      return {
        id: datetimeObject.id,
        start: start,//new moment(start).format(), //moment.utc(start).format(),
        end: end//new moment(end).format() //moment.utc(end).format()
      };
    });

    var me = this;
    $(function () {
      var currentDate = moment().format("YYYY-MM-DD");
      var minTime = me.getMinTime(me.field['data']);
      // var maxTime = me.getMaxTime(me.field['data']);

      var fullCalendar = new FullCalendar.Calendar($calendarWrap[0], {
        themeSystem: 'bootstrap',
        timeZone: 'local',
        buttonText: { week: 'Week' },
        eventTimeFormat:
        {
          hour: 'numeric',
          minute: '2-digit',
          meridiem: 'short'
        },
        plugins: ['timeGrid'],
        defaultView: 'timeGridWeek',
        slotEventOverlap: false,
        selectable: true,
        events: calendarEvents,
        defaultDate: currentDate,
        validRange: {
          start: currentDate
        },
        // firstDay: moment().day(),
        minTime: minTime,
        // maxTime: maxTime,
        eventRender: function (eventObj, $el) {
          var datetime = me.parseAppointmentId(eventObj.event.id);

          $(eventObj.el)
            .addClass("fc-event--disabled")
            .attr({
              "data-day": datetime.day,
              "data-time": datetime.time
            });
        },
        eventPositioned: function (eventObj) {
          if (me.hasValue()) {
            var datetime = me.parseAppointmentId(eventObj.event.id);
            if (datetime.day === me.value.day && datetime.time === me.value.time) {
              me.addAppointment(eventObj.event.id, me.value);
            }
          }
        },
        eventClick: function (eventObj) {
          var datetime = me.parseAppointmentId(eventObj.event.id);
          me.value = datetime;
          me.addAppointment(eventObj.event.id, datetime);
        }
      });

      fullCalendar.render();
    });
  }

  getMinTime(data) {
    var fakeDate = '01/01/2011';

    var minTime = data[0].time.start;

    for (var i = 1; i < data.length; i++) {
      var fromTime = data[i].time.start;

      if (Date.parse("{0} {1}".format(fakeDate, fromTime)) <
        Date.parse("{0} {1}".format(fakeDate, minTime))) {
        minTime = fromTime;
      }
    }

    return minTime;
  }

  /*
  getMaxTime(data) {
    var fakeDate = '01/01/2011';

    var maxTime = data[0].time.end;

    for (var i = 1; i < data.length; i++) {
      var fromTime = data[i].time.start;

      if (Date.parse("{0} {1}".format(fakeDate, fromTime)) > 
        Date.parse("{0} {1}".format(fakeDate, maxTime))) {
          maxTime = fromTime;
        }
    }

    return maxTime;
  }
  */

  parseAppointmentId(eventId) {
    var datetime = eventId.split('&');

    return {
      day: datetime[0],
      time: datetime[1]
    };
  }

  getValue(valueDict) {
    if (!this.hasValue()) {
      return 'Field is required. Missing: appointment time';
    }

    valueDict[this.field['n']] = this.value;
  }

  hasValue() {
    return this.value && this.value.day && this.value.time;
  }

  addAppointment(id, value) {
    var $event = $(".fc-event[data-day='" + value.day + "'][data-time='" + value.time + "']");

    if ($event.length) {
      // Remove the selection from the other events
      $(".fc-event--selected")
        .removeClass("fc-event--selected")
        .addClass("fc-event--disabled");

      // Add the selection to clicked event
      $event
        .removeClass("fc-event--disabled")
        .addClass("fc-event--selected");

      var date = new moment(value.day).format("Do MMMM YYYY");

      var datetimeObject = this.field['data'].find(d => d.id === id);

      this._$appointementLabel.html(`Your appointment will be on <b>${date}</b> from <b>${datetimeObject.time.start}</b> till <b>${datetimeObject.time.end}</b>`);
    }
  }
}

class EditableOfflineChatField extends BaseEditableField {
  _render(value, allFieldsValues) {
    if (this.field['readonly']) {
      EditableOfflineChatField.renderReadOnlyValue(this.renderOn, value, this.field)
      return;
    }
    /** @type {string}  */
    this.value = value || this.field['default_value'] || [];
    var showSendBtn = 'show_send_btn' in this.field ? this.field['show_send_btn'] : true;

    var chatInboxContainer = this.container = $(`  
    <div class="offline-chat-inbox-container flex-wrap align-items-center flex-grow-1 bg-gray-50">
      <div class="pos-top pos-bottom w-100 overflow-hidden">
        <div class="d-flex h-100 flex-column">        
          <div class="msgr d-flex h-100 flex-column bg-white">
            <div class="custom-scroll flex-1 h-100">
              <div id="chat_container" class="offline-chat-msg-container w-100 p-2">

              </div>
            </div>
            <div class="d-flex flex-column">
              <div class="offline-chat-msg-input-container border-faded border-right-0 border-bottom-0 border-left-0 flex-1 mr-3 ml-3  shadow-top">
                <div class="pt-3 pb-1 pr-0 pl-0 rounded-0" tabindex="-1">
                  <div id="msgr_input" contenteditable="true" data-placeholder="Type your message here..."
                    class="offline-chat-msg-input height-10 form-content-editable"></div>
                </div>
              </div>

            </div>
          </div>
        </div>
      </div>
    </div>`);
    chatInboxContainer.appendTo(this.renderOn);

    var msgInput = chatInboxContainer.find('.offline-chat-msg-input');
    this.chatMessagesContainer = this.container.find('.offline-chat-msg-container');
    var me = this;

    if (showSendBtn) {
      var sendBtnDom = $(`
      <div class="offline-chat-send-btn-container height-8 px-3 d-flex flex-row align-items-center flex-wrap flex-shrink-0">
        <div class="ml-auto">
          <button class="offline-chat-send-btn btn btn-info">Send</button>
        </div>
      </div>`);
      sendBtnDom.insertAfter(chatInboxContainer.find('.offline-chat-msg-input-container'));


      var sendBtn = sendBtnDom.find('.offline-chat-send-btn');
      sendBtn.on('click', function () {
        // Save message
        var currentdate = new Date();
        var datetime = getCustomStringDate(currentdate) + " @ "
          + currentdate.toLocaleTimeString();

        var msg = {
          'sender_id': WIRE.data['account'] || '',
          'msg_txt': msgInput.text(),
          'timestamp': datetime
        };
        me.value.push(msg);
        // Show message on its dom
        EditableOfflineChatField.renderMessages([msg], me.chatMessagesContainer);
        me.onChangeCallback();
      });
    } else {
      msgInput.on('keyup', function () {
        var currentdate = new Date();
        var datetime = getCustomStringDate(currentdate) + " @ "
          + currentdate.toLocaleTimeString();

        me.value.push({
          'sender_id': WIRE.data['account'] || '',
          'msg_txt': this.innerText,
          'timestamp': datetime
        });
        me.onChangeCallback();
      });
    }

    // [{ 'sender_id': '', 'msg_txt': '', 'timestamp': ''}, ...]
    if (this.value) {
      EditableOfflineChatField.renderMessages(me.value, me.chatMessagesContainer);
      this.onChangeCallback();
    }
    return this.container;
  }

  onAfterRender(value) {
    this.blurbContainer = this.container;
    super.onAfterRender(value || this.value || '');
  }

  static renderReadOnlyValue(renderOn, fieldValue, fieldSchema) {
    if (fieldValue) {
      var chatInboxContainer = this.container = $(`  
        <div class="offline-chat-inbox-container flex-wrap align-items-center flex-grow-1 bg-gray-50" style="max-height: 25rem">
          <div class="pos-top pos-bottom w-100 overflow-hidden">
            <div class="d-flex h-100 flex-column">        
              <div class="msgr d-flex h-100 flex-column bg-white">
                <div class="custom-scroll flex-1 h-100">
                  <div id="chat_container" class="offline-chat-msg-container w-100 p-2">

                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>`);
      chatInboxContainer.appendTo(renderOn);
      var chatMessagesContainer = chatInboxContainer.find('.offline-chat-msg-container');
      EditableOfflineChatField.renderMessages(fieldValue, chatMessagesContainer);
    }
  }

  static renderMessages(messages, messagesContainer) {
    (messages || []).forEach(msg => {
      var msgSegment = $(`
            <div class="chat-segment ${msg['sender_id'] == WIRE.data['account'] ? 'chat-segment-sent' : 'chat-segment-get'} ">
              <div class="chat-message">
                <p>
                  ${msg['msg_txt']}
                </p>
              </div> 
              <div class=" ${msg['sender_id'] == WIRE.data['account'] ? 'text-right' : ''} fw-300 text-muted mt-1 fs-xs">
                ${msg['timestamp']}
              </div>                        
            </div>`);
      messagesContainer.append(msgSegment);
    });
  }

  readValue_() {
    return this.value;
  }
}

class EditablePayerField extends BaseEditableField {
  _render(value, allFieldsValues) {
    this.value = value;
    if (this.field['readonly']) {
      EditablePayerField.renderReadOnlyValue(this.renderOn, this.value, this.field)
      return;
    }

    var panelID = Guid.generate();
    this.dom = `
  <div class="panel m-0" id="${panelID}" style="max-width: fit-content;">
    <div class="panel-hdr radio-payer" role="heading">
      <h2>${this.field['d'] || this.field['n']}</h2>
      <div class="panel-toolbar">
          <div class="custom-control custom-radio custom-control-inline">
            <input type="radio" class="custom-control-input" id="credit" name="payerMethods" value="credit"
                field-type="text" checked="checked">
            <label class="custom-control-label" for="credit">Credit / Debit Card</label>
          </div>
          <div class="custom-control custom-radio custom-control-inline">
            <input type="radio" class="custom-control-input" id="paypal" name="payerMethods" value="paypal"
                field-type="email">
            <label class="custom-control-label" for="paypal">PayPal</label>
          </div>
      </div>
    </div>
    <div class="panel-container">
      <div class="panel-content  p-2" id="payer-content">
      </div>
    </div>
   </div>`;

    $(this.dom).appendTo(this.renderOn);
    this.renderCredit(this.renderOn.find('#payer-content'));
    this.renderOn.find('input[name="payerMethods"]').change(function () {
      if ($('input[name="payerMethods"]:checked').val() == 'paypal') {
        this.onChangeCallback();
        this.renderOn.find('#payer-content').empty();
        this.renderPayPal(this.renderOn.find('#payer-content'));
        this.renderOn.find(".pay-actions").addClass('mb-2 text-center');
      } else {
        this.onChangeCallback();
        this.renderOn.find('#payer-content').empty();
        this.renderCredit(this.renderOn.find('#payer-content'));
      }
    }.bind(this));
    this.renderOn.find("#payNow").click(function (e) {
      e.preventDefault();
      this.onChangeCallback();
    }.bind(this));
  }
  renderPayPal(container) {
    container.append(`<div class="pay-actions"></div><div id="paypal-button-container"></div>`);
    var me = this;
    paypal.Buttons({
      style: {
        layout: 'vertical',
        color: 'blue',
        shape: 'rect',
        label: 'checkout'
      },
      // createOrder when clicked
      createOrder: function (data, actions) {
        return actions.order.create(
          {
            purchase_units: [{
              amount: {
                value: me.field['amount'] || ''
              }
            }]
          });
      },
      // Capture the Transaction
      onApprove: function (data, actions) {
        // Show a success message to the buyer
        console.log(data);
      }
    }).render('#paypal-button-container');
    this.renderAmount();
  }
  renderCredit(container) {
    container.append(`
    <div class="payer-wrapper">
   <div class="card-form shadow-5">
      <div class="card-list panel-conten">
         <div class="card-item">
            <div class="">
               <div class="">
                  <div class="card-wrapper pb-2 pt-2"></div>
               </div>
            </div>
         </div>
      </div>
      <div class="card-form__inner">
         <div class="form-container-payer active">
            <div class="col-lg-12 col-md-12 col-sm-12">
               <form>
                  <div class="panel-content">
                     <div class="form-row">
                        <div class="col-md-6 mb-3">
                           <label class="form-label" for="credit-number">Card number</label>
                           <input type="text" class="form-control" id="credit-number" name="number"
                              required="" placeholder="Card number">
                        </div>
                        <div class="col-md-6 mb-3">
                        <label class="form-label" for="credit-owner">Card holder</label>
                        <input type="text" class="form-control" name="name" id="credit-owner"
                           placeholder="Card holder" required="">
                     </div>
                     </div>
                     <div class="form-row"> 
                        <div class="col-md-6 mb-3">
                           <label class="form-label" for="credit-expiry">Expiry Date</label>
                           <input type="text" class="form-control" id="credit-expiry" placeholder='MM/YY'
                              name="expiry" required="">
                        </div>
                        <div class="col-md-6 mb-3">
                        <label class="form-label" for="credit-cvc">CVC</label>
                        <input type="text" class="form-control" id="credit-cvc" placeholder="CVC" name="cvc"
                           required="">
                     </div>
                     </div>
                  </div>
                  <span class="d-none amount-container"></span>
                  <div
                     class="payments-action p-0 mb-2 panel-content border-faded border-left-0 border-right-0 border-bottom-0 d-flex flex-row">
                     <button id="payNow" class="mx-auto btn btn-primary waves-effect waves-themed"
                        type="submit"><i class="fa fa-lock mr-1"></i>Pay Now</button>
                  </div>
               </form>
            </div>
         </div>
      </div>
   </div>
</div>`);

    var me = this;
    this.renderOn.find('form').card({
      container: me.renderOn.find(".card-wrapper")
    });
    this.renderOn.find('#credit-expiry').inputmask({
      alias: 'datetime',
      inputFormat: 'mm/yy',
      placeholder: 'MM/YY'
    });
    if (this.field['hidePayButton']) {
      this.renderOn.find("#payNow").addClass('d-none');
      this.renderAmount(true);
    } else {
      this.renderAmount();
    }
  }
  renderAmount(isPaypal) {
    var amount = this.field['amount'] || this.value['amount'];
    var currency = this.field['currency'] || this.value['currency'];
    var amountDom = `<div class="d-inline-flex flex-column justify-content-center mr-3">
    <span class="fw-300 fs-xs d-block opacity-50">
        <small>Amount</small>
    </span>
    <span class="fw-500 fs-xl d-block color-primary-500">
    <span class="payments-text">${amount.toLocaleString()}  ${currency.toUpperCase()}</span>
    <input type="text" id="amountInput" class="text-center form-control d-none" value="${amount.toLocaleString()} ${currency.toUpperCase()}">
    </span>
  </div>`;
    if (isPaypal) {
      this.renderOn.find('.payments-action').append(amountDom);
    } else {
      if (amount) {
        $(amountDom).prependTo(this.renderOn.find('.pay-actions'));
        this.renderOn.find('#payNow').append(`<span class="credit-amount"> ${amount.toLocaleString()} ${currency.toUpperCase()}</span>`);
      }
    }
    if (this.field['isEditable']) {
      this.renderOn.find('.payments-text').addClass("d-none");
      this.renderOn.find("#amountInput").removeClass("d-none");
      this.renderOn.find(".credit-amount").addClass("d-none");
      //this.renderOn.find(".credit-amount").parent().append(`<input type="text" id="amountInput" class="text-center form-control" value="${amount.toLocaleString()} ${currency.toUpperCase()}">`);
      this.renderOn.find("form").find(".amount-container").removeClass('d-none').append(`<input type="text" id="amountInput" class="col-4 text-center mx-auto form-control" value="400,000 AED" style="
      display: flex; align-items: center;justify-content: center;align-self: center;">`);
    }
  }
  static renderReadOnlyValue(renderOn, fieldValue, fieldSchema) {
    let financial_note = WIRE.d(fieldValue);

    let fin_note_obj = {};
    let financial_note_id_split = financial_note['_id'].split(':');
    fin_note_obj['type'] = financial_note_id_split[0];
    fin_note_obj['id'] = financial_note_id_split[1];

    //TODO check if fieldValue payer attribute is in WIRE.data.wallets
    //then display make payments button (which should open the same payer field)
    //WIRE.modal('Pay', u('EditableObject', ['pay', {'fields': [{'n': 'payment', 't': 'payer'}]}, {'payment': WIRE.d(fieldValue)}]))
    //Must call WIRE.call('business::make_payment')

    //TODO check if fieldValue payee attribute is in WIRE.data.wallets
    //then display receive payments button, where the landlord can upload a cheque scan
    //Must call WIRE.call('interactions::receive_payment')
    //WIRE.d(financial_note.payments[0])
    if (financial_note) {
      var payment_statement = $('<span>')
        .addClass('alert alert-secondary payment-message p-2 mb-0 col-12')
        .appendTo(renderOn);
      var total = 0;
      if (financial_note["payments"] && financial_note["payments"].length > 0) {
        financial_note["payments"].forEach(e => total += WIRE.d(e)['amount']);
      }
      var badge = (total == 0) ? { status: 'unpaid', class: 'badge-danger', btn: 'btn-danger' }
        : (total >= financial_note["amount"]) ? { status: 'paid', class: 'bg-success-700', btn: 'btn-success' }
          : { status: 'partially paid', class: 'bg-warning-200', btn: 'btn-warning' };

      let financialNoteAmount = financial_note["amount"];
      let financialNoteCurrency = financial_note["currency"].toUpperCase();
      let remainingBalance = financialNoteAmount - total;
      var statementDom = $(`
                  <h5 class="text-muted">
                    <span class="total-payments text-primary ml-1">${total + ' '}</span>
                    <span>paid out of </span><span class="text-primary">${financialNoteAmount + ' ' + financialNoteCurrency}</span>
                    <span> (Remaining Balance: ${remainingBalance} ${financialNoteCurrency})</span>
                    <small class="mt-0 mb-0 text-muted payments-btns"></small>
                    <span class="badge ${badge['class']} fw-n position-absolute pos-top pos-right mt-3 mr-3" style="top: -10px;">
                      ${badge['status']}
                    </span>
                  </h5>`);
      statementDom.appendTo(payment_statement);
      if(remainingBalance !== 0) {
        var makePaymentsBtn = $(`<button type="button" id="transfer"
      class="btn btn-light btn-pills waves-effect btn-sm waves-themed mt-1"><svg width="16" height="16" fill="none"
        xmlns="http://www.w3.org/2000/svg">
        <path
          d="M6.197 3.802c0 .374.3.667.667.667h3.727l-7.26 7.26a.664.664 0 10.94.94l7.26-7.26v3.727c0 .366.3.666.666.666.367 0 .667-.3.667-.666V3.802c0-.366-.3-.666-.667-.666H6.864c-.367 0-.667.3-.667.666z"
          fill="currentColor"></path>
      </svg>Make payments</button>`);
        makePaymentsBtn.click(function () {
          if (financial_note["amount"]) {
            WIRE.modal('Pay', u('EditableObject', ['pay', {
              'fields': [{
                'n': 'payment',
                't': 'payer',
                amount: financial_note["amount"] - total,
                currency: financial_note["currency"].toUpperCase()
              }]
            }]));
          }
        });
        var receivePaymentsBtn = $(`<button id="receive" type="button" class="btn btn-light btn-pills waves-effect btn-sm waves-themed mt-1"><svg width="16"
      height="16" fill="none" xmlns="http://www.w3.org/2000/svg">
      <path
        d="M12.672 3.335a.664.664 0 00-.94 0l-7.26 7.253V6.861c0-.366-.3-.666-.667-.666-.367 0-.667.3-.667.666v5.334c0 .366.3.666.667.666h5.333c.367 0 .667-.3.667-.666 0-.367-.3-.667-.667-.667H5.412l7.26-7.26a.668.668 0 000-.933z"
        fill="currentColor"></path>
      </svg>Receive payments</button>`);
        receivePaymentsBtn.click(function () {
          var modal;
          var modalButtons = [
            {
              label: "Receive Payments",
              onClick: function () {
                //TODO get args
                let args = WIRE.getEditableValues('finance_transaction');
                args['note'] = fin_note_obj;
                WIRE.call('interactions::receive_payment', args, function (response) {
                  WIRE.attemptToUpdateObjectsCache(response);

                  financial_note.refs.forEach((ref, i) => {
                    let ref_clean = ref.replace('!obj!', '');
                    if (WIRE.objectChangeNotificationCallbacks[ref_clean]) {
                      WIRE.objectChangeNotificationCallbacks[ref_clean]();
                    }
                  });

                  // close the modal and update the view payments table
                  // var updatedFinancialNote = WIRE.d(response['financial_note']);
                  // EditablePayerField.renderPayments(payment_statement, updatedFinancialNote['payments']);

                  //TODO We can get rid of the below code because it should be updated through socket.io emit from backend
                  // render new payment in paymnets table
                  // EditablePayerField.renderPayments(payment_statement, [response['received_payment']]);
                  //
                  // // updat total paymnets label text
                  // var totalPaymentsLabel = renderOn.find('.total-payments');
                  // totalPaymentsLabel.text(totalPaymentsLabel.text().replace(/\d+/, Number(totalPaymentsLabel.text().match(/\d+/)[0]) + Number(response['received_payment']['amount'])));

                  modal.close();
                });
              },
              color: "btn btn-primary"
            }
          ];

          modal = WIRE.modal('Receive payments', u('EditableObject', ['finance_transaction',
            {
              'fields': [
                {
                  "n": "amount",
                  "d": "Amount",
                  "t": "number",
                  "r": "1",
                  "default_value": remainingBalance,
                  "max": remainingBalance
                },
                {
                  "n": "pay_date",
                  "d": "Pay Date",
                  "t": "date",
                  "r": "1",
                  "default_value_fn": "f => Number((new Date()).getFullYear() + String((new Date()).getMonth() + 1).padStart(2, '0') + String((new Date()).getDate()).padStart(2, '0'));"
                },
                {
                  "n": "receipt_front_photo",
                  "d": "Receipt Photo",
                  "t": "photo",
                  "r": 0
                }],
              "displayed_fields": [
                "amount",
                "pay_date",
                "receipt_front_photo"
              ]
            }]), modalButtons);

        });

        if (WIRE.data.wallets.includes(financial_note["payer"]) && WIRE.data.wallets.includes(financial_note["payee"])) {
          $(statementDom).find('.payments-btns').append(makePaymentsBtn).append(' or ').append(receivePaymentsBtn);
        }
        else if ((WIRE.data.wallets.includes(financial_note["payer"]))) {
          $(statementDom).find('.payments-btns').append(makePaymentsBtn);
        }
        else if (WIRE.data.wallets.includes(financial_note["payee"])) {
          $(statementDom).find('.payments-btns').append(receivePaymentsBtn);
        }
      }

      if (financial_note["payments"] && financial_note["payments"].length > 0) {
        EditablePayerField.renderPayments(payment_statement, financial_note['payments']);
      }
    }
  }

  static renderPayments(renderOn, payments) {
    //Leenah we can do one of these two options:
    // 1- remove the alredy rendered payments table and rerender it with new payment
    // 2- append the last payemnt
    // but we will follow the second option
    var paymentsHistory = renderOn.find('.payments-history');
    var table;
    if (paymentsHistory && paymentsHistory.length) {
      //1-
      //paymentsHistory.remove();
      //2-
      table = paymentsHistory.find('.payments-history-table');
    } else {
      paymentsHistory = $(`
        <div class="payments-history toast fade show" role="alert" aria-live="assertive" aria-atomic="true" data-toggle="toast">
          <div class="toast-header">
            <i class="fa fa-history mr-2"></i>
            <strong class="mr-auto">Payments history</strong>    
          </div>
          <div class="toast-body history-body"></div>
        </div>`);
      renderOn.append(paymentsHistory);
      table = $(`
        <table class="payments-history-table table table-sm m-0">
          <thead class="bg-grey">
            <tr>        
              <th>Pay date</th>
              <th>To</th>
              <th>Amount</th>
            </tr>
          </thead>
          <tbody> 
          </tbody>
        </table>`);
      paymentsHistory.find('.history-body').append(table);
    }
    (payments || []).forEach(function (element) {
      var payment = element;
      if (typeof element === 'string') {
        payment = WIRE.d(element);
        if(payment['payee_wt']) {
          payment['payee_wt_email'] = WIRE.d(payment['payee_wt'])['email'];
        }
      }

      if(payment['payee_wt_email']) {
        var tr = $(`<tr><td>${dateIntToStr(payment['pay_date'], true)}</td>
        <td class="text-truncate" title="${payment['payee_wt_email']}" 
        style="max-width: 104px;">${payment['payee_wt_email']}</td>
        <td>${payment['amount']}</td></tr>`)
        tr.appendTo(table.find('tbody'));
      }
    });
  }
}

class EditableTenancyOfferPaymentsField extends BaseEditableField {
  _render(value, allFieldsValues) {
    if (this.field['readonly']) {
      EditableTenancyOfferPaymentsField.renderReadOnlyValue(this.renderOn, value, this.field)
      return;
    }

    this.value = value || this.field['default_value'] || {};
    // [{'n': 'quarter', 'd': '', 'content': '', value: 250, currency: ''}, {'n': 'quarter', 'd': '', 'content': '', value: 250, currency: ''}]
    var tabs = this.field['tabs'];
    var negotiable = this.field['is_rent_negotiable'];

    var container = $(`<div>`).addClass('text-center').appendTo(this.renderOn);
    var header = $('<h3>').html(this.field['d'] || '').appendTo(container);
    var tabsDom = $(`
    <div class="js-toggle-skin btn-group btn-group-toggle" data-toggle="buttons"></div>`)
      .appendTo(container);
    var tabsContentDom = $(`<div class="tab-content p-2"></div>`)
      .appendTo(container);

    var sliderInput = $(`<input value="" class="slider-input irs-hidden-input d-none " tabindex="-1" readonly="">`)
      .appendTo(tabsContentDom);

    sliderInput.ionRangeSlider(
      {
        skin: "round",
        min: negotiable ? 0 : tabs[0].value,
        max: tabs[0].value * 2,
        from: tabs[0].value,
        step: 500, // default 1 (set step)
        // grid: true, // default false (enable grid)
        // grid_num: 5, // default 4 (set number of grid cells)
        // grid_snap: false, // default false (snap grid to step)         
      });
     
    var sliderInstance = sliderInput.data("ionRangeSlider");
    this.value = {
      'frequency': tabs[0].n, 'value': Number(sliderInput.val()),
      'suggestedPayment': sliderInput.val() != tabs[0].value,
      'tenant_negotiated_rate': Number(sliderInput.val()) - Number(tabs[0].value)
    };

    this.currentTab = tabs[0];
    var me = this;
    sliderInput.on('change', function (event) {
      event.stopPropagation();
      var sliderInputVal = sliderInput.val();
      var changedInput = container.find(`#changedInput`);
      changedInput.html(sliderInputVal);
      if (sliderInputVal < me.currentTab.value - 1000) {
        tabsContentDom.find('.irs--round')
          .removeClass('irs--round-slider-top')
          .addClass('irs--round-slider-warning');
        tabsContentDom.find('.irs-handle')
          .removeClass('irs--round-slider-top')
          .addClass('irs--round-slider-warning');
      } else if (sliderInputVal > me.currentTab.value + 1000) {
        tabsContentDom.find('.irs--round')
          .removeClass('irs--round-slider-warning')
          .addClass('irs--round-slider-top');
        tabsContentDom.find('.irs-handle')
          .removeClass('irs--round-slider-warning')
          .addClass('irs--round-slider-top');
      } else {
        tabsContentDom.find('.irs--round')
          .removeClass('irs--round-slider-warning')
          .removeClass('irs--round-slider-top');
        tabsContentDom.find('.irs-handle')
          .removeClass('irs--round-slider-warning')
          .removeClass('irs--round-slider-top');
      }
      me.value = {
        'frequency': me.currentTab.n, 'value': Number(sliderInput.val()),
        'suggestedPayment': sliderInput.val() != me.currentTab.value,
        'tenant_negotiated_rate': Number(sliderInput.val()) - Number(me.currentTab.value)
      };

      me.onChangeCallback();
    });

    (tabs || []).forEach(function (tab, index) {
      var paymentLabel = $(`
      <label class="btn btn-default ${index == 0 ? 'active' : ''}">
        <input type="radio" name="${tab.n}" id="${tab.n}" ${index == 0 ? 'checked=""' : ''}>
        <span class="">${tab.d}</span>
      </label>`).appendTo(tabsDom);

      paymentLabel.find('input').on('change', function (e) {
        me.currentTab = tab;
        e.stopPropagation();
        tabsContentDom.find('.payment-tab').remove();

        $(`<div id="${tab.n}" class="payment-tab">
            <div class="panel-tag">${tab.content}</div>
            <div class="d-flex justify-content-center flex-nowrap"> 
              <h2 class="form-label mx-1" id="changedInput">${tab.value}</h2>
              <h2 class="form-label">${tab.currency.toUpperCase()} / ${tab.n.titleCase()}</h2>
            </div>       
          </div>`)
          .prependTo(tabsContentDom);

        // sliderInstance.reset();
        sliderInstance.update(
          {
            skin: "round",
            min: negotiable ? 0 : tab.value,
            max: tab.value * 2,
            from: tab.value,
            step: 500
          });

      });

      if (index == 0) {
        paymentLabel.find('input').change();
      }
    }.bind(this));

    // if (this.value) {
    //   //TODO Update the slider
    //   this.onChangeCallback();
    // }
    // return this.container;
  }

  // onAfterRender(value) {
  //   this.blurbContainer = this.container;
  //   super.onAfterRender(value || this.value || '');
  // }

  static renderReadOnlyValue(renderOn, fieldValue, fieldSchema) {
    if (fieldValue) {
      //TODO Leenah
    }
  }

  readValue_() {
    return this.value;
  }
}

// Should move to fields.js
class FieldDocumenter {
  static appendFieldExamplesOnDom(domJQ, fieldSchema, possibleValues) {
    domJQ.append($('<h2>Field Schema</h2>'));
    domJQ.append($('<pre>').text(JSON.stringify(fieldSchema, null, 2)));
    possibleValues.forEach(function (possibleValue, idx) {
      domJQ.append($('<h3>When given value: </h3>'));
      domJQ.append($('<pre>').html(JSON.stringify(possibleValue, null, 2)));

      domJQ.append($('<h3>Renders as: </h3>'));
      var fieldDom = $('<div>').appendTo(domJQ);

      var liveValueDom = $('<div>')
        .addClass('p-3 my-2')
        .css({ 'border': '1px solid #afa0c7', 'border-radius': '3px', 'background': '#faf7ff' })
        .appendTo(domJQ);
      liveValueDom.append($('<h3>Live Value:</h3>'));
      var valuePre = $('<pre>').appendTo(liveValueDom);

      var formName = 'doc_' + idx + + '_' + Math.floor(Math.random() * 10000);
      var callback = function () {
        var values = JSON.stringify(WIRE.getEditableValues(formName), null, 2);
        valuePre.text(values);
      }

      WIRE.unrollRecursive(
        u('EditableObject', [formName, fieldSchema, possibleValue, callback]),
        fieldDom);
      callback();
    });
  }
}

_FIELD_CLASS_BY_TYPE = {
  text: EditableTextField,
  longtext: EditableLongTextField,
  password: EditablePasswordField,
  email: EditableEmailField,
  numeric: EditableNumericField,
  number: EditableNumericField,

  // Field must have key 'choices'
  categorical: EditableCategoricalField,
  bool: EditableBooleanField,

  phone: EditablePhoneField,
  photo: PhotoUploadField,
  file: FileUploadField,
  dropzone: EditableDropzoneField,
  objectreadonly: ReadOnlySingleObjectField,

  // Field can have key getFn: Function to return IDs of objects to be selected.
  //singleobject: EditableSingleObjectField,

  // Field must have key 'listFnName'. Optional field 'max' (if set, at most, this many will be selectable).
  multiobject: EditableMultipleObjectField,
  advancedMultiobject: EditableAdvancedMultipleObjectField,
  advancedMultiobjectV2: EditableAdvancedMultipleObjectFieldV2,

  // Field must have key 'listFnName'.
  multiobjectgroup: EditableMultipleObjectGroupField,

  addresslatlng: EditableAddressLatLangField,
  date: EditableDateField,
  daterange: EditableDateRangeField,

  // Field takes keys:
  //   data: Array of dicts with keys ('n', 'd', 'parent')
  //   levels: Array of dicts with keys ('n', 'd').
  // Number of levels must match max number of ancestors in `data`.
  treeselect: EditableSelectTreeField2,
  treeselect_old: EditableSelectTreeField,

  buttoncategorical: EditableRadioButtonsField,
  radio: EditableDefaultRadioButtonsField,
  button: ReadonlyButtonField,

  // Field must have key 'fields' with value Array of dicts
  table: EditableTableField,

  // Read Only time display
  time: ReadOnlyTimeField,

  checklist: EditableCheckListField,
  radiolist: EditableRadioListField,

  // Render select control with check boxs
  combobox: EditableComboBoxField,

  // Field to let user choose their wallet or login/register.
  // Options "accounts" which must be a list of wallet types
  // including "tenant_wt", "admin_wt", etc.
  // This field will throw an error / not submit if the user is not
  // equipped with the given wallet.
  wallet_chooser: EditableWalletChooserField,

  // Renders dictionary. Field must have key 'fields'
  dict: EditableDictField,

  // Renders an object schema.
  // Musy provide one of {"schema_name", "schema"}:
  //   "schema_name" must match object defined in schema.json
  //   "schema" must look like {"fields": [ ... ]}.
  // Fails if you supply both.
  // Alternative to defining them in the field schema,
  // you may also pass them as part of the value. If the value is a dict,
  // provide a key "_config" as:
  // value = { ... , "_config": {"schema_name": "work_order" }, ... }
  // (you may also use "schema")
  schema: EditableSchemaField,
  signature: EditableSignatureField,
  markdown: EditableMarkdownField,
  tag: EditableTagField,
  label: LabelField,
  sidenavigator: EditableSideNavigatorField,
  inputgroup: EditableInputGroupField,
  multifield: EditableMultiField,
  inline_object: InlineObjectField,
  userlookup: EditableUserLookupField,
  checkabledropdown: EditableCheckableDropdownField,
  rangeslider: EditableRangeSliderField,
  intrange: EditableIntRangeField,
  summarytagslist: EditableSummaryTagsListField,
  qrcode: ReadonlyQRCode,
  list4lease: EditableList4LeaseField,

  // Accepts keys:
  //   'presets': output of financial_offer.
  //   'schedule_fn': Function that computes the schedule given a preset.
  scheduled_payments: EditableScheduledPaymentsField,
  iframe: EditableIFrameField,
  fieldradioselector: EditableFieldRadioSelector,
  blurb: EditableBlurbField,
  appointmentchooser: EditableAppointmentChooserField,
  offlinechat: EditableOfflineChatField,
  payer: EditablePayerField,
  tenantofferpayments: EditableTenancyOfferPaymentsField
};


/**
 * Gets a field from a list of fields.
 * @param {Array<Object>} fields array of dicts containing key "n"
 * @param {String} fieldName must match an "n" of one of the fields.
 */
function getField(fields, fieldName) {
  var matchingFields = fields.filter(f => f['n'] == fieldName);
  if (matchingFields.length != 1) {
    throw "Expecting exactly one field with name " + fieldName;
  }
  return matchingFields[0];
}

function annotatedTableToTableField(field) {
  field = JSON.parse(JSON.stringify(field));  // deep copy
  var annotations = field['annotations'];
  field['t'] = 'schema';
  var srcSchema = WIRE.schemaManager.schema[field['src_schema']]['fields'];
  field['schema'] = { 'fields': JSON.parse(JSON.stringify(srcSchema)) };  // deep copy

  var recursiveMarkReadOnly;
  recursiveMarkReadOnly = function (fields) {
    fields.forEach(function (field) {
      field['readonly'] = 1;
      if (field['fields']) {
        recursiveMarkReadOnly(field['fields']);
      }
    });
  };

  recursiveMarkReadOnly(field['schema']['fields']);

  // Copy the schema of the table
  annotations.forEach(function (annotation) {
    var subfield = field['schema'];
    for (var i = 0; i < annotation['annotate_field_path'].length; i += 1) {
      subfield = getField(subfield['fields'], annotation['annotate_field_path'][i]);
    }

    subfield['fields'] = subfield['fields'].concat(annotation['fields']);
  });
  return field;
}

function subFields(schema, whitelistFieldNames, copy = false) {
  whitelistFieldNames = new Set(whitelistFieldNames);
  var fields = schema['fields'].filter(f => whitelistFieldNames.has(f['n']));
  if (copy) {
    fields = JSON.parse(JSON.stringify(fields));
  }
  return { 'fields': fields };
}

function getFieldAndClass(field) {
  var fieldType = field.t || "text";

  if (fieldType == 'annotated_table') {
    field = annotatedTableToTableField(field);
    fieldType = field.t || "text";
  } /*else if (fieldType == 'oneobject') {
    field.t = 'multiobject';
    field['max'] = 1;
    field['one'] = 1;
    fieldType = field.t;
  }*/

  if (!_FIELD_CLASS_BY_TYPE[fieldType]) {
    console.log("Unknown field type: " + fieldType + ". Defaulting to text.");
    fieldType = "text";
  }
  return [field, _FIELD_CLASS_BY_TYPE[fieldType]];
}


function getEditableFieldClass(field) {
  return getFieldAndClass(field)[1];
}
class UnrollAJS {
  //
  render(params, jq, parentElement) {
    //
    var vcPath = params['args'][0];
    var dataObj = params['args'][1] || null;
    var callback = params['args'][2] || null;
    this.wire.renderAJS(jq, vcPath, dataObj, callback);
  }
}

class UnrollLayout {
  render(unrollElement, jq, parentElement) {
    var layout = $('<div class="layout">').appendTo(jq);
    this.jq = layout;
    var children = unrollElement['args'][0];
    children.forEach(function (child) {
      this.wire.unrollRecursive(child, layout, this);
    }.bind(this));
  }
}

class UnrollForm {
  render(unrollElement, jq, parentElement) {
    var form = $('<div class="form-container">').appendTo(jq);
    this.jq = form;
    var name = unrollElement['args'][0];
    var children = unrollElement['args'][1];
    $('<div class="form_title">').html(name).appendTo(form);
    var formBody = $('<div class="form_body">').appendTo(form);
    children.forEach(function (child) {
      this.wire.unrollRecursive(child, formBody, this);
    }.bind(this));
  }
}

class UnrollTabView {
  render(unrollElement, jq, parentElement) {
    //
    this.leftPanel = $('<div class="tab_panel">').appendTo(jq);
    this.contentPanel = $('<div class="content_panel">').appendTo(jq);
    this.dataName = unrollElement['kwargs']['tabData'];
    this.onAddTabs(this.wire.data[this.dataName]);
    this.wire.registerOnAddObjects(this.dataName, this.onAddTabs.bind(this));
  }

  onAddTabs(tabs) {
    tabs.forEach(function (tab) {
      this.wire.unrollRecursive(tab, null, this);
    }.bind(this));
  }
}

class UnrollTab {
  render(unrollElement, jq, parentElement) {
    var tabButton = $('<div class="tab">').html(unrollElement['args'][0]);
    tabButton.appendTo(parentElement.leftPanel);
    tabButton.click(function () {
      parentElement.contentPanel.empty();
      this.wire.unrollRecursive(
        unrollElement['args'][1], parentElement.contentPanel);
    }.bind(this));
  }
}


var valueRenderers = {
  'htmlValue': function (jq, value) { jq.html(value); },
  'itemViewRenderer': function (jq, value) {
    value = this.wire.d(value);
    value['addresslatlng'] = value['addresslatlng'] || {};
    jq.css({ 'position': 'relative' });
    var div = $('<div class="itemView">').appendTo(jq);
    var mapDiv = $('<div class="smallerMap">').appendTo(div);
    var infoDiv = $('<div class="info">').appendTo(div);
    infoDiv.html(value['name'] + '; ' + value['type'] + '; ' +
      value['addresslatlng']['address']);
    var latlng = value['addresslatlng']['l'];
    onInitGoogleMaps(function () {
      var mapObject = new google.maps.Map(mapDiv[0], {
        'center': latlng,
        'zoom': 16,
      });

      new google.maps.Marker({
        'position': latlng,
        'map': mapObject,
        'title': value['name'],
      });
    });
  },
};

class UnrollTable {
  render(unrollElement, jq, parentElement) {
    this.tableName = unrollElement['args'][0];
    this.recordIdToTr = {};
    this.dataName = unrollElement['kwargs']['renderData'];
    this.table = $('<table>').appendTo(jq);
    var headTr = $('<tr>').appendTo(this.table);
    this.fields = unrollElement['kwargs']['rowFields'];
    this.actions = unrollElement['kwargs']['rowActions'] || [];
    this.fields.forEach(function (field) {
      $('<td>').html(field[0]).appendTo(headTr);
    }.bind(this));

    this.actions.forEach(function (a) {
      $('<td>').html('&nbsp;').appendTo(headTr);
    }.bind(this));

    var data = this.wire.fetchData(this.dataName);
    data.forEach(this.renderRecord.bind(this));

    this.onObjectsAddBound = this.onAddObjects.bind(this);
    this.onObjectsRemoveBound = this.onRemoveObjects.bind(this);
    this.wire.registerOnAddObjects(this.dataName, this.onObjectsAddBound);
    this.wire.registerOnRemoveObjects(
      this.dataName, this.onObjectsRemoveBound);
  }

  /**
   * Called when server notifies of new data.
   */
  onAddObjects(records) {
    if ($(document.body).find(this.table).length == 0) {
      this.wire.unregisterOnAddObjects(this.dataName, this.onObjectsAddBound);
      return;
    }
    records.forEach(this.renderRecord.bind(this));
  }

  /**
   * Called when server notifies of data removal.
   */
  onRemoveObjects(records) {
    if ($(document.body).find(this.table).length == 0) {
      this.wire.unregisterOnRemoveObjects(
        this.dataName, this.onObjectsRemoveBound);
      return;
    }
    records.forEach(function (r) {
      if (this.recordIdToTr[r._id]) {
        this.recordIdToTr[r._id].remove();
      }
    }.bind(this));
  }

  renderRecord(r) {
    //
    var tr = $('<tr>').appendTo(this.table);
    this.recordIdToTr[r._id] = tr;
    this.fields.forEach(function (field) {
      var fieldValExpr = field[1];
      var val;
      if (fieldValExpr.startsWith('${') && fieldValExpr.endsWith('}')) {
        val = eval(fieldValExpr.substr(2, fieldValExpr.length - 3));
      } else {
        val = r[fieldValExpr];
      }
      val = val || "";
      // Default to html renderer.
      var rendererFn = valueRenderers[field[2] || 'htmlValue'];
      rendererFn.call(this, $('<td>').appendTo(tr), val);
    }.bind(this));

    this.actions.forEach(function (a) {
      var button = $('<button>').html(a[0]);
      var action = new Unroll[a[1]['ref']]();
      action.wire = this.wire;
      action.target = r;
      button.click(function () {
        this.wire.tableItems[this.tableName] = r;
        action.invoke(a[1]['args']);
      }.bind(this));
      $('<td>').appendTo(tr).append(button);
    }.bind(this));
  }
}


class UnrollGrid {
  render(unrollElement, jq, parentElement) {
    this.tableName = unrollElement['args'][0];
    this.recordIdToTr = {};
    this.dataName = unrollElement['kwargs']['renderData'];
    this.table = $(`  
    <table id="manageRealestateTable" 
          data-show-fullscreen="true"
          data-show-search-button="true"
          data-search="true"
          class="tableClass" 
          data-show-header="false"   
          data-buttons-align="left"
          data-id-field="id"
          data-unique-id = "id"
          data-pagination="true"
          data-page-list="[5, 10, 25, 50, 100,'All']"
          data-page-size="5"> 
     <!-- 
        data-unique-id = 'description'
         data-side-pagination="server"
         data-id-field="name"
         data-detail-view="true"
         data-show-export="true"
         data-url="json/data1.json"
     -->
            <thead>
            <tr>
           
            </tr>
            </thead>
    </table> `).appendTo(jq);
    // <th data-field="id" data-visible="false" ></th>   
    // <th data-field="map" data-formatter="mapIconFormatter" data-events="window.operateEvents"></th>
    // <th data-field="description"></th>
    // <th data-field="edit" data-formatter="editIconFormatter" data-events="window.operateEvents"></th>

    var headTr = this.table.find('tr');
    this.fields = unrollElement['kwargs']['rowFields'];
    this.actions = unrollElement['kwargs']['rowActions'] || [];
    this.fields.forEach(function (field) {
      $('<th>').html(field[0]).appendTo(headTr);
    }.bind(this));

    this.actions.forEach(function (a) {
      $('<td>').html('&nbsp;').appendTo(headTr);
    }.bind(this));

    var data = this.wire.fetchData(this.dataName);
    data.forEach(this.renderRecord.bind(this));

    this.onObjectsAddBound = this.onAddObjects.bind(this);
    this.onObjectsRemoveBound = this.onRemoveObjects.bind(this);
    this.wire.registerOnAddObjects(this.dataName, this.onObjectsAddBound);
    this.wire.registerOnRemoveObjects(
      this.dataName, this.onObjectsRemoveBound);
  }

  /**
   * Called when server notifies of new data.
   */
  onAddObjects(records) {
    if ($(document.body).find(this.table).length == 0) {
      this.wire.unregisterOnAddObjects(this.dataName, this.onObjectsAddBound);
      return;
    }
    records.forEach(this.renderRecord.bind(this));
  }

  /**
   * Called when server notifies of data removal.
   */
  onRemoveObjects(records) {
    if ($(document.body).find(this.table).length == 0) {
      this.wire.unregisterOnRemoveObjects(
        this.dataName, this.onObjectsRemoveBound);
      return;
    }
    records.forEach(function (r) {
      if (this.recordIdToTr[r._id]) {
        this.recordIdToTr[r._id].remove();
      }
    }.bind(this));
  }

  renderRecord(r) {
    //
    var tr = $('<tr>').appendTo(this.table);
    this.recordIdToTr[r._id] = tr;
    this.fields.forEach(function (field) {
      var fieldValExpr = field[1];
      var val;
      if (fieldValExpr.startsWith('${') && fieldValExpr.endsWith('}')) {
        val = eval(fieldValExpr.substr(2, fieldValExpr.length - 3));
      } else {
        val = r[fieldValExpr];
      }

      // Default to html renderer.
      var rendererFn = valueRenderers[field[2] || 'htmlValue'];
      rendererFn.call(this, $('<td>').appendTo(tr), val);
    }.bind(this));

    this.actions.forEach(function (a) {
      var button = $('<button>').html(a[0]);
      var action = new Unroll[a[1]['ref']]();
      action.wire = this.wire;
      action.target = r;
      button.click(function () {
        this.wire.tableItems[this.tableName] = r;
        action.invoke(a[1]['args']);
      }.bind(this));
      $('<td>').appendTo(tr).append(button);
    }.bind(this));
  }
}


class UnrollParagraph {
  render(unrollElement, jq, parentElement) {
    var pContents = unrollElement['args'][0];
    if (pContents.startsWith('${') && pContents.endsWith('}')) {
      pContents = eval(pContents.substr(2, pContents.length - 3));
    }
    $('<div class="paragraph">').html(pContents).appendTo(jq);
  }
}

class InvokableCallback {
  invoke(args) {
    console.log('Target.invoke');
    var r = this.target;
    var wire = this.wire;
    var value;
    if (args.length > 1) {
      value = eval(args[1].substr(2, args[1].length - 3));
    } else {
      value = null;
    }
    this.wire.call(args[0], value);
  }
}


/**
 * Constructable only in Javascript. Calls a local callback (not on server).
 */
class InvokableLocalCallback {
  invoke(args) {
    args[0]();
  }
}


class InvokablePopup {
  invoke(args) {
    console.log('Invoking Popup');
    // this.div = $('<div>').attr('title', args[0]).appendTo($(document.body));
    // this.wire.unrollRecursive(args[1], this.div, this);
    // this.div.dialog({
    //   'autoOpen': true,
    //   'modal': true,
    //   'height': 'auto',
    //   'open': function () { autoResizePopup(this.div) }.bind(this),
    // });

    // this.wire.popups[args[0]] = this;

    this.div = $('<div>').addClass("custom-modal"); //.height(500).width(800);

    this.wire.unrollRecursive(args[1], this.div, this);
    //

    var modal = Specto.ui.Modal.showModal(this.div, args[0]);
    this.wire.modals[args[0]] = modal;
    return modal;
  }
}



class InvokableModal {
  invoke(args) {
    console.log('Invoking Modal');
    this.div = $('<div>').addClass("custom-modal"); //.height(500).width(800);

    this.wire.unrollRecursive(args[1], this.div, this);
    //

    var modal = Specto.ui.Modal.showModal(this.div, args[0], args[2], args[3]);
    this.wire.modals[args[0]] = modal;

    return modal;
  }
}

class InvokableWarningModal {
  invoke(args) {
    console.log('Invoking Warning Modal');

    var modal = Specto.ui.Modal.showWarningModal(args[0]);
    this.wire.modals[args[0]] = modal;

    return modal;
  }
}

class InvokableInformModal {
  invoke(args) {
    console.log('Invoking Inform Modal');
    var modal = Specto.ui.Modal.showInformationModal(args[0], args[1], args[2]);
    this.wire.modals[args[0]] = modal;

    return modal;
  }
}

class InvokableConfirmModal {
  invoke(args) {
    console.log('Invoking Confirm Modal');
    var modal = Specto.ui.Modal.showConfirmModal(args[0], args[1], args[2], args[3]);
    this.wire.modals[args[0]] = modal;

    return modal;
  }
}


class InvokableErrorModal {
  invoke(args) {
    var modal = Specto.ui.Modal.showErrorModal(args[0], args[1], args[2], args[3]);
    this.wire.modals[args[0]] = modal;

    return modal;
  }
}

class UnrollButton {
  render(unrollElement, jq, parentElement) {
    var button = $('<button type="button">').html(unrollElement['args'][0]).appendTo(jq);
    var targetArg = unrollElement['args'][1];
    var action = new Unroll[targetArg['ref']]();
    action.wire = this.wire;
    // Can go more levels.
    if (parentElement) {
      action.target = parentElement.target || (
        parentElement.parent && parentElement.parent.target);
    }
    button.click(function () {
      action.invoke(targetArg['args']);
    });

    if (unrollElement['kwargs']['css_class']) {
      button.addClass(unrollElement['kwargs']['css_class']);
    }
  }
}

class SchemaListRenderer {
  static renderMultiplePictures(elementDiv, element) {
    if (element['Photos'] && element['Photos'].length) {
      SchemaListRenderer.renderSinglePicture(elementDiv, element['Photos'][0]);
    }
    //$('<img>').src(element['Picture']).appendTo(elementDiv);
  }

  static renderSinglePicture(elementDiv, element) {
    $('<img>').attr('src', element['Picture']).appendTo(elementDiv);
  }

  static renderTextual(elementDiv, element) {
    // First one matches will be taken.
    var orderedFields = ['name', 'Name', 'Description', 'type'];
    var display = undefined;
    for (var i = 0; i < orderedFields.length; i += 1) {
      display = display || element[orderedFields[i]];
    }
    elementDiv.html(display);
  }
}


class UnrollEditableObject {
  /**
   * 
   * @param {*} unrollElement array containing elements:
   *   [0]: Name of object (can be used to get its values)
   *   [1]: Object with key "fields" and value Array, coming from schema.json [or similar format].
   *   [2]: (optional) Object Field values.
   *   [3]: (optional) on change callback.
   * @param {*} jq 
   * @param {*} parentElement 
   */
  render(unrollElement, jq, parentElement) {
    //
    this.name = unrollElement.args[0];
    this.wire.editableObjects[this.name] = this;
    this.fields = unrollElement['args'][1]['fields'];
    var groupDivs = {};
    this.fieldValues = unrollElement['args'][2] || {};
    this.onChangeCallback = unrollElement['args'][3] || function () { };
    //this.inputs = [];
    this.containingDivs = [];
    this.fieldObjects = [];
    this.fields.forEach(function (field) {
      var renderOn = jq;
      if (field['group']) {
        if (!groupDivs[field['group']]) {
          var groupName = (field['group']).replace(/\s/g, "_");
          var parentDiv = $(`<div id="${groupName}" class="panel mb-1" >
                                    <div class="panel-hdr cursor-pointer bg-primary text-white" style="min-height: 2.5rem;" 
                                      data-toggle="collapse" data-target="#${'content' + groupName}">
                                        <span class="w-100 group-panel-title">${field['group_html'] || field['group']}</span>
                                        <div class="panel-toolbar ml-auto">
                                        <div class="group-header-collapse-icon"  data-action="panel-collapse"
                                            data-toggle="tooltip" data-offset="0,10" data-original-title="Collapse">
                                            <i  class="fa fa-angle-double-up  text-black faa-vertical animated-hover"></i>
                                          </div>
                                        </div>
                                    </div>
                                    <div class="panel-container show  panel-collapse" id="${'content' + groupName}" >
                                        <div class="panel-content">
                                        </div>
                                    </div>
                    </div>`).appendTo(jq);
          groupDivs[field['group']] = parentDiv.find('.panel-content');

          parentDiv.find(".group-panel-title").tooltip('dispose');
          parentDiv.find(".group-panel-title").tooltip({
            title: "Click to collapse"
          });
          parentDiv.on('show.bs.collapse', function () {
            parentDiv.find(".group-panel-title").tooltip('dispose');
            parentDiv.find(".group-panel-title").tooltip({
              title: "Click to collapse"
            });
            parentDiv.find('.group-header-collapse-icon').find('.fa').removeClass('fa-angle-double-down');
            parentDiv.find('.group-header-collapse-icon').find('.fa').addClass('fa-angle-double-up');
          }).on('hide.bs.collapse', function () {
            parentDiv.find(".group-panel-title").tooltip('dispose');
            parentDiv.find(".group-panel-title").tooltip({
              title: "Click to expand"
            });
            parentDiv.find('.group-header-collapse-icon').find('.fa').removeClass('fa-angle-double-up');
            parentDiv.find('.group-header-collapse-icon').find('.fa').addClass('fa-angle-double-down');
          });

        }

        renderOn = groupDivs[field['group']];

        renderOn.addClass('form-row');
      }
      if (field['pre_blurb']) {
        renderOn.append($('<div class="preblurb col-12">').html(field['pre_blurb']));
      }
      var div = $('<div class="editingDiv">')
        .addClass(field['inline'] ? 'col-xl-4 col-lg-4 col-md-6 col-sm-6 col-12 mb-1' : 'col-12 mb-1 px-0')
        .appendTo(renderOn);

      this.containingDivs.push(div);
      var fieldAndClass = getFieldAndClass(field);
      var fieldClass = fieldAndClass[1];
      field = fieldAndClass[0];
      var fieldObject = new fieldClass(field, div, function () {
        if ($(div).hasClass('is-invalid')) {
          $(div).removeClass('is-invalid');
          $(div).find('.err-msg').remove();
        }
        this.onChangeCallback();
      }.bind(this));
      fieldObject.wire = this.wire;
      var fieldValue;
      if (field['n'] in this.fieldValues) {
        fieldValue = this.fieldValues[field['n']];
      } else {
        fieldValue = field['default_value'];
      }
      fieldObject.startValue = fieldValue;
      fieldObject.parent = this;
      fieldObject.render(fieldValue, this.fieldValues);
      
      if (field['post_blurb']) {
        renderOn.append($('<div class="postblurb">').html(field['post_blurb']));
      }
      this.fieldObjects.push(fieldObject);
      //this.inputs.push(this.renderField(field, div));
    }.bind(this));
  }

  /**
   * Populates field value in valueDict. Returns error if it happens but
   * returns null if no errors.
   */
  populateValue(field, input, valueDict) {
    var inputType = field['t'] || 'text';

    if (inputType == 'password' && field['repeat']) {
      //.
      if (input[0].val() != input[1].val()) {
        return 'Password not correctly repeated.';
      } else {
        valueDict[field['n']] = input[0].val();
      }
    } else {
      valueDict[field['n']] = input.val();
    }

    if (!valueDict[field['n']] && field['r']) {
      return 'Field is required';
    }
  }

  getValues(ignoreErrors=false) {
    var valueDict = {};
    var hasError = false;
    var _styleErrorDom = function (container) {
      if (container.find('.is-invalid').length == 0) {
        container.addClass('is-invalid');
        container.find('input').addClass('is-invalid');
      }
      var formGroup = container.find('.form-group');
      if (formGroup && formGroup.length && !formGroup.find('.err-msg').length && !container.find('.err-msg').length) {
        container.find('.form-group').append($(`<span class="text-danger err-msg"
          style="position: relative;">`).html(error));
      }
      if ((!formGroup || !formGroup.length) && !container.find('.err-msg').length) {
        container.append($(`<span class="text-danger err-msg"
          style="position: relative;">`).html(error));
      }
    };
    for (var i = 0; i < this.fieldObjects.length; i += 1) {
      var fieldObject = this.fieldObjects[i];
      if (fieldObject.field['t'] == 'blurb')
        continue;
      this.containingDivs[i].find('div.error').remove();
      //var error = this.populateValue(
      //    this.fields[i], this.inputs[i], valueDict);
      var error = fieldObject.getValue(valueDict);
      var container = $(this.containingDivs[i]);
      if (error) {
        _styleErrorDom(container);
        //$('<div class="error">').html(error).appendTo(this.containingDivs[i]);
        hasError = true;
      }
    }
    if (ignoreErrors || !hasError) {
      return valueDict;
    } else {
      var jq;
      if (this.parent) {
        jq = this.parent.div || this.parent.jq;
      } else {
        jq = $(this.containingDivs);
      }
      
      var firstErrorMsg = jq.find('.err-msg').first();
      if (!firstErrorMsg.length) {
        $.each(jq, function (index, element) {
          if ($(element).find('.err-msg').length) {
            firstErrorMsg = element.find('.err-msg').first();
            return false;
          }
        });
      }
      var modalBody = $(firstErrorMsg.parents('.modal-body')[0]);
      var errorParentDom = modalBody.length ? modalBody :
        firstErrorMsg.parents('.view-container');
      if (firstErrorMsg.length && errorParentDom.length) {
        var offset = firstErrorMsg.offset().top - errorParentDom.scrollTop();
        if (offset > errorParentDom.innerHeight()) {
          errorParentDom.animate({ scrollTop: offset }, 1000);
        }
        else if (offset < 0) {
          errorParentDom.animate({ scrollTop: 0 }, 1000);
        }
      }
    }
  }
}

class UnrollCustomView {
  render(unrollElement, jq, parentElement) {
    var customViewDiv = $('<div>').addClass('custom_view').appendTo(jq);
    var viewName = unrollElement['args'][0];
    var customViewClass = eval(viewName);
    var customView = new customViewClass(
      this.wire, unrollElement['args'].slice(1));
    customView.render(customViewDiv);
    customViewDiv.on("remove", customView.removed.bind(customView));
  }
}

function u(elementName, args, kwargs) {
  return { 'ref': elementName, 'args': args || [], 'kwargs': kwargs || {} };
}

Unroll = {
  'Layout': UnrollLayout,
  'AJS': UnrollAJS,
  'Form': UnrollForm,
  'TabView': UnrollTabView,
  'Table': UnrollTable,
  'Tab': UnrollTab,
  'Paragraph': UnrollParagraph,
  'Button': UnrollButton,
  // Arguments.
  //   1. (string) Editable object name
  //   2. (Object) schema dict with key "fields"
  'EditableObject': UnrollEditableObject,
  'CustomView': UnrollCustomView,

  'Callback': InvokableCallback,
  'LocalCallback': InvokableLocalCallback,
  'Popup': InvokablePopup,
  'Modal': InvokableModal,
  'WarningModal': InvokableWarningModal,
  'InformModal': InvokableInformModal,
  'ConfirmModal': InvokableConfirmModal,
  'ErrorModal': InvokableErrorModal,

};

class BaseCustomView {
    constructor(wire) {
        this.wire = wire;
    }

    /**
     * Renders the view on jquery selector
     */
    render(jq) { }

    /** Function called when UI has been removed from screen */
    removed() {

    }
}

class ItemMultiSelect extends BaseCustomView {
    /**
     * @param {string} objectName: Unique name to store object instance under dict
     *   wire.editableObjects.
     * @param {Object} item Single or array of items to render.
     */
    constructor(wire, args) {
        super(wire);
        this.objectName = args[0];
        this.items = args[1];
        this.wire.editableObjects[this.objectName] = this;
        this.types = {
            'Building': 1,
            'Building Complex': 1,
            'Apartment': 1,
            'Villa': 1,
            'Semi-Attached Villa': 1
        };

        // List of objects with keys: "input" and "id". 
        this.itemCheckboxes = [];
    }

    getSelectedIds() {
        var selectedIds = [];
        this.itemCheckboxes.forEach(function (itemCheckbox) {
            if (itemCheckbox.input.prop('checked')) {
                selectedIds.push(itemCheckbox.id);
            }
        });
        return selectedIds;
    }

    render(jq) {
        var listDiv = $('<div>').addClass('multiselectlist').appendTo(jq);

        this.traverseRecursive(this.items, this.types, [], function (item, rootPath) {
            console.log('should render item ');
            console.log(item);

            var rootPathStrArr = rootPath.map(function (i) {
                var display = i.item['type'];

                // TODO(Hadeel): Task 1 & Task 2.
                if (i.item['name']) {
                    display += ' (' + i.item['name'] + ')';
                } else {
                    display += ' (unnamed)';
                }
                return display;
            });

            // Create <div> and add to listDiv
            var display = rootPathStrArr.join(' > ');
            if (rootPathStrArr.length > 0) {
                display += ' > ';
            }

            // TODO(Hadeel): Task 1 & Task 2.
            display += item['type'];
            if (item['name']) {
                display += ' (' + item['name'] + ')';
            } else {
                display += ' (unnamed)';
            }

            var checkbox = $('<input type=checkbox>');
            var span = $('<span>').html(display);
            this.itemCheckboxes.push({ input: checkbox, id: item._id });
            $('<div>').append(checkbox).append(span).appendTo(listDiv);
        }.bind(this));
    }

    traverseRecursive(items, types, rootPath, callback) {
        if (Array.isArray(items)) {
            items.forEach(function (item) {
                this.traverseRecursive(item, types, rootPath, callback);
            }.bind(this));
        } else if (typeof (items) == 'string' && items.startsWith('!obj!')) {
            // Object ID.
            var item = items; // single item.
            this.traverseRecursive(this.wire.d(item), types, rootPath, callback);
        } else {
            var item = items; // single item.
            if (items['type'] && types[items['type']]) {
                // Add item.
                callback(item, rootPath);
            }
            for (var k in item) {
                if (Array.isArray(item[k])) {
                    rootPath.push({ item: item, parentField: k });
                    this.traverseRecursive(
                        item[k], types, rootPath,
                        callback);
                    rootPath.pop();
                }
            }
        }
    }
}


class ItemTagsTab extends BaseCustomView {
    constructor(wire, itemTagsDataName) {
        super(wire);
        this.dataName = itemTagsDataName;
    }

    removed() {
        console.log('removed');
        this.wire.unregisterOnAddObjects(this.dataName, this.boundRenderTags);
    }

    render(jq) {
        var data = {};
        data.dataName = this.dataName;
        this.wire.renderAJS(jq, 'tag/tag', data, function (scope) {
            this.scope = scope;
        }.bind(this));

    }

}
class ItemTags extends BaseCustomView {
    constructor(wire, itemTagsDataName) {
        super(wire);
        this.dataName = itemTagsDataName;
    }

    removed() {
        console.log('removed');
        this.wire.unregisterOnAddObjects(this.dataName, this.boundRenderTags);
    }

    render(jq) {
        this.dom = $(
            `<span><h2 id="title" class="title">Tags:</h2>
       <div id="tags" class="tagsContainer" ></div><br/>
       <div id="add" calss="addButton"></div><br/><br/>
       <div id="tag_entries_header"></div>
       <div id="tag_entries"></div>
       <div id="tag_entries_footer"></div>
       </span>`);
        this.dom.appendTo(jq);
        this.tagsDiv = this.dom.find('#tags');
        this.tagEntries = this.dom.find('#tag_entries');
        this.addButtonDiv = this.dom.find('div#add');
        this.makeAddTagButton();
        this.footer = this.dom.find('#tag_entries_footer');
        //
        this.boundRenderTags = this.renderTags.bind(this);
        this.wire.registerOnAddObjects(this.dataName, this.boundRenderTags);
        this.renderTags(this.wire.fetchData(this.dataName));

        this.currentTag = null;
    }

    renderTags(tags) {
        tags.forEach(function (tag) {
            tag = this.wire.d(tag); // Get actual tag object.
            var display = tag['name'];
            if (tag['public_name']) {
                display += ' (Public: ' + tag['public_name'] + ')';
            }
            var tagDiv = $('<span>').html(display).addClass('tag');
            tagDiv.click(this.tagClicked.bind(this, tag));

            var deleteButton = $('<button>').html('X').addClass('closeButton');
            deleteButton.click(function () {
                this.wire.call();
            }.bind(this));

            this.tagsDiv.append(tagDiv);
            this.tagsDiv.append(deleteButton);
            this.tagsDiv.append($('<br>'));


        }.bind(this));
    }

    /**
     * Called when tag object is clicked.
     */
    tagClicked(tag) {
        this.clickedTag = tag;
        var display = tag['name'];
        if (tag['public_name']) {
            display += ' (Public: ' + tag['public_name'] + ')';
        }
        this.dom.find('#tag_entries_header').html('Entries for tag: ' + display).addClass('tagEntries');
        this.footer.empty();
        this.wire.call('business::get_item_tag_entries', tag._id, function (data) {
            if (tag._id != this.clickedTag._id) {
                return;
            }

            // Add data
            console.log('hello');
            data['_entries'].forEach(function (entryId) {
                var entry = this.wire.d(entryId);
                var item = this.wire.d(entry['item']);

                var offerCalls = this.wire.data['ItemOfferCalls'];
                var select = $('<select>');
                select.append($('<option>').val('').html(''));
                offerCalls.forEach(function (offerCall) {
                    offerCall = this.wire.d(offerCall);
                    select.append($('<option>').val(offerCall._id).html(offerCall['name'] || '(unnamed)'));
                }.bind(this));

                if (entry['offer_call']) {

                }
                select.append($('<option>').val('__new__').html('New Call for Offers'));

                select.change(function () {
                    if (select.val() == '__new__') {
                        var fn_name = 'business::create_item_offer_call';
                        this.wire.call(fn_name, {}, function (response) {
                            //
                            this.associateEntryAndPopupEditOfferSettings(entryId, response['_id']);
                        }.bind(this));
                    } else if (select.val() == '') {
                        // Nothing is selected. Should remove association.
                        console.log('Should associate with None');
                    } else {
                        this.associateEntryAndPopupEditOfferSettings(entryId, select.val());
                    }
                }.bind(this));


                var entryDiv = $('<div>');
                // TODO(sami): Use Hadeel's function once she checks it in.
                entryDiv.append($('<span>').html(item['name']));
                entryDiv.append($('<br>'));
                entryDiv.append($('<span>').html('Offer Settings:'));
                entryDiv.append(select);
                entryDiv.appendTo(this.tagEntries);
            }.bind(this));

            // Render footer.
            this.footer.append(
                $('<span>').html('Add Approved Items to tag ' + display + '&nbsp;'));

            this.makeAddItemButton(this.footer, tag);
            this.dom.find('#tag_entries_footer').addClass('tagEntries');
        }.bind(this));
    }

    associateEntryAndPopupEditOfferSettings(entryId, offerSettingsId) {
        this.setOfferArgs = {
            entry: entryId,
            offer_call: offerSettingsId,
        };

        // TODO(sami): Simplify. Make method AJSWithButtons.
        var terms = [
            { 'name': 'Rent', 'type': 'fee' },
            //{name: 'Swimming Pool', type: MDTerm},
        ]

        var ajsCallback = function (scope) {
            this.scope = scope;
        }.bind(this);

        var modalButtons = [{
            label: "Submit",
            onClick: this.saveOfferSettings.bind(this)
        }];

        this.wire.modal('Offer Settings', u('Form', ['', [
            u('AJS', ['call_for_offers', terms, ajsCallback])
        ]]), modalButtons, { "resizable": true });

        // Popup edit
        /*
        var popupArgs = [
            'Offer Settings',
            u('Form', ['', [
              u('CustomView', ['OfferSettingsView', 'offerSettings', offerSettingsId]),
              u('Button', ['Save', u('LocalCallback', [this.saveOfferSettings.bind(this)]) ])
            ]
            ])
        ];

        var popup = new Unroll.Popup();
        popup.wire = this.wire;
        popup.invoke(popupArgs);
        */

        // TODO(volunteer). Show "loading" until we get response.
        this.wire.call(
            'business::set_item_entry_offer_call', this.setOfferArgs.bind(this));

    }

    saveOfferSettings() {
        alert("Save Offer Settings");
        console.log('saving. We have scope as:');
        console.log(this.scope);
        //
        //console.log('Got offer settings:');
        //TODO: to be save in json object called smartOfferTerms
        console.log(this.scope.getValue());
        var offerTerms = { 'smart_offer_terms': this.scope.getValue() };
        jQuery.extend(offerTerms, this.setOfferArgs);
        this.wire.call(
            'business::set_offer_call', offerTerms);
        //console.log(this.wire.editableObjects['fee'].getValue());
    }

    /**
     * Makes ('+') button and adds it to `jq` for adding realestate item to tag.
     */
    makeAddItemButton(jq, tag) {
        this.selectorName = 'multiselect';
        this.popupName = 'Add realestate items to tag ' + tag['name'];
        var renderData = this.wire.data['ItemOwner_ia']; // approved items.
        var addItemsForm = u('Form', ['Select Items', [
            u('CustomView', ['ItemMultiSelect', this.selectorName, renderData]),
            u('Button', ['Add Selected', u('LocalCallback', [this.onAddItemsClick.bind(this)])]),
        ]]);
        var btn = u('Button', ['+', u('Popup', [this.popupName, addItemsForm])]);
        this.wire.unrollRecursive(btn, jq);
    }

    makeAddTagButton() {
        var fieldSchema = this.wire.fetchData('item_tag_fields');

        var newTagForm = u('Form', ['Tag Details', [
            u('EditableObject', ['tag_details', fieldSchema]),
            u('Button', ['Save', u('LocalCallback', [this.onSaveClick.bind(this)])]),
        ]]);
        var btn = u('Button', ['+', u('Popup', ['New Tag', newTagForm])]);
        this.wire.unrollRecursive(btn, this.addButtonDiv);
    }

    onAddItemsClick() {
        var selectedIds = this.wire.editableObjects[this.selectorName].getSelectedIds();
        console.log('Adding IDs:');
        console.log(selectedIds);
        console.log('To tag:');
        console.log(this.clickedTag);
        this.wire.call(
            'business::add_items_to_tag', { 'tag': this.clickedTag._id, 'items': selectedIds },
            this.tagClicked.bind(this, this.clickedTag));
        this.wire.closePopups([this.popupName]);
    }

    onSaveClick() {
        console.log('Save was clicked');
        var tagDetails = this.wire.editableObjects['tag_details'].getValues();
        this.wire.call('business::add_item_tag', tagDetails);
    }

    /**
     * Gets list of offer calls.
     */
    processOfferCalls(response) {

    }
}
/**
 * Provides tools for managing Realestate Items.
 */
class ItemManager {
  constructor(wire) {
    this.wire = wire;
    this._schema = null;
    this.schema = null;
    /*
    this.listableTypes = [];
    this.rootableTypes = [];
    */
    this.byGroup = {};
    this._itemSummary = {};
    this._itemListableFields = {};
    
    /**
     * From scheme type (e.g. building)
     * @type {Object<string, Array<string>>}
     */
    this.plainFieldsByType = {}
  }

  processSchema() {
    this.byGroup = {};
    var types = [];
    for (var type in this.schema) {
      types.push(type);
    }
    //this.listableTypes = [];
    //this.rootableTypes = [];
    this.plainFieldsByType = {};
    types.forEach(function(type) {
      (this.schema[type]['groups'] || []).forEach(function(groupName) {
        if (!this.byGroup[groupName]) {
          this.byGroup[groupName] = [];
        }
        this.byGroup[groupName].push(type);
      }.bind(this));
      this.plainFieldsByType[type] = [];
      this.schema[type]['fields'].forEach(function(field) {
        if (field['type'] == 'EditableField') {
          this.plainFieldsByType[type].push(field['name']);
        } else if (field['type'] == 'EditableObject') {
          field['typeargs'][0].forEach(function(subfield) {
            this.plainFieldsByType[type].push(subfield['n']);
          }.bind(this));
        }
      }.bind(this));
    }.bind(this));

    // Amenities:
    var amenityChoices = this.schema['Apartment'].fields.filter(f => f['name'] == 'Amenities')[0]['typeargs'][0][0]['choices'];
    this.amenities = {};
    amenityChoices.forEach(function(choice) {
      this.amenities[choice['n']] = choice['d'] || choice['n'];
    }.bind(this));
  }

  /**
   * Fetches Hot Schema from server and caches it.
   * @param {Function} callback Function will be called with HotSchema.
   */
  getHotSchema(callback) {
    if (this.schema) {
      callback(this.schema);
    } else {
      this.wire.call('business::get_hot_schemas', null, function(schema) {
        this._schema = schema;  // NOTE: Deprecated
        this.schema = schema;
        this._processSchema();
        callback(schema);
      }.bind(this));
    }
  }

  getItemCountableFields(id) {
    if (!this._itemSummary[id]) {
      this._itemSummary[id] = {};
      var item = this.wire.d(id);
      if (item && item.type) {
        // Enhance this code by caching the item listable of fields (e.g. fields of type list)
        var fields = this.schema[item.type].fields.filter(f => f.type == "List");
        //var fields = this._getItemListableFields(item);
  
        fields.forEach(function (field) {
          var type = field.typeargs[0];
          var name = field.name;
          if (item[name]) {
            this._itemSummary[id][type] = this._itemSummary[id][type] || 0;
            this._itemSummary[id][type] += item[name].length;
            item[name].forEach(function (subField) {
              this._itemSummary[subField] = this.getItemCountableFields(subField);
              for (var subType in this._itemSummary[subField]) {        
                this._itemSummary[id][subType] = this._itemSummary[id][subType] || 0;
                this._itemSummary[id][subType] += this._itemSummary[subField][subType];          
              }
            }.bind(this));
          }
        }.bind(this));
      }
    }
    return this._itemSummary[id];
  }

  // _getItemListableFields(item) {
  //   if (!this._itemListableFields[item._id]) {
  //     this._itemListableFields[item._id] = this.schema[item.type].fields.filter(f => f.type == "List");
  //   }
  //   return this._itemListableFields[item._id];
  // }
  
  promptNewHotObject(dbType, fieldType, saveFnArgs) {
    var newFieldType = '_new_' + fieldType;
    if (!(newFieldType in this.wire.schemaManager.schema)) {
      newFieldType = "_new_hotobject";
      console.log('has NO ' + newFieldType);
    }
    
    this.wire.promptFields('Please specify name and attributes for the ' + fieldType, 'New ' + fieldType, newFieldType, null, function(values) {

      // Step 1. Create object
      values = values['fields'];  // In "multifield".
      values['type'] = fieldType;
      var saveNodeCallArgs = {
        'fields': {'name': values['name'], 'type': fieldType},
        'type': dbType,
      }
      saveNodeCallArgs = {
        ...saveNodeCallArgs,
        ...saveFnArgs
      };
      this.wire.call('interactions::save_node', saveNodeCallArgs, function(response) {
        var newItemId = response['_objs'][0];
        var designerAJS = u('AJS', ['item/designer', newItemId]);
        console.log('RESP is', response);
        var popupDesigner = function() {
          this.wire.modal('Design ' + fieldType, designerAJS, [
            {
              label: "Close",
              onClick: function(modal) {
                modal.close();
              },
              color: "btn btn-primary"
            }
          ], { sizeMode: "full", expandButton: false });
        }.bind(this);

        
        var fieldDict = SchemaManager.fieldsDict(this.wire.schemaManager.schema[newFieldType]['fields'])['fields'];
        fieldDict = SchemaManager.fieldsDict(fieldDict['fields']);
        var counts = {};
        var total = 0;
        for (var key in values) {
          if (key.startsWith('_new_num_')) {
            var v = values[key];
            if (v > 0) {
              total += v;
              var fieldNameInParent = key.substr('_new_num_'.length);
              counts[fieldNameInParent] = [fieldDict[key]['obj_type'],  v]
            }
          }
        }

        if (total > 0) {
          debugger;
          this.wire.call("business::add_many_subitems", [newItemId, counts], function(results) {
            popupDesigner();
          });
        } else {
          popupDesigner();
        }
      }.bind(this));
    }.bind(this));
  }

  promptNewItem(itemType) {
    this.promptNewHotObject('item', itemType, {'ref': 'create-item'});
  }
};


class SchemaManager {
  constructor(wire) {
    this.wire = wire;
    this.schema = null;
  }

  getSchema(callback) {
    if (this.schema) {
      callback(this.schema);
    } else {
      this.wire.call('business::get_schemas', null, function(response) {
        this.schema = response['_schema'];
        callback(this.schema);
      }.bind(this));
    }
  }

  static fieldsDict(fields) {
    var d = {};
    fields.forEach(field => { d[field['n']] = field });
    return d;
  }
};

class EdgeSchemaManager {
  constructor(wire) {
    this.wire = wire;
    this.schema = null;
    // Object type to {t: edge typename, i: endpoint index}
    this.typeIndex = {};
  }

  processSchema() {
    for (var typename in this.schema) {
      var edgeType = this.schema[typename];
      edgeType['endpoints'].forEach(function(ep, idx) {
        ep.typeSet = new Set(ep['types'])
        if (ep['search_fn']) {
          ep.searchFn = eval(ep['search_fn']);
        }
        if (ep['assign_fn']) {
          ep.assignFn = eval(ep['assign_fn']);
        }

        ep['types'].forEach(function(epType) {
          if (!(epType in this.typeIndex)) {
            this.typeIndex[epType] = [];
          }
          this.typeIndex[epType].push({i: idx, t: typename});
        }.bind(this))
      }.bind(this));
    }
  }

  /**
   * Given an edge type and an object, returns the endpoint index which can hold the object.
   * This can be used for:
   *  - Displaying the label.
   *  - Deducing remaining object types that would complete the edge.
   * @param {string} typename 
   * @param {Object} obj 
   * @returns list of lists. Each list indicate a set of types
   */
  getEndpointIndex(typename, obj) {
    var edgeType = this.schema[typename];
    if (!edgeType) {
      this.wire.errorMessageModal('No schema for Edge type ' + typename);
      return;
    }
    if (!edgeType.endpoints) {
      this.wire.errorMessageModal('Edge type ' + typename + ' has no endpoints.');
      return;
    }

    var t = obj['type'].toLowerCase();
    for (var i = 0; i < edgeType.endpoints.length; i += 1) {
      if (edgeType.endpoints[i].typeSet.has(t)) {
        return i;
      }
    }
    this.wire.errorMessageModal('edge type ' + typename + ' does not have endpoint type ' + t);
  }
};

/**
 * Provides functions for accessing lists from server, including pagination.
 * Functions prepare data that is directly ingestible in GroupList
 */
class Lister {
  constructor(wire) {
    this.wire = wire;
    this.cache = {};
    /**
     * GUID to callback. Populated in subscribe. This method is
     * invoked when the server transmits new object to WIRE (on socket).
     */
    this._subscriptions = {}; 
  }

  interactionArgs(fnName) {
    var interactionType = fnName.split(':')[1];
    var requestArgs;
    if (interactionType == 'ref') {
      requestArgs = {'ref': fnName.split(':')[2]};
    } else {
      var idxAtInteractionId = fnName.substr("interaction::".length + interactionType.length);
      var parts = idxAtInteractionId.split('@');
      var idx = Number(parts[parts.length - 2]);
      var interactionId = parts[parts.length - 1];
      requestArgs = {'i_type': interactionType, 'idx': idx, 'interaction_id': interactionId};
      if (parts.length == 3) {
        // first part must indicate endpoint idx.
        requestArgs['ep'] = Number(parts[0]);
      }
    }
    return requestArgs;
  }

  /**
   *
   * @param {string} fnName Name of function defined below, or one of these strings:
   *   "o:<db_type>:<field_type>" signifies a getter on object type, owned by the current context wallet.
   *   <db_type> refers to the object data type (as stored), and <field_type> refers to the "type" field on
   *   the object attribute. In many cases, they match. However, in some cases they differ e.g. "item" is a db type for
   *   many objects including ("Apartment", "Building", ...). Similarly, e.g. "o:account:employee"
   *
   *   It can also be a list of strings. If so, the same function is called on every item of the list in parallel and
   *   the items are combined then passed to callback.
   *
   * @param {Function} callback accepts one parameter (listConfig). See doc of group_list.js
   * @param {string} fetchEdge if given, must be edge typename which will be fetched from
   *   the server for the responded objects.
   */
  get(fnName, callback, fetchEdge=null, options=null) {
    if (fetchEdge) {
      return this.get(
        fnName,
        function(config) {
          // Get edges. Upon return, proceed with callback.
          var getEdgesArgs = {
            obj_ids: config["items"].map(o => o._id),
            typename: fetchEdge
          };
          this.wire.call(
            "business::get_edges_with_type",
            getEdgesArgs,
            function(response) {
              callback(config);
            }
          );
        }.bind(this)
      );
    }

    if (fnName instanceof Array) {
      var promises = fnName.map(
        name =>
          new Promise(
            function(resolve) {
              this.get(name, function(data) {
                resolve(data);
              });
            }.bind(this)
          )
      );
      Promise.all(promises).then(function(values) {
        var allGroups = ["type"];
        var allItems = [];
        for (var i = 0; i < values.length; i += 1) {
          allItems = allItems.concat(values[i]["items"]);
          for (var j = 0; j < values[i]["group"]; j += 1) {
            if (allGroups.indexOf(value["group"][j]) < 0) {
              allGroups.push(value["group"][j]);
            }
          }
        }
        callback({ items: allItems, group: allGroups });
      });
      return;
    }
    if (this[fnName]) {
      this[fnName](callback);
    } else if (fnName.startsWith("o:")) {
      var parts = fnName.split(":");
      var requestArgs = { type: parts[1] };
      if (parts.length == 3) {
        requestArgs["subtype"] = parts[2];
      }

      this.wire.call("business::get_owned_objects", requestArgs, function(response) {
        callback({
          group: [],
          items: response["_objs"].map(this.wire.d.bind(this.wire))
        });
      }.bind(this));
    } else if (fnName.startsWith("interaction:")) {
      var requestArgs = this.interactionArgs(fnName);
      
      this.wire.callWithSpinner("interactions::list_objects", requestArgs, function(response) {
        if(options && options['rawResponse']){
          callback(response);
        }
        else{
          this.uniqify(response);
          callback({
            group: [],
            items: response["_objs"].map(this.wire.d.bind(this.wire))
          });
        }
      }.bind(this));
    } else {
      console.log("ERROR: Cannot understand fnName: " + fnName);
    }
  }

  /**
   * 
   * @param {string} fnName interactions fnName (that gave the object in the first place).
   * @param {string} objId ID of object to be retrieved from server.
   * @param {Function} callback will be called when server returns object.
   */
  getOneObject(fnName, objId, callback) {
    var requestArgs = this.interactionArgs(fnName);
    requestArgs['obj'] = objId;
    this.wire.callWithSpinner('interactions::fetch_object', requestArgs, callback);
  }

  /**
   * Subscribes to real-time server updates on lister with fnName
   * @param {JQuery} lifetimeDom 
   * @param {string} fnName same as method `get`
   * @param {Function} callback will be called with newly-added objects.
   */
  subscribe(lifetimeDom, fnName, callback) {
    if (lifetimeDom.attr('lister_guid')) {
      // DOM has already subscribed. Ignore.
    } else if(WIRE.socket) {
      // DOM newly subscribing
      var guid = Guid.generate();
      this._subscriptions[guid] = {dom: lifetimeDom, fnName: fnName, callback: callback};
      var subscribeData = {'list': fnName, 'guid': guid};
      // TODO(live index destruction): when lifetimeDom is removed from dom,
      lifetimeDom.on("remove", function () {
        this.unsubscribe(lifetimeDom, fnName);
      }.bind(this));
      // invoke `{'fn': 'unsubscribe'}` on `subscribeData`
      lifetimeDom.attr('lister_guid', guid);
      var subscribeRequest = {
        'fn': 'subscribe',
        'data': subscribeData,
      };
      WIRE.socket.emit('fn', JSON.stringify(subscribeRequest));
    }
  }

  /**
   * Remove the subscriptions from the real-time server
   * @param {JQuery} lifetimeDom 
   * @param {string} fnName 
  */
  unsubscribe(lifetimeDom, fnName) {
    var guid = lifetimeDom.attr('lister_guid');
    if (guid) {
      if (this._subscriptions.hasOwnProperty(guid)) {
        delete this._subscriptions[guid];
      }
      var subscribeData = { 'list': fnName, 'guid': guid };
      var unsubscribeRequest = {
        'fn': 'unsubscribe',
        'data': subscribeData,
      };
      WIRE.socket.emit('fn', JSON.stringify(unsubscribeRequest));
    }
  }

  /**
   * 
   * @param {Object} payload server-sent packet containing updated object.
   */
  handleUpdatedObject(payload) {
    var guid = payload['live'];
    var updatedObjId = payload['_s_obj'];
    var updatedObj = this.wire.d(updatedObjId);
    var subscription = this._subscriptions[guid];
    this.wire.attemptToUpdateObjectsCache(payload);
    if (subscription) {
      subscription.callback([updatedObj]);
    }
  }

  uniqify(response) {
    var oldObjs = response["_objs"];
    var newObjs = [];
    var seenSet = new Set();
    oldObjs.forEach(objId => {
      if (!seenSet.has(objId)) {
        newObjs.push(objId);
      }
      seenSet.add(objId);
    });
    response['_objs'] = newObjs;
  }

  getIncomingOffers(callback) {
    const typename = 'wallet_offer';
    var getEdgesArgs = {
      obj_ids: [this.wire.data['wallet']],
      typename: typename
    };
    this.wire.call("business::get_edges_with_type", getEdgesArgs, function(response) {
      // Edges are loaded in edgeDB. Get them:
      var idx = WIRE.edgeSchemaManager.getEndpointIndex(
          typename, this.wire.d(this.wire.data['wallet']));
      var nextNodeIds = this.wire.edgeDb.getNextNodes(
          this.wire.data['wallet'], typename, idx);
      var nextNodes = nextNodeIds.map(this.wire.d.bind(this.wire));
      var config = {
        'items': nextNodes,
        'groups': [],
      }
      callback(config);
    }.bind(this));
  }

  getOccupableItems(callback) {
    this.wire.call('interactions::list_objects', {'ref': 'occupable-items'}, function(response) {
      callback({
        group: [],
        items: response["_objs"].map(this.wire.d.bind(this.wire))
      });
    }.bind(this));
  }

  getRentableItems(callback) {
    this.wire.call('interactions::list_objects', {'ref': 'rentable-items'}, function(response) {
      callback({
        group: [],
        items: response["_objs"].map(this.wire.d.bind(this.wire))
      });
    }.bind(this));
  }

  getOwnedItems(callback) {
    console.error('getOwnedItems is deprecated.');
    return this.getOccupableItems(callback);
  }

  /**
   * fetches the rental listings from either cache or server
   * @param {Function} callback, the fuction that should be executed after fetching the data
   * @param {obj} jq, the jQuery element which will contain the loading spinner span
   */
  getRentalListings(callback, jq) {
    const loadingSpan = $('<span><div id="loading" class="preloader"><div class="spinner"></div></div></span>');
    if (jq) {
      jq.append(loadingSpan);
    }
    
    this.wire.call('public::residential_rentals', null, function (response) {
      callback(response);
      loadingSpan.remove();
    });
    // var response = Cache.get(fnName);
    // if(response){
    //   callback(response);
    // }
    // else{
    //   this.wire.call(fnName, null, function(response) {
    //     Cache.set(fnName, response, 30*60*1000);
    //     callback(response);
    //   });
    // }
  }

  /*  
  getOwnedItems1(callback) {
    var keys = ["ItemOwner_ia", "ItemOwner_iaa", "ItemOwner_id"];
    var ownedItems = [];
    for (var i = 0; i < keys.length; i += 1) {
      ownedItems = ownedItems.concat(this.wire.data[keys[i]] || []);
    }

    this.wire.itemManager.getHotSchema(
      function() {
        var listTypesDict = {};
        this.wire.itemManager.listableTypes.forEach(t => {
          listTypesDict[t] = 1;
        });

        // TODO(sami): No need to flatten then re-group?
        var itemsConfig = {
          group: ["type", "tree"],
          items: []
        };

        this.traverseRecursive(
          ownedItems,
          listTypesDict,
          [],
          function(item, rootPath) {
            console.log("Got item with rootPath:");
            console.log(item);
            console.log(JSON.parse(JSON.stringify(rootPath)));
            if (rootPath.length > 0) {
              //debugger;
            }
            itemsConfig["items"].push({
              _id: item["_id"],
              type: item["type"],
              tree: rootPath.map(p => {
                return p.item["_id"];
              })
            });
          }.bind(this)
        );

        callback(itemsConfig);
      }.bind(this)
    );
  }
  */

  traverseRecursive(items, types, rootPath, callback) {
    if (Array.isArray(items)) {
      items.forEach(
        function(item) {
          this.traverseRecursive(item, types, rootPath, callback);
        }.bind(this)
      );
    } else if (typeof items == "string" && items.startsWith("!obj!")) {
      // Object ID.
      var item = items; // single item.
      this.traverseRecursive(this.wire.d(item), types, rootPath, callback);
    } else {
      var item = items; // single item.
      if (items["type"] && types[items["type"]]) {
        // Add item.
        callback(item, rootPath);
      }
      for (var k in item) {
        if (Array.isArray(item[k])) {
          rootPath.push({ item: item, parentField: k });
          this.traverseRecursive(item[k], types, rootPath, callback);
          rootPath.pop();
        }
      }
    }
  }
}


/**
 * Returns icons and labels for objects living on the wire.
 */
class Depictor {
  constructor(wire) {
    this.wire = wire;
  }

  // Create card (render given object on card)
  createItemDom(item, hidePopover = false, defaultDomText = '') {
    var entryDom = Carder.card(item);
    if (entryDom) {
      return entryDom;
    }


    if (item._id && item._id.startsWith('e^')) {
      console.log('Making edge item dom.');
      var fullEdgeId = item._id.substr(2);
      var edgeTypename = fullEdgeId.split(':')[0];
      var entryDom = $('<div>');
      if (edgeTypename == 'item_tag_offer_call') {
        this.renderSummaryOfferCall(item, entryDom);
      } else if (edgeTypename == 'item_contract') {
        this.renderItemContractCard(item, entryDom);
      } else if (edgeTypename == 'ic') {
        this.renderTenantItemContractCard(item, entryDom);
      } else {

        console.log('Do not know how to render edge ' + edgeTypename)
        entryDom = $(
          `<div class="card border entry">
               <div>       
                   <img class="icon" draggable="false"></img>
                   <div class="label" data-toggle="tooltip" data-placement="bottom" title=""></div>
               </div>
          </div>`);
        entryDom.find('.label').html('Edge: ' + edgeTypename);
      }


      return entryDom;
    }

    if (item.type == 'Ledger') {
      debugger;
      const entryDom = $(
        `<div class="card border entry" style="width: 200px; height:200px">
             <div>
                <div id=piechart width=95px height=95px></div>
                <!--<div><b>Budget</b>: <span id=budget></span></div>       
                 <div><b>Committed</b>: <span id=committed></span></div> -->
                 <div class="label" data-toggle="tooltip" data-placement="bottom" title=""></div>
             </div>
        </div>`);
      var data = google.visualization.arrayToDataTable([
        ['Type', 'Amount'],
        ['Available', (item.budget || 10000) - (item.committed || 0)],
        ['Committed', item.committed || 0],
      ]);

      var options = {
        //title: 'My Daily Activities'
        'width': 150,
        'height': 100,
        'chartArea': { 'width': '100%', 'height': '80%' },
      };

      var chart = new google.visualization.PieChart(entryDom.find('#piechart')[0]);

      chart.draw(data, options);
      //entryDom.find('#budget').html(item.budget || 0);
      //entryDom.find('#committed').html(item.committed || 0);
      entryDom.find('.label').html(item.name || 'Ledger');
      return entryDom;
      //return this.createDefaultItemDom(item);
    }
    else if (item.type == 'residential_rental_listing') {
      return this.renderItemResidentialCard(item);
    } else if (item.type == 'wallet_type_application') {
      return this.renderItemWalletCard(item);
    } else if (item.type && item.type.endsWith('_wt')) {
      return this.renderItemAccountCard(item);
    } else if (item.type == 'fm_service_scope' || item.type == 'pm_service_scope') {
      return this.renderScopeBidCard(item);
    }

    return this.createDefaultItemDom(item, hidePopover, defaultDomText);
  }

  createDefaultItemDom(item, hidePopover = false, defaultDomText = '') {
    const entryDom = $(
      `<div class="card border entry" _id="${(item && item._id) ? item._id : (item || '')}">
           <div>       
               <img class="icon" draggable="false"></img>
               <div class="label"></div>
           </div>
      </div>`
    );

    const iconUri = this.getIconForItem(item);
    if (iconUri) {
      entryDom.find(".icon").attr("src", iconUri);
      if(iconUri.contains(".svg")){
        entryDom.find(".icon").css("object-fit","fill");
      }
    }
    var text = defaultDomText || this.getLabelForItem(item);
    var label = entryDom.find(".label");
    label.html(text)
      .attr("data-original-title", text);

    var showPopover = this.wire.itemManager.schema[item["type"]];
    if (hidePopover) {
      showPopover = false;
    }
    if (showPopover) {
      var itemCountableFields = this.wire.itemManager.getItemCountableFields(item._id);
      if (!isEmpty(itemCountableFields)) {
        this._createCardPopover(itemCountableFields, entryDom, text);
      }
    }
    else {
      entryDom.find("div.label").attr({ 'data-toggle': 'tooltip', 'data-placement': 'bottom', 'title': '' });
      label.tooltip();
    }

    return entryDom;
  }

  /**
   * Creates status dom with top progress line and right-hand buttons.
   * @param {object} statusObj data Object with field "s" and "status_trail"
   * @param {object} statusOptions dict with keys
   *   'actions': dict from status to list of actions (with "n" / "d" fields).
   *   'renderers': Not used yet.
   *   'names': Names of statuses.
   *   'nexts': Next statuses.
   **/
  createStatusDom(statusObj, statusOptions, buttonCallback) {
    var statusActionDict = statusOptions['actions'];
    var statusRenderDict = statusOptions['renderers'];

    // Create containers
    var dom = $('<div class="card status-card mb-1">');
    var cardHeader = $(`<div class="card-header p-2 color-primary-700" data-toggle="collapse">`)
      .appendTo(dom);
    var headerTitle = '<b class="cursor-pointer">Show less <span class="fa fa-angle-double-up" style="font-weight:bold; cursor:pointer"></span></b>';
    var headerContainer = $('<div class="float-right" style="font-size: 14px">').html(headerTitle)
      .appendTo(cardHeader);
    var collapsableDiv = $(`<div class="status-collapse show"></div>`)
      .on('show.bs.collapse', function (e) {
        if ($(this).is(e.target)) {
          headerTitle = '<b class="cursor-pointer">Show less <span class="fa fa-angle-double-up" style="font-weight:bold"></span></b>';
          headerContainer.html(headerTitle);
        }
      })
      .on('hide.bs.collapse', function (e) {
        if ($(this).is(e.target)) {
          headerTitle = '<b>Show more <span class="fa fa-angle-double-down" style="font-weight:bold"></span></b>';
          headerContainer.html(headerTitle);
        }
      })
      .appendTo(dom);
    var cardBody = $(`<div class="card-body pt-0 pl-4">`)
      .appendTo(collapsableDiv);
    var navigationBtns = $(`<div id="statusDomNav" class="position-absolute w-100" style="z-index: 2;left: 0">
      <a id="slideBack" role="button" class="float-left position-relative" style="top: 13px; left: 5px;"><i class="fa fa-chevron-left color-primary" style="font-size: 20px;"></i></a>
      <a id="slide" role="button" class="float-right position-relative" style="top: 13px; right: 5px"><i class="fa fa-chevron-right color-primary" style="font-size: 20px;"></i></a>
    </div>`);
    var statusNamesLength = Object.keys(statusOptions['names']).length;
    var prevBtn = navigationBtns.find('#slideBack');
    var nextBtn = navigationBtns.find('#slide');
    prevBtn.on('click', function () {
      sideScroll(statusProgressLine[0], 'left', 100, $(this), nextBtn);
    });
    nextBtn.on('click', function () {
      sideScroll(statusProgressLine[0], 'right', 100, prevBtn, $(this));
    });
    function sideScroll(element, direction, step, prev, next) {
      if (direction == 'left') {
        element.scrollLeft -= step;
      } else {
        element.scrollLeft += step;
      }
    };
    var statusProgressLine = $('<ul class="statusLine my-3"></ul>')
      .appendTo(cardBody);
    if (statusNamesLength - 3 > 0 && statusObj['s'] > -1) {
      navigationBtns.prependTo(cardBody);
    } else {
      statusProgressLine.css('padding-left', '27px');
    }
    var table = $(`
      <div class="status-table row">
        <div id=table_container class="w-100" style="border: 1px solid #e9e9e9; overflow-y: auto"></div>
      </div>`)
      .appendTo(cardBody);
    // Fill attributes
    cardHeader.attr('href', `#sd${statusObj['_id2']}`);
    collapsableDiv.attr('id', `sd${statusObj['_id2']}`);
    cardHeader.append($(`<span>`).html(statusObj['name']));
    // Render top progress line
    var drawStage = function (name, number, date, isCompleted) {
      var li = $(`<li class="li ${isCompleted ? 'complete' : ''}">`);
      var statusDetails = $('<div class="status-details">');
      $('<div class="status">')
        .append(statusDetails)
        .attr('data-content', `${number}`)
        .appendTo(li);
      statusDetails.append($('<span>').html(name))
        .append($('<span class="text-primary text-center">').html(date))
      return li;
    };
    var lastCompletedStage;  /* TODO: These variables are set but not read. */
    var isContractSigned;

    var collapsedStatusTrail = [];
    (statusObj["s_trail"] || []).forEach(function(trailEntry) {
      var lastIdx = collapsedStatusTrail.length - 1;
      if (lastIdx < 0 || trailEntry['s'] != collapsedStatusTrail[lastIdx].s) {
        collapsedStatusTrail.push({
          s: trailEntry['s'],
          start: parseTimeStamp(trailEntry['at']),
          end: parseTimeStamp(trailEntry['at']),
        });
      } else {
        collapsedStatusTrail[lastIdx].end = parseTimeStamp(trailEntry['at']);
      }
    });


    collapsedStatusTrail.forEach(function(entry, idx) {
      var phaseDate = entry.start;
      if (entry.end != entry.start) {
        phaseDate += ' - ' + entry.end;
      }
      statusProgressLine.append(
        drawStage(statusOptions['names'][entry.s], idx+1, phaseDate, true))
    });
    var seenStatus = new Set([])
    if (collapsedStatusTrail.length) {
      var lastStatus = collapsedStatusTrail[collapsedStatusTrail.length - 1].s;
      lastStatus = statusOptions['nexts'][lastStatus];
      seenStatus.add(lastStatus);
      while (lastStatus != undefined) {
        statusProgressLine.append(
          drawStage(statusOptions['names'][lastStatus], ' ', ' ', false));
        lastStatus = statusOptions['nexts'][lastStatus];
        if (seenStatus.has(lastStatus)) {
          break;
        } else {
          seenStatus.add(lastStatus);
        }
      }
    }

    // handle the style of the last li in the progress bar
    var lastLi = statusProgressLine.find('li').last();
    lastLi.find('.status').addClass('last');

    // handle the style of the last completed status
    if (!lastLi.hasClass('complete')) {
      var lastCompletedLi = statusProgressLine.find('li.complete .status:not(.last)').last();
      lastCompletedLi.css('border-top', '3px solid #D6DCE0');
    }
    var status = statusObj['s'];
    
    var objectContainer = table.find('#table_container');
    var buttonsContainer = $(`
      <nav class="shortcut-menu" style="bottom: 1.3125rem; right: 2.5rem;"></nav>`).prependTo(dom);
    
    if (statusActionDict[status] == undefined) {
      buttonsContainer.addClass('d-none');
    }

    if (statusObj['s'] in statusRenderDict) {
      var renderDictList = statusRenderDict[statusObj['s']];
      if (!(renderDictList instanceof Array)) {
        renderDictList = [renderDictList];
      }
      (renderDictList || []).forEach(function(renderDict) {
        var renderField = statusObj;
        if (renderDict['field']) {
          renderField = renderField[renderDict['field']];
        }
        if (renderField == undefined) {
          return;  // Should not render a field that is not populated.
        }
        var subcontainer = $('<div>').appendTo(objectContainer);

        if ('schema_name' in renderDict) {
          this.renderFlatObject(renderField, subcontainer, { 'type': renderDict['schema_name'], 'display': renderDict['d'] || '' });
        } else if ('schema' in renderDict) {
          this.renderFlatObject(renderField, subcontainer, { 'schema': renderDict['schema'] });
        }
      }.bind(this));
    } else {
      objectContainer.html(JSON.stringify(statusObj));
    }

    // Process status actions. Add them as buttons.

    if(statusActionDict[status]){
      (statusActionDict[status]).forEach(function (action) {
        const btnLabel = action['d'] || action['n'];
        var actionBtn = $(`
          <a class="menu-item d-flex btn waves-effect waves-themed" data-toggle="tooltip" data-placement="left" title="" data-original-title="${btnLabel}">
            <i class="fal fa-arrow-up"></i>
          </a>`).prependTo(buttonsContainer);
        actionBtn.html(`<span class="p-1">${btnLabel}</span>`);
        actionBtn.click(function () {
          if (status != statusObj['s']) {
            return;
          }
          buttonCallback(statusObj, action);
          buttonsContainer.find('#status_buttons').trigger('click');
        })
      });
    }
    $(`<input type="checkbox" class="menu-open" name="status_buttons" id="status_buttons">
      <label for="status_buttons" class="menu-open-button" >
        <span class="app-shortcut-icon d-block"></span>
      </label>`).prependTo(buttonsContainer);
    const statusMenuLabel = buttonsContainer.find('label');
    statusMenuLabel.tooltip({ 'title': 'Actions', 'placement': 'top' });
    var hideTooltip = function () {
      if (buttonsContainer.find('#status_buttons:checked').length) {
        statusMenuLabel.tooltip('hide');
      }
    };
    statusMenuLabel.hover(hideTooltip);
    buttonsContainer.click(hideTooltip);
    const statusMenuInput = buttonsContainer.find('#status_buttons');
    statusMenuInput.click( function(){
      if ($(this).is(':checked')) {
        buttonsContainer.find('a').addClass('status-btn-item');
      } else {
        buttonsContainer.find('a').removeClass('status-btn-item');
      }
    });
    // set status progress line width
    statusProgressLine.css('width', window.innerWidth - 95);
    // make sure that the current status is in view
    var currentStatus = statusProgressLine.find('li.complete').last().find('.status-details');
    if (currentStatus && currentStatus.offset()) {
      var statusOffset = currentStatus.offset().left - statusProgressLine.offset().left;
      var position = statusOffset - statusProgressLine.scrollLeft();
      if (position > statusProgressLine.innerWidth()) {
        statusProgressLine.animate({ scrollLeft: position }, 1000);
      }
    }
    return dom;
  }

  _createCardPopover(itemCountableFields, entryDom, label) {
    var popoverDom = $(`<div>
      <div class="wallet-card card border text-center p-0">
        <div class="bg-primary text-light px-2 py-1" style="border-radius: 5px 5px 0px 0px;">
          <span class="wallet-label my-auto">${label}</span>
        </div>  
        <div class="wallet-info-container px-2 py-1"></div>
      </div>
    </div>`);
    var tableContainer = $(`<div class="d-table mt-1">`);
    popoverDom.find('.wallet-info-container').append(tableContainer);

    //TODO: refactor this by using bootstrap4 classes if possible
    var counter = 0;
    for (var key in itemCountableFields) {
      var value = itemCountableFields[key];
      if (counter % 2 == 0) {
        var row = $('<div class="d-table-row">');
        tableContainer.append(row);
      }
      counter++;
      var img = $(`<img class="d-table-cell mr-2">`).attr({ 'src': this.wire.itemManager.schema[key].icon, 'width': '16px' });
      var val = $(`<div class="d-table-cell cust-fsize">`).html(value);
      var text = $(`<div class="d-table-cell pl-2 pr-3 cust-fsize">`).html(key);
      $(tableContainer.find(".d-table-row:last-child")).append(img).append(val).append(text);
    }
    // remove first space in each row in table container
    // tableContainer.find('.d-table-row').each(function () {
    //   $($(this).find(".d-table-cell:first-child")).removeClass('ml-4');
    // });
    entryDom.attr({ "data-toggle": "popover" })
      .popover({
        // To fix refresh issue on the popover entryDom specified as container for popover
        trigger: 'hover',
        delay: {
          show: 50,
          hide: 50
        },
        placement: 'auto',
        content: popoverDom.find('.wallet-card').html(),
        html: true,
        template: `<div class="popover" role="tooltip">
          <div class="arrow"></div>
          <h3 class="popover-header"></h3>
          <div class="popover-body p-0"></div>
        </div>`
      })
      .on('click', function (e) {
        // e.preventDefault();
        // me.wire.popupObjectView(me.wire.d(item));
        $(this).popover('hide');
      });
  }

  /**
   * returns URI to an icon (can be set to 'src' attribute of <img>).
   * @param {Object} item instantiation of object defined in HotSchema (building complex, ..., bed).
   */
  getIconForItem(item) {
    if (item["photo"]) {
      return item["photo"];
    }
    if (item["picture"]) {
      return item["picture"];
    }
    if (item["Photos"] && item["Photos"].length > 0) {
      var firstPhoto = this.wire.d(item["Photos"][0]);
      if (firstPhoto["picture"]) {
        return firstPhoto["picture"];
      }
    }
    //console.log(JSON.stringify(item));
    var itemType = item["type"];
    // Wallets dont have individual entries in schema.
    if (itemType && itemType.endsWith('_wt')) {
      itemType = 'wallet_type';
    }
    var schema =
      this.wire.itemManager.schema[itemType] ||
      this.wire.schemaManager.schema[itemType];

    if (schema && schema["icon_fn"]) {
      var fn = eval(schema["icon_fn"]);
      var icon = fn(item);
      if (icon) {
        return icon;
      }
    }
    if (schema && schema["icon"]) {
      return schema["icon"];
    }
    if (item["account_type"]) {
      return `/www/icons/financial/${item["account_type"]}.svg`;
    }
    return `/www/img/placeholder_keyras.png`;
  }

  /**
   * returns URI to an icon (can be set to 'src' attribute of <img>).
   * @param {Object} item instantiation of object defined in HotSchema (building complex, ..., bed).
   * @param {Function} onImageReadyCallback callback is called when the generated image becomes ready
   */
  getItemImageIcon(item, onImageReadyCallback) {
    var img = null;
    var icon = null;
    if (item["picture"]) {
      img = item["picture"];
    }
    if (item["Photos"] && item["Photos"].length > 0) {
      var firstPhoto = this.wire.d(item["Photos"][0]);
      if (firstPhoto["picture"]) {
        img = firstPhoto["picture"];
      }
    }
    if (
      this.wire.itemManager.schema[item["type"]] &&
      this.wire.itemManager.schema[item["type"]].icon
    ) {
      icon = this.wire.itemManager.schema[item["type"]].icon;
    }
    return this.getImageFromCanvas(
      img,
      icon,
      "png",
      false,
      onImageReadyCallback
    );
  }

  /**
   *
   * @param {string} src image soruce file (base64 or path)
   * @param {string} iconSrc icon soruce file (base64 or path)
   * @param {string} outputFormat extension of target image
   * @param {string} isRtl location of icon on the target image
   * @param {string} hieght of target image
   * @param {string} with of target image
   */
  getImageFromCanvas(
    src,
    iconSrc,
    outputFormat,
    isRtl,
    onRready,
    width,
    height
  ) {
    if (!src) {
      src = iconSrc;
      iconSrc = null;
    }

    var canvasImageGenerator = new CanvasImageGenerator(src, {
      width: width,
      height: height,
      icon: {
        type: "src",
        content: iconSrc
      },
      outputFormat: outputFormat,
      rtl: isRtl,
      onReady: function () {
        debugger;
        var base64 = canvasImageGenerator.getBase64();
        if (onRready) {
          onRready(base64);
        }
      }
    });
  }

  /**
   * Returns textual content for an item.
   * @param {Object} item
   */
  getLabelForItem(item) {
    // Custom labels.
    if (item['type'] == 'item_offer') {
      var date = new Date(0); // The 0 there is the key, which sets the date to the epoch
      date.setUTCSeconds(item['created_on'] || 0);
      return 'Offer on:\n' + date.toLocaleString("en-GB", { day: "numeric", month: "short", year: "numeric" }); // .replace(/ /g, '-');
    } else if (item['type'] && item['type'].endsWith('_wt')) {
      var displayType = item['type'].replace('_wt', '');
      displayType = displayType[0].toUpperCase() + displayType.substr(1)
      return item['name'] || item['company_name'] || (displayType + ' Wallet');
    } else if (item['type'] == 'wallet_type_application') {
      return item['name'] || item['company_name'] || (item['application_type'] + ' application');
    } else if (item['type'] == 'signature') {
      return 'Signature on ' + new Date(item['created_on'] * 1000 || 0).toDateString();
    } else if (item['type'] === 'calendar_response') {
      let start = new Date(item['start'] * 1000).toLocaleString();
      let end = new Date(item['end'] * 1000).toLocaleString();
      return `${start}-${end} ${item.title}`;
    }

    // Default Label (from name)
    if (item["name"]) {
      return item["name"];
    }

    if (item["title"]) {
      return item["title"];
    }

    return "(new) " + item["type"];
  }

  /**
   * Returns icon for a list `field` of an `item`
   * @param {*} item Object having attribute indicated by `field` to be list.
   * @param {Object} field encoded by hot_schema.py (with 'name' and 'typeargs').
   */
  getIconForItemListField(item, field) {
    var listType = field["typeargs"][0];
    if (!this.wire.itemManager.schema[listType]) {
      console.log("Not found schema list type " + listType);
    } else {
      return this.wire.itemManager.schema[listType].icon;
    }
  }

  getLabelForItemListField(item, field) {
    var label = field["name"] + " (";
    if (field["name"] in item && item[field["name"]].length > 0) {
      // Calculate length.
      var length = 0;
      for (var i = 0; i < item[field["name"]].length; i += 1) {
        var child = this.wire.d(item[field["name"]][i]);
        if (child["cardinality"] && child["cardinality"] > 1) {
          length += child["cardinality"];
        } else {
          length += 1;
        }
      }
      label += length + ")";
    } else {
      label += "0)";
    }
    return label;
  }

  /**
   * Renders object on dom.
   * @param {*} obj should be a standard data object i.e. with fields "_id", and potentially "type" [for most]
   * @param {*} jq Dom element wrapped in jQuery selector
   */
  renderObjectOnDom(obj, jq, options) {
    // ************** EDGES.
    if (obj._id && obj._id.startsWith('e^item_tag_offer_call:')) {
      this.renderDetailedOfferCall(obj, jq);
    } else if (obj._id && obj._id.startsWith('e^item_contract:')) {
      this.renderItemContractEdge(obj, jq);
    } else if (obj._id.startsWith('e^')) {
      this.renderGenericEdge(obj, jq);
      console.log('generic edge rendered');
      // **************  NODES
    } else if (obj["type"] == "offer_call") {
      Offers.renderOfferCall(obj, jq);
    } else if (obj["type"] == 'CateringMenu') {
      this.renderCateringMenu(obj, jq);
    } else if (obj["type"] == "TransportationRoute") {
      this.renderTransportationRoute(obj, jq);
    } else if (obj["type"] == 'Ledger') {
      this.renderLedger(obj, jq);
    } else if (obj['type'] == 'item_contract') {
      this.renderItemContract(obj, jq);
    } else if (obj["type"] == 'item_offer') {
      this.renderItemOffer(obj, jq);
    } else if (obj["type"] in this.wire.itemManager.schema) {
      // HotType i.e. nested-type e.g. Appartment etc.
      this.renderRealStateUnit(obj, jq, options);
    } else if (obj["type"] in this.wire.schemaManager.schema) {
      // Flat type e.g. User, Asset.
      this.renderFlatObject(obj, jq, options);
    } else if (obj["type"].endsWith('_wt')) {
      this.renderFlatObject(obj, jq, { type: 'wallet_type' });
    } else if (obj["type"] == "fm_scope_bid" || obj["type"] == "pm_scope_bid") {
      this.renderScopeBid(obj, jq, options);
    } else {
      console.error("Cannot find renderer for object: ", obj);
    }
  }

  renderItemContractCard(obj, jq) {
    var itemContract = this.wire.d(obj.data.contract);
    this.makeEdgeCard(
      `Until ${itemContract.end_date || ""}`,
      this.wire.d(obj.ep[1]),
      this.wire.d(this.wire.d(obj.data.contract).item)).appendTo(jq);
  }

  renderItemResidentialCard(item) {
    var entryDom = $(`
      <div class="card residential-card border entry text-center pt-2">
        <h5 class="label mt-2 mb-0 position-relative"></h5>
        <ul class="list-group list-group-flush text-left"></ul>
      </div>`
    );
    // item.listing_logo
    var logoUrl = item['listing_logo'];
    $(`<img class="card-img-top position-relative" draggable="false">`)
      .attr("src", logoUrl ? logoUrl : 'https://keyras.github.io/img/no_image.jpg').css({
        "object-fit": "contain",
        "width": "100%",
        "height": "100px"
      })
      .prependTo(entryDom);
    // item.name
    var itemName = item['name'];
    var label = entryDom.find(".label");
    $('<span>').html(itemName).attr("data-original-title", itemName).appendTo(label);
    $('<span class="d-block">').append(`<i style="font-size: 11px"> (${item['is_public'] ? 'Public' : 'Private'})</i>`).appendTo(label);
    entryDom.find("div.label").attr({
      'data-toggle': 'tooltip',
      'data-placement': 'bottom',
      'title': ''
    });
    label.tooltip();
    var listGroupUl = entryDom.find(".list-group");
    // item.items
    var itemUnites = item['items'];
    if (itemUnites) {
      `<span class="badge badge-info" style="border-radius: 24px;">{0}</span>`
      listGroupUl.append(
        $(`<li class="list-group-item font-weight-bold"><span class="badge badge-info"
          style="border-radius: 24px;">${Object.keys(itemUnites).length}</span> Units</li>`)
      );
    };
    // item.allow_appointments
    var allowApp = item['allow_appointments'];
    listGroupUl.append(
      $(`<li class="list-group-item font-weight-bold"><i class="fa ${allowApp ? 'fa-check' : 'fa-times'} ${allowApp ? 'text-success' : 'text-danger'}" 
        style="font-size: 12px"></i> ${allowApp ? 'Allows' : 'No'} Appointments</li>`)
    );
    // item.promo_daterange
    var promoEnd = item['promo_daterange'] ?
      (item['promo_daterange']['endDate'] || item['promo_daterange']['end']) : "";
    if (promoEnd) {
      var listingPromotion = parseIntDay(promoEnd);
      var promotionDate = new Date(`${listingPromotion.month} ${listingPromotion.day} ${listingPromotion.year}`);
      // if promotion is in the present
      if (Date.parse(promotionDate) - Date.parse(new Date()) > 0) {
        // var cornerRibbon = $('<div class="ribbon ribbon-top-right">').appendTo(entryDom);
        // $(`<span>Promotion<i><br>until ${listingPromotion.year}-${listingPromotion.month}-${listingPromotion.day}</i></span>`)
        //   .appendTo(cornerRibbon);
        listGroupUl.append(
          $(`<li class="list-group-item font-weight-bold"><i class="fa fa-calendar-check-o text-primary" 
            style="font-size: 12px"></i> Promotion until ${listingPromotion.year}-${listingPromotion.month}-${listingPromotion.day}</li>`)
        );
      };
    }
    else {
      listGroupUl.append(
        $(`<li class="list-group-item font-weight-bold" style="min-height: 60px"><i class="fa fa-calendar-check-o text-primary" 
          style="font-size: 12px"></i> No Promotions</li>`)
      );
    }
    return entryDom;
  };

  renderItemWalletCard(item) {
    return this._renderIdCardTemplate(item);
  };

  renderItemAccountCard(item) {
    return this._renderIdCardTemplate(item, true);
  };

  _renderIdCardTemplate(item, isAccount) {
    var me = this;
    let classes = isAccount? "wallet-card card card-not-clickable border text-center p-0"
        : "wallet-card card border text-center p-0";
    var entryDom = $(`<div class="mr-2 position-relative" style="display: inline-block">
      <div class="${classes}" style="${isAccount? 'min-height: 0' : ''}">
        <div class="row no-gutters bg-primary text-light px-2 py-1" 
          style="border-radius: 4px 4px 0px 0px;">
          <span class="wallet-label"></span><i class="wallet-type ml-1"></i>
        </div>  
        <div class="row no-gutters">
          <div class="wallet-ico-container col-4">
            <img class="wallet-icon p-1" draggable="false" style="max-height: 100px" alt="Profile Picture" style="width: 60px;height: 60px;"
                onerror="this.onerror=null;this.src='img/demo/avatars/avatar-m.png';">
          </div>
          <div class="wallet-info-container col-8">
            <ul class="list-group list-group-flush my-0 text-left"></ul>
          </div>
        </div>
      </div>
      <div class="mini-wallet-card card border entry cursor-pointer" style="display:none;">
        <div>
          <img class="mini-wallet-icon icon" draggable="false" width="70" height="60">
          <div class="mini-wallet-name label"></div>
        </div>
      </div>
    </div>`);
    entryDom.find('.mini-wallet-card')
      .attr({ "data-toggle": "popover" })
      .popover({
        trigger: 'hover',
        delay: {
          show: 50,
          hide: 50
        },
        placement: 'auto',
        content: entryDom.find('.wallet-card').css('display', 'table-cell'),
        html: true,
        template: `<div class="popover" role="tooltip">
          <div class="arrow"></div>
          <h3 class="popover-header"></h3>
          <div class="popover-body p-0"></div>
        </div>`
      })
      .click(function () {
        me.wire.popupObjectView(me.wire.d(item));
        $(this).popover('hide');
      });
    var listGroupUl = entryDom.find(".list-group");
    var type = isAccount ? this.getLabelForItem(item) : item.application_type;
    if (type) {
      entryDom.find('.wallet-type').html(`${type}`);
    }
    var picture = item['picture'] || item['photo'];
    //this.getIconForItem(item);
    if (picture) {
      entryDom.find(".wallet-icon").attr("src", picture);
      entryDom.find(".mini-wallet-icon").attr("src", picture);
    }
    else {
      var gender = (isAccount ? item['gender'] : item['gender']) || 'male';
      var genderIcon = `img/demo/avatars/avatar-${gender == 'male' ? 'm' : 'f'}.png`;
      entryDom.find(".wallet-icon").attr('src', genderIcon);
      entryDom.find(".mini-wallet-icon").attr("src", genderIcon);
    }
    var name = isAccount ? item['name'] : this.getLabelForItem(item);
    if (name) {
      listGroupUl.append(
        $(`<li class="list-group-item py-2 px-2" style="word-break: break-all"><i class="fa fa-user text-primary" 
          style="font-size: 12px"></i><span class="font-weight-bold"> </span> ${name}</li>`)
      );
      entryDom.find('.mini-wallet-name')
        .text(name);
    }
    var nationalId = isAccount ? null : item['national_id_number'];
    listGroupUl.append(
        $(`<li class="list-group-item py-2 px-2" style="word-break: break-all"><i class="fa fa-id-card text-primary" 
          style="font-size: 12px"></i><span class="font-weight-bold"></span> ${nationalId || '-'}</li>`)
    );
    var emailAddress = item['email'];
    if (emailAddress) {
      listGroupUl.append(
        $(`<li class="list-group-item py-1 px-2" style="text-overflow: ellipsis;
        overflow: hidden; white-space: nowrap;"><i class="fa fa-envelope text-primary mr-1" 
          style="font-size: 12px"></i>${emailAddress}</li>`)
      );
    }
    var phoneNumber = item['cell'] || item['phone'];
    listGroupUl.append(
        $(`<li class="list-group-item py-1 px-2" style="word-break: break-all"><i class="fa fa-phone text-primary" 
          style="font-size: 12px"></i><span class="font-weight-bold"> </span> ${phoneNumber || '-'}</li>`)
    );

    return entryDom;
  };

  renderCalendarAppointmentTemplate(item) {
    var me = this;
    var entryDom = $(`<div class="mr-2 position-relative" style="display: inline-block">
      <div class="appointment-card card border text-center p-0">
        <div class="row no-gutters bg-primary text-light px-2 py-1" 
          style="border-radius: 4px 4px 0px 0px;">
          <span class="wallet-label"></span><i class="wallet-type ml-1"></i>
        </div>
      </div>
    </div>`);
    var listGroupUl = entryDom.find(".list-group");
    var type = this.getLabelForItem(item);
    if (type) {
      entryDom.find('.wallet-type').html(`${type}`);
    }
    return entryDom;
  };

  renderScopeBidCard(obj) {
    var properties = [
      { 'label': 'kpis', 'value': obj.kpis.length, 'icon': 'fa fa-cogs', 'isBadge': true },
      { 'label': 'Duration', 'value': `${obj.contract_start_date} - ${obj.contract_end_date}`, 'icon': 'fa fa-clock' }
      // { 'label': 'Start Day', 'value': obj.contract_start_date, 'icon': 'fa fa-clock' },
      // { 'label': 'End Day', 'value': obj.contract_end_date, 'icon': 'fa fa-clock' }
    ];
    // add 'service_scope' property to properties array
    var serviceScopeItems = [];
    (obj.service_scope || []).forEach(element => {
      serviceScopeItems.push([
        { 'label': 'Properties', 'value': element.items? element.items.length: 0, 'icon': 'fa fa-home' },
        { 'label': 'Services', 'value': (element.services && element.services.length) ? element.services.length: 0, 'icon': 'fa fa-wrench' }
      ]);
    });
    if (serviceScopeItems.length) {
      properties.push({ 'label': 'Service Scope', 'icon': 'fa fa-wrench', 'items': serviceScopeItems });
    }
    // render entry dom
    // var badge = `<span class="badge badge-icon position-relative ml-1" style="display: -webkit-inline-box; padding: 0px 5px !important;">{0}</span>`;
    const entryDom = $(`
    <div class="mr-2 mb-2" style="display: inline-block">
      <div class="wallet-card card border w-auto" style="display: table-cell;">
        <div class="bg-primary text-light px-2 py-1" style="border-radius: 4px 4px 0px 0px;">
          <i class="wallet-type ml-1">${obj.name}</i>
        </div>
        <ul class="list-group list-group-flush overflow-auto" 
          style="min-width: 270px; max-width: 270px; min-height: 110px; max-height: 110px;">
        </ul>
      </div>
    </div>`);
    // append properties to entry dom
    (properties || []).forEach(li => {
      var propertyDom = $(
        `<li class="list-group-item py-1 px-2" style="word-break: break-all">
          <i class="${li.icon} text-primary" style="font-size: 12px"></i>
          ${li.label}: ${li.value ?
          (li.isBadge ? `<span class="badge badge-icon position-relative ml-1" style="display: -webkit-inline-box; padding: 0px 5px !important;">${li.value}</span>` :
            li.value) : ''}
        </li>`)
        .appendTo(entryDom.find('ul.list-group'));
      if (li.items) {
        (li.items|| []).forEach(item => {
          propertyDom.append('<hr class="ml-3 my-0"/>');
          var singleServiceScope = $('<div class="d-flex">').appendTo(propertyDom);
          (item || []).forEach(itemProperty => {
            singleServiceScope.append(`
            <p class="ml-3 mb-0">
              <span class="${itemProperty.icon} text-primary mr-1" style="font-size: 13px"></span>${itemProperty.label}: ${`<span class="badge badge-icon position-relative ml-1" style="display: -webkit-inline-box; padding: 0px 5px !important;">${itemProperty.value}</span>`}
            </p>`);
          });
        });
      }
    });
    return entryDom;
  };

  renderTenantItemContractCard(obj, jq) {
    var itemContract = this.wire.d(obj.data.contract);
    this.makeEdgeCard(
      `Until ${itemContract.end_date || ""}`,
      this.wire.d(obj.ep[1]),
      this.wire.d(this.wire.d(obj.data.contract).offer_fields.target_w)).appendTo(jq);
  }

  renderItemContract(obj, jq) {
    var offer = this.wire.d(obj.offer)
    this.renderItemOffer(offer, jq);
  }

  /**
   * Renders Edge (seen from Landlord) between Tenant and Realestate Property.
   * @param {*} obj 
   * @param {*} jq 
   */
  renderItemContractEdge(obj, jq) {
    var contract = this.wire.d(obj.data.contract);
    var offer = this.wire.d(contract.offer);
    this.renderItemOffer(offer, jq);
  }


  renderSummaryOfferCall(obj, jq) {
    const entryDom = $(`
      <div>
        <div class=realEstateView></div>
        <div class='callSummary container-fluid mb-2'></div>
      </div>`).appendTo(jq);
    // Realestate.
    // Offercall summary
    var offerCall = this.wire.d(obj.ep[1]);
    // entryDom.find('.callSummary').html(
    //   'Offer Terms: ' + JSON.stringify(offerCall['smart_offer_terms']));
    var callSummary = $("<div>"); //entryDom.find('.callSummary');
    var row = $('<ul class="list-unstyled d-contents">').appendTo(callSummary);
    var drawTermIcon = function (termIcon, termTitle, termDesc) {
      var col = $('<li class="d-inline-flex mr-2 p-2">').appendTo(row);
      $(`<div class="${termIcon} text-primary mr-2" style="font-size: 20px;">`).appendTo(col);
      var termContainer = $('<div class="text-break text-secondary">').appendTo(col);
      $('<span class="text-break" style="color: black">').html(termTitle + ': ').appendTo(termContainer);
      $('<span class="text-break">').html(termDesc).appendTo(termContainer);
    };
    $.each(offerCall['smart_offer_terms'], function (termName, termValue) {
      if (termName == "Rent") {
        var rentValue = '';
        if (termValue.feesDetails && termValue.feesDetails.length) {
          rentValue = `${termValue.feesDetails[0].amount} ${termValue.feesDetails[0].currency} per ${termValue.feesDetails[0].frequency}</br>`;
        }
        else {
          rentValue = 'No specified rent';
        }
        drawTermIcon("fa fa-money", "Rent", rentValue);
      }
      if (termName == "Termination" && termValue.duration) {
        var terminationValue = '';
        if (termValue.duration.renewal) {
          terminationValue = termValue.duration.renewal.type ? termValue.duration.renewal.type + ' ' : '' + 'renewal';
        }
        else {
          terminationValue = termValue.duration.type + ' ' +
            termValue.duration.type.amount + ' ' + termValue.duration.frequency;
        }
        drawTermIcon("fa fa-sign-out", "Termination", terminationValue);
      }
      if (termName == "PetsNoPets") {
        var petsValue = '';
        if (termValue.PetsDetails && termValue.PetsDetails.length) {
          $.each(termValue.PetsDetails, function (pet, petDetails) {
            //var petTypes = ["Bird", "Cat", "Dog", "Fish", "Rabbit", "Turtle"];
            petsValue = petsValue + petDetails.type.trimAll() + '<br>';
          })
        }
        else {
          petsValue = 'No specified pets';
        }
        drawTermIcon("fa fa-paw", "Pets", petsValue);
      }
      if (termName == "Gym") {
        drawTermIcon("fa fa-trophy", "Gym", "Yes");
      }
      if (termName == "Swimming") {
        drawTermIcon("fa fa-tint", "Swimming", "Yes");
      }
      if (termName == "Sublease" && termValue.isAllowed) {
        drawTermIcon("fa fa-file-text-o", "Sublease", "Yes");
      }
      if (termName == "MasterTenant") {
        if (termValue.allowEquip) {
          drawTermIcon("fa fa-wrench", "Equipping", "Allowed");
        }
        if (termValue.allowOccupy) {
          drawTermIcon("fa fa-pencil", "Assigning Occupants", "Allowed");
        }
      }
      if (termName == "SmartKey") {
        drawTermIcon("fa fa-key", "Smart Key", "Yes");
      }
      if (termName == "ServiceContracts") {
        drawTermIcon("fa fa-files-o", "Service Contracts", "Yes");
      }
      if (termName == "NumberOfOccupants") {
        var numOfOccupants = 0;
        if (termValue[0]) {
          numOfOccupants = termValue[0];
        }
        drawTermIcon("fa fa-users", "No. of Occupants", numOfOccupants);
      }
    });
    this.renderRealStateUnit(
      { _id: this.wire.d(obj.ep[0]).ep[1], offerSmmary: callSummary },
      entryDom.find('.realEstateView'));
  }

  renderLedger(obj, jq) {
    var textualizeRecursive = function (ledger, numSpaces = 0) {
      var subText = ledger.name + ' (' + (ledger.account_code || '#account code') + '): ' + (ledger.budget || 0) + '\n';
      for (var i = 0; i < numSpaces; i += 1) {
        subText = ' ' + subText;
      }
      (ledger['SubLedgers'] || []).forEach(function (subLedger) {
        subText += textualizeRecursive(this.wire.d(subLedger), numSpaces + 2);
      }.bind(this));
      return subText;
    }.bind(this);
    var dom = $(`
    <div><pre id=info></pre></div>
    `).appendTo(jq);
    debugger;
    var text = textualizeRecursive(obj);
    dom.find('#info').html(text);
  }

  renderDetailedOfferCall(obj, jq) {
    this.renderSummaryOfferCall(obj, jq);
  }

  renderGenericEdge(obj, jq) {
    jq.append($('<h2>').html('Entities'));
    (obj.ep || []).forEach(function (ep) {
      ep = this.wire.d(ep);
      var epDom = this.createItemDom(ep);
      epDom.click(function () {
        this.wire.popupObjectView(ep);
      }.bind(this));
      jq.append(epDom);
    }.bind(this));

    if (obj.data) {
      for (var k in obj.data) {
        var v = this.wire.d(obj.data[k]);
        var div = $('<div>').appendTo(jq).append($('<h2>').html(k));
        this.renderObjectOnDom(v, div);
      }
    }
  }

  renderItemOffer(obj, jq) {
    var item = this.wire.d(obj.item);
    var entry = this.createItemDom(item);
    entry.click(function () {
      this.wire.popupObjectView(item);
    }.bind(this));
    jq.append($("<div class='my-2'><h3>Realestate Property:</h3></div>").append(entry));

    var owner = this.wire.d(obj.owner);
    var ownerWalletDom = this.createItemDom(owner);
    ownerWalletDom.click(function () {
      this.wire.popupObjectView(owner);
    }.bind(this));
    jq.append($("<div class='my-2'><h3>Tenant:</h3></div>").append(ownerWalletDom));

    //$("<div class='my-2'>").text(`Item: ${item.name || ""} ${item.type}`).appendTo(jq);
    jq.append($("<div class='my-2'><h3>Offer Terms:</h3></div>"));
    var terms = Offers.terms;
    $.each(obj['offer_details'], function (termName, termValue) {
      var term = terms[termName];
      var termTitle = term ? term.title : "";
      var iconClass = term ? term.iconClass : "";

      if (termName == "LeaseDate") {
        termTitle = "Lease Start Date";
        iconClass = "fa fa-calendar"
      }

      var termDom = $('<div>').appendTo(jq);
      var termIconAndName = `<a><i class="${iconClass}"></i><label class="font-weight-bold ml-2">${termTitle}</label>: </a>`;
      termDom.append(termIconAndName);

      if (termName == "LeaseDate") {

        var date = Date.parse(termValue);
        // TODO: use moment instead of this
        var rgx = /(\d{4})\/(\d{2})\/(\d{2})/;
        var dateArr = rgx.exec(termValue);

        var date = new Date(
          (+dateArr[1]),
          (+dateArr[2]) - 1,
          (+dateArr[3]));

        var formatedDate = date.toLocaleString("en-GB", { day: "numeric", month: "short", year: "numeric" });
        termDom.append($("<label>").text(formatedDate));
      }
      else if (termName == "Rent") {
        var content = `${termValue.amount} ${termValue.currency} ${termValue.frequency}`;
        termDom.append($("<label>").text(content));
      }
      else if (termName == "PetsNoPets") {
        if (termValue && termValue.length) {
          var termContainer = $('<div>').appendTo(termDom);
          termContainer.append($("<div>").text("Pets Details: "));
          var table = $(
            `<table class="table-bordered my-2 table table-sm m-0">
          <thead class="bg-primary-500">
            <tr>
              <th>Pet Type</th>
              <th>Pet Quantity</th>
            </tr>
            </thead>
            <tbody>
            </tbody>
          </table>`);
          termContainer.append(table);
          (termValue || []).forEach(pd => {
            table.find("tbody").append($("<tr>").append($("<td>").text(pd.type)).append($("<td>").text(pd.quantity)));
          });
        }
      } else {
        termDom.append($("<label>").text(" Term is agreed on."));
      }
    });
  }

  /**
   * 
   * @param {Object} obj object to be rendered with fields defined in
   *   `objSchema` or found on schemaManager using `objType`.
   * @param {JQuery} jq JQuery Selector where object will be rendered.
   * @param {Object?} options If given must be dictionary with possible keys:
   *   "type" (string) mutually-exclusive with key "schema". If given,
   *   must be schema name recognized by schemaManager or itemManager.
   *   "schema" (dict) containing key "fields".
   */
  renderFlatObject(obj, jq, options) {
    jq.empty();
    options = options || {};
    var objType = options.type;
    var objSchema = options.schema;
    if (objType && objSchema) {
      throw 'Must specify exactly one of `objType` and `objSchema`';
    }
    if (objSchema) {
      if (!("fields" in objSchema)) {
        throw 'objSchema must contain key "fields"';
      }
    } else {
      objSchema = this.wire.schemaManager.schema[objType || obj["type"]] ||
        this.wire.itemManager.schema[objType || obj["type"]];
    }

    var ungroupData = $(`
    <div class = 'panel mb-2 d-none' id="ungroupPanel">
    <div class = 'panel-content'>
    <div class="table table-striped table-responsive m-0 vertical-table" id="ungroupTable"></div>
    </div>
    </div>
    `).appendTo(jq);

    var groups = [];
    var dom = $(`
    <div class = 'panel mb-2'>
    <div class="panel-hdr cursor-pointer" data-action="panel-collapse">
      <h2 id="title">${options['display'] || ''}</h2>
      <div class="panel-toolbar dashboard-panel">
      <div class="group-header-collapse-icon mr-2 ml-2" data-action="panel-collapse" data-toggle="tooltip" data-offset="0,10" data-original-title="Collapse" style="font-size: 14px;">
        <i class="fa text-black fa-window-minimize" style="margin-left: -2px; margin-top: -3px;"></i>
      </div>
      </div>
      </div>
      <div class="panel-container collapse show" style="">
        <div class = 'panel-content'>
          <div class="row">
            <div class="col-auto cc_cursor read-control">
              <div class="nav flex-column nav-pills" id="v-pills-tab-control" role="tablist"
                aria-orientation="vertical">
              </div>
            </div>
          <div class="col cc_cursor read-content">
            <div class="tab-content" id="v-pills-tab-controlContent">
            </div>
          </div>
        </div>
      </div>
      </div>
      </div>`);

    var fieldsByGroup = {};
    if (objSchema) {
      (objSchema["fields"] || []).forEach(f => {
        if (f['group']) {
          fieldsByGroup[f['group']] = fieldsByGroup[f['group']] || [];
          fieldsByGroup[f['group']].push(f);
        }
      });
    }

    var whitelistedGroups = new Set();
    for (var group in fieldsByGroup) {
      var fields = fieldsByGroup[group];

      var setFields = fields.filter(f => f['n'] in obj);
      if (setFields.length > 0) {
        whitelistedGroups.add(group);
      }
    }

    if (objSchema) {
      (objSchema["fields"] || []).forEach(function (field) {
        var fieldAndClass = getFieldAndClass(field);
        var fieldClass = fieldAndClass[1];
        var field = fieldAndClass[0];
        if (field['group']) {
          if (!whitelistedGroups.has(field['group'])) {
            return;
          }
          dom.appendTo(jq);
          var groupName = (field['group']).split(' ').join('_');
          if (!groups.includes((field['group']).split(' ').join('_'))) {
            groups.push(groupName);
            var group = $('<div></div>')
              .addClass('nav-link')
              .attr({ id: ('tab' + groupName), 'data-toggle': "pill", href: ("#" + groupName), role: "tab" });
            var span = $(`<span class=" ml-1"></span>`).html(field['group']);
            group.append(span).appendTo(jq.find('.read-control').find(jq.find('#v-pills-tab-control')));
            var contentDom = $('<div class="tab-pane fade" role="tabpanel"></div>').attr({ id: groupName });
            contentDom.appendTo(jq.find('.read-content').find(jq.find('#v-pills-tab-controlContent')));
            var tableMain = $('<table class="table table-striped m-0">').attr({ id: 'table' + groupName }).appendTo(contentDom);
            var rowMain = $(
              "<tr><td class='label p-2'></td><td class='value p-2'></td><td><td></tr>"
            ).appendTo(tableMain);
            rowMain.find(".label").html((field["d"] || field["n"]) + ' : ');
            fieldClass.renderReadOnlyValue(
              rowMain.find(jq.find(".value")),
              obj[field["n"]],
              field,
              obj
            );
          } else {
            var rowSub = $(
              "<tr><td class='label p-2'></td><td class='value p-2'></td><td><td></tr>"
            ).appendTo(jq.find('#table' + groupName));
            rowSub.find(".label").html((field["d"] || field["n"]) + ' : ');
            fieldClass.renderReadOnlyValue(
              rowSub.find(jq.find(".value")),
              obj[field["n"]],
              field,
              obj
            );
          }
          if (groups) {
            jq.find('#tab' + groups[0].split(' ').join('_')).addClass('active');
            jq.find('#' + groups[0].split(' ').join('_')).addClass('active show');
          }
        } else {
          // Add header row
          if ((!jq.find('#ungroupTableHeader') || !jq.find('#ungroupTableHeader').length) &&
            options['display']) {
            $(`<div id="ungroupTableHeader" class='row col-xl-12 p-1 m-2 fs-md'>
                ${options['display'] || ''}</div>`).appendTo(jq.find('#ungroupTable'));
          }

          jq.find('#ungroupPanel').removeClass('d-none');
          var row = $(
            `<div class='row col-xl-12 p-0 m-0'>
            <div class='label col-xs-2 p-2' style='border: 1px solid #f1f1f1'></div>
            <div class='value col-xs-10 p-2' style='border: 1px solid #f1f1f1'></div>
          </div>`
          ).appendTo(jq.find('#ungroupTable'));
          row.find(".label").html(field["d"] || field["n"]);
          //if (field['n'] in obj) {
          fieldClass.renderReadOnlyValue(
            row.find(".value"),
            obj[field["n"]],
            field,
            obj
          );
          //}
        }
      });
    }
  }

  renderRealStateUnit(obj, jq, options) {
    var fullItem = this.wire.assembleData(obj._id);
    var item = fullItem;
    if (options && options.showTree) {
      var button = $(`
      <button ng-if="hasTreeView" id='showTree' type="button" class="btn btn-outline-primary waves-effect 
        waves-themed ml-2" style="margin-bottom: 1rem;">
        <span class="fal fa-tree mr-1"></span>Show Tree
      </button> 
      `).appendTo(jq);
      button.click(function () {
        this.wire.modal("Realestate Tree View", u('AJS', ['item_viewer', { item: fullItem }]), null, { sizeMode: "full" });
      }.bind(this));
    }

    // TODO: View that Leena made.

    while (item.parent) {
      item.parent = this.wire.d(item.parent);
      item = item.parent;
    }

    var schema = this.wire.itemManager.schema[item.type];

    var container = $("<div>").appendTo(jq);
    container.RealStateViewer({
      item: fullItem,
      itemSchema: schema,
      offerSummary: obj.offerSmmary
    });
    // container.PubliclyAdvertisedViewer({
    //   item: fullItem,
    //   itemSchema: schema,
    //   offerSummary: obj.offerSmmary
    // });
  }

  renderTransportationRoute(obj, jq) {
    var tRouteObj = this.wire.assembleData(obj);
    var trips = tRouteObj.Trips;
    var stops = tRouteObj.Stops;
    var grid = $(`
        <!-- Grid column -->
        <div class="col-md-12">
            <h4 class="py-3 text-center font-bold font-up blue-text">Transportation Route: ${tRouteObj.name || ""}</h4>
        </div>
        <!-- Grid column -->`).appendTo(jq);

    var tableResponsive = $('<div class="table-responsive-lg">').appendTo(grid);
    var table = $('<table class="table table-bordered m-0">').appendTo(tableResponsive);
    var tHead = $('<thead>').appendTo(table);
    var tr = $('<tr>').appendTo(tHead);
    $('<td class="trnas-table-border trans-route-col-sm"></td>').appendTo(tr);
    // rendering trips as cols
    $.each(trips, function (key, trip) {
      $(`<th class="text-center trnas-table-border trans-table-yellow" data-original-title="${trip.description || ""}" data-toggle="tooltip" 
                data-placement="top">${trip.name || ""}</th>`).appendTo(tr).tooltip();
    });
    var tBody = $('<tbody>').appendTo(table);
    // rendering stops as rows
    $.each(stops, function (key, stop) {
      var tr = $('<tr>').appendTo(tBody);
      $(`<th class="trnas-table-border trans-table-pink" data-original-title="${stop.location ? stop.location.address : stop.description || ""}" data-toggle="tooltip" data-placement="right">${stop.name || ""}</th>`)
        .appendTo(tr).tooltip();

      // rendering trips' stops
      $.each(trips, function (key, trip) {
        var fullStops = '';
        $.each(trip.Stops, function (key, stop) {
          fullStops = `${fullStops} Stop${key + 1}: (${stop.time || ""})<br/>`;
        });
        $(`<th class="text-center trnas-table-border trans-table-lightPink">${fullStops}</th>`).appendTo(tr);
      });
    });
    // rendering pagination
    var pagination = $(`
        <!--Bottom Table UI-->
        <div class="d-flex justify-content-center">
          <!--Pagination -->
          <nav class="my-4 pt-2">
              <ul class="pagination pagination-circle pg-blue mb-0">
                  <!--First-->
                  <li class="page-item disabled clearfix d-none d-md-block"><a class="page-link">First</a></li>
                  <!--Arrow left-->
                  <li class="page-item disabled">
                      <a class="page-link" aria-label="Previous">
                          <span aria-hidden="true">&laquo;</span>
                          <span class="sr-only">Previous</span>
                      </a>
                  </li>
                  <!--Numbers-->
                  <li class="page-item active"><a class="page-link">1</a></li>
                  <!--Arrow right-->
                  <li class="page-item disabled">
                      <a class="page-link" aria-label="Next">
                          <span aria-hidden="true">&raquo;</span>
                          <span class="sr-only">Next</span>
                      </a>
                  </li>
                  <!--First-->
                  <li class="page-item disabled clearfix d-none d-md-block"><a class="page-link">Last</a></li>
              </ul>
          </nav>
        <!--/Pagination -->`).appendTo(grid);
  }

  /**
   * 
   * @param {String} edgeTitle title to display on top of edge.
   * @param {Object} leftObj data object to display on the left.
   * @param {Object} rightObj data object to display on the right
   */
  makeEdgeCard(edgeTitle, leftObj, rightObj) {
    var edgeCard = $(`<div class="card border edge-entry">
        <label class="edge-entry-label"></label>
        <div id='epDiv'></div>   
        <div data-toggle="tooltip" data-placement="bottom" title="">
          <div class="border-top line-sperator">
          </div>    
        </div>
      </div>`);
    var leftDom = this.createItemDom(leftObj);
    leftDom.removeClass('border').removeClass('card').removeClass('entry').addClass('edge-ep-entry').addClass('ep1');
    var rightDom = this.createItemDom(rightObj);
    rightDom.removeClass('border').removeClass('card').removeClass('entry').addClass('edge-ep-entry').addClass('ep2');
    edgeCard.find('#epDiv').append(leftDom).append(rightDom);
    edgeCard.find("label.edge-entry-label").text(edgeTitle);
    return edgeCard;
  }


  renderCateringMenu(obj, jq) {
    jq.empty();
    var cateringMenu = this.wire.assembleData(obj._id);
    var cateringMenuTitle = cateringMenu.name || "";

    var cateringContainer = $(`<div class="card"></div>`);
    jq.append(cateringContainer);

    var cateringSubContainer = $(`<div class="catering-wrapper"></div>`);
    cateringContainer.append(cateringSubContainer);

    // 1. Render Menu Name
    var cateringTitleContainer = $('<h2 class="catering-menu-title"></h2>').html(cateringMenuTitle);
    cateringSubContainer.append(cateringTitleContainer);

    var subMenusTabs = $(`<ul class="nav nav-pills" role="tablist"></ul>`);
    cateringSubContainer.append(subMenusTabs);

    var subMenusTabsContent = $(`<div class="tab-content py-3"></div>`);
    cateringSubContainer.append(subMenusTabsContent);

    // 2. Render Sub Menus
    var cateringMenuSubmenus = cateringMenu.Submenus || [];
    for (var i = 0; i < cateringMenuSubmenus.length; i++) {
      var subMenu = cateringMenuSubmenus[i];
      var subMenuTitle = subMenu.name || "";
      var subMenuDescription = subMenu.description || "";
      var subMenuItems = subMenu.Items || [];

      var randomId = Guid.generate();
      var subMenulId = "catering" + randomId;
      var subMenuTab = $(`<li class="nav-item">
        <a class="nav-link catering-menu-nav-link" data-toggle="tab" href="#${subMenulId}">
      <i class="fa fa-cutlery mr-2" aria-hidden="true"></i>${subMenuTitle}</a></li>`);
      subMenusTabs.append(subMenuTab);

      var subMenuTabContent = $(`<div class="tab-pane fade" role="tabpanel"></div>`).attr("id", subMenulId);
      subMenusTabsContent.append(subMenuTabContent);

      // Activate first tab which represent fisrt submenu
      if (i == 0) {
        subMenuTab.find('a.catering-menu-nav-link').addClass("active");
        subMenuTabContent.addClass("show active");
      }

      (subMenuItems || []).forEach(subMenuItem => {
        var subMenuItemTitle = subMenuItem.name || "";
        var subMenuItemIngredients = subMenuItem.ingredients || "";
        var subMenuItemNutritionFacts = subMenuItem.NutritionFacts || [];
        var subMenuItemPhotos = subMenuItem.Photos || [];
        subMenuItemPhotos = subMenuItemPhotos.filter(photo => photo.picture);

        if (subMenuItemTitle || subMenuItemIngredients || subMenuItemPhotos.length > 0 || subMenuItemNutritionFacts.length > 0) {
          var galleryRandomId = Guid.generate();
          var subMenuItemGalleryId = "catering-gallery" + galleryRandomId;
          var subMenuItemContent = $(`<div class="catering-submenu-item row ml-2">
                                      <div class="catering-img-thumb col-xl-3 col-lg-3 col-md-12 col-12 mb-2">
                                        <div class="catering-item-gallery" id="${subMenuItemGalleryId}"></div>
                                      </div>
                                      <div class="col-xl-9 col-lg-9 col-md-12 col-12">
                                        <div class="catering-submenu-item-header">
                                          <h3 class="catering-submenu-item-title">${subMenuItemTitle}</h3>
                                          <span class="catering-submenu-item-dots"></span>
                                          <span class="catering-submenu-item-price"></span>
                                        </div>
                                        <p class="catering-submenu-item-description">${subMenuItemIngredients}</p>
                                        <div class="catering-submenu-item-nutrition-facts"></div>
                                      </div>
                                    </div>`);
          subMenuTabContent.append(subMenuItemContent);

          // Render Submenu Item's Photos
          if (subMenuItemPhotos.length > 0) {
            var itemGallery = subMenuItemContent.find("#" + subMenuItemGalleryId);
            (subMenuItemPhotos || []).forEach(function (photo, index) {
              var itemImageLink = $(`
                <a class="jg-entry entry-visible" href="${photo.picture}" data-sub-html="<h2>${photo.name || ""}</h2><p>${photo.description || ""}</p>">
                  <img class="catering-item-image img-responsive" src="${photo.picture}">
                </a>`);
              itemGallery.append(itemImageLink);

              // to dispaly just first image in menu, and the others will be viewed in light gallary box
              if (index != 0) {
                itemImageLink.addClass("d-none");
              }
            });

            itemGallery.lightGallery({
              thumbnail: true,
            });
          }

          // Render Submenu Item's Nutrition Facts
          var nutritionFactsContainer = subMenuItemContent.find(".catering-submenu-item-nutrition-facts");
          var areThereFeatures = false;
          (subMenuItemNutritionFacts || []).forEach(nutritionFact => {
            var servingSize = nutritionFact.serving_size || "";

            var nutritionFactTag = $(`<div class="alert alert-secondary alert-dismissible fade show mb-1 pb-1" role="alert"></div>`);

            if (servingSize) {
              var servingSizeTag = $(`<span class="badge badge-danger fw-600 l-h-n mb-1"></span>`).html("Serving Size: " + servingSize);
              nutritionFactTag.append(servingSizeTag);
            }

            var itemFields = this.wire.itemManager.schema[nutritionFact.type].fields || [];
            itemFields = itemFields.filter(field => field.name != "serving_size");
            (itemFields || []).forEach(field => {
              var features = [];
              var objFeaturesTitle = field.name;

              var objFeatures = field.typeargs[0] || []; // [0] because its array of array
              if (Array.isArray(objFeatures)) {
                (objFeatures || []).forEach(feature => {
                  var featureName = feature.n || objFeaturesTitle;
                  if (nutritionFact[featureName]) {
                    features.push({ 'text': feature.d || objFeaturesTitle, 'value': nutritionFact[featureName] })
                  }
                });
              } else {
                var featureName = objFeatures.n || objFeaturesTitle;
                if (nutritionFact[featureName]) {
                  features.push({ 'text': objFeatures.d || objFeaturesTitle, 'value': nutritionFact[featureName] })
                }
              }

              if (features.length > 0) {
                areThereFeatures = true;

                var featuresTitleContainer = $("<h5>").addClass("color-primary-700").text(objFeaturesTitle);
                nutritionFactTag.append(featuresTitleContainer);

                var featuresList = $("<ul>").addClass("m-0 p-0");
                nutritionFactTag.append(featuresList);

                (features || []).forEach(function (feature) {
                  var listPoint = $(`
                  <li class="color-primary-900 custom-control-inline"><span class="fw-700 color-primary-900 mr-1">${feature.text + ": "}</span>
                    <label class="color-primary-700">${feature.value}</label>
                  </li>`);
                  featuresList.append(listPoint);
                });

                features = [];
              }
            });

            if (areThereFeatures) {
              nutritionFactsContainer.append(nutritionFactTag);
            }
          });
          if (areThereFeatures) {
            var nutritionFactsTitle = $(`<h4 class="color-primary-900">Nutrition Facts:</h4>`);
            nutritionFactsContainer.prepend(nutritionFactsTitle);
          }
        }
      });
    }

    // 3. Render Menu Photos
    var cateringMenuPhotos = cateringMenu.Photos || [];
    cateringMenuPhotos = cateringMenuPhotos.filter(photo => photo.picture) || [];
    if (cateringMenuPhotos.length > 0) {
      var photosTabId = "cateringPhotosTab";
      var photosTab = $(`<li class="nav-item">
            <a class="nav-link catering-menu-nav-link" data-toggle="tab" href="#${photosTabId}">
          <i class="fa fa-cutlery mr-2" aria-hidden="true"></i>Photos</a></li>`);
      subMenusTabs.append(photosTab);

      var photosTabContent = $(`<div class="tab-pane fade" role="tabpanel"></div>`).attr("id", photosTabId);
      subMenusTabsContent.append(photosTabContent);

      var menuGallery = $("<div>").addClass('justified-gallery');
      photosTabContent.append(menuGallery);

      (cateringMenuPhotos || []).forEach(function (photo, index) {
        var menuImageLink = $(`
          <a class="jg-entry entry-visible" href="${photo.picture}" data-sub-html="${photo.description || ""}">
            <img class="catering-item-image img-responsive" src="${photo.picture}">
            <div class="caption">${photo.name || ""}</div>
          </a>`);
        menuGallery.append(menuImageLink);
      });

      menuGallery.justifiedGallery(
        {
          border: -1,
          rowHeight: 150,
          margins: 8,
          waitThumbnailsLoad: true,
          randomize: false,
        }).on('jg.complete', function () {
          menuGallery.lightGallery(
            {
              thumbnail: true,
              animateThumb: true,
              showThumbByDefault: true,
            });
        });
    };
  }

  renderScopeBid(obj, jq, options) {
    var table = $(`
      <table class="table table-bordered table-hover m-0" style="max-width: 490px;">
        <thead class="thead-themed">
          <tr>
            <th>Service</th>
            <th>Cost</th>
          </tr>
        </thead>
        <tbody></tbody>
    `).appendTo(jq);
    for (var key in obj.bid_values) {
      var tr = $('<tr>').appendTo(table.find('tbody'));
      $('<td>').text(key).appendTo(tr);
      $('<td>').text(obj.bid_values[key]).appendTo(tr);
    }
  }
}

/**
 * @param {String} title string like "Lease Contract"
 * @param {Object[]} data array of object like 
 * [
 *  {'label': 'Tenant', 'value': 'Admin', 'icon': 'fa fa-user', 'is_badge': true },
 *  {'label': 'Property', 'value': 'Burj Khalifa Downtown view', 'icon': 'fa fa-building', 'tooltip': true},
 *  {'label': 'History', 'icon': 'fa fa-history', 'items': [
 *    { 'label': 'By', 'value': 'admin@admin.com', icon: 'fa fa-pen' },
 *    { 'value': '10' },
 *  ]}
 * ]
 * @param {Object} options object like
 * options {
 *  theme: 'colorful'/'classic'(default)
 *  min_height: minimum height value, 120(default)
 *  max_height: maximum height value, 148(default)
 *  min_width: minimum width value, 244(default)
 *  max_width: maximum width value, 272(default)
 * }
 * @returns {Object} jQuery object
 */
function _drawCard(title, data, options) {
  const opt = options || [];
  var entryDom;
  switch (opt['theme']) {
    case 'colorful':
      entryDom = _ApplyColorfulTheme(title, data, opt);
      break;
    case 'classic':
    default:
      entryDom = _ApplyDefaultTheme(title, data, opt);
      break;
  }
  return entryDom;
};

function _ApplyDefaultTheme(title, data, options) {
  // BUG NO SHOW OF WORK ORDER CARD
  // NOTE: second div had class:
  //   card
  // after wallet-card
  const entryDom = $(`
    <div class="mr-2 mb-2" style="display: inline-block;">
      <div class="wallet-card border w-auto" style="display: table-cell;">
        <div class="bg-primary text-light px-2 py-1" style="border-radius: 4px 4px 0px 0px;">
          <span><i class="fa fa-file-text text-light mr-1"></i>${title}</span>
        </div>
        <ul class="list-group list-group-flush overflow-auto" 
          style="min-height: ${options['min_height'] ? `${options['min_height']}px` : '120px'}; 
          max-height: ${options['max_height'] ? `${options['max_height']}px` : '148px'}; 
          min-width: ${options['min_width'] ? `${options['min_width']}px` : '244px'}; 
          max-width: ${options['max_width'] ? `${options['max_width']}px` : '272px'}">
        </ul>
      </div>
    </div>`);
  // fill entry dom with data
  data.forEach(property => {
    if (property['label'] && !property['badges']) {
      var propertyDom = $(
        `<li class="list-group-item text-left py-1 px-2" style="word-break: break-all; ${property['items'] ? '' : 'display: flex;'}">
          <i class="${property['icon']} text-primary mr-1 mt-1" style="font-size: 12px"></i>${property['value'] ?
          (property['is_badge'] ? `${property['label']}: <span class="badge badge-icon bg-info position-relative ml-1 py-0 px-1" style="height: 17px; display: -webkit-inline-box !important; 
          max-width: inherit !important;">${property['value']}</span>` : `<span class="d-block text-truncate">${property['label']}: ${property['value']}</span>`) : `${property['label']}:`}</li>`)
        .appendTo(entryDom.find('ul.list-group'));
      if (property['tooltip']) {
        propertyDom.find('.text-truncate').tooltip({ 'title': property['value'] });
      }
      if (property['items']) {
        property['items'].forEach(item => {
          propertyDom.append('<hr class="ml-3 mt-0 mb-1"/>');
          var flexDom = $('<div class="d-flex">').appendTo(propertyDom);
          item.forEach(itemProperty => {
            if (!itemProperty['icon'] && !itemProperty['icon']) {
              flexDom.append(`
              <p class="ml-3 mb-0">
                ${`<span class="badge badge-icon position-relative ml-1 d-block py-0 px-1" 
                style="max-width: inherit !important;">${itemProperty['value']}</span>`}
              </p>`);
            }
            else {
              flexDom.append(`
              <p class="ml-3 mb-0">
                <span class="${itemProperty['icon']} text-primary mr-1" style="font-size: 13px"></span>
                ${itemProperty['label']}: ${`<span class="badge badge-icon position-relative ml-1 d-block py-0 px-1" 
                style="max-width: inherit !important;">${itemProperty['value']}</span>`}
              </p>`);
            }
          });
        });
      }
    }
    else if (property['badges']) {
      var propertyDom = $(`
        <li class="list-group-item text-left py-1 px-2" style="word-break: break-all;">
          <i class="${property['icon']} text-primary mr-1 mt-1" style="font-size: 12px"></i>${property['label']}:
        </li>`)
        .appendTo(entryDom.find('ul.list-group'));
      property['badges'].forEach(badge => {
        propertyDom.append(`
        <span class="badge badge-icon ${badge['checked'] ? 'bg-success' : ''}
          position-relative ml-1 py-0 px-1" style="${badge['checked'] ? '' : 'background-color: #dedede; color: #525252;'} height: 17px; border-radius: 7px; display: -webkit-inline-box !important;
          max-width: inherit !important;"><i class="fa ${badge['checked'] ? 'fa-check' : 'fa-times'}"></i> ${badge['value']}
        </span>`);
      });
    }
  });
  return entryDom;
};

function _ApplyColorfulTheme(title, data, options) {
  const entryDom = $(`
    <div class="mr-2 mb-2" style="display: inline-block;">
      <div class="wallet-card card border w-auto" style="display: table-cell; border-radius: 0px 150px 0px 0px;">
        <span class="position-absolute text-light"
          style="font-size: 25px; z-index: 1; left: 50px; top: 62px;">${title}</span>
        <div class="bg-default text-light px-2 py-1" style="border-radius: 4px 4px 140px 0px;;
          background: url(../img/about-keyras/cover3.jpg);
          min-height: 145px; background-size: cover; opacity: 0.8;">
        </div>
        <ul class="list-group list-group-flush overflow-auto" 
          style="min-height: ${options['min_height'] ? `${options['min_height']}px` : '120px'}; 
          max-height: ${options['max_height'] ? `${options['max_height']}px` : '148px'}; 
          min-width: ${options['min_width'] ? `${options['min_width']}px` : '244px'}; 
          max-width: ${options['max_width'] ? `${options['max_width']}px` : '272px'}">
        </ul>
      </div>
    </div>`);
  // fill entry dom with data
  data.forEach(property => {
    if (property['label'] && !property['badges']) {
      var propertyDom = $(
        `<li class="row no-gutters list-group-item text-left py-1 px-2" style="justify-content: space-around; font-size: 15px; word-break: break-word; display: flex;">
        <span class="col-4 d-block">${property['label']}</span>  
        <i class="col-2 ${property['icon']} text-primary mr-1 mt-1"></i>${(property['is_badge'] ? `<span class="col-5 badge badge-icon bg-info position-relative ml-1 py-0 px-1" style="height: 17px; 
          max-width: inherit !important;">${property['value']}</span>` : `<span class="col-5 d-block text-truncate">${property['value']}</span>`)}</li>`)
        .appendTo(entryDom.find('ul.list-group'));
      if (property['tooltip']) {
        propertyDom.find('.text-truncate').tooltip({ 'title': property['value'] });
      }
      if (property['items']) {
        property['items'].forEach(item => {
          propertyDom.append('<hr class="ml-3 mt-0 mb-1"/>');
          var flexDom = $('<div class="d-flex w-75">').appendTo(propertyDom);
          item.forEach(itemProperty => {
            if (!itemProperty['icon'] && !itemProperty['icon']) {
              flexDom.append(`
              <p class="ml-3 mb-0">
                ${`<span class="badge badge-icon position-relative ml-1 d-block py-0 px-1" 
                style="max-width: inherit !important;">${itemProperty['value']}</span>`}
              </p>`);
            }
            else {
              flexDom.append(`
              <p class="ml-3 mb-0">
                <span class="${itemProperty['icon']} text-primary mr-1" style="font-size: 13px"></span>
                ${itemProperty['label']}: ${`<span class="badge badge-icon position-relative ml-1 d-block py-0 px-1" 
                style="max-width: inherit !important;">${itemProperty['value']}</span>`}
              </p>`);
            }
          });
        });
      }
    }
    else if (property['badges']) {
      var propertyDom = $(`
        <li class="list-group-item text-left py-1 px-2" style="word-break: break-all;">
          <i class="${property['icon']} text-primary mr-1 mt-1" style="font-size: 12px"></i>${property['label']}:
        </li>`)
        .appendTo(entryDom.find('ul.list-group'));
      property['badges'].forEach(badge => {
        propertyDom.append(`
        <span class="badge badge-icon ${badge['checked'] ? 'bg-success' : ''}
          position-relative ml-1 py-0 px-1" style="${badge['checked'] ? '' : 'background-color: #dedede; color: #525252;'} height: 17px; border-radius: 7px; display: -webkit-inline-box !important;
          max-width: inherit !important;"><i class="fa ${badge['checked'] ? 'fa-check' : 'fa-times'}"></i> ${badge['value']}
        </span>`);
      });
    }
  });
  return entryDom;
}

class Carder {
  static card(obj) {
    console.log('CAN I CARD? ', obj.type);
    var carderFn = Carder.BY_TYPE[obj.type];
    if (!carderFn) {
      return null;
    }
    return carderFn(obj);
  }


  static cardOffer(obj) {
    var display = {
      "tenant": obj['behalf'],
      "movein_date": dateIntToStr(obj['movein_date'], true),
      "security_deposit": (obj["security_deposit"] != undefined) ? obj["security_deposit"]["value"] + ' ' + obj["security_deposit"]["currency"].toUpperCase() : "",
      "num_payments": obj["rent_schedule"] ? obj["rent_schedule"].length : 0,
      "total_payments": {
        "value": obj['rent_schedule'] ? obj['rent_schedule'].map(e => e['value']).reduce((s, a) => s + a, 0) : null,
        'currency': obj['rent_schedule'] ? (obj['rent_schedule'][0] || {})['currency'] || '' : null
      },
      "target": WIRE.d(obj['target'])['email']
    }
    window.handleClick = function (e, element) {
      if (e.target.className == "fa fa-history" ||
        e.target.className == "btn btn-sm btn-primary rounded-circle btn-icon waves-effect waves-themed") {
        e.stopPropagation();
        e.preventDefault();
        $(element).parents(".view-container").click(function () {
          $(element).parents(".view-container").find(".dropdown-menu").hide();
        });
        $(element).parents(".view-container").find(".dropdown-menu").not($(element).find(".dropdown-menu")).hide();
        $(element).find(".dropdown-menu").slideToggle("fast");
      }
    }

    var sTrailItems = [];
    if (obj['s_trail'] && obj['s_trail'].length) {
      var loggedInUserObj = WIRE.d(WIRE.data['account']);
      var loggedInUser = loggedInUserObj ? loggedInUserObj['email'] : '';
      obj['s_trail'].forEach(element => {
        var byObj = WIRE.d(element.by);
        if (byObj && byObj['email']) {
          var emailValue = loggedInUser.toLowerCase() == byObj['email'].toLowerCase() ?
            'You' : byObj['email'];
          sTrailItems.push(
            { 'at': dateIntToStr(element['at'], true), 'by': emailValue });
        }
      });
    }
    var propertyName = WIRE.d(obj['item']) ? WIRE.d(obj['item'])['name'] : "";
    var cardDom = $(`<div class="toast fade show tenancy-card mr-2 shadow-hover-5 ">
        <div class="toast-header" style="padding: 3px 5px 5px 10px;">
          <strong class="mr-auto" style="font-size: 12px;font-weight: 800;color: #886ab5;">Tenancy Offer</strong>
          <small>${display["movein_date"]}</small>
          <span class="${sTrailItems.length == 0 ? "d-none" : "d-block"}">
          <div class="btn-group ml-1 tenancy-history" onClick="window.handleClick(event, this)">
              <button type="button" id="tenancy-history" 
                class="btn btn-sm btn-primary rounded-circle btn-icon waves-effect waves-themed" 
                data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
              <i class="fa fa-history"></i>
              </button>
              <div class="dropdown-menu history-menu">
                <span class="ml-2 mb-2 text-primary">History : </span>
              </div>
          </div>
          </span>
        </div>
        <div class="toast-body" style="font-size: 12px;max-height: 116px;">
          <ul class="list-group list-group-flush overflow-auto">
              <li class="list-group-item text-left py-1 px-2 ${propertyName == "" || propertyName == undefined ? "d-none" : "d-flex flex-row"}" style="word-break: break-all;">
              <i class="fa fa-building text-primary mr-1 mt-1" style="font-size: 12px"></i>
              <span class="d-block text-truncate"  title="${propertyName}" style="max-width: 152px;">
              ${propertyName}
              </span>
              </li>
              <li class="list-group-item text-left py-1 px-2 ${display["security_deposit"] == "" || display["security_deposit"] == undefined ? "d-none" : "d-flex flex-row"}"  style="word-break: break-all;">
              <i class="kr-financial text-primary mr-1 mt-1" style="font-size: 12px"></i>
              <span>     
              Security deposit: ${display["security_deposit"]}
              </span>
              </li>
              <li class="list-group-item text-left py-1 px-2  style="word-break: break-all;">
                <i class="fa fa-money text-primary mr-1 mt-1" style="font-size: 12px"></i>
                <span>
                Number of payments:  ${display["num_payments"]}
                </span>
              </li>
              <li class="list-group-item text-left py-1 px-2" style="word-break: break-all; ">
                <i class="fa fa-calculator text-primary mr-1 mt-1" style="font-size: 12px"></i>
                Total Payments:
                <span class="badge badge-danger">${display["total_payments"]["value"] + '' + display["total_payments"]["currency"]}</span>
              </li>
          </ul>
        </div>
    </div>
      `);
    if (sTrailItems) {
      sTrailItems.forEach(element => {
        var historySlot = $(`<div class="history-dropdown ml-2 mt-1">
      <i class="fa fa-history mx-1 text-primary"></i>
      <div class="mr-2" style="display: grid ">
         <span class="f-sm wishlist-text">AT</span>
         <span class="f-sm wishlist-text text-danger">${element['at']}</span>
      </div>
      <div style="display: grid">
         <span class="f-sm wishlist-text">BY</span>
         <span title="${element['by']}" class="f-sm text-truncate wishlist-text text-danger">
         ${element['by']}</span>
      </div>
     </div>`);
        historySlot.appendTo(cardDom.find(".history-menu"));
      });
    }

    return cardDom;
  }

  static cardItemContract(obj) {
    var display = [];
    var tenantObj = WIRE.d(obj['tenant']);
    if (tenantObj) {
      var tenantValue = tenantObj['name'] || tenantObj['email'] || tenantObj['account_type'];
      display.push({ 'label': 'Tenant', 'value': tenantValue, 'icon': 'fa fa-user' });
    }
    var propertyObj = WIRE.d(obj['item']);
    if (propertyObj && propertyObj['name']) {
      display.push({ 'label': 'Property', 'value': propertyObj['name'], 'icon': 'fa fa-building', 'tooltip': true });
    }
    var startDay = dateIntToStr(obj['start_day'], true);
    var endDay = dateIntToStr(obj['end_day'], true);
    display.push({ 'label': 'Start Day', 'value': startDay, 'icon': 'fa fa-clock' });
    display.push({ 'label': 'End Day', 'value': endDay, 'icon': 'fa fa-clock' });
    // calculate the duration (in months) between start & end days
    const differenceInTime = new Date(endDay).getTime() - new Date(startDay).getTime();
    const duration = Math.round(differenceInTime / (1000 * 3600 * 24) / 30)
    display.push({ 'label': 'Duration', 'value': `${duration} months`, 'icon': 'fa fa-clock', 'is_badge': true });

    // add 's_trail' info to 'display' array
    if (obj['s_trail'] && obj['s_trail'].length) {
      var sTrailItems = [];
      var loggedInUserObj = WIRE.d(WIRE.data['account']);
      var loggedInUser = loggedInUserObj ? loggedInUserObj['email'] : '';
      obj['s_trail'].forEach(element => {
        var byObj = WIRE.d(element.by);
        if (byObj && byObj['email']) {
          var emailValue = loggedInUser.toLowerCase() == byObj['email'].toLowerCase() ?
            'You' : byObj['name'] || byObj['email'];
          sTrailItems.push([
            { 'label': 'At', 'value': dateIntToStr(element['at'], true), 'icon': 'fa fa-clock' },
            { 'label': 'By', 'value': emailValue, 'icon': 'fa fa-user' }
          ]);
        }
      });
      display.push({ 'label': 'History', 'icon': 'fa fa-history', 'items': sTrailItems });
    }

    return _drawCard('Lease Contract', display, { 'min_height': 220, 'max_height': 220 });
  }

  static cardWorkOrder(obj) {
    var display = [
      { 'label': 'Assigned at', 'value': dateIntToStr(obj['assigned_at'], true), 'icon': 'fa fa-clock' },
    ];
    // add 'e_trail' info to 'display' array
    if (obj['e_trail'] && obj['e_trail'].length) {
      var eTrailItems = [];
      obj['e_trail'].forEach(element => {
        eTrailItems.push([
          { 'value': dateIntToStr(element['at'], true) },
          { 'value': element['by_text'] },
        ]);
      });
      display.push({ 'label': 'History', 'icon': 'fa fa-history', 'items': eTrailItems });
    }
    // add 'categories' info to 'display' array
    var catogriesList = obj['report'] ? obj['report']['filled_moveinlist'] : null;
    if (catogriesList && catogriesList['categories']) {
      var categories = [];
      catogriesList['categories'].forEach(category => {
        category['items'].forEach(item => {
          categories.push([
            { 'value': category['category'] },
            { 'value': item['name'] },
          ]);
        })
      });
      if (categories.length) {
        display.push({ 'label': 'Categories', 'icon': 'fa fa-list', 'items': categories });
      }
    }
    // add 'assignee_trail' info to 'display' array
    if (obj['assignee_trail'] && obj['assignee_trail'].length) {
      var aTrails = [];
      obj['assignee_trail'].forEach(item => {
        var assigneeObj = WIRE.d(item['assignee']);
        if (assigneeObj) {
          var loggedInUserObj = WIRE.d(WIRE.data['account']);
          var loggedInUser = loggedInUserObj ? loggedInUserObj['email'] : '';
          var assigneeEmail = loggedInUser.toLowerCase() == assigneeObj['email'] ? 'You' :
            assigneeObj['name'] || assigneeObj['email'];
          aTrails.push([
            { 'value': assigneeEmail },
            { 'value': dateIntToStr(item['assigned_at']) },
          ]);
        }
      });
      if (aTrails.length) {
        display.push({ 'label': 'Assignee Trails', 'icon': 'fa fa-road', 'items': aTrails });
      }
    }

    return _drawCard(obj['name'], display, { 'min_height': 148, 'max_height': 148 });
  }

  static cardInquiry(obj) {
    var display = [
      { 'label': 'From', 'value': obj['email'], 'icon': 'fa fa-user' },
      { 'label': 'Phone', 'value': obj['phone'], 'icon': 'fa fa-phone' },
      { 'label': 'Message', 'value': obj['message'], 'icon': 'fa fa-file-text-o' },
      { 'label': 'To', 'value': WIRE.d(obj['target'])['email'], 'icon': 'fa fa-user', 'is_badge': true },
    ];
    return _drawCard('Inquiry', display);
  }

  static cardContractTemplate(obj) {
    var display = [];
    if (obj['contract_terms']) {
      const securtiyDeposit = obj['contract_terms']['security_deposit'];
      if (securtiyDeposit) {
        // add 'amount' info to 'display' array
        if (securtiyDeposit['amount']) {
          display.push({
            'label': 'SD Amount',
            'value': `${securtiyDeposit['amount']['value'] ?
              securtiyDeposit['amount']['value'] : '0.00'} ${securtiyDeposit['amount']['currency']}`,
            'icon': 'fa fa-money',
            'is_badge': true
          });
        }
      }
      // add 'terms_md' to 'display' array
      // if (securtiyDeposit['terms_md']) {
      //   display.push(
      //     { 'label': 'Terms', 'value': securtiyDeposit['terms_md'], 'icon': 'fa fa-file', 'tooltip': true },
      //   );
      // }
      // add 'duration' info to 'display' array
      const duration = obj['contract_terms']['duration']
      if (duration) {
        var startDay = dateIntToStr(duration['start_day'], true);
        var endDay = dateIntToStr(duration['end_day'], true);
        if (startDay || endDay) {
          display.push({
            'label': 'Duration',
            'value': `${startDay ? startDay : '?/?/????'} - ${endDay ? endDay : '?/?/????'}`,
            'icon': 'fa fa-clock'
          });
        }
        else {
          display.push({ 'label': 'Duration', 'value': 'unlimited', 'icon': 'fa fa-clock' });
        }
      }
      // add 'termination' info to 'display' array
      const termination = obj['contract_terms']['termination'];
      if (termination) {
        const earlyTermination = termination['earlyterminationval'];
        if (earlyTermination) {
          display.push(
            {
              'label': 'Early Termination',
              'value': `${earlyTermination['earlyterminationnumber']} ${earlyTermination['terminationduration']}`,
              'icon': 'fa fa-clock'
            },
          );
        }
        // termination renewal/extensions and breakoflease
        const renewal = termination['renewal'];
        const extensions = termination['extensions'];
        const breakOfLease = termination['breakoflease'];
        display.push({
          'label': 'Accepts',
          'icon': 'fa fa-check-square-o',
          'badges': [
            { 'value': 'Renewal', 'checked': renewal },
            { 'value': 'Extensions', 'checked': extensions },
            { 'value': 'Break of Lease', 'checked': breakOfLease }
          ]
        });
      }

      // add 'rent' info to 'display' array
      // const rent = obj['contract_terms']['rent'];
      // var rSchedule = [];
      // if (rent && rent['schedule']) {
      //   rent['schedule'].forEach(item => {
      //     rSchedule.push([
      //       { 'value': `${item['value'] ? item['value'] : '0.00'} ${item['currency']}` },
      //     ]);
      //   });
      //   if (rSchedule.length) {
      //     display.push({ 'label': 'Rent Schedule', 'icon': 'fa fa-history', 'items': rSchedule});
      //   }
      // }
      // else {
      //   rSchedule.push([
      //     { 'value': '0.00 AED' },
      //   ]);
      //   display.push({ 'label': 'Rent Schedule', 'icon': 'fa fa-history', 'items': rSchedule});
      // }
    }
    var options = {
      'min_height': 142,
      'max_height': 142,
      'min_width': 234,
      'max_width': 234
    };
    return _drawCard(obj['name'], display, options);
  }
};

Carder.BY_TYPE = {
  'tenancy_offer': Carder.cardOffer,
  'item_contract': Carder.cardItemContract,
  'work_order': Carder.cardWorkOrder,
  'inquiry': Carder.cardInquiry,
  'contract_template': Carder.cardContractTemplate,
};
/**
 * Searches among some objects.
 */
class Searcher {
  constructor(wire, objects) {
    this.objects = objects;
    this.wire = wire;
    this.objTypes = new Set(this.objects.map(o => o['type']));
    this.typeList = [];
    //this.flatAttributes = [];
    //this.listAttributes = [];
    this.flatAttributeDict = {};
    this.listAttributeDict = {};
    this.hasEdges = false;  // Will be set to true if any of `objTypes` has edges.
    this.searchableTypes = new Set([
      'text', 'longtext', 'categorical', 'checklist'
    ]);
    this.objTypes.forEach(function(itemType) {
      if(itemType){
        this.typeList.push(itemType);
        if (wire.itemManager.schema[itemType]) {
          // Hot Schema
          var fields = JSON.parse(JSON.stringify(wire.itemManager.schema[itemType]['fields']));
          fields.forEach(f => {
            if (f['type'] == 'EditableField' && this.searchableTypes.has(f['typeargs'][0]['t'] || 'text')) {
              //this.flatAttributes.push(f['name']);
              this.flatAttributeDict[f['name']] = f;
            } else if (f['type'] == 'EditableObject') {
              f['typeargs'].forEach(arr => {
                arr.filter(f2 => this.searchableTypes.has(f2['t'] || 'text')).forEach(function (f2) {
                  this.flatAttributeDict[f2['n']] = f2;
                }.bind(this));
              });
            } else if (f['type'] == 'List') {
              //this.listAttributes.push(f['name']);
              this.listAttributeDict[f['name']] = f;
            } else {
              // TODO(sami): Support all fields (esp. EditableObject).
              console.error('What about field type ' + f['type'], f);
            }
          });
        } else if (wire.schemaManager.schema[itemType]) {
          var fields = JSON.parse(JSON.stringify(wire.schemaManager.schema[itemType]['fields']));
          fields.filter(f => this.searchableTypes.has(f['t'] || 'text')).forEach(function(f) {
            this.flatAttributeDict[f['n']] = f;
          }.bind(this));
        }

        if (itemType.toLocaleLowerCase() in wire.edgeSchemaManager.typeIndex) {
          this.hasEdges = true;
        }
      }
    }.bind(this));

    //TODO make this array empty by default to remove `type` from possible groups
    this.attributes = [{ n: 'type', d: 'Type', src: 'type', t:'checklist', render_label: true, d_pos: 'above', choices: this.getTypeValues()}];
    for (var k in this.flatAttributeDict) {
      this.flatAttributeDict[k]['n'] = this.flatAttributeDict[k]['n'] || this.flatAttributeDict[k]['name'];
      if(!this.attributes.some(a=> a['n'] == this.flatAttributeDict[k]['n']))
      {
        if(this.flatAttributeDict[k]['t'] == 'checklist'){
          this.flatAttributeDict[k]['op'] = 'and';
          this.flatAttributeDict[k]['render_label'] = true;
          this.flatAttributeDict[k]['d_pos'] = 'above';
        }

        if(this.flatAttributeDict[k]['t'] == 'categorical'){
          this.flatAttributeDict[k]['t'] = 'checklist';
          this.flatAttributeDict[k]['render_label'] = true;
          this.flatAttributeDict[k]['d_pos'] = 'above';
        }

        this.attributes.push($.extend({}, this.flatAttributeDict[k], {src: 'flat'}));
      }
    }
    for (var k in this.listAttributeDict) {
      this.attributes.push({ n: '#' + k , d: '#' + k, src: 'list', t: 'number'});
    }
    //this.attributes = this.flatAttributes.concat(this.listAttributes.map(a => '#' + a));
    // if (this.hasEdges) {
    //   var edgeList = this.getEdgeValues();
    //   this.attributes.push({ n: 'with', d: 'With', src: 'edge', t: 'checklist', render_label: true, d_pos: 'above', choices: edgeList});
    //   this.attributes.push({ n: 'without', d: 'Without', src: 'edge', t: 'checklist', render_label: true, d_pos: 'above', choices: edgeList});
    // }
  }

  /**
   * Given dictionary of key-value pairs, it filters and returns a subset of `objects`
   * given to constructor.
   *
   * The keys in the filter can be anything returned from getAttributes(). Here are
   * some possible values:
   *  + "with" and "without": value must be array.
   *  + "#ListFieldName": value must be number
   *  + Other fields: value depends on attributeValues(field)
   * @param {Object} filter 
   */
  getFilteredData(filter=null) {
    filter = filter || function() { return true; };
    return this.objects.filter(this.makeFilterFn(filter));
  }

  makeFilterFn(filter) {
    for (var k in filter) {
      if (filter[k] instanceof Array) {
        filter[k] = new Set(filter[k]);
      }
    }
    // {"gender":["male"]}
    var wire = this.wire;
    return function(obj) {
      var matches = true;
      obj = wire.d(obj._id);
      for (var k in filter) {
        var v = filter[k];
        if (k == "with" || k == "without") {
          var edgeNames = [];
          filter[k].forEach(en => {edgeNames.push(en)});
          console.log('EDGE ', k, ' ', edgeNames);
          obj.type
          var edgeTypes = wire.edgeSchemaManager.typeIndex[obj.type.toLocaleLowerCase()];
          for (var j = 0; j < edgeTypes.length; j += 1) {
            var edgeType = edgeTypes[j];
            var name = wire.edgeSchemaManager.schema[edgeType.t]['endpoints'][edgeType.i]['label'];
            if (v.has(name)) {
              // it must exist if "with"
              matches = (k == 'with') == (wire.edgeDb.objHasRelation(obj._id, edgeType.t));
            }
            if (!matches) {
              break;
            }
          }
        } else if (k.startsWith('#')) {
          var fieldName = k.substr(1);
          matches = (fieldName in obj) && (obj[fieldName].length == Number(filter[k]));
        } else {
          if(k in obj && Array.isArray(obj[k])){
            var attribute = this.attributes.find(a=> a['n'] == k);
            if(attribute['op'] == 'and'){
              matches = filter[k].intersect(obj[k]).size >= filter[k].size;
            }
          } else if (filter[k] instanceof Set) {
            matches = (k in obj) && filter[k].has(obj[k]);
          } else if (k in obj) {
            switch (typeof(obj[k])) {
              case "number":
                matches = (filter[k] == obj[k]);
                break;
              case "string":
                matches = wildCardFilter(obj[k], filter[k]);
                break;
            }
          } else {
            matches = false;
          }
        }
        if (!matches) {
          return false;
        }
      }

      return matches;
    }.bind(this);
  }

  getAttributes(textStart) {
    textStart = textStart || '';
    textStart = textStart.toLowerCase();
    
    // 
    this.attributes.forEach(attr=>{
        if (!attr['n']){
          attr['n'] = attr['name'];
        }
        // delete readonly property if it is cloned from field
        delete attr['readonly'];
      });
    var attributes = this.attributes.filter(att => (att['n'].substr(0, textStart.length).toLowerCase() ==  textStart));
    // TODO(Leena): uncommenting below should result in normal behavior
    //attributes = attributes.map(attrName => ({'n': attrName, 'd': attrName}));
    return attributes;
  }

  /**
   * returns one of: 'text', 'number', or list of choices.
   * @param {string} attribute
   */
  attributeValues(attribute) {
    if (attribute == 'with' || attribute == 'without') {
      var edges = [];
      
      this.objTypes.forEach(function (t) {
        t = t.toLowerCase();
        if (t in this.wire.edgeSchemaManager.typeIndex) {
          var tIndex = this.wire.edgeSchemaManager.typeIndex[t];
          tIndex.forEach(function (indexInfo) {
            // indexInfo
            var ep = this.wire.edgeSchemaManager.schema[indexInfo.t]['endpoints'][indexInfo.i];
            //if (!(ep['label'] in edgeSet)) {
              edges.push(ep['label']);
            //  edgeSet.add(ep['label']);
            //}
          }.bind(this));
        }
      }.bind(this));
      var edgeSet = new Set(edges);
      var uniqueEdges = [];
      edgeSet.forEach(e => {uniqueEdges.push(e)});
      return uniqueEdges;
    } else if (attribute == 'type') {
      return this.typeList;
    } else if (attribute.startsWith('#')) {
      // List
      return 'number';
    } else if (attribute in this.flatAttributeDict) {
      if (this.flatAttributeDict[attribute]['t'] == 'categorical') {
        //return this.flatAttributeDict[attribute]['choices'];
        return this.flatAttributeDict[attribute]['t'];
      } else if (this.flatAttributeDict[attribute]['typeargs'] && 
                 this.flatAttributeDict[attribute]['typeargs'][0]['t'] == 'categorical') {
        // TODO(sami): Above if-statement might be useless (this one works).
        return this.flatAttributeDict[attribute]['typeargs'][0]['t'];
      } else if (this.flatAttributeDict[attribute]['t'] == 'checklist'){
        return 'checklist';
      } else if (this.flatAttributeDict[attribute]['t'] == 'numeric') {
        return 'number';
      } else {
        return 'string';
      }
    }
  }

  getEdgeValues(){
    var edges = [];
      
    this.objTypes.forEach(function (t) {
      t = t.toLowerCase();
      if (t in this.wire.edgeSchemaManager.typeIndex) {
        var tIndex = this.wire.edgeSchemaManager.typeIndex[t];
        tIndex.forEach(function (indexInfo) {
          // indexInfo
          var ep = this.wire.edgeSchemaManager.schema[indexInfo.t]['endpoints'][indexInfo.i];
          //if (!(ep['label'] in edgeSet)) {
            // Ask Sami about this line below, sometimes the ep['label'] equals null
            if(ep['label']){
              edges.push(ep['label']);
            }
          //  edgeSet.add(ep['label']);
          //}
        }.bind(this));
      }
    }.bind(this));
    var edgeSet = new Set(edges);
    var uniqueEdges = [];
    edgeSet.forEach(e => {uniqueEdges.push(e)});
    return uniqueEdges;
  }

  getTypeValues(){
    return this.typeList;
  }
}
// TODO(sami): This is work in progress, it will likely be refactored a lot.

class Assignments {
  // TODO(sami): Make raise events.
  static createAssignmentsDom(
    parentDom,
    objId,
    relationTypename,
    endpointIndex,
    searchClickCallback,
    optOptions
  ) {
    var uiOptions = $.extend(
      true,
      {},
      {
        className: "drop-assignments pt-2",
        textClassName: "drop-desc",
        text: "Click search button then drag {0}"
      },
      optOptions
    );
    var acceptingDiv = $("<div>")
      .addClass(uiOptions.className)
      .appendTo(parentDom)
      .on("dragover", Assignments.allowDrop)
      .on("dragleave", Assignments.dragLeave)
      .on("drop", Assignments.drop.bind(this, uiOptions));
    acceptingDiv
      .attr("objId", objId)
      .attr("relation", relationTypename)
      .attr("epIndex", endpointIndex);

    Assignments.populateAssignmentsDom(
      acceptingDiv,
      objId,
      relationTypename,
      endpointIndex,
      optOptions
    );

    if (searchClickCallback) {
      var searchButton = $(`
      <a class="searchbtn btn btn-primary btn-icon rounded-circle waves-effect waves-themed">
          <i class="fa fa-search" style="color: white"></i>
      </a>`).appendTo(acceptingDiv);
      searchButton.click(searchClickCallback);
      // subscribe to click.
    }
  }

  static populateAssignmentsDom(
    acceptingDiv,
    objId,
    relationTypename,
    endpointIndex,
    optOptions
  ) {
    var uiOptions = $.extend(
      true,
      {},
      {
        className: "drop-assignments pt-2",
        textClassName: "drop-desc",
        text: "Click search button then drag {0}"
      },
      optOptions
    );

    acceptingDiv.empty();
    var hasDeletePermission = false;
    if (WIRE.edgeP[objId]) {
      hasDeletePermission = WIRE.edgeP[objId][relationTypename] & 3;
    }

    var currentEdges = WIRE.edgeDb.getNextEdges(
      objId,
      relationTypename,
      endpointIndex
    );
    if (currentEdges.length == 0) {
      //acceptingDiv.html('Choose a resident and drag it here');
      var endpoint =
        window.WIRE.edgeSchemaManager.schema[relationTypename]["endpoints"][
          endpointIndex
        ];

      if ($(".searchbtn")) {
        acceptingDiv.append(
          $("<span>")
            .addClass(uiOptions.textClassName)
            .html(
              uiOptions.text ? uiOptions.text.format(endpoint["label"]) : ""
            )
        );
      }
    } else {
      currentEdges.forEach(edge => {
        var objId = edge.node;
        var obj = WIRE.d(objId);
        var dom = WIRE.depictor.createItemDom(obj);

        dom.attr('data-relationId', edge.edgeId);

        dom.click(function() {
          WIRE.popupObjectView(obj);
        });
        if (hasDeletePermission) {
          dom.addClass('position-relative');
          var btnRemove = $('<span class="fa fa-times-circle position-absolute" style="top: -6px; right: -1%; z-index: 1;color: red;background-image: radial-gradient(at center, white 40%, transparent 40%);font-size: 18px;">');
          dom.prepend(btnRemove);
          btnRemove.on("click", function (e) {
            e.stopPropagation();
            WIRE.call('business::remove_edge', {'edge_id': edge.edgeId}, function(response) {
              if (response['_msg'] == 'ok') {
                var domRelationId = dom.attr('data-relationId');
                dom.remove();
                // remove relational(associated) doms if exist
                var associatedDom = $('div[data-relationId="' + domRelationId + '"]');
                if (associatedDom.length > 0) {
                  associatedDom.remove();
                }
              }
            });    
          });
        }
        dom.appendTo(acceptingDiv);
     
        // Disable popover when the item has relationship and assigned because 
        //it appear in small place and became not clear
        var attr = dom.attr('data-relationId');
        // For some browsers, `attr` is undefined; for others,
        // `attr` is false.  Check for both.
        if (typeof attr !== typeof undefined && attr !== false) {
          dom.popover('disable');
        }

      });
    }
  }

  static dragStart(ev) {
    var origEvent = ev;
    if (origEvent.originalEvent) {
      origEvent = origEvent.originalEvent;
    }
    const dt = origEvent.dataTransfer;
    if (dt) {
      dt.setData("objId", ev.currentTarget.getAttribute("objId"));
    }
    $(".drop-assignments").removeClass("drop-assignments-recieve");
  }

  static allowDrop(ev) {
    ev.originalEvent.preventDefault();
    var target = $(ev.originalEvent.currentTarget);

    //'objId', objId).attr('relation', relationTypename
    //epIndex

    if (!target.hasClass("assign-dropping")) {
      target.addClass("assign-dropping");

      // Check if dropping is allowed or not.
      var objId = target.attr("objId");
      var relationTypename = target.attr("relation");
      var epIndex = Number(target.attr("epIndex"));
      var errors = WIRE.edgeDb.assignObjErrors(
        WIRE.d(objId),
        relationTypename,
        epIndex
      );
      if (errors && errors.length > 0) {
        if (!target.hasClass("drop-assignments-recieve-error")) {
          $(`<div class="alert bg-transparent text-secondary fade show" role="alert" id="errorMessage">
                <div class="d-flex align-items-center px-5">       
                        <div  class="color-danger-900" style="width: 140px;
                        text-align: left; margin-left: -30px;"><span class="icon-stack icon-stack-md" style="font-size: 15px;
                        margin: 0px 3px;">
                        <i class="base-7 icon-stack-3x color-danger-900"></i>
                        <i class="fal fa-times icon-stack-1x text-white"></i>
                    </span>${errors} </div>                                                      
                </div>
              </div>`
          ).prependTo(target);
          target.addClass("drop-assignments-recieve-error");
        }
        console.log(errors);
      } else {
        target.addClass("drop-assignments-recieve");
      }
    }
  }

  static dragLeave(ev) {
    ev.originalEvent.preventDefault();
    var target = $(ev.originalEvent.currentTarget);
    target.removeClass("assign-dropping");
    target.removeClass("drop-assignments-recieve");
  }

  static drop(options, ev) {
    var target = $(ev.originalEvent.currentTarget);
    $(".drop-assignments").removeClass("drop-assignments-recieve");
    if ($("#errorMessage")) {
      $("#errorMessage").remove();
      target.removeClass("drop-assignments-recieve-error");
    }
    ev.preventDefault();
    var target = $(ev.originalEvent.currentTarget);
    target.removeClass("assign-dropping");

    var targetObjId = target.attr("objId");
    var targetObjEndpointIndex = Number(target.attr("epIndex"));
    var droppedObjId = ev.originalEvent.dataTransfer.getData("objId");

    var relationTypename = target.attr("relation");

    //attr('objId', objId).attr('relation', relationTypename).attr('epIndex', endpointIndex)
    // Error Checking.
    var errors = WIRE.edgeDb.assignObjErrors(
      WIRE.d(targetObjId),
      relationTypename,
      targetObjEndpointIndex
    );
    if (errors && errors.length > 0) {
      WIRE.errorMessageModal(errors.join("; "));
      return;
    }
    // TODO(sami): Support edges with more than 2 nodes.
    errors = WIRE.edgeDb.assignObjErrors(
      WIRE.d(droppedObjId),
      relationTypename,
      1 - targetObjEndpointIndex
    );
    if (errors && errors.length > 0) {
      WIRE.errorMessageModal(errors.join("; "));
      return;
    }

    //var jsonObj = JSON.parse(obj);
    var loadingSpinner = $(`<button class="btn btn-info rounded-pill waves-effect waves-themed float-left my-3 mx-2" type="button" disabled="">
          <span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span>
          Loading...
      </button>`).appendTo(target);

    // TODO(sami): Extend to more-than 2 endpoints, when needed.

    // TODO(sami): Consider making this class concrete rather than static.
    var edgeEndpoints = [null, null];
    edgeEndpoints[targetObjEndpointIndex] = targetObjId;
    edgeEndpoints[1 - targetObjEndpointIndex] = droppedObjId;
    var addEdgeArgs = {
      typename: target.attr("relation"),
      endpoints: edgeEndpoints
    };

    window.WIRE.call("business::create_edge", addEdgeArgs, function() {
      //debugger;
      Assignments.populateAssignmentsDom(
        target,
        targetObjId,
        relationTypename,
        targetObjEndpointIndex,
        options
      );

      // Also add card element which is related to "target obj",
      // in dropped area(if exist) which is related to "dropped Obj" 
      Assignments.reflectiveDrop(options, droppedObjId);
    });
  }

  static reflectiveDrop(options, droppedObjId) {
    //debugger;
    var target = $('.droppable-area[objid="' + droppedObjId + '"]');
    if (target.length > 0) {
      $(".drop-assignments").removeClass("drop-assignments-recieve");
      if ($("#errorMessage")) {
        $("#errorMessage").remove();
        target.removeClass("drop-assignments-recieve-error");
      }
      target.removeClass("assign-dropping");

      var targetObjId = droppedObjId;
      var targetObjEndpointIndex = Number(target.attr("epIndex"));
      var relationTypename = target.attr("relation");

      var loadingSpinner = $(`<button class="btn btn-info rounded-pill waves-effect waves-themed float-left my-3 mx-2" type="button" disabled="">
          <span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span>
          Loading...
      </button>`);
      target.append(loadingSpinner);

      Assignments.populateAssignmentsDom(
        target,
        targetObjId,
        relationTypename,
        targetObjEndpointIndex,
        options
      );
    }
  }
}


/**
 * Contains custom logic to render user interfaces for:
 *  - Object View
 *  - Object Edit
 * 
 * The depictor differs from this: specfically, depictor renders cards for an object (Icon, label)
 */

class DefaultSchemaEditor {
  constructor(wire, dom, objSchemaType, objDbType, objValues, callback) {
    var formName = 'add_obj_' + objSchemaType;
    /***
     * Copied from editable object:
     *   [0]: Name of object (can be used to get its values)
     *   [1]: Object with key "fields" and value Array, coming from schema.json [or similar format].
     *   [2]: (optional) Object Field values.
     *   [3]: (optional) on change callback.
     */
    //debugger;
    var fields = wire.schemaManager.schema[objSchemaType]
    var editableObjectArgs = [formName, fields];
    if (objValues) {
      editableObjectArgs.push(objValues);
    } else {
      editableObjectArgs.push(null);
    }
    if (callback) {
      editableObjectArgs.push(callback);
    }
    
    var editableFormConfig = u('EditableObject', editableObjectArgs);
    this.editableForm = wire.unrollRecursive(editableFormConfig, dom);
  }

  getValue() {
    return this.editableForm.getValues();
  } 
};

class OfferCallEditor {
  constructor(wire, dom, objSchemaType, objDbType, objValues, callback) {
    wire.unrollRecursive(
      u("AJS", ["call_for_offers", objValues, function(scope) {
          this.viewScope = scope;
        }.bind(this)]),
      dom);    
  }

  getValue() {
    return this.viewScope.getValue();
  }
};


class ObjInterfaces {
  constructor(wire) {
    this.wire = wire;
  }

  makeEditor(dom, objSchemaType, objDbType, objValues, callback) {
    /*if (objDbType == 'item_group') {
      console.log('HAHAHA');

    } else */
    if (objDbType == 'offer_call') {
      return new OfferCallEditor(
        this.wire, dom, objSchemaType, objDbType, objValues, callback);
    } else if (objSchemaType in this.wire.schemaManager.schema) {
      return new DefaultSchemaEditor(
        this.wire, dom, objSchemaType, objDbType, objValues, callback);
    } else if (objSchemaType in this.wire.itemManager.schema) {
      return new HotSchemaEditor(
        this.wire, dom, objSchemaType, objDbType, objValues, callback);
    } else {
      //console.error('Dont know editor for ' + objSchemaType);
    }
  }
}
class EdgeDatabase {
  constructor(wire) {
    this.wire = wire;
    this.edges = {};
    this.byObjId = {}; // Obj Id -> typename -> (partial) edge id.
  }

  reset() {
    this.edges = {};
    this.byObjId = {};
  }

  process(response) {
    if (response["edges"]) {
      this.edges = {
        ...this.edges,
        ...response["edges"]
      };
      for (var k in response["edges"]) {
        var edge = response["edges"][k];
        edge._id = 'e^' + k;
        edge._id2 = k.replace(':', '_')
        var kParts = k.split(":");
        var edgeType = kParts[0];
        var edgePartialId = kParts[1];
        var endpoints = edge["ep"];
        for (var j = 0; j < endpoints.length; j += 1) {
          var objId = endpoints[j];
          if (objId.startsWith("!obj!")) {
            objId = objId.substr(5);
          }
          if (!this.byObjId[objId]) {
            this.byObjId[objId] = {};
          }
          if (!this.byObjId[objId][edgeType]) {
            this.byObjId[objId][edgeType] = {};
          }
          this.byObjId[objId][edgeType][edgePartialId] = edge["data"];
        }
      }
    }
    if (response['edges-']) {  // Edges are removed.
      response['edges-'].forEach(function(edgeId) {
        var edge = this.edges[edgeId];
        if (!edge) {
          return;  // edge was not in db.
        }
        var edgeIdParts = edgeId.split(':');
        edge['ep'].forEach(function(objId) {
          // For each endpoint.
          if (objId.startsWith('!obj!')) {
            objId = objId.substr(5);
          }
          if ((objId in this.byObjId) && (edgeIdParts[0] in this.byObjId[objId])) {
            delete this.byObjId[objId][edgeIdParts[0]][edgeIdParts[1]];
            if (objectSize(this.byObjId[objId][edgeIdParts[0]]) == 0) {
              delete this.byObjId[objId][edgeIdParts[0]];
              if (objectSize(this.byObjId[objId]) == 0) {
                delete this.byObjId[objId];
              }
            }
          }
        }.bind(this));
        delete this.edges[edgeId];
      }.bind(this));
    }
  }

  objHasRelation(objId, typename) {
    if (!(objId in this.byObjId)) {
      return false;
    }
    return typename in this.byObjId[objId];
  }

  /**
   * When `srcObj` is dragged onto `dstObj` under edge type `typename`,
   * Returns string error.
   *
   * @param {Object} obj data Object
   * @param {string} typename edge type
   * @param {number} epIndex Index of endpoint
   */
  assignObjErrors(obj, typename, epIndex) {
    var assignFn = this.wire.edgeSchemaManager.schema[typename].endpoints[
      epIndex
    ].assignFn;
    if (assignFn) {
      var errors = assignFn(obj);
      if (typeof(errors) == 'string') {
        errors = [errors];
      }
      return errors;
    }
  }

  /**
   * Gets node IDs that are connected to `nodeId` via edge `typename`.
   * @param {string} nodeId source node ID
   * @param {string} typename Edge type
   * @param {Number} endpointIdx assumes that it is the position of nodeId within the edge.
   */
  getNextNodes(nodeId, typename, endpointIdx) {
    return this.getNextEdges(nodeId, typename, endpointIdx).map(e => e.node);
  }

  /**
   * Like the above, but returns the edge connecting and node.
   * @param {string} nodeId source node ID
   * @param {string} typename Edge type
   * @param {Number} endpointIdx assumes that it is the position of nodeId within the edge.
   */
  getNextEdges(nodeId, typename, endpointIdx) {
    if (nodeId.startsWith('!obj!')) {
      nodeId = nodeId.substr(5);
    }
    if (!(nodeId in this.byObjId)) {
      return [];
    }
    if (!(typename in this.byObjId[nodeId])) {
      return [];
    }
    var nextEdges = [];
    var edgeDict = this.byObjId[nodeId][typename];
    for (var edgeId in edgeDict) {
      edgeId = typename + ":" + edgeId;
      nextEdges.push({
          node: this.edges[edgeId].ep[1 - endpointIdx],
          edgeId: edgeId,
      });
    }
    return nextEdges;
  }
}

class ActionManager {
  constructor(wire) {
    this.wire = wire;
    this.objIdToInteractionToAction = {};
  }

  /**
   * 
   * @param {String} objId object ID.
   * @param {Function} fn accepts 2 arguments:
   *   interactionName (string), action (object) ({"n": , "schemaName":})
   */
  forEachAction(objId, fn) {
    if (objId.startsWith('!obj!')) {
      objId = objId.substr(5);
    }
    if (!this.objIdToInteractionToAction[objId]) {
      return;
    }
    for (var interactionName in this.objIdToInteractionToAction[objId]) {
      var actions = this.objIdToInteractionToAction[objId][interactionName];
      for (var actionName in actions) {
        fn(interactionName, actions[actionName]);
      }
    }
  }
  
  /**
   * @param {Object} data with keys 'actions', 'interaction', 'object_id'
   */
  process(data) {
    data['object_ids'].forEach(function(objId) {
      if (objId.startsWith('!obj!')) {
        objId = objId.substr(5);
      }
      this.objIdToInteractionToAction[objId] = this.objIdToInteractionToAction[objId] || {};
      var interactionToAction = this.objIdToInteractionToAction[objId];
      interactionToAction[data['interaction']] = interactionToAction[data['interaction']] || {};
      var actions = interactionToAction[data['interaction']];

      data['actions'].forEach(a => {
        actions[a['n']] = a;
        a['i_type'] = data['i_type'];
        a['i_idx'] = data['i_idx'];
      });
    }.bind(this));
  }

  /**
   * Empties-out all actions.
   */
  reset() {
    this.objIdToInteractionToAction = {}
  }
}
var IsPopoverClicked = function (target) {
  return $(".popover:visible").filter(function () {
    return $(this).is(target) || $(this).has(target).length > 0;
  }).length > 0;
}

class ObjectListRenderer {
  /**
   * 
   * @param {Array<Object>} objects list of data.Object
   * @param {JQuery} jq dom to render list on.
   */
  /*
  constructor(wire, objects, jq) {
    objects.forEach(obj => {
      var objDom = wire.depictor.createItemDom(obj);
      jq.append(objDom);
    });
  }
  */

  static popupObjectList(wire, objects, title, callback) {
    var listDom = $('<div>');
    var modal;
    objects.forEach(obj => {
      if (typeof (obj) == 'string') {
        obj = wire.d(obj);
      }
      var objDom = wire.depictor.createItemDom(obj);
      listDom.append(objDom);
      if (callback) {
        objDom.click(function () {
          callback(obj, modal);
        });
      }
    });
    modal = Specto.ui.Modal.showModal(listDom, title, null, { sizeMode: 'full' });
  }
}

/**
 * Given a dictionary, returns the number of keys in it.
 */
var objectSize = function (obj) {
  var size = 0;
  for (var _ in obj) {
    size += 1;
  }
  return size;
};

class GroupingSearchingDom {
  constructor(renderOn, changeCallback) {
    this.groups = []; //new Set([]);
    this.searchAttributes = []; //new Set([]);

    // UI containing all groups/search attributes.
    var searchingGroupingContainer = $(`
      <div class="form-group search-group-select-container">                                                           
        <select class="form-control search-group-select-control"
          data-placeholder="Select search options..." multiple="multiple">
        </select>
        <span class="help-block">Selected values will be highlighted. 
          You can drag selected values to rearrange them for grouping purposes.
        </span>
      </div>`
    );

    searchingGroupingContainer.appendTo(renderOn);

    var selectInput = this.input = searchingGroupingContainer.find('select');

    selectInput.select2({
      templateResult: icon,
      templateSelection: icon,
      escapeMarkup: function (elm) {
        return elm;
      }
    });

    function icon(elm) {
      elm.element;
      var text = elm.id
        ? ($(elm.element).hasClass('grouping-searching-option')
          ? "<i class='" + $(elm.element).data("icon") + " mr-2'></i>" + "<i class='fal fa-object-group fw-500 color-info-300 mr-2'></i>" + elm.text
          : "<i class='" + $(elm.element).data("icon") + " mr-2'></i>" + elm.text)
        : elm.text;
      return text;
    }

    // When user selects many items (tags), 
    // they are automatically sorted based on their order in main list, 
    // so we prevent tags sorting by moving the user's selected item to the end
    selectInput.on("select2:select", function (evt) {
      var selectedOption = evt.params.data.element;
      var $selectedOption = $(selectedOption);

      $selectedOption.detach();
      $(this).append($selectedOption);
      $(this).trigger("change");
    });

    var selectedTagsList = searchingGroupingContainer.find("ul.select2-selection__rendered");
    if (selectedTagsList) {
      selectedTagsList.sortable({
        containment: 'parent',
        stop: function (event) {
          // Rearrange (select2) options based on tags order
          var tagsList = Array.from($(event.target).find('li:not(.select2-search)').map(function () {
            return $(this).data('data').text;
          }));
          for (var i = 0; i < tagsList.length; i++) {
            var $targetOption = selectInput.find('option').filter(function (index, option) {
              if (option.value == tagsList[i]) {
                return option;
              }
            });
            $targetOption.detach();
            selectInput.append($targetOption);
          }
          selectInput.trigger("change");
        },
      });
    }

    // Called new group/search attribute is added or removed
    selectInput.change(function () {
      var selectedValues = this.input.val();
      // Its important to guarantee the order of selected values for grouping purposes 
      // so we must 'filter' values from (selectedValues) array
      var selectedSearchAttributes = selectedValues.length > 0 ?
        Array.from(this.searchAttributes).filter(s => selectedValues.includes(s['n'])) : [];
      var selectedGroups = selectedValues.length > 0 ?
        Array.from(this.groups).filter(g => selectedValues.includes(g['name'])) : [];

      var searchInputsContainer = renderOn.find('#search-inputs-container');
      if (selectedSearchAttributes.length > 0 && searchInputsContainer.length == 0) {
        searchInputsContainer = $(`<div class="panel" id="search-inputs-container">
                                            <div class="panel-hdr cursor-pointer" data-action="panel-collapse">
                                                <h5 class="m-0 p-2"><i class="fa fa-filter color-danger-500 mr-1"></i>Search Fields</h5>
                                                <h2 id="title"></h2>
                                                <div class="panel-toolbar">
                                                    <button class="btn btn-panel has-tooltip" data-action="panel-collapse"
                                                        data-original-title="Collapse" title="Collapse"/>
                                                </div>
                                            </div>
                                            <div class="panel-container show" style="max-height: 250px; overflow-x: auto;">
                                                <div class="panel-content">
                                                    
                                                    <div class="form-row" id="search-inputs-content"></div>
                                                </div>
                                            </div>
                                        </div>`);

        searchInputsContainer.appendTo(renderOn);
      } else if (selectedSearchAttributes.length == 0 && searchInputsContainer.length > 0) {
        searchInputsContainer.remove();
      }

      // selectedSearchAttributes = selectedSearchAttributes.map(u => u.trim());
      // selectedSearchAttributes = selectedSearchAttributes.filter(a => 
      //   this.searchAttributes.some(s => a['n'] == s['n']));

      // selectedGroups = selectedGroups.map(u => u.trim());
      //selectedGroups = selectedGroups.filter(g=> this.groups.some(s=> g['name'] == s['names']));

      // selectedSearchAttributes = selectedSearchAttributes.forEach(u => {
      //   debugger;   
      //   u['n'] = u['n'].trim();
      // });
      // Ask about this line of code
      //selectedSearchAttributes = selectedSearchAttributes.filter(this.searchAttributes.has.bind(this.searchAttributes));   
      // selectedGroups = selectedGroups.forEach(element => {
      //   u['name'] = u['name'].trim();
      // });

      // Ask about this line of code
      //selectedGroups = selectedGroups.filter(this.groups.has.bind(this.groups));
      changeCallback(selectedSearchAttributes, selectedGroups);
    }.bind(this));
  }

  /**
   * 
   * @param {Array<string>} groups activates on UI the list of selected groups. Must correspond to
   *   'name' of groups that are in the Universe.
   */
  setGroups(groups) {
    //var groupsStr = groups.join(', ');
    //debugger;
    this.input.val(groups.map(g => g['name']));
    this.input.change();
  }

  /**
   * 
   * @param {Array<Object>} groups list of objects with keys `name` and `display`.
   */
  setSearchAttributesAndGroupUniverse(searchAttributes, groups) {
    this.searchAttributes = searchAttributes;
    this.groups = groups;

    //searchAttributes = searchAttributes.map(a=> a['d']);
    //groups = groups.map(g => g.display || g.name);  // TODO(hadeel): Use .display too.

    //var mergedArray = [...new Set(groups.concat(searchAttributes))];
    var optionsAsString = "";
    // for (var i = 0; i < mergedArray.length; i++) {
    //   optionsAsString += "<option value='" + mergedArray[i] + "'>" + mergedArray[i] + "</option>";
    // }

    var sharedValues = this.searchAttributes.filter(s => this.groups.some(g => g['name'] == s['n']));
    var searchAttributesUniqueValues = this.searchAttributes.filter(s => !sharedValues.some(v => v['n'] == s['n']));
    var groupsUniqueValues = this.groups.filter(g => !sharedValues.some(v => v['n'] == g['name']));

    for (var i = 0; i < sharedValues.length; i++) {
      var text = sharedValues[i]['d'] || sharedValues[i]['n'];
      optionsAsString += "<option  class='grouping-searching-option' value='"
        + sharedValues[i]['n'] + "' data-icon='fa fa-filter color-danger-300'>"
        + text + "</option > ";
    }
    for (var i = 0; i < searchAttributesUniqueValues.length; i++) {
      var text = searchAttributesUniqueValues[i]['d'] || searchAttributesUniqueValues[i]['n'];
      optionsAsString += "<option value='" + searchAttributesUniqueValues[i]['n'] + "' data-icon='fa fa-filter fw-500 color-danger-300'>"
        + text + "</option > ";
    }
    for (var i = 0; i < groupsUniqueValues.length; i++) {
      optionsAsString += "<option value='" + groupsUniqueValues[i]['name'] + "' data-icon='fal fa-object-group fw-500 color-info-300'>"
        + groupsUniqueValues[i]['display'] + "</option>";
    }

    this.input.append(optionsAsString);

    //this.groups = new Set(groups);
    //this.searchAttributes = new Set(searchAttributes);
    return this;
  }
}

class DataFilterGrouper {
  constructor(wire, data) {
    this.searcher = new Searcher(wire, data);
    this.searchFields = this.searcher.getAttributes('');
    this.groupFields = this.searchFields;

    var sharedFields = this.searchFields
      .intersect(this.groupFields, 'n')
      .map(f => $.extend({}, f, { searchable: true, groupable: true }));

    var searchableFields = this.searchFields
      .difference(this.groupFields, 'n')
      .map(f => $.extend({}, f, { searchable: true }));

    var groupableFields = this.groupFields
      .difference(this.searchFields, 'n')
      .map(f => $.extend({}, f, { groupable: true }));

    this.allFields = [];
    this.allFields = this.allFields.concat(sharedFields)
      .concat(searchableFields)
      .concat(groupableFields);
  }

  get searchGroupFields() {
    return this.allFields;
  }

  filterData(searchFields) {
    return isEmpty(searchFields) ? this.searcher.getFilteredData() :
      this.searcher.getFilteredData(searchFields);
  }
}

/*
* options: {
    fields: [],
    showGrouping: true(default)/false,
    showFiltering: true(default)/false,
    selectedFilters:..,
    selectedGroups:..,
  }
*/
class FilterGrouperComponent {
  constructor(renderGroupingBoxOn, renderFilterBoxOn, options, onFilteringGroupingCallback) {
    this.renderGroupingBoxOn = renderGroupingBoxOn;
    this.renderFilterBoxOn = renderFilterBoxOn;

    this._settings = $.extend(true, { showGrouping: true, showFiltering: true }, options);
    this.fields = this._settings.fields;
    this.fieldDict = {};
    
    this.fields.forEach(f => {
      f.iconClasses = f.iconClasses || [];
      if (f.searchable) {
        f.iconClasses.push('fal fa-object-group fw-500 color-info-300');
      }
      if (f.groupable) {
        f.iconClasses.push('fa fa-filter color-danger-300');
      }

      this.fieldDict[f['n']] = f;
    });

    this._selectedGroups = this._settings.selectedGroups || [];
    this._selectedFilters = this._settings.selectedFilters || {};

    this.onFilteringGroupingCallback = onFilteringGroupingCallback;
  }

  render() {
    var pageContent = this.renderGroupingBoxOn.parents('#js-page-content'); //TODO_: Note the js-page-content is not in all pages
    var topButtonsExists = pageContent.find('.top-buttons').length &&
      pageContent.find('.top-buttons').children().length;
    
    var searchGroupContainer = $('<div>').appendTo(this.renderGroupingBoxOn);

    var $searchGroupFilterButtonsWrap = $(`<div class='searchGroupBtn text-right ${topButtonsExists ? 'absolute-btn' : 'mb-2'}'>`)
      .appendTo(searchGroupContainer);

    if (this._settings.showGrouping) {
      this._appendGroupingButton($searchGroupFilterButtonsWrap);
      this._appendGroupingElement(searchGroupContainer);
    }

    if (this._settings.showFiltering) {
      this._appendFilteringButton($searchGroupFilterButtonsWrap);
    }

    var isViewDraggable = false;
    // var showModalView = window.matchMedia('(max-width: 768px)').matches;
    // var isViewDraggable = false;
    // var innerList = this.renderOn.parents('.inner-list');
    // if (!innerList.length) {
    //     innerList = this.renderOn.parents('.draggable-container');
    //     isViewDraggable = true;
    // }
    var searchFieldsDom = $(`
      <div class="fields-container ${isViewDraggable ? 'col-lg-3': 'col-lg-2 col-md-3'} col-sm-12 p-0">
        <div class="search-fields"></div>
      </div>`
    );

    let me = this;
    searchFieldsDom.appendTo(this.renderFilterBoxOn).hide();

    // var groupList = this.renderGroupingBoxOn.parents('.group-list'); //Note: The group-list class is not exist in all views
    var groupList = $(this.renderFilterBoxOn.children()[0]); //TODO_: Find an appropriate way to get the grid list container
    searchGroupContainer.find('.view-fields-btn').click(function () {
      $(this).tooltip('hide');
      if (me.renderFilterBoxOn.hasClass('row')) {
        me.renderFilterBoxOn.removeClass('row');
        groupList.removeClass(isViewDraggable ? 'col-lg-9 col-sm-12' : 'col-lg-10 col-md-9 col-sm-12');
        pageContent.removeClass('pr-3').css('overflow-x', 'auto');
        searchFieldsDom.hide();
        $(this).attr("data-original-title", "Expand search fields");
        $(this).find('.fa-chevron-right').removeClass('fa-chevron-right').addClass('fa-search');
      }
      else {
        me.renderFilterBoxOn.addClass('row');
        groupList.addClass(isViewDraggable ? 'col-lg-9 col-sm-12' : 'col-lg-10 col-md-9 col-sm-12');
        pageContent.addClass('pr-3').css('overflow-x', 'hidden');
        searchFieldsDom.show();
        $(this).attr("data-original-title", "Collapse search fields");
        $(this).find('.fa-search').removeClass('fa-search').addClass('fa-chevron-right');
      }
    });
      
    this.renderGroupingBoxOn.find('.view-fields-btn').tooltip();
    // move results dom on page scroll
    pageContent.scroll(function () {
      var searchFieldsDiv = searchFieldsDom.find('#searchFields');
      var isScrollable = $(this).scrollTop() > 100 &&
        parseInt(searchFieldsDiv.css('margin-top').replace('px', '')) < groupList.find('#itemsview').innerHeight(); //TODO_: Pass the itemsview by params
      if (isScrollable) {
        searchFieldsDiv.removeClass('m-0').css('margin-top',
          `${$(this).scrollTop() - ($(this).find('.view-container .top-buttons').innerHeight() + 65)}px`);
      }
      else {
        searchFieldsDiv.addClass('m-0').css('margin-top', '0px');
      }
    });
    
    var randomId = "sg" + Guid.generate();
    searchGroupContainer.find(".searchGroupCollapse").attr("id", randomId);
    searchGroupContainer.find(".group-btn")
      .attr({ "data-target": "#" + randomId, "aria-controls": randomId })
      .on('click', function () {
        if (!$(this).hasClass('collapsed') && $('.fields-container').is(":visible")) {
          $('.view-fields-btn').trigger('click');
        }
      });
    // this.fields.forEach(f => {
    //   f.iconClasses = f.iconClasses || [];
    //   if (f.searchable) {
    //     f.iconClasses.push('fal fa-object-group fw-500 color-info-300');
    //   }
    //   if (f.groupable) {
    //     f.iconClasses.push('fa fa-filter color-danger-300');
    //   }

    //   this.fieldDict[f['n']] = f;
    // });
    var searchFieldsContainer = //showModalView ? searchGroupContainer.parents('.page-inner').find('.search-fields') :
      searchFieldsDom.find('.search-fields');
    this.searchField = new EditableMultiField({
      n: 'searchFields',
      d: 'Search Fields',
      hideIfEmpty: true,
      multiline: true,
      no_collapse: true,
      showResetButton: true,
      fields: this.fields,
    }, searchFieldsContainer, function (e) {
      if(e.action === "FieldSelected" || e.action === "Reset") {
        // debugger;
        this._selectedFilters = e.instance.readValue.call(e.instance);
        this._fireGroupingEvent();
      }
    }.bind(this));

    // Render the search field
    this.searchField.render(this._selectedFilters);

    // Fill the search fields
    // for (let i = 0; i < this.fields.length; i++) {
    //   this.searchField.addField(this.fields[i]);
    // }

    this.searchGroupField = new EditableTagField({
      n: 'searchGroupFields',
      d: 'Group By',
      choices: this.fields
    }, searchGroupContainer.find('.group-search-fields'), function (e) {
        // if (e.targetField.searchable) {
        //   if (e.action == 'select') {
        //     this.searchField.addField(e.targetField);
        //   }
        //   else if (e.action == 'unselect') {
        //     this.searchField.removeField(e.targetField);
        //   }
        // }
        if (e.targetField && e.targetField.groupable) {
          this._selectedGroups = e.instance.readValue.call(e.instance);
        }
        this._fireGroupingEvent();
      }.bind(this));

    if(this._selectedGroups) {
      this.searchGroupField.render(this._selectedGroups);
    }
    // if (showModalView) {
    //   this.renderOn.find('#searchFields').css('height', `${window.innerHeight - 65}px`);
    //   this._setStyles(this.renderOn.find('.modal'));
    // }
    // else {
    //   // searchFieldsDom.find('#searchFields').css('height', `${window.innerHeight - 180}px`);
    //   searchFieldsDom.find('#searchFields').css('height', 'calc(100vh - 90px)');
    //   this._setStyles(innerList.find('.search-fields'), searchFieldsDom.find('#searchFields'));
    // }
    searchFieldsDom.find('#searchFields').css('height', 'calc(100vh - 90px)');

    this._setStyles(this.renderFilterBoxOn.find('.search-fields'), searchFieldsDom.find('#searchFields'));

    this.renderGroupingBoxOn.find('.select2 ul').css('padding-right', '50px');
  }

  _appendGroupingButton($container) {
    $(`<button class="btn btn-sm btn-primary waves-effect waves-themed collapsed group-btn" type="button"
      data-toggle="collapse" aria-expanded="false">
      <div>
        <i class="fal fa-object-group color-info-300 mr-1"></i>Group
      </div>
    </button>`).appendTo($container);
  }

  _appendFilteringButton($container) {
    $(`<button class="btn btn-sm btn-primary waves-effect waves-themed view-fields-btn ml-1" type="button" 
      data-target=".search-fields-modal" data-toggle="tooltip" title="" data-original-title="Expand search fields">
      <i class="fa fa-search"></i> Search
    </button>`).appendTo($container);
  }

  _appendGroupingElement($container) {
    return $(`
      <!--<div class="searchGroupSummary" style="position: absolute; top: 130px; left: 184px;max-height: 33px !important;
      overflow: scroll;"></div>-->
      <div class='panel mb-2' style="border: none !important;">
      <div class="panel-container collapse searchGroupCollapse text-left">
        <div class="panel-content">
          <div class="search-grouping-box">
            <div class="form-group">
              <div class="group-search-fields"></div>
            </div>
          </div>
        </div>
      </div>
    </div>`).appendTo($container);
  }

  _fireGroupingEvent() {
    this.onFilteringGroupingCallback(this.selectedGroups, this.selectedFilters);
  }

  _setStyles(jq, searchField) {
    // Hack: Remove wrapping from each of the nested fields
    jq.find('.checklist-field')
      .removeClass('mw-410')
      .css({
        'max-height': '300px',
        'min-height': '85px',
        'overflow': 'hidden auto'
      });
    jq.find('.checklist-field .custom-checkbox')
      .removeClass('col-6')
      .addClass('col-12');
    // Highlight button for 2 seconds on each field select
    this.renderGroupingBoxOn.find('.view-fields-btn')
      .removeClass('btn-primary').addClass('btn-danger');
    setTimeout(() => {
      this.renderGroupingBoxOn.find('.view-fields-btn')
        .removeClass('btn-danger').addClass('btn-primary');
    }, 2000);
    if (searchField) {
      // set dynamic height for amenities field
      if ($('div[data-name="amenities"]').length) {
        var fieldsCount = $('.multifield-child').length - 1;
        var avgFieldHeight = 150;
        $('div[data-name="amenities"]').find('.checklist-field').css('max-height',
          `${(searchField.innerHeight() - 200) - (avgFieldHeight * fieldsCount)}px`);
      }
    }
  };

  get selectedGroups() {
    var groups = this._selectedGroups.map(f => {
      var field = this.fieldDict[f];
      if (field) {
        return {
          name: field['n'],
          display: field['d'] || field['n'],
          field: field
        }
      }
    });

    groups = groups.filter(g => g != undefined);
    return groups;
  }

  get selectedFilters() {
    return removeEmpty(this._selectedFilters);
  }
}

class Wizard {
  constructor(wire, renderOn, pagesInfo, finishCallback) {
    this.wizardDom = $(`<div id="smartwizard">
                        <ul id="wizardStepsList" style="width:100%;">                                    
                        </ul>
                        <div class="p-3" id="wizardPagesContainer">                                      
                        </div>
                    </div>`);

    this.wizardDom.appendTo(renderOn);

    var wizardStepsListContainer = this.wizardDom.find('#wizardStepsList');
    this.wizardPagesContainer = this.wizardDom.find('#wizardPagesContainer');

    // var pointMaxWidth = (100 / pagesInfo.length) - 1;
    var listPointsAsString = "";
    var pagesAsString = "";
    this.wizardDict = {};
    for (var i = 0; i < pagesInfo.length; i++) {
      listPointsAsString += '<li><a href="#' + pagesInfo[i].id + '">' + pagesInfo[i].title + '<br><small>' +
        (pagesInfo[i].description ? pagesInfo[i].description : "") + '</small></a></li>';
      pagesAsString += '<div id="' + pagesInfo[i].id + '" class=""></div>';

      this.wizardDict[pagesInfo[i].id] = {
        nextBtnText: pagesInfo[i].nextBtnText,
        getUnrollObject: pagesInfo[i].getUnrollObject,
        unrollObject: ""
      }
    }
    wizardStepsListContainer.append(listPointsAsString);
    this.wizardPagesContainer.append(pagesAsString);

    // Smart Wizard
    $('#smartwizard').smartWizard(
      {
        selected: 0, // Initial selected step, 0 = first step 
        keyNavigation: true, // Enable/Disable keyboard navigation(left and right keys are used if enabled)
        autoAdjustHeight: false, // Automatically adjust content height
        cycleSteps: false, // Allows to cycle the navigation of steps
        backButtonSupport: true, // Enable the back button support
        useURLhash: false, // Enable selection of the step based on url hash
        showStepURLhash: false,
        lang:
        { // Language variables
          next: 'Next',
          previous: 'Previous'
        },
        toolbarSettings:
        {
          toolbarPosition: 'bottom', // none, top, bottom, both
          toolbarButtonPosition: 'right', // left, right
          showNextButton: true, // show/hide a Next button
          showPreviousButton: true, // show/hide a Previous button
          toolbarExtraButtons: [
            $('<button></button>').text('Finish').css('display', 'none')
              .addClass('btn btn-primary btn-finish')
              .attr('type', 'submit')
              .on('click', function () {
                var wizradPages = this.wizardPagesContainer.find("div.tab-pane.step-content");
                var wizardValues = {};

                for (var j = 0; j < wizradPages.length; j++) {
                  try {
                    wizardValues = $.extend(wizardValues, WIRE.getEditableValues(wizradPages[j]['id']));
                  }
                  catch (error) {
                    console.error(error);
                  }
                }
                // var tableRows = "";
                // var array = $.map(wizardValues, function (value, index) {
                //   tableRows += '<tr><th scope="row">' + index + '</th><td>' + value + '</td>';
                //   //return [value];
                //   return [{ name: index, val: value }]
                // });

                // var table = $(`<table class="table table-striped m-0"> <tbody></tbody></table>`);
                // table.find('tbody').append(tableRows);

                if (finishCallback && $.isFunction(finishCallback)) {
                  finishCallback(wizardValues);
                }

                // this.currentPage.empty();
                // this.currentPage.append(table);

              }.bind(this)),
            /* $('<button></button>').text('Cancel')
                           .addClass('btn btn-danger')
                           .on('click', function(){ 
                         alert('Cancel button click');                            
                           })*/
          ]
        },
        anchorSettings:
        {
          anchorClickable: true, // Enable/Disable anchor navigation
          enableAllAnchors: false, // Activates all anchors clickable all times
          markDoneStep: true, // add done css
          enableAnchorOnDoneStep: true // Enable/Disable the done steps navigation
        },
        contentURL: null, // content url, Enables Ajax content loading. can set as data data-content-url on anchor
        contentCache: true, //ajax content
        disabledSteps: [], // Array Steps disabled
        errorSteps: [], // Highlight step with errors
        theme: 'default', //dots, default, circles
        // transitionEffect: 'slide', // Effect on navigation, none/slide/fade
        // transitionSpeed: '400',
      });

    this.currentPage = this.wizardPagesContainer.find("div.tab-pane.step-content").filter(function () {
      return $(this).index() === $('#smartwizard').data('smartWizard').current_index;
    });
    this.nextButton = this.wizardDom.find('.btn.sw-btn-next');
    this.finishButton = this.wizardDom.find('.btn.btn-finish');

    var wizardPages = this.wizardPagesContainer.find("div.tab-pane.step-content");

    // Add Custom Transition Effects
    wizardPages.addClass('step-forward');

    // 
    // for (var i = 0; i < wizardPages.length; i++) {
    //   $(wizardPages[i]).on('input', function () {
    //     this.NextButtonEnabling(wire);
    //   }.bind(this));
    // }   

    $('#smartwizard').on("showStep", function (e, anchorObject, stepNumber, stepDirection, stepPosition) {
      this.currentPage = this.wizardPagesContainer.find("div.tab-pane.step-content").filter(function () {
        return $(this).index() === stepNumber;
      });

      // Add custom transition effects
      if (stepDirection == "backward") {
        this.currentPage.addClass('step-backward');
        this.currentPage.removeClass('step-forward');
      } else {
        this.currentPage.addClass('step-forward');
        this.currentPage.removeClass('step-backward');
      }

      // Disappear "Next" Button in last page, and view "Finish" button    
      if (stepPosition == 'final') {
        this.nextButton.css('display', 'none');
        this.finishButton.css('display', 'block');
      } else {
        this.nextButton.css('display', 'block');
        this.finishButton.css('display', 'none');
      }

      var currentPageId = this.currentPage.attr('id');
      this.renderPage(wire, this.wizardDict[currentPageId]);

    }.bind(this));
  }

  renderPage(wire, targetWizardDictValue) {
    // this.currentPage = this.currentPage ||
    //   this.wizardPagesContainer.find("div.tab-pane.step-content").filter(function () {
    //     return $(this).index() === $('#smartwizard').data('smartWizard').current_index;
    //   });

    var currentPageId = this.currentPage.attr('id');
    var cachedUnrollObject = this.wizardDict[currentPageId].unrollObject;
    var newUnrollObject = targetWizardDictValue.getUnrollObject(this.currentPage);
    if (JSON.stringify(cachedUnrollObject) != JSON.stringify(newUnrollObject)) {
      this.currentPage.empty();
      wire.unrollRecursive(newUnrollObject, this.currentPage);
      this.currentPage.find('.form-label img.icon').css('object-fit', 'unset');
      this.wizardDict[currentPageId].unrollObject = newUnrollObject;
    }

    this.nextButton.text(targetWizardDictValue.nextBtnText);

    // disable & enable (next & finish) buttons
    this.NextButtonEnabling(wire);

    this.currentPage.on('input', function () {
      this.NextButtonEnabling(wire);
    }.bind(this));
  }

  NextButtonEnabling(wire) {
    var allValuesFilled = false;
    try {
      var pageValues = wire.getEditableValues(this.currentPage.attr("id"));
      allValuesFilled = true;
      // for (var key in pageValues) {
      //   if (!pageValues[key]) {
      //     allValuesFilled = false;
      //     break;
      //   }
      //   else {
      //     allValuesFilled = true;
      //   }
      // }
    }
    catch (error) {
      allValuesFilled = false;
      //console.error(error);
    }

    if (!allValuesFilled) {
      this.nextButton.attr("disabled", "");
      this.finishButton.attr("disabled", "");
    }
    else {
      this.nextButton.removeAttr("disabled");
      this.finishButton.removeAttr("disabled");
    }
  }
}

/**
 * Shows wizard for registering for wallet type
 * @param {Array<string>} whitelistWalletTypes If given, must be wallet types (ignoring suffix) e.g. ['tenant', 'landlord']
 *   Only the given types will be shown for registration. If not given, all wallet types will be shown.
 */
var popupRegisterWalletWizard = function (whitelistWalletTypes = null) {
  // var walletsList = [
  //   { name: 'Admin', title: 'Admin' },
  //   { name: 'Landlord', title: 'Landlord' },
  //   { name: 'MasterTenant', title: 'Master Tenant' },
  //   { name: 'PropertyManager', title: 'Property Manager' },
  //   { name: 'Broker', title: 'Broker' },
  //   { name: 'ServiceProvider', title: 'Service Provider' },
  // ];
  // var unregisteredWallets = walletsList.filter(comparer(registeredWallets));

  // var accounts = [];
  // var accountToIconMap = {
  //   Admin: "admin",
  //   Broker: "broker",
  //   Landlord: "landlord",
  //   PropertyManager: "pm",
  //   ServiceProvider: "sp",
  //   MasterTenant: "tenants",
  //   tenant: "tenants"
  // };
  // unregisteredWallets.forEach(w => {
  //   accounts.push({ n: w.name, d: w.title, icon: `/www/icons/accounts/${accountToIconMap[w.name]}.svg` });
  // })
  // var schema = [
  //   {
  //     'n': 'accounts', 'd': 'Accounts', 't': 'buttoncategorical',
  //     'choices': accounts
  //   }
  // ];
  // var editableObject = u('EditableObject', ['btnChoices', { 'fields': schema }]);
  // WIRE.modal('Select Account', u('Form', ["", [editableObject]]));

  var walletChoices = [
    { "n": "tenant", "d": "Tenant", "icon": "/www/icons/accounts/tenants.svg" },
    { "n": "landlord", "d": "Landlord", "icon": "/www/icons/accounts/landlord.svg" },
    { "n": "sp", "d": "Service Provider", "icon": "/www/icons/accounts/sp.svg" },
    { "n": "pm", "d": "Property Manager", "icon": "/www/icons/accounts/pm.svg" },
    { "n": "fm", "d": "Facility Manager", "icon": "/www/icons/accounts/fm.svg" }
  ];
  var registerdWalletTypes = new Set(WIRE.getRegisteredWalletTypes());
  walletChoices = walletChoices.filter(choice => !registerdWalletTypes.has(choice['n']));
  if (whitelistWalletTypes) {
    whitelistWalletTypes = new Set(whitelistWalletTypes);
    walletChoices = walletChoices.filter(choice => !whitelistWalletTypes.has(choice['n']));
  }

  /**
   * IMPORTANT NOTE:
   * Now we will not check the registered wallets here, 
   * since this checking will be when rendering "Register" button,
   * so if user has all wallets, the btn will be hidden 
   */
  // if (walletChoices.length == 0) {
  //   WIRE.informModal('Cannot register for wallets. User already has all required wallet types.');
  //   return;
  // }
  var userAccount = WIRE.d(WIRE.data.account);
  var pagesInfo = [
    {
      id: "step-1", title: "Wallet Type", description: "",
      nextBtnText: "Next",
      getUnrollObject: function (currentPageDom) {
        var schema = {
          fields: [
            {
              "n": "application_type",
              "d": "Wallet Type",
              "t": "buttoncategorical",
              "r": 1,
              "choices": walletChoices,
            }
          ]
        };//wire.schemaManager.schema["wallet_type_application"];
        var unrollObject = "";
        if (schema) {
          var fields = schema.fields;
          // editable
          var editableObjectName = currentPageDom.attr('id');
          if (fields.length > 0) {
            unrollObject = u("Form", ["",
              [
                u("EditableObject", [editableObjectName,
                  {
                    fields: fields
                  }
                ])
              ]
            ]);
          } else {
            unrollObject = u("EditableObject", [editableObjectName,
              {
                fields: fields
              }
            ]);
          }
        }
        return unrollObject;
      }
    },
    {
      id: "step-2", title: "Account Type", nextBtnText: "Next",
      getUnrollObject: function (currentPageDom) {
        var fields = [{
          n: "account_type", d: "Account Type", t: "radio",
          choices: [{ n: "Individual", d: "Individual" }, { n: "Company", d: "Company" }],
          isVertical: true,
          default_value: "Individual"
        }];


        var editableObjectName = currentPageDom.attr('id');;
        var unrollObject = u("Form", ["",
          [
            u("EditableObject", [editableObjectName,
              {
                fields: fields
              }
            ])
          ]
        ]);

        return unrollObject;
      }
    },
    {
      id: "step-3", title: "General Information", nextBtnText: "Next",
      getUnrollObject: function (currentPageDom) {
        //get previous values and decide this step values
        var wizardValues = {};

        for (var j = 0; j < currentPageDom.index(); j++) {
          try {
            wizardValues = $.extend(wizardValues, WIRE.getEditableValues(pagesInfo[j]['id']));
          }
          catch (error) {
            console.error(error);
          }
        }

        var accountType = wizardValues ? (wizardValues['account_type'] || "Individual") : "Individual";
        var walletType = wizardValues ? wizardValues['application_type'] : "";
        var fields = []; // { n: "Name", d: "Name", t: "text" }];

        switch (accountType) {
          case "Individual":
            fields = fields.concat([
              { n: "name", d: "Name", t: "text", "default_value": userAccount.name },
              { n: "national_id_number", d: "Emirates ID Number", t: "number" },
              { n: "national_id_photo", d: "National ID Photo", t: "photo" },
              { n: "photo", d: "Profile Photo", t: "photo", default_value: userAccount.photo || userAccount.picture },
            ]);
            break;
          case "Company":
            fields = fields.concat([
              { n: "company_name", d: "Company Name", t: "text", "default_value": userAccount.name },
              { n: "Size of Employees", d: "Size of Employees", t: "number" },
              { n: "Services", d: "Services", t: "categorical", choices: [] },
              { n: "Trade Licences Expiry Date", d: "Trade Licences Expiry Date", t: "date" },
              { n: "TRN number", d: "TRN number", t: "number" },
              { n: "company_logo", d: "Company Logo", t: "photo" },
              {
                "n": "trade_licences", "d": "Trade Licences", "t": "file",
                "accepted_mime_types": ["application/pdf", "image/png", "image/jpeg"]
              },
              {
                "n": "tax_certificate",
                "d": "Tax Certificate",
                "t": "file",
                "accepted_mime_types": ["application/pdf", "image/png", "image/jpeg"]
              }
            ]);
            break;
        }

        switch (walletType) {
          case "pm":
            break;
          case "Broker":
            break;
          case "sp":
            fields = [...new Set(fields.concat([
              { n: "Supplier Type", d: "Supplier Type", t: "categorical", choices: ["Supplier", "Employee"] },
              { n: "Supplier Category", d: "Supplier Category", t: "categorical", choices: [] },
              { n: "Supplier Registered for VAT", d: "Supplier Registered for VAT", t: "bool" },
              { n: "Commercial License Number", d: "Commercial License Number", t: "number" },
              { n: "License Number Expiry Date", d: "License Number Expiry Date", t: "date" }]))];
            break;
          case "tenant":
            break;
        }

        var editableObjectName = currentPageDom.attr('id');;

        var unrollObject = u("Form", ["",
          [
            u("EditableObject", [editableObjectName,
              {
                fields: fields
              }
            ])
          ]
        ]);

        return unrollObject;
      }
    },
    {
      id: "step-4", title: "Contact Information", nextBtnText: "Next",
      getUnrollObject: function (currentPageDom) {
        //get previous values and decide this step values
        var wizardValues = {};

        for (var j = 0; j < currentPageDom.index(); j++) {
          try {
            wizardValues = $.extend(wizardValues, WIRE.getEditableValues(pagesInfo[j]['id']));
          }
          catch (error) {
            console.error(error);
          }
        }

        var accountType = wizardValues ? wizardValues['application_type'] : "";
        var walletType = wizardValues ? wizardValues['Wallet Type'] : "";
        var fields = [
          { n: "email", d: "Email", t: "email", "default_value": userAccount.email },
          { n: "phone", d: "Phone Number", t: "phone", "default_value": userAccount.cell },
        ];

        switch (walletType) {
          case "Individual":
            break;
          case "Company":
            fields = fields.concat([{ n: "address", d: "Address", t: "addresslatlng" }]);
            break;
        }

        switch (accountType) {
          case "pm":
            break;
          case "Broker":
            break;
          case "sp":
            fields = fields.concat([
              /*  { n: "Address Line 1", d: "Address Line 1", t: "text" },
                { n: "Address Line 2", d: "Address Line 2", t: "text" },
                { n: "region", d: "Region/Area", t: "text" },
                { n: "city", d: "City", t: "text" },
                { n: "state", d: "State/County", t: "text" },
                { n: "country", d: "Country", t: "text" },
                { n: "zip_code", d: "Zip Code", t: "text" }, 
                { n: "supplier_name", d: "Supplier Contact Name", t: "text" } */
            ]);
            break;
          case "tenant":
            break;
        }

        var editableObjectName = currentPageDom.attr('id');;

        var unrollObject = u("Form", ["",
          [
            u("EditableObject", [editableObjectName,
              {
                fields: fields
              }
            ])
          ]
        ]);

        return unrollObject;
      }
    },
    /*{
      id: "step-5", title: "Terms And Bank Details", nextBtnText: "Next",
      getUnrollObject: function (currentPageDom) {
        //get previous values and decide this step values
        var wizardValues = {};

        for (var j = 0; j < currentPageDom.index(); j++) {
          try{
            wizardValues = $.extend(wizardValues, wire.getEditableValues(pagesInfo[j]['id']));
          }
          catch (error) {
            console.error(error);
          }
        }

        var accountType = wizardValues ? wizardValues['application_type'] : "";
        var walletType = wizardValues ? wizardValues['Wallet Type'] : "";
        var fields = [{ n: "Bank Name", d: "Bank Name", t: "text" },
        { n: "Bank Account Name", d: "Bank Account Name", t: "text" },
        { n: "Bank Account Number", d: "Bank Account Number", t: "number" },
        { n: "Bank Account IBAN Number", d: "Bank Account IBAN Number", t: "text" }];

        switch (walletType) {
          case "Individual":
            break;
          case "Company":
            break;
        }

        switch (accountType) {
          case "pm":
            break;
          case "Broker":
            break;
          case "sp":
            fields = fields.concat([{ n: "Currency", d: "Currency", t: "categorical", choices: ["USD", "AED"] },
            { n: "Payment Terms", d: "Payment Terms", t: "text" },
            { n: "Delivery Terms", d: "Delivery Terms", t: "text" },
            { n: "Bank Account SWIFT Details", d: "Bank Account SWIFT Details", t: "text" }]);
            break;
          case "tenant":
            break;
        }

        var editableObjectName = currentPageDom.attr('id');;
        
        var unrollObject = u("Form", ["",
            [
              u("EditableObject", [editableObjectName,
                {
                  fields: fields
                }
              ])
            ]
          ]);
        
        return unrollObject;
      }
    }*/
  ]
  if ($('#myWizard').length == 0) {
    var modal = WIRE.popupWizard(pagesInfo, "Register", function (wizardValues) {
      var saveArgs = { 'ref': 'account_create_wallet', 'type': 'wallet_type_application', 'fields': wizardValues };
      WIRE.call('interactions::save_node', saveArgs, function (response) {
        WIRE.informModal("Application has been filed.");
        modal.close();
      });
    });
  };
};

var showRegisterBtnInWalletWizard = function (whitelistWalletTypes = null) {
  var shown = true;
  var walletChoices = [
    { "n": "tenant", "d": "Tenant", "icon": "/www/icons/accounts/tenants.svg" },
    { "n": "landlord", "d": "Landlord", "icon": "/www/icons/accounts/landlord.svg" },
    { "n": "sp", "d": "Service Provider", "icon": "/www/icons/accounts/sp.svg" },
    { "n": "pm", "d": "Property Manager", "icon": "/www/icons/accounts/pm.svg" },
    { "n": "fm", "d": "Facility Manager", "icon": "/www/icons/accounts/fm.svg" }
  ];
  var registerdWalletTypes = new Set(WIRE.getRegisteredWalletTypes());
  walletChoices = walletChoices.filter(choice => !registerdWalletTypes.has(choice['n']));
  if (whitelistWalletTypes) {
    whitelistWalletTypes = new Set(whitelistWalletTypes);
    walletChoices = walletChoices.filter(choice => !whitelistWalletTypes.has(choice['n']));
  }
  if (walletChoices.length == 0) {
    shown = false;
  }
  return shown;
};

var firstKey = function (dict) {
  for (var k in dict) {
    return k;
  }
  return null;
};

// // Return all fields and its related fields info
// var getItemFieldsDetails = function (wire, itemType) {
//   var fields = wire.itemManager.schema[itemType] ? wire.itemManager.schema[itemType].fields : [];
//   return fields;  // TODO(rawa): Fix this infinit recursion
//   if (fields.length > 0) {
//     fields = getItemFieldsAndSubFields(wire, fields);
//   }
//   return fields;
// }

// // Return all fields and its related fields info
// var getItemFieldsAndSubFields = function (wire, itemFields) {
//   var newFields = itemFields;
//   newFields.forEach(function (field, index) {
//     if (field.type == 'List' && field.name != "Photos") {
//       var subFields = wire.itemManager.schema[field.typeargs[0]] ?
//         wire.itemManager.schema[field.typeargs[0]].fields : [];
//       if (subFields.length > 0) {
//         newFields[index]['children'] = subFields;
//         getItemFieldsAndSubFields(wire, subFields);
//       }
//     }
//   });
//   return newFields;
// }

// // Return all fields and its related fields info
// var getItemFieldsDetails = function (wire, itemType) {
//   var fields = wire.itemManager.schema[itemType] ? wire.itemManager.schema[itemType].fields : [];
//   // return fields; // TODO(rawa): Fix this infinit recursion
//   debugger;   
//   // This is a workaround until teat the infinite recursion (ask Sami)
//   if (itemType.toLowerCase() == "ledger") {
//     return fields;
//   }
//   if (fields.length > 0) {
//     fields = getItemFieldsAndSubFields(wire, fields, itemType);
//   }
//   return fields;
// }

// Return all fields and its related fields info (sub fields)
var getItemFieldsAndSubFields = function (itemFields, itemType) {
  var newFields = itemFields;
  if (itemType && itemType.toLowerCase() == "ledger") {
    return itemFields;
  }

  newFields.forEach(function (field, index) {
    if (field.type == 'List' && itemType != field.typeargs[0]) {
      var itemSchema = WIRE.itemManager.schema[field.typeargs[0]];
      var subFields = itemSchema ? itemSchema.fields : [];
      if (subFields.length > 0) {
        //subFields = subFields.filter(f => f != field);
        newFields[index]['subFields'] = subFields;
        getItemFieldsAndSubFields(subFields, field.typeargs[0]);
      }
    }
  });
  return newFields;
};

var getItemIcon = function (itemType) {
  var icon = WIRE.itemManager.schema[itemType] ?
    WIRE.itemManager.schema[itemType].icon : "";
  return icon;
};

var getMainPhoto = function (item) {
  var mainPhoto;
  if (item && item.Photos && item.Photos.length > 0 && item.Photos[0]) {
    mainPhoto = WIRE.d(item.Photos[0]).picture;
  }
  return mainPhoto;
};

function _test2() {
  var testtt = {
    "fields": [
      { 'n': 'tag', 't': 'multiobject', 'listFnName': 'interaction:ref:tag-create', 'max': 1 },
      { 'n': 'offer_call', 't': 'multiobject', 'listFnName': 'interaction:ref:offercall-create', 'max': 1 },
      { 'n': 'items', 't': 'multiobject', 'listFnName': 'getRentableItems' }
    ]
  }
  WIRE.modal('test', u('EditableObject', ['test', testtt]), [], { sizeMode: "full" });
}


function promptNewProperty() {
  WIRE.modal('Create New Property: Choose type', u('AJS', ['item/designer_new', {}]));
}

function _test3() {


  var testtt = {
    "fields": [
      { "n": "name", "d": "Name" },
      { "n": "pm_qualifications", "d": "Qualified PMs", "t": "multiobject", "listFnName": "interaction:ref:qualified-fms" },
      {
        "n": "service_scope", "t": "table", "d": "Scope of Service: Realestate Properties & Fees", "add_caption": "Realestate", "title_dom": "<h2 style='padding-top: 10px'>", "fields": [
          { "t": "multiobjectgroup", "n": "items", "d": "Realestate Properties (grouped)", "listFnName": "getRentableItems" },
          { "n": "sign_commission_percent", "d": "Signing Commission (Percent)", "t": "numeric" },
          { "n": "monthly_fee_percent", "d": "Monthly Fee (Percent)", "t": "numeric" },
          { "n": "ledger", "d": "Financial Account", "t": "multiobject", "listFnName": "interaction:ref:landlord-ledgers", "max": 1 }
        ]
      },
      {
        "n": "kpis", "t": "table", "d": "Key Performance Indicators (KPIs)", "title_dom": "<h2>", "fields": [
          { "n": "kpi", "d": "KPI", "t": "longtext" },
          { "n": "weight", "d": "Weight", "t": "numeric" }
        ], "default_value": [
          { "kpi": "Implementation and monitoring of PPM", "weight": 100 },
          { "kpi": "Ensure all units are fit to live before handing over", "weight": 100 },
          { "kpi": "Response time to routine/normal/emergency call outs as per agreed timeframes", "weight": 100 }
        ]
      }
    ]
  };


  WIRE.modal('test', u('EditableObject', ['test', testtt]), [], { sizeMode: "full" });

  //pm_service_scope

}

function _testUI() {
  var testtt = {
    "fields": [
      {
        "n": "service_scope", "t": "table", "d": "Scope of Service: Realestate Properties & Services", "add_caption": "Scope", "title_dom": "<h2 style='padding-top: 10px'>", "fields": [
          { "t": "multiobjectgroup", "n": "items", "d": "Realestate Properties (grouped)", "listFnName": "getRentableItems" },

          {
            "n": "services", "add_caption": "Services and Account", "d": "Requested Services / Materials; Accounting", "t": "table", "fields": [
              {
                "t": "table", "add_caption": "Service", "n": "services", "d": "Services", "fields": [
                  { "n": "service", "d": "Service" },
                  { "n": "frequency", "t": "numeric" }
                ]
              },
              {
                "t": "table", "add_caption": "Material", "n": "materials", "d": "Materials", "fields": [
                  { "n": "material", "d": "Material" },
                  { "n": "quantity", "t": "numeric" }
                ]
              },
              { "n": "ledger", "d": "Financial Account", "t": "multiobject", "listFnName": "interaction:ref:landlord-ledgers", "max": 1 }
            ]
          }
        ],

      },
      {
        "n": "kpis", "t": "table", "d": "Key Performance Indicators (KPIs)", "title_dom": "<h2>", "fields": [
          { "n": "kpi", "d": "KPI", "t": "longtext" },
          { "n": "weight", "d": "Weight", "t": "numeric" }
        ], "default_value": [
          { "kpi": "Implementation and monitoring of PPM", "weight": 100 },
          { "kpi": "Ensure all units are fit to live before handing over", "weight": 100 },
          { "kpi": "Response time to routine/normal/emergency call outs as per agreed timeframes", "weight": 100 }
        ]
      }
    ]
    /*


    */
    // Reactive: Response to maintanance calls
    // Proactive: 
  }


  WIRE.modal('test', u('EditableObject', ['test', testtt]), [], { sizeMode: "full" });

}

/**
 * Pops-up UI for customizing Calendar settings for the logged-in email.
 */
function popupCalendarSettings() {
  WIRE.call('business::get_calendar_availability_settings', null, function (response) {
    WIRE.popupObjectView(WIRE.d(response['_objs'][0]));
    //console.log('response for get_calendar_availability_settings', response);
  });
}

function makeRangeValidator(minVal, maxVal) {
  var validator = function (obj, val) {
    if (minVal != null) {
      if (minVal > val) {
        return "Must be greater than " + minVal;
      }
    }
    if (maxVal != null) {
      if (maxVal < val) {
        return "Must be smaller than " + maxVal;
      }
    }
  };
  return validator;
}

function validateNoShiftsOverlap(obj, value) {
  console.log('NO DATES OVERLAP VALIDATE: IMPLEMENT');
  var sortedEvents = [];
  //debugger;
  for (var i = 0; i < value.length; i += 1) {
    var shift = value[i];
    var shiftStart = (shift['start']['hour'] || 0) * 60 + (shift['start']['minute'] || 0);
    var shiftEnd = (shift['end']['hour'] || 24) * 60 + (shift['end']['minute'] || 0);
    if (shiftEnd < shiftStart) {
      return 'Shift ' + (i + 1) + ' ends before it starts.';
    }
    var startStr = [shiftStart, 'a', i].join('_');
    while (startStr.length < 8) {
      startStr = '0' + startStr;
    }
    var endStr = [shiftEnd, 'b', i].join('_');
    while (endStr.length < 8) {
      endStr = '0' + endStr;
    }
    sortedEvents.push(startStr);
    sortedEvents.push(endStr);
  }

  sortedEvents.sort();
  for (var i = 0; i < sortedEvents.length / 2; i += 1) {
    var pos1 = Number(sortedEvents[i * 2].split('_')[2]);
    var pos2 = Number(sortedEvents[1 + i * 2].split('_')[2]);
    if (pos1 != pos2) {
      return `Overlapping shifts on positions ${pos1 + 1} and ${pos2 + 1}`;
    }
  }
}

function validateNoDatesOverlap(obj, value) {
  value = value.filter(v => v && v.daterange && v.daterange.start && v.daterange.end);

  var sortedEvents = (value.map((a, i) => [a.daterange.start, 'a', i].join('_')).concat(
    value.map((a, i) => [a.daterange.end, 'b', i].join('_')))).sort();
  for (var i = 0; i < value.length; i += 1) {
    var pos1 = Number(sortedEvents[i * 2].split('_')[2]);
    var pos2 = Number(sortedEvents[1 + i * 2].split('_')[2]);
    if (pos1 != pos2) {
      return `Overlapping dates on positions ${pos1 + 1} and ${pos2 + 1}`;
    }
  }
}

/**
 * Calculates list of allowed appointment slots. All slots will start and finish within
 * `timeslot`, will be of duration `appointmentDuration`, and will start at a minute
 * divisible by `ticks`.
 * @param {number} appointmentDuration in minutes
 * @param {Object<string, Object<string, number>>} timeslot contains 4 quantities {f, t}.{h, m} for {"from", "to"}.{"hours", "minutes"}
 * @param {number} ticks the timestamp (in minutes) where appointments are allowed to start.
 *   If == 15, then appointments can start at the hour, at :15, at :30, or at :45. If == 60, then it must start at the hour.
 */
function calculateAppointmentSlots(appointmentDuration, timeslot, ticks) {
  var start = timeslot['f']['h'] * 60 + timeslot['f']['m'];
  var end = timeslot['t']['h'] * 60 + timeslot['f']['m'];
  if (ticks == 0) {
    ticks = 60;
  }
  var appointmentSlots = [];
  for (var i = start; i <= end - appointmentDuration; i += ticks) {
    var j = i + appointmentDuration;
    var fromH = Math.floor(i / 60);
    var fromM = i % 60;
    var toH = Math.floor(j / 60);
    var toM = i % 60;
    appointmentSlots.push({ 'f': { 'h': fromH, 'm': fromM }, 't': { 'h': toH, 'm': toM } });
  }

  return appointmentSlots;
}

/**
 * Returns dict e.g. like {year: 2020, month: 05, day: 28}
 * @param {number} dayInt E.g. like 20200528
 */
function parseIntDay(dayInt) {
  var year = parseInt(dayInt / 10000);
  var month = parseInt((dayInt % 10000) / 100);
  var day = dayInt % 100;
  return { year: year, month: month, day: day };
}

function isObjectId(maybeObjId) {
  return typeof (maybeObjId) == 'string' && maybeObjId.startsWith('!obj!');
}

/**
 * Returns integer representing today: YYYYMMDD
 */
function todayAsInt() {
  var date = new Date();
  return date.getFullYear() * 10000 + (1 + date.getMonth()) * 100 + date.getDate();
}

/**
 * Returns date string e.g. like '2020-4-8'
 * @param {number} timeStamp E.g. like 1596550028.47
 */
function parseTimeStamp(timeStamp) {
  var date = new Date(timeStamp * 1000);
  var mm_dd_yyyy = date.toLocaleDateString('en-US');
  var yyyy_mm_dd = mm_dd_yyyy.replace(/(\d+)\/(\d+)\/(\d+)/g, "$3/$1/$2");
  return yyyy_mm_dd;
}

function makePaymentsScheduleFn(durationFieldName) {
  function _helper(fieldInstance, preset) {
    var durationField = fieldInstance.siblings? fieldInstance.siblings.parent.siblings.searchAll(durationFieldName)[0]: null;
    if (!durationField) {
      console.error('Cannot find field with name ' + durationFieldName);
      return [];
    }

    var durationValue = durationField.readValue();
    if (!durationValue['start_day']) {
      WIRE.errorMessageModal('You must select a start day');
      return [];
    }
    var curDay = durationValue['start_day'];
    curDay = parseIntDay(curDay);
    var numOccurances = preset['num_payments'] || preset['numberofpayments'];
    var payments = [];
    for (var i = 0; i < numOccurances; i += 1) {
      var nextDay = addDays(curDay, i, preset['per']);
      payments.push({
        'day': nextDay.year * 10000 + nextDay.month * 100 + nextDay.day,
        'amount': preset['amount'],
        'currency': preset['currency'],
      });
    }
    return payments;
  }
  return _helper;
}

// https://stackoverflow.com/questions/2706125/javascript-function-to-add-x-months-to-a-date/2706169
function addMonths(date, count) {
  if (date && count) {
    var m, d = (date = new Date(+date)).getDate()

    date.setMonth(date.getMonth() + count, 1)
    m = date.getMonth()
    date.setDate(d)
    if (date.getMonth() !== m) date.setDate(0)
  }
  return date
}

/**
 * 
 * @param {Object} dayObj with keys `year`, `month`, `day`.
 * @param {Number} increment 
 * @param {string} unit one of 'year', 'quarter', 'day', 'month'.
 */
function addDays(dayObj, increment = 1, unit = 'day') {
  if (unit == 'quarter') {
    unit = 'month';
    increment = increment * 3;
  }
  var incrementedDay = new Date(
    dayObj.year + (increment * (unit == 'year')),
    dayObj.month - 1 + (increment * (unit == 'month')),
    dayObj.day + (increment * (unit == 'day')));

  return {
    year: incrementedDay.getFullYear(),
    month: incrementedDay.getMonth() + 1,
    day: incrementedDay.getDate(),
  };
}

function drawCategoryCollapseButton(container) {
  var btn = $(`
    <button type="button" id="collapsable-btn" class="btn btn-sm btn-primary waves-effect waves-themed mb-2">
      <span class="fa fa-angle-double-up mr-1"></span><span class="btn-text">Collapse All</span>
    </button>`);
  container.prepend(btn);
  btn.click(function () {
    var text = btn.find('.btn-text').text();
    if (text.trimAll() === 'CollapseAll') {
      btn.find('.fa').removeClass('fa-angle-double-up');
      btn.find('.fa').addClass('fa-angle-double-down');
      btn.find('.btn-text').text('Expand All');
      container.find(".panel-hdr").not('.panel-hdr[aria-expanded="false"]').click();
    } else {
      btn.find('.fa').removeClass('fa-angle-double-down');
      btn.find('.fa').addClass('fa-angle-double-up');
      btn.find('.btn-text').text('Collapse All');
      container.find('.collapsed').click();
    }
  });
}

function checkPasswordValidation(jqElement) {
  var isValid = false;
  if (IsPassword(jqElement.val())) {
    isValid = true;
    jqElement.parent().find('.help-block').remove();
    valid(jqElement);
  } else {
    isValid = false;
    jqElement.parent().find('.help-block').remove();
    invalid(jqElement);
    appendErrorMsg("Please enter a valid password!.", jqElement.parent());
    if (jqElement.find('.help-block').length == 0) {
      jqElement.parent().append(`<div class="help-block" style="width: 207px;">Your password must be 8-20 characters long, contain letters and numbers, and at least one UPERCASE letter.</div>`);
    };
  };
  return isValid;
}

function IsPassword(password) {
  // at least one number, one lowercase and one uppercase letter
  // at least eight characters
  // without special characters
  var re = /^(?=.*\d)(?=.*[a-z])(?=.*[A-Z])(?=.*[a-zA-Z]).{8,}$/;
  if (!password || !re.test(password)) {
    return false;
  } else {
    return true;
  };
};

function IsEmail(obj, email) {
  var regex = /^([a-zA-Z0-9_\.\-\+])+\@(([a-zA-Z0-9\-])+\.)+([a-zA-Z0-9]{1,4})+$/;
  if (!regex.test(email)) {
    return false;
  } else {
    return true;
  };
};

// function to append error msgz each on input group parent
function appendErrorMsg(msg, jqParent) {
  if (jqParent.find('.invalid-feedback').length == 0) {
    jqParent.append(`<div class="invalid-feedback m-0">${msg}</div>`);
  } else {
    jqParent.find('.invalid-feedback').text(msg);
  };
};

// style the valid field :
function valid(jqElement) {
  jqElement.removeClass('is-invalid').addClass('is-valid')
};
// style the invalid vield :
function invalid(jqElement) {
  jqElement.removeClass('is-valid').addClass('is-invalid');
};

function validateRegiterFormInputs(jsInputsContainer) {
  jsInputsContainer.find('input').on("keyup", function () {
    switch ($(this).attr('id')) {
      case 'name': {
        if ($(this).val()) {
          valid($(this));
        } else {
          invalid($(this));
          appendErrorMsg("Please enter your name!", $(this).parent());
        };
        break;
      }
      case 'email': {
        var email = $(this).val();
        if (IsEmail(null, email)) {
          valid($(this));
        } else {
          invalid($(this));
          appendErrorMsg("Please enter a valid email!", $(this).parent());
        };
        break;
      };
      case 'cellphone': {
        var phoneValue = $(this).val();
        if (Number(phoneValue)) {
          valid($(this));
        } else {
          invalid($(this));
          appendErrorMsg("Please enter a valid phone number!", $(this).parent());
        }
        break;
      };
      case 'password': {
        var me = $(this);
        var confirmPasswordInput = jsInputsContainer.find('#confirmPassword');
        if (checkPasswordValidation(me)) {
          if (confirmPasswordInput.val() != "" &&
            me.val() == confirmPasswordInput.val()) {
            valid(me);
            valid(confirmPasswordInput);
          } else {
            invalid(confirmPasswordInput);
            appendErrorMsg("Password not correctly repeated.!", confirmPasswordInput.parent());
          }
        } else {
          if (confirmPasswordInput.val() != "") {
            invalid(confirmPasswordInput);
            confirmPasswordInput.parent().find('.invalid-feedback').remove();
          }
        };
        break;
      };
      case 'confirmPassword': {
        var me = $(this);
        var passwordInput = jsInputsContainer.find('#password');
        if (checkPasswordValidation(passwordInput)) {
          if (me.val() && me.val() == passwordInput.val()) {
            valid(me);
          } else {
            invalid(me);
            appendErrorMsg("Password not correctly repeated.!", me.parent());
          }
        } else {
          me.parent().find('.invalid-feedback').remove();
        }
        break;
      }
      default:
        valid($(this));
        break;
    };
  });
}

var startApp = function (containerDom) {
  gapi.load('auth2', function () {
    // Retrieve the singleton for the GoogleAuth library and set up the client.
    var auth2 = gapi.auth2.init({
      client_id: '746453789840-90qme7c29nuk8r1sg2nngu2u9p2b2nl9.apps.googleusercontent.com',
      cookiepolicy: 'single_host_origin',
      // Request scopes in addition to 'profile' and 'email'
      //scope: 'additional_scope'
    });
    var googleSignInBtn = containerDom.find('.google-signin');
    if (googleSignInBtn && googleSignInBtn.length) {
      attachSignin(googleSignInBtn[0], auth2);
    }
    var googleSignUpBtn = containerDom.find('.google-signup');
    if (googleSignUpBtn && googleSignUpBtn.length) {
      attachSignin(googleSignUpBtn[0], auth2);
    }
  });
};

function attachSignin(element, auth2) {
  auth2.attachClickHandler(element, {},
    function (googleUser) {
      //TODO
      debugger;  
      var profile = googleUser.getBasicProfile();
      var loginValues = {
        'name': profile.getGivenName(),
        'email': profile.getEmail(),
        'password': profile.getId()
      };

      WIRE.call('login_with_google', loginValues, function () {
        // debugger; 
      }.bind(this), function (response) {
        // debugger; 
        if (response['error']) {
          // debugger; 
        }
      }.bind(this));

    }, function (error) {
      // debugger;      
    });
}

function signOut() {
  var auth2 = gapi.auth2.getAuthInstance();
  if (auth2){
    auth2.signOut();
  }
}
var revokeAllScopes = function() {
  if(gapi && gapi.auth2) {
    var auth2 = gapi.auth2.getAuthInstance();
    if (auth2) {
      auth2.disconnect();
    }
  }
};
/*!
 * Select2 4.0.3
 * https://select2.github.io
 *
 * Released under the MIT license
 * https://github.com/select2/select2/blob/master/LICENSE.md
 */
(function (factory) {
  if (typeof define === 'function' && define.amd) {
    // AMD. Register as an anonymous module.
    define(['jquery'], factory);
  } else if (typeof exports === 'object') {
    // Node/CommonJS
    factory(require('jquery'));
  } else {
    // Browser globals
    factory(jQuery);
  }
}(function (jQuery) {
  // This is needed so we can catch the AMD loader configuration and use it
  // The inner file should be wrapped (by `banner.start.js`) in a function that
  // returns the AMD loader references.
  var S2 =
(function () {
  // Restore the Select2 AMD loader so it can be used
  // Needed mostly in the language files, where the loader is not inserted
  if (jQuery && jQuery.fn && jQuery.fn.select2 && jQuery.fn.select2.amd) {
    var S2 = jQuery.fn.select2.amd;
  }
var S2;(function () { if (!S2 || !S2.requirejs) {
if (!S2) { S2 = {}; } else { require = S2; }
/**
 * @license almond 0.3.1 Copyright (c) 2011-2014, The Dojo Foundation All Rights Reserved.
 * Available via the MIT or new BSD license.
 * see: http://github.com/jrburke/almond for details
 */
//Going sloppy to avoid 'use strict' string cost, but strict practices should
//be followed.
/*jslint sloppy: true */
/*global setTimeout: false */

var requirejs, require, define;
(function (undef) {
    var main, req, makeMap, handlers,
        defined = {},
        waiting = {},
        config = {},
        defining = {},
        hasOwn = Object.prototype.hasOwnProperty,
        aps = [].slice,
        jsSuffixRegExp = /\.js$/;

    function hasProp(obj, prop) {
        return hasOwn.call(obj, prop);
    }

    /**
     * Given a relative module name, like ./something, normalize it to
     * a real name that can be mapped to a path.
     * @param {String} name the relative name
     * @param {String} baseName a real name that the name arg is relative
     * to.
     * @returns {String} normalized name
     */
    function normalize(name, baseName) {
        var nameParts, nameSegment, mapValue, foundMap, lastIndex,
            foundI, foundStarMap, starI, i, j, part,
            baseParts = baseName && baseName.split("/"),
            map = config.map,
            starMap = (map && map['*']) || {};

        //Adjust any relative paths.
        if (name && name.charAt(0) === ".") {
            //If have a base name, try to normalize against it,
            //otherwise, assume it is a top-level require that will
            //be relative to baseUrl in the end.
            if (baseName) {
                name = name.split('/');
                lastIndex = name.length - 1;

                // Node .js allowance:
                if (config.nodeIdCompat && jsSuffixRegExp.test(name[lastIndex])) {
                    name[lastIndex] = name[lastIndex].replace(jsSuffixRegExp, '');
                }

                //Lop off the last part of baseParts, so that . matches the
                //"directory" and not name of the baseName's module. For instance,
                //baseName of "one/two/three", maps to "one/two/three.js", but we
                //want the directory, "one/two" for this normalization.
                name = baseParts.slice(0, baseParts.length - 1).concat(name);

                //start trimDots
                for (i = 0; i < name.length; i += 1) {
                    part = name[i];
                    if (part === ".") {
                        name.splice(i, 1);
                        i -= 1;
                    } else if (part === "..") {
                        if (i === 1 && (name[2] === '..' || name[0] === '..')) {
                            //End of the line. Keep at least one non-dot
                            //path segment at the front so it can be mapped
                            //correctly to disk. Otherwise, there is likely
                            //no path mapping for a path starting with '..'.
                            //This can still fail, but catches the most reasonable
                            //uses of ..
                            break;
                        } else if (i > 0) {
                            name.splice(i - 1, 2);
                            i -= 2;
                        }
                    }
                }
                //end trimDots

                name = name.join("/");
            } else if (name.indexOf('./') === 0) {
                // No baseName, so this is ID is resolved relative
                // to baseUrl, pull off the leading dot.
                name = name.substring(2);
            }
        }

        //Apply map config if available.
        if ((baseParts || starMap) && map) {
            nameParts = name.split('/');

            for (i = nameParts.length; i > 0; i -= 1) {
                nameSegment = nameParts.slice(0, i).join("/");

                if (baseParts) {
                    //Find the longest baseName segment match in the config.
                    //So, do joins on the biggest to smallest lengths of baseParts.
                    for (j = baseParts.length; j > 0; j -= 1) {
                        mapValue = map[baseParts.slice(0, j).join('/')];

                        //baseName segment has  config, find if it has one for
                        //this name.
                        if (mapValue) {
                            mapValue = mapValue[nameSegment];
                            if (mapValue) {
                                //Match, update name to the new value.
                                foundMap = mapValue;
                                foundI = i;
                                break;
                            }
                        }
                    }
                }

                if (foundMap) {
                    break;
                }

                //Check for a star map match, but just hold on to it,
                //if there is a shorter segment match later in a matching
                //config, then favor over this star map.
                if (!foundStarMap && starMap && starMap[nameSegment]) {
                    foundStarMap = starMap[nameSegment];
                    starI = i;
                }
            }

            if (!foundMap && foundStarMap) {
                foundMap = foundStarMap;
                foundI = starI;
            }

            if (foundMap) {
                nameParts.splice(0, foundI, foundMap);
                name = nameParts.join('/');
            }
        }

        return name;
    }

    function makeRequire(relName, forceSync) {
        return function () {
            //A version of a require function that passes a moduleName
            //value for items that may need to
            //look up paths relative to the moduleName
            var args = aps.call(arguments, 0);

            //If first arg is not require('string'), and there is only
            //one arg, it is the array form without a callback. Insert
            //a null so that the following concat is correct.
            if (typeof args[0] !== 'string' && args.length === 1) {
                args.push(null);
            }
            return req.apply(undef, args.concat([relName, forceSync]));
        };
    }

    function makeNormalize(relName) {
        return function (name) {
            return normalize(name, relName);
        };
    }

    function makeLoad(depName) {
        return function (value) {
            defined[depName] = value;
        };
    }

    function callDep(name) {
        if (hasProp(waiting, name)) {
            var args = waiting[name];
            delete waiting[name];
            defining[name] = true;
            main.apply(undef, args);
        }

        if (!hasProp(defined, name) && !hasProp(defining, name)) {
            throw new Error('No ' + name);
        }
        return defined[name];
    }

    //Turns a plugin!resource to [plugin, resource]
    //with the plugin being undefined if the name
    //did not have a plugin prefix.
    function splitPrefix(name) {
        var prefix,
            index = name ? name.indexOf('!') : -1;
        if (index > -1) {
            prefix = name.substring(0, index);
            name = name.substring(index + 1, name.length);
        }
        return [prefix, name];
    }

    /**
     * Makes a name map, normalizing the name, and using a plugin
     * for normalization if necessary. Grabs a ref to plugin
     * too, as an optimization.
     */
    makeMap = function (name, relName) {
        var plugin,
            parts = splitPrefix(name),
            prefix = parts[0];

        name = parts[1];

        if (prefix) {
            prefix = normalize(prefix, relName);
            plugin = callDep(prefix);
        }

        //Normalize according
        if (prefix) {
            if (plugin && plugin.normalize) {
                name = plugin.normalize(name, makeNormalize(relName));
            } else {
                name = normalize(name, relName);
            }
        } else {
            name = normalize(name, relName);
            parts = splitPrefix(name);
            prefix = parts[0];
            name = parts[1];
            if (prefix) {
                plugin = callDep(prefix);
            }
        }

        //Using ridiculous property names for space reasons
        return {
            f: prefix ? prefix + '!' + name : name, //fullName
            n: name,
            pr: prefix,
            p: plugin
        };
    };

    function makeConfig(name) {
        return function () {
            return (config && config.config && config.config[name]) || {};
        };
    }

    handlers = {
        require: function (name) {
            return makeRequire(name);
        },
        exports: function (name) {
            var e = defined[name];
            if (typeof e !== 'undefined') {
                return e;
            } else {
                return (defined[name] = {});
            }
        },
        module: function (name) {
            return {
                id: name,
                uri: '',
                exports: defined[name],
                config: makeConfig(name)
            };
        }
    };

    main = function (name, deps, callback, relName) {
        var cjsModule, depName, ret, map, i,
            args = [],
            callbackType = typeof callback,
            usingExports;

        //Use name if no relName
        relName = relName || name;

        //Call the callback to define the module, if necessary.
        if (callbackType === 'undefined' || callbackType === 'function') {
            //Pull out the defined dependencies and pass the ordered
            //values to the callback.
            //Default to [require, exports, module] if no deps
            deps = !deps.length && callback.length ? ['require', 'exports', 'module'] : deps;
            for (i = 0; i < deps.length; i += 1) {
                map = makeMap(deps[i], relName);
                depName = map.f;

                //Fast path CommonJS standard dependencies.
                if (depName === "require") {
                    args[i] = handlers.require(name);
                } else if (depName === "exports") {
                    //CommonJS module spec 1.1
                    args[i] = handlers.exports(name);
                    usingExports = true;
                } else if (depName === "module") {
                    //CommonJS module spec 1.1
                    cjsModule = args[i] = handlers.module(name);
                } else if (hasProp(defined, depName) ||
                           hasProp(waiting, depName) ||
                           hasProp(defining, depName)) {
                    args[i] = callDep(depName);
                } else if (map.p) {
                    map.p.load(map.n, makeRequire(relName, true), makeLoad(depName), {});
                    args[i] = defined[depName];
                } else {
                    throw new Error(name + ' missing ' + depName);
                }
            }

            ret = callback ? callback.apply(defined[name], args) : undefined;

            if (name) {
                //If setting exports via "module" is in play,
                //favor that over return value and exports. After that,
                //favor a non-undefined return value over exports use.
                if (cjsModule && cjsModule.exports !== undef &&
                        cjsModule.exports !== defined[name]) {
                    defined[name] = cjsModule.exports;
                } else if (ret !== undef || !usingExports) {
                    //Use the return value from the function.
                    defined[name] = ret;
                }
            }
        } else if (name) {
            //May just be an object definition for the module. Only
            //worry about defining if have a module name.
            defined[name] = callback;
        }
    };

    requirejs = require = req = function (deps, callback, relName, forceSync, alt) {
        if (typeof deps === "string") {
            if (handlers[deps]) {
                //callback in this case is really relName
                return handlers[deps](callback);
            }
            //Just return the module wanted. In this scenario, the
            //deps arg is the module name, and second arg (if passed)
            //is just the relName.
            //Normalize module name, if it contains . or ..
            return callDep(makeMap(deps, callback).f);
        } else if (!deps.splice) {
            //deps is a config object, not an array.
            config = deps;
            if (config.deps) {
                req(config.deps, config.callback);
            }
            if (!callback) {
                return;
            }

            if (callback.splice) {
                //callback is an array, which means it is a dependency list.
                //Adjust args if there are dependencies
                deps = callback;
                callback = relName;
                relName = null;
            } else {
                deps = undef;
            }
        }

        //Support require(['a'])
        callback = callback || function () {};

        //If relName is a function, it is an errback handler,
        //so remove it.
        if (typeof relName === 'function') {
            relName = forceSync;
            forceSync = alt;
        }

        //Simulate async callback;
        if (forceSync) {
            main(undef, deps, callback, relName);
        } else {
            //Using a non-zero value because of concern for what old browsers
            //do, and latest browsers "upgrade" to 4 if lower value is used:
            //http://www.whatwg.org/specs/web-apps/current-work/multipage/timers.html#dom-windowtimers-settimeout:
            //If want a value immediately, use require('id') instead -- something
            //that works in almond on the global level, but not guaranteed and
            //unlikely to work in other AMD implementations.
            setTimeout(function () {
                main(undef, deps, callback, relName);
            }, 4);
        }

        return req;
    };

    /**
     * Just drops the config on the floor, but returns req in case
     * the config return value is used.
     */
    req.config = function (cfg) {
        return req(cfg);
    };

    /**
     * Expose module registry for debugging and tooling
     */
    requirejs._defined = defined;

    define = function (name, deps, callback) {
        if (typeof name !== 'string') {
            throw new Error('See almond README: incorrect module build, no module name');
        }

        //This module may not have dependencies
        if (!deps.splice) {
            //deps is not an array, so probably means
            //an object literal or factory function for
            //the value. Adjust args.
            callback = deps;
            deps = [];
        }

        if (!hasProp(defined, name) && !hasProp(waiting, name)) {
            waiting[name] = [name, deps, callback];
        }
    };

    define.amd = {
        jQuery: true
    };
}());

S2.requirejs = requirejs;S2.require = require;S2.define = define;
}
}());
S2.define("almond", function(){});

/* global jQuery:false, $:false */
S2.define('jquery',[],function () {
  var _$ = jQuery || $;

  if (_$ == null && console && console.error) {
    console.error(
      'Select2: An instance of jQuery or a jQuery-compatible library was not ' +
      'found. Make sure that you are including jQuery before Select2 on your ' +
      'web page.'
    );
  }

  return _$;
});

S2.define('select2/utils',[
  'jquery'
], function ($) {
  var Utils = {};

  Utils.Extend = function (ChildClass, SuperClass) {
    var __hasProp = {}.hasOwnProperty;

    function BaseConstructor () {
      this.constructor = ChildClass;
    }

    for (var key in SuperClass) {
      if (__hasProp.call(SuperClass, key)) {
        ChildClass[key] = SuperClass[key];
      }
    }

    BaseConstructor.prototype = SuperClass.prototype;
    ChildClass.prototype = new BaseConstructor();
    ChildClass.__super__ = SuperClass.prototype;

    return ChildClass;
  };

  function getMethods (theClass) {
    var proto = theClass.prototype;

    var methods = [];

    for (var methodName in proto) {
      var m = proto[methodName];

      if (typeof m !== 'function') {
        continue;
      }

      if (methodName === 'constructor') {
        continue;
      }

      methods.push(methodName);
    }

    return methods;
  }

  Utils.Decorate = function (SuperClass, DecoratorClass) {
    var decoratedMethods = getMethods(DecoratorClass);
    var superMethods = getMethods(SuperClass);

    function DecoratedClass () {
      var unshift = Array.prototype.unshift;

      var argCount = DecoratorClass.prototype.constructor.length;

      var calledConstructor = SuperClass.prototype.constructor;

      if (argCount > 0) {
        unshift.call(arguments, SuperClass.prototype.constructor);

        calledConstructor = DecoratorClass.prototype.constructor;
      }

      calledConstructor.apply(this, arguments);
    }

    DecoratorClass.displayName = SuperClass.displayName;

    function ctr () {
      this.constructor = DecoratedClass;
    }

    DecoratedClass.prototype = new ctr();

    for (var m = 0; m < superMethods.length; m++) {
        var superMethod = superMethods[m];

        DecoratedClass.prototype[superMethod] =
          SuperClass.prototype[superMethod];
    }

    var calledMethod = function (methodName) {
      // Stub out the original method if it's not decorating an actual method
      var originalMethod = function () {};

      if (methodName in DecoratedClass.prototype) {
        originalMethod = DecoratedClass.prototype[methodName];
      }

      var decoratedMethod = DecoratorClass.prototype[methodName];

      return function () {
        var unshift = Array.prototype.unshift;

        unshift.call(arguments, originalMethod);

        return decoratedMethod.apply(this, arguments);
      };
    };

    for (var d = 0; d < decoratedMethods.length; d++) {
      var decoratedMethod = decoratedMethods[d];

      DecoratedClass.prototype[decoratedMethod] = calledMethod(decoratedMethod);
    }

    return DecoratedClass;
  };

  var Observable = function () {
    this.listeners = {};
  };

  Observable.prototype.on = function (event, callback) {
    this.listeners = this.listeners || {};

    if (event in this.listeners) {
      this.listeners[event].push(callback);
    } else {
      this.listeners[event] = [callback];
    }
  };

  Observable.prototype.trigger = function (event) {
    var slice = Array.prototype.slice;
    var params = slice.call(arguments, 1);

    this.listeners = this.listeners || {};

    // Params should always come in as an array
    if (params == null) {
      params = [];
    }

    // If there are no arguments to the event, use a temporary object
    if (params.length === 0) {
      params.push({});
    }

    // Set the `_type` of the first object to the event
    params[0]._type = event;

    if (event in this.listeners) {
      this.invoke(this.listeners[event], slice.call(arguments, 1));
    }

    if ('*' in this.listeners) {
      this.invoke(this.listeners['*'], arguments);
    }
  };

  Observable.prototype.invoke = function (listeners, params) {
    for (var i = 0, len = listeners.length; i < len; i++) {
      listeners[i].apply(this, params);
    }
  };

  Utils.Observable = Observable;

  Utils.generateChars = function (length) {
    var chars = '';

    for (var i = 0; i < length; i++) {
      var randomChar = Math.floor(Math.random() * 36);
      chars += randomChar.toString(36);
    }

    return chars;
  };

  Utils.bind = function (func, context) {
    return function () {
      func.apply(context, arguments);
    };
  };

  Utils._convertData = function (data) {
    for (var originalKey in data) {
      var keys = originalKey.split('-');

      var dataLevel = data;

      if (keys.length === 1) {
        continue;
      }

      for (var k = 0; k < keys.length; k++) {
        var key = keys[k];

        // Lowercase the first letter
        // By default, dash-separated becomes camelCase
        key = key.substring(0, 1).toLowerCase() + key.substring(1);

        if (!(key in dataLevel)) {
          dataLevel[key] = {};
        }

        if (k == keys.length - 1) {
          dataLevel[key] = data[originalKey];
        }

        dataLevel = dataLevel[key];
      }

      delete data[originalKey];
    }

    return data;
  };

  Utils.hasScroll = function (index, el) {
    // Adapted from the function created by @ShadowScripter
    // and adapted by @BillBarry on the Stack Exchange Code Review website.
    // The original code can be found at
    // http://codereview.stackexchange.com/q/13338
    // and was designed to be used with the Sizzle selector engine.

    var $el = $(el);
    var overflowX = el.style.overflowX;
    var overflowY = el.style.overflowY;

    //Check both x and y declarations
    if (overflowX === overflowY &&
        (overflowY === 'hidden' || overflowY === 'visible')) {
      return false;
    }

    if (overflowX === 'scroll' || overflowY === 'scroll') {
      return true;
    }

    return ($el.innerHeight() < el.scrollHeight ||
      $el.innerWidth() < el.scrollWidth);
  };

  Utils.escapeMarkup = function (markup) {
    var replaceMap = {
      '\\': '&#92;',
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      '\'': '&#39;',
      '/': '&#47;'
    };

    // Do not try to escape the markup if it's not a string
    if (typeof markup !== 'string') {
      return markup;
    }

    return String(markup).replace(/[&<>"'\/\\]/g, function (match) {
      return replaceMap[match];
    });
  };

  // Append an array of jQuery nodes to a given element.
  Utils.appendMany = function ($element, $nodes) {
    // jQuery 1.7.x does not support $.fn.append() with an array
    // Fall back to a jQuery object collection using $.fn.add()
    if ($.fn.jquery.substr(0, 3) === '1.7') {
      var $jqNodes = $();

      $.map($nodes, function (node) {
        $jqNodes = $jqNodes.add(node);
      });

      $nodes = $jqNodes;
    }

    $element.append($nodes);
  };

  return Utils;
});

S2.define('select2/results',[
  'jquery',
  './utils'
], function ($, Utils) {
  function Results ($element, options, dataAdapter) {
    this.$element = $element;
    this.data = dataAdapter;
    this.options = options;

    Results.__super__.constructor.call(this);
  }

  Utils.Extend(Results, Utils.Observable);

  Results.prototype.render = function () {
    var $results = $(
      '<ul class="select2-results__options" role="tree"></ul>'
    );

    if (this.options.get('multiple')) {
      $results.attr('aria-multiselectable', 'true');
    }

    this.$results = $results;

    return $results;
  };

  Results.prototype.clear = function () {
    this.$results.empty();
  };

  Results.prototype.displayMessage = function (params) {
    var escapeMarkup = this.options.get('escapeMarkup');

    this.clear();
    this.hideLoading();

    var $message = $(
      '<li role="treeitem" aria-live="assertive"' +
      ' class="select2-results__option"></li>'
    );

    var message = this.options.get('translations').get(params.message);

    $message.append(
      escapeMarkup(
        message(params.args)
      )
    );

    $message[0].className += ' select2-results__message';

    this.$results.append($message);
  };

  Results.prototype.hideMessages = function () {
    this.$results.find('.select2-results__message').remove();
  };

  Results.prototype.append = function (data) {
    this.hideLoading();

    var $options = [];

    if (data.results == null || data.results.length === 0) {
      if (this.$results.children().length === 0) {
        this.trigger('results:message', {
          message: 'noResults'
        });
      }

      return;
    }

    data.results = this.sort(data.results);

    for (var d = 0; d < data.results.length; d++) {
      var item = data.results[d];

      var $option = this.option(item);

      $options.push($option);
    }

    this.$results.append($options);
  };

  Results.prototype.position = function ($results, $dropdown) {
    var $resultsContainer = $dropdown.find('.select2-results');
    $resultsContainer.append($results);
  };

  Results.prototype.sort = function (data) {
    var sorter = this.options.get('sorter');

    return sorter(data);
  };

  Results.prototype.highlightFirstItem = function () {
    var $options = this.$results
      .find('.select2-results__option[aria-selected]');

    var $selected = $options.filter('[aria-selected=true]');

    // Check if there are any selected options
    if ($selected.length > 0) {
      // If there are selected options, highlight the first
      $selected.first().trigger('mouseenter');
    } else {
      // If there are no selected options, highlight the first option
      // in the dropdown
      $options.first().trigger('mouseenter');
    }

    this.ensureHighlightVisible();
  };

  Results.prototype.setClasses = function () {
    var self = this;

    this.data.current(function (selected) {
      var selectedIds = $.map(selected, function (s) {
        return s.id.toString();
      });

      var $options = self.$results
        .find('.select2-results__option[aria-selected]').css('min-height', '30px');

      $options.each(function () {
        var $option = $(this);

        var item = $.data(this, 'data');

        // id needs to be converted to a string when comparing
        var id = '' + item.id;

        if ((item.element != null && item.element.selected) ||
            (item.element == null && $.inArray(id, selectedIds) > -1)) {
          $option.attr('aria-selected', 'true');
        } else {
          $option.attr('aria-selected', 'false');
        }
      });

    });
  };

  Results.prototype.showLoading = function (params) {
    this.hideLoading();

    var loadingMore = this.options.get('translations').get('searching');

    var loading = {
      disabled: true,
      loading: true,
      text: loadingMore(params)
    };
    var $loading = this.option(loading);
    $loading.className += ' loading-results';

    this.$results.prepend($loading);
  };

  Results.prototype.hideLoading = function () {
    this.$results.find('.loading-results').remove();
  };

  Results.prototype.option = function (data) {
    var option = document.createElement('li');
    option.className = 'select2-results__option';

    var attrs = {
      'role': 'treeitem',
      'aria-selected': 'false'
    };

    if (data.disabled) {
      delete attrs['aria-selected'];
      attrs['aria-disabled'] = 'true';
    }

    if (data.id == null) {
      delete attrs['aria-selected'];
    }

    if (data._resultId != null) {
      option.id = data._resultId;
    }

    if (data.title) {
      option.title = data.title;
    }

    if (data.children) {
      attrs.role = 'group';
      attrs['aria-label'] = data.text;
      delete attrs['aria-selected'];
    }

    for (var attr in attrs) {
      var val = attrs[attr];

      option.setAttribute(attr, val);
    }

    if (data.children) {
      var $option = $(option);

      var label = document.createElement('strong');
      label.className = 'select2-results__group';

      var $label = $(label);
      this.template(data, label);

      var $children = [];

      for (var c = 0; c < data.children.length; c++) {
        var child = data.children[c];

        var $child = this.option(child);

        $children.push($child);
      }

      var $childrenContainer = $('<ul></ul>', {
        'class': 'select2-results__options select2-results__options--nested'
      });

      $childrenContainer.append($children);

      $option.append(label);
      $option.append($childrenContainer);
    } else {
      this.template(data, option);
    }

    $.data(option, 'data', data);

    return option;
  };

  Results.prototype.bind = function (container, $container) {
    var self = this;

    var id = container.id + '-results';

    this.$results.attr('id', id);

    container.on('results:all', function (params) {
      self.clear();
      self.append(params.data);

      if (container.isOpen()) {
        self.setClasses();
        self.highlightFirstItem();
      }
    });

    container.on('results:append', function (params) {
      self.append(params.data);

      if (container.isOpen()) {
        self.setClasses();
      }
    });

    container.on('query', function (params) {
      self.hideMessages();
      self.showLoading(params);
    });

    container.on('select', function () {
      if (!container.isOpen()) {
        return;
      }

      self.setClasses();
      self.highlightFirstItem();
    });

    container.on('unselect', function () {
      if (!container.isOpen()) {
        return;
      }

      self.setClasses();
      self.highlightFirstItem();
    });

    container.on('open', function () {
      // When the dropdown is open, aria-expended="true"
      self.$results.attr('aria-expanded', 'true');
      self.$results.attr('aria-hidden', 'false');

      self.setClasses();
      self.ensureHighlightVisible();
    });

    container.on('close', function () {
      // When the dropdown is closed, aria-expended="false"
      self.$results.attr('aria-expanded', 'false');
      self.$results.attr('aria-hidden', 'true');
      self.$results.removeAttr('aria-activedescendant');
    });

    container.on('results:toggle', function () {
      var $highlighted = self.getHighlightedResults();

      if ($highlighted.length === 0) {
        return;
      }

      $highlighted.trigger('mouseup');
    });

    container.on('results:select', function () {
      var $highlighted = self.getHighlightedResults();

      if ($highlighted.length === 0) {
        return;
      }

      var data = $highlighted.data('data');

      if ($highlighted.attr('aria-selected') == 'true') {
        self.trigger('close', {});
      } else {
        self.trigger('select', {
          data: data
        });
      }
    });

    container.on('results:previous', function () {
      var $highlighted = self.getHighlightedResults();

      var $options = self.$results.find('[aria-selected]');

      var currentIndex = $options.index($highlighted);

      // If we are already at te top, don't move further
      if (currentIndex === 0) {
        return;
      }

      var nextIndex = currentIndex - 1;

      // If none are highlighted, highlight the first
      if ($highlighted.length === 0) {
        nextIndex = 0;
      }

      var $next = $options.eq(nextIndex);

      $next.trigger('mouseenter');

      var currentOffset = self.$results.offset().top;
      var nextTop = $next.offset().top;
      var nextOffset = self.$results.scrollTop() + (nextTop - currentOffset);

      if (nextIndex === 0) {
        self.$results.scrollTop(0);
      } else if (nextTop - currentOffset < 0) {
        self.$results.scrollTop(nextOffset);
      }
    });

    container.on('results:next', function () {
      var $highlighted = self.getHighlightedResults();

      var $options = self.$results.find('[aria-selected]');

      var currentIndex = $options.index($highlighted);

      var nextIndex = currentIndex + 1;

      // If we are at the last option, stay there
      if (nextIndex >= $options.length) {
        return;
      }

      var $next = $options.eq(nextIndex);

      $next.trigger('mouseenter');

      var currentOffset = self.$results.offset().top +
        self.$results.outerHeight(false);
      var nextBottom = $next.offset().top + $next.outerHeight(false);
      var nextOffset = self.$results.scrollTop() + nextBottom - currentOffset;

      if (nextIndex === 0) {
        self.$results.scrollTop(0);
      } else if (nextBottom > currentOffset) {
        self.$results.scrollTop(nextOffset);
      }
    });

    container.on('results:focus', function (params) {
      params.element.addClass('select2-results__option--highlighted');
    });

    container.on('results:message', function (params) {
      self.displayMessage(params);
    });

    if ($.fn.mousewheel) {
      this.$results.on('mousewheel', function (e) {
        var top = self.$results.scrollTop();

        var bottom = self.$results.get(0).scrollHeight - top + e.deltaY;

        var isAtTop = e.deltaY > 0 && top - e.deltaY <= 0;
        var isAtBottom = e.deltaY < 0 && bottom <= self.$results.height();

        if (isAtTop) {
          self.$results.scrollTop(0);

          e.preventDefault();
          e.stopPropagation();
        } else if (isAtBottom) {
          self.$results.scrollTop(
            self.$results.get(0).scrollHeight - self.$results.height()
          );

          e.preventDefault();
          e.stopPropagation();
        }
      });
    }

    this.$results.on('mouseup', '.select2-results__option[aria-selected]',
      function (evt) {
      var $this = $(this);

      var data = $this.data('data');

      if ($this.attr('aria-selected') === 'true') {
        if (self.options.get('multiple')) {
          self.trigger('unselect', {
            originalEvent: evt,
            data: data
          });
        } else {
          self.trigger('close', {});
        }

        return;
      }

      self.trigger('select', {
        originalEvent: evt,
        data: data
      });
    });

    this.$results.on('mouseenter', '.select2-results__option[aria-selected]',
      function (evt) {
      var data = $(this).data('data');

      self.getHighlightedResults()
          .removeClass('select2-results__option--highlighted');

      self.trigger('results:focus', {
        data: data,
        element: $(this)
      });
    });
  };

  Results.prototype.getHighlightedResults = function () {
    var $highlighted = this.$results
    .find('.select2-results__option--highlighted');

    return $highlighted;
  };

  Results.prototype.destroy = function () {
    this.$results.remove();
  };

  Results.prototype.ensureHighlightVisible = function () {
    var $highlighted = this.getHighlightedResults();

    if ($highlighted.length === 0) {
      return;
    }

    var $options = this.$results.find('[aria-selected]');

    var currentIndex = $options.index($highlighted);

    var currentOffset = this.$results.offset().top;
    var nextTop = $highlighted.offset().top;
    var nextOffset = this.$results.scrollTop() + (nextTop - currentOffset);

    var offsetDelta = nextTop - currentOffset;
    nextOffset -= $highlighted.outerHeight(false) * 2;

    if (currentIndex <= 2) {
      this.$results.scrollTop(0);
    } else if (offsetDelta > this.$results.outerHeight() || offsetDelta < 0) {
      this.$results.scrollTop(nextOffset);
    }
  };

  Results.prototype.template = function (result, container) {
    var template = this.options.get('templateResult');
    var escapeMarkup = this.options.get('escapeMarkup');

    var content = template(result, container);

    if (content == null) {
      container.style.display = 'none';
    } else if (typeof content === 'string') {
      container.innerHTML = escapeMarkup(content);
    } else {
      $(container).append(content);
    }
  };

  return Results;
});

S2.define('select2/keys',[

], function () {
  var KEYS = {
    BACKSPACE: 8,
    TAB: 9,
    ENTER: 13,
    SHIFT: 16,
    CTRL: 17,
    ALT: 18,
    ESC: 27,
    SPACE: 32,
    PAGE_UP: 33,
    PAGE_DOWN: 34,
    END: 35,
    HOME: 36,
    LEFT: 37,
    UP: 38,
    RIGHT: 39,
    DOWN: 40,
    DELETE: 46
  };

  return KEYS;
});

S2.define('select2/selection/base',[
  'jquery',
  '../utils',
  '../keys'
], function ($, Utils, KEYS) {
  function BaseSelection ($element, options) {
    this.$element = $element;
    this.options = options;

    BaseSelection.__super__.constructor.call(this);
  }

  Utils.Extend(BaseSelection, Utils.Observable);

  BaseSelection.prototype.render = function () {
    var $selection = $(
      '<span class="select2-selection" role="combobox" ' +
      ' aria-haspopup="true" aria-expanded="false">' +
      '</span>'
    );

    this._tabindex = 0;

    if (this.$element.data('old-tabindex') != null) {
      this._tabindex = this.$element.data('old-tabindex');
    } else if (this.$element.attr('tabindex') != null) {
      this._tabindex = this.$element.attr('tabindex');
    }

    $selection.attr('title', this.$element.attr('title'));
    $selection.attr('tabindex', this._tabindex);

    this.$selection = $selection;

    return $selection;
  };

  BaseSelection.prototype.bind = function (container, $container) {
    var self = this;

    var id = container.id + '-container';
    var resultsId = container.id + '-results';

    this.container = container;

    this.$selection.on('focus', function (evt) {
      self.trigger('focus', evt);
    });

    this.$selection.on('blur', function (evt) {
      self._handleBlur(evt);
    });

    this.$selection.on('keydown', function (evt) {
      self.trigger('keypress', evt);

      if (evt.which === KEYS.SPACE) {
        evt.preventDefault();
      }
    });

    container.on('results:focus', function (params) {
      self.$selection.attr('aria-activedescendant', params.data._resultId);
    });

    container.on('selection:update', function (params) {
      self.update(params.data);
    });

    container.on('open', function () {
      // When the dropdown is open, aria-expanded="true"
      self.$selection.attr('aria-expanded', 'true');
      self.$selection.attr('aria-owns', resultsId);

      self._attachCloseHandler(container);
    });

    container.on('close', function () {
      // When the dropdown is closed, aria-expanded="false"
      self.$selection.attr('aria-expanded', 'false');
      self.$selection.removeAttr('aria-activedescendant');
      self.$selection.removeAttr('aria-owns');

      self.$selection.focus();

      self._detachCloseHandler(container);
    });

    container.on('enable', function () {
      self.$selection.attr('tabindex', self._tabindex);
    });

    container.on('disable', function () {
      self.$selection.attr('tabindex', '-1');
    });
  };

  BaseSelection.prototype._handleBlur = function (evt) {
    var self = this;

    // This needs to be delayed as the active element is the body when the tab
    // key is pressed, possibly along with others.
    window.setTimeout(function () {
      // Don't trigger `blur` if the focus is still in the selection
      if (
        (document.activeElement == self.$selection[0]) ||
        ($.contains(self.$selection[0], document.activeElement))
      ) {
        return;
      }

      self.trigger('blur', evt);
    }, 1);
  };

  BaseSelection.prototype._attachCloseHandler = function (container) {
    var self = this;

    $(document.body).on('mousedown.select2.' + container.id, function (e) {
      var $target = $(e.target);

      var $select = $target.closest('.select2');

      var $all = $('.select2.select2-container--open');

      $all.each(function () {
        var $this = $(this);

        if (this == $select[0]) {
          return;
        }

        var $element = $this.data('element');

        $element.select2('close');
      });
    });
  };

  BaseSelection.prototype._detachCloseHandler = function (container) {
    $(document.body).off('mousedown.select2.' + container.id);
  };

  BaseSelection.prototype.position = function ($selection, $container) {
    var $selectionContainer = $container.find('.selection');
    $selectionContainer.append($selection);
  };

  BaseSelection.prototype.destroy = function () {
    this._detachCloseHandler(this.container);
  };

  BaseSelection.prototype.update = function (data) {
    throw new Error('The `update` method must be defined in child classes.');
  };

  return BaseSelection;
});

S2.define('select2/selection/single',[
  'jquery',
  './base',
  '../utils',
  '../keys'
], function ($, BaseSelection, Utils, KEYS) {
  function SingleSelection () {
    SingleSelection.__super__.constructor.apply(this, arguments);
  }

  Utils.Extend(SingleSelection, BaseSelection);

  SingleSelection.prototype.render = function () {
    var $selection = SingleSelection.__super__.render.call(this);

    $selection.addClass('select2-selection--single');

    $selection.html(
      '<span class="select2-selection__rendered"></span>' +
      '<span class="select2-selection__arrow" role="presentation">' +
        '<b role="presentation"></b>' +
      '</span>'
    );

    return $selection;
  };

  SingleSelection.prototype.bind = function (container, $container) {
    var self = this;

    SingleSelection.__super__.bind.apply(this, arguments);

    var id = container.id + '-container';

    this.$selection.find('.select2-selection__rendered').attr('id', id);
    this.$selection.attr('aria-labelledby', id);

    this.$selection.on('mousedown', function (evt) {
      // Only respond to left clicks
      if (evt.which !== 1) {
        return;
      }

      self.trigger('toggle', {
        originalEvent: evt
      });
    });

    this.$selection.on('focus', function (evt) {
      // User focuses on the container
    });

    this.$selection.on('blur', function (evt) {
      // User exits the container
    });

    container.on('focus', function (evt) {
      if (!container.isOpen()) {
        self.$selection.focus();
      }
    });

    container.on('selection:update', function (params) {
      self.update(params.data);
    });
  };

  SingleSelection.prototype.clear = function () {
    this.$selection.find('.select2-selection__rendered').empty();
  };

  SingleSelection.prototype.display = function (data, container) {
    var template = this.options.get('templateSelection');
    var escapeMarkup = this.options.get('escapeMarkup');

    return escapeMarkup(template(data, container));
  };

  SingleSelection.prototype.selectionContainer = function () {
    return $('<span></span>');
  };

  SingleSelection.prototype.update = function (data) {
    if (data.length === 0) {
      this.clear();
      return;
    }

    var selection = data[0];

    var $rendered = this.$selection.find('.select2-selection__rendered');
    var formatted = this.display(selection, $rendered);

    $rendered.empty().append(formatted);
    $rendered.prop('title', selection.title || selection.text);
  };

  return SingleSelection;
});

S2.define('select2/selection/multiple',[
  'jquery',
  './base',
  '../utils'
], function ($, BaseSelection, Utils) {
  function MultipleSelection ($element, options) {
    MultipleSelection.__super__.constructor.apply(this, arguments);
  }

  Utils.Extend(MultipleSelection, BaseSelection);

  MultipleSelection.prototype.render = function () {
    var $selection = MultipleSelection.__super__.render.call(this);

    $selection.addClass('select2-selection--multiple');

    $selection.html(
      '<ul class="select2-selection__rendered"></ul>'
    );

    return $selection;
  };

  MultipleSelection.prototype.bind = function (container, $container) {
    var self = this;

    MultipleSelection.__super__.bind.apply(this, arguments);

    this.$selection.on('click', function (evt) {
      self.trigger('toggle', {
        originalEvent: evt
      });
    });

    this.$selection.on(
      'click',
      '.select2-selection__choice__remove',
      function (evt) {
        // Ignore the event if it is disabled
        if (self.options.get('disabled')) {
          return;
        }

        var $remove = $(this);
        var $selection = $remove.parent();

        var data = $selection.data('data');

        self.trigger('unselect', {
          originalEvent: evt,
          data: data
        });
      }
    );
  };

  MultipleSelection.prototype.clear = function () {
    this.$selection.find('.select2-selection__rendered').empty();
  };

  MultipleSelection.prototype.display = function (data, container) {
    var template = this.options.get('templateSelection');
    var escapeMarkup = this.options.get('escapeMarkup');

    return escapeMarkup(template(data, container));
  };

  MultipleSelection.prototype.selectionContainer = function () {
    var $container = $(
      '<li class="select2-selection__choice">' +
        '<span class="select2-selection__choice__remove" role="presentation">' +
          '&times;' +
        '</span>' +
      '</li>'
    );

    return $container;
  };

  MultipleSelection.prototype.update = function (data) {
    this.clear();

    if (data.length === 0) {
      return;
    }

    var $selections = [];

    for (var d = 0; d < data.length; d++) {
      var selection = data[d];

      var $selection = this.selectionContainer();
      var formatted = this.display(selection, $selection);

      $selection.append(formatted);
      $selection.prop('title', selection.title || selection.text);

      $selection.data('data', selection);

      $selections.push($selection);
    }

    var $rendered = this.$selection.find('.select2-selection__rendered');

    Utils.appendMany($rendered, $selections);
  };

  return MultipleSelection;
});

S2.define('select2/selection/placeholder',[
  '../utils'
], function (Utils) {
  function Placeholder (decorated, $element, options) {
    this.placeholder = this.normalizePlaceholder(options.get('placeholder'));

    decorated.call(this, $element, options);
  }

  Placeholder.prototype.normalizePlaceholder = function (_, placeholder) {
    if (typeof placeholder === 'string') {
      placeholder = {
        id: '',
        text: placeholder
      };
    }

    return placeholder;
  };

  Placeholder.prototype.createPlaceholder = function (decorated, placeholder) {
    var $placeholder = this.selectionContainer();

    $placeholder.html(this.display(placeholder));
    $placeholder.addClass('select2-selection__placeholder')
                .removeClass('select2-selection__choice');

    return $placeholder;
  };

  Placeholder.prototype.update = function (decorated, data) {
    var singlePlaceholder = (
      data.length == 1 && data[0].id != this.placeholder.id
    );
    var multipleSelections = data.length > 1;

    if (multipleSelections || singlePlaceholder) {
      return decorated.call(this, data);
    }

    this.clear();

    var $placeholder = this.createPlaceholder(this.placeholder);

    this.$selection.find('.select2-selection__rendered').append($placeholder);
  };

  return Placeholder;
});

S2.define('select2/selection/allowClear',[
  'jquery',
  '../keys'
], function ($, KEYS) {
  function AllowClear () { }

  AllowClear.prototype.bind = function (decorated, container, $container) {
    var self = this;

    decorated.call(this, container, $container);

    if (this.placeholder == null) {
      if (this.options.get('debug') && window.console && console.error) {
        console.error(
          'Select2: The `allowClear` option should be used in combination ' +
          'with the `placeholder` option.'
        );
      }
    }

    this.$selection.on('mousedown', '.select2-selection__clear',
      function (evt) {
        self._handleClear(evt);
    });

    container.on('keypress', function (evt) {
      self._handleKeyboardClear(evt, container);
    });
  };

  AllowClear.prototype._handleClear = function (_, evt) {
    // Ignore the event if it is disabled
    if (this.options.get('disabled')) {
      return;
    }

    var $clear = this.$selection.find('.select2-selection__clear');

    // Ignore the event if nothing has been selected
    if ($clear.length === 0) {
      return;
    }

    evt.stopPropagation();

    var data = $clear.data('data');

    for (var d = 0; d < data.length; d++) {
      var unselectData = {
        data: data[d]
      };

      // Trigger the `unselect` event, so people can prevent it from being
      // cleared.
      this.trigger('unselect', unselectData);

      // If the event was prevented, don't clear it out.
      if (unselectData.prevented) {
        return;
      }
    }

    this.$element.val(this.placeholder.id).trigger('change');

    this.trigger('toggle', {});
  };

  AllowClear.prototype._handleKeyboardClear = function (_, evt, container) {
    if (container.isOpen()) {
      return;
    }

    if (evt.which == KEYS.DELETE || evt.which == KEYS.BACKSPACE) {
      this._handleClear(evt);
    }
  };

  AllowClear.prototype.update = function (decorated, data) {
    decorated.call(this, data);

    if (this.$selection.find('.select2-selection__placeholder').length > 0 ||
        data.length === 0) {
      return;
    }

    var $remove = $(
      '<span class="select2-selection__clear">' +
        '&times;' +
      '</span>'
    );
    $remove.data('data', data);

    this.$selection.find('.select2-selection__rendered').prepend($remove);
  };

  return AllowClear;
});

S2.define('select2/selection/search',[
  'jquery',
  '../utils',
  '../keys'
], function ($, Utils, KEYS) {
  function Search (decorated, $element, options) {
    decorated.call(this, $element, options);
  }

  Search.prototype.render = function (decorated) {
    var $search = $(
      '<li class="select2-search select2-search--inline">' +
        '<input class="select2-search__field" type="search" tabindex="-1"' +
        ' autocomplete="off" autocorrect="off" autocapitalize="off"' +
        ' spellcheck="false" role="textbox" aria-autocomplete="list" />' +
      '</li>'
    );

    this.$searchContainer = $search;
    this.$search = $search.find('input');

    var $rendered = decorated.call(this);

    this._transferTabIndex();

    return $rendered;
  };

  Search.prototype.bind = function (decorated, container, $container) {
    var self = this;

    decorated.call(this, container, $container);

    container.on('open', function () {
      self.$search.trigger('focus');
    });

    container.on('close', function () {
      self.$search.val('');
      self.$search.removeAttr('aria-activedescendant');
      self.$search.trigger('focus');
    });

    container.on('enable', function () {
      self.$search.prop('disabled', false);

      self._transferTabIndex();
    });

    container.on('disable', function () {
      self.$search.prop('disabled', true);
    });

    container.on('focus', function (evt) {
      self.$search.trigger('focus');
    });

    container.on('results:focus', function (params) {
      self.$search.attr('aria-activedescendant', params.id);
    });

    this.$selection.on('focusin', '.select2-search--inline', function (evt) {
      self.trigger('focus', evt);
    });

    this.$selection.on('focusout', '.select2-search--inline', function (evt) {
      self._handleBlur(evt);
    });

    this.$selection.on('keydown', '.select2-search--inline', function (evt) {
      evt.stopPropagation();

      self.trigger('keypress', evt);

      self._keyUpPrevented = evt.isDefaultPrevented();

      var key = evt.which;

      if (key === KEYS.BACKSPACE && self.$search.val() === '') {
        var $previousChoice = self.$searchContainer
          .prev('.select2-selection__choice');

        if ($previousChoice.length > 0) {
          var item = $previousChoice.data('data');

          self.searchRemoveChoice(item);

          evt.preventDefault();
        }
      }
    });

    // Try to detect the IE version should the `documentMode` property that
    // is stored on the document. This is only implemented in IE and is
    // slightly cleaner than doing a user agent check.
    // This property is not available in Edge, but Edge also doesn't have
    // this bug.
    var msie = document.documentMode;
    var disableInputEvents = msie && msie <= 11;

    // Workaround for browsers which do not support the `input` event
    // This will prevent double-triggering of events for browsers which support
    // both the `keyup` and `input` events.
    this.$selection.on(
      'input.searchcheck',
      '.select2-search--inline',
      function (evt) {
        // IE will trigger the `input` event when a placeholder is used on a
        // search box. To get around this issue, we are forced to ignore all
        // `input` events in IE and keep using `keyup`.
        if (disableInputEvents) {
          self.$selection.off('input.search input.searchcheck');
          return;
        }

        // Unbind the duplicated `keyup` event
        self.$selection.off('keyup.search');
      }
    );

    this.$selection.on(
      'keyup.search input.search',
      '.select2-search--inline',
      function (evt) {
        // IE will trigger the `input` event when a placeholder is used on a
        // search box. To get around this issue, we are forced to ignore all
        // `input` events in IE and keep using `keyup`.
        if (disableInputEvents && evt.type === 'input') {
          self.$selection.off('input.search input.searchcheck');
          return;
        }

        var key = evt.which;

        // We can freely ignore events from modifier keys
        if (key == KEYS.SHIFT || key == KEYS.CTRL || key == KEYS.ALT) {
          return;
        }

        // Tabbing will be handled during the `keydown` phase
        if (key == KEYS.TAB) {
          return;
        }

        self.handleSearch(evt);
      }
    );
  };

  /**
   * This method will transfer the tabindex attribute from the rendered
   * selection to the search box. This allows for the search box to be used as
   * the primary focus instead of the selection container.
   *
   * @private
   */
  Search.prototype._transferTabIndex = function (decorated) {
    this.$search.attr('tabindex', this.$selection.attr('tabindex'));
    this.$selection.attr('tabindex', '-1');
  };

  Search.prototype.createPlaceholder = function (decorated, placeholder) {
    this.$search.attr('placeholder', placeholder.text);
  };

  Search.prototype.update = function (decorated, data) {
    var searchHadFocus = this.$search[0] == document.activeElement;

    this.$search.attr('placeholder', '');

    decorated.call(this, data);

    this.$selection.find('.select2-selection__rendered')
                   .append(this.$searchContainer);

    this.resizeSearch();
    if (searchHadFocus) {
      this.$search.focus();
    }
  };

  Search.prototype.handleSearch = function () {
    this.resizeSearch();

    if (!this._keyUpPrevented) {
      var input = this.$search.val();

      this.trigger('query', {
        term: input
      });
    }

    this._keyUpPrevented = false;
  };

  Search.prototype.searchRemoveChoice = function (decorated, item) {
    this.trigger('unselect', {
      data: item
    });

    this.$search.val(item.text);
    this.handleSearch();
  };

  Search.prototype.resizeSearch = function () {
    this.$search.css('width', '25px');

    var width = '';

    if (this.$search.attr('placeholder') !== '') {
      width = this.$selection.find('.select2-selection__rendered').innerWidth();
    } else {
      var minimumWidth = this.$search.val().length + 1;

      width = (minimumWidth * 0.75) + 'em';
    }

    this.$search.css('width', width);
  };

  return Search;
});

S2.define('select2/selection/eventRelay',[
  'jquery'
], function ($) {
  function EventRelay () { }

  EventRelay.prototype.bind = function (decorated, container, $container) {
    var self = this;
    var relayEvents = [
      'open', 'opening',
      'close', 'closing',
      'select', 'selecting',
      'unselect', 'unselecting'
    ];

    var preventableEvents = ['opening', 'closing', 'selecting', 'unselecting'];

    decorated.call(this, container, $container);

    container.on('*', function (name, params) {
      // Ignore events that should not be relayed
      if ($.inArray(name, relayEvents) === -1) {
        return;
      }

      // The parameters should always be an object
      params = params || {};

      // Generate the jQuery event for the Select2 event
      var evt = $.Event('select2:' + name, {
        params: params
      });

      self.$element.trigger(evt);

      // Only handle preventable events if it was one
      if ($.inArray(name, preventableEvents) === -1) {
        return;
      }

      params.prevented = evt.isDefaultPrevented();
    });
  };

  return EventRelay;
});

S2.define('select2/translation',[
  'jquery',
  'require'
], function ($, require) {
  function Translation (dict) {
    this.dict = dict || {};
  }

  Translation.prototype.all = function () {
    return this.dict;
  };

  Translation.prototype.get = function (key) {
    return this.dict[key];
  };

  Translation.prototype.extend = function (translation) {
    this.dict = $.extend({}, translation.all(), this.dict);
  };

  // Static functions

  Translation._cache = {};

  Translation.loadPath = function (path) {
    if (!(path in Translation._cache)) {
      var translations = require(path);

      Translation._cache[path] = translations;
    }

    return new Translation(Translation._cache[path]);
  };

  return Translation;
});

S2.define('select2/diacritics',[

], function () {
  var diacritics = {
    '\u24B6': 'A',
    '\uFF21': 'A',
    '\u00C0': 'A',
    '\u00C1': 'A',
    '\u00C2': 'A',
    '\u1EA6': 'A',
    '\u1EA4': 'A',
    '\u1EAA': 'A',
    '\u1EA8': 'A',
    '\u00C3': 'A',
    '\u0100': 'A',
    '\u0102': 'A',
    '\u1EB0': 'A',
    '\u1EAE': 'A',
    '\u1EB4': 'A',
    '\u1EB2': 'A',
    '\u0226': 'A',
    '\u01E0': 'A',
    '\u00C4': 'A',
    '\u01DE': 'A',
    '\u1EA2': 'A',
    '\u00C5': 'A',
    '\u01FA': 'A',
    '\u01CD': 'A',
    '\u0200': 'A',
    '\u0202': 'A',
    '\u1EA0': 'A',
    '\u1EAC': 'A',
    '\u1EB6': 'A',
    '\u1E00': 'A',
    '\u0104': 'A',
    '\u023A': 'A',
    '\u2C6F': 'A',
    '\uA732': 'AA',
    '\u00C6': 'AE',
    '\u01FC': 'AE',
    '\u01E2': 'AE',
    '\uA734': 'AO',
    '\uA736': 'AU',
    '\uA738': 'AV',
    '\uA73A': 'AV',
    '\uA73C': 'AY',
    '\u24B7': 'B',
    '\uFF22': 'B',
    '\u1E02': 'B',
    '\u1E04': 'B',
    '\u1E06': 'B',
    '\u0243': 'B',
    '\u0182': 'B',
    '\u0181': 'B',
    '\u24B8': 'C',
    '\uFF23': 'C',
    '\u0106': 'C',
    '\u0108': 'C',
    '\u010A': 'C',
    '\u010C': 'C',
    '\u00C7': 'C',
    '\u1E08': 'C',
    '\u0187': 'C',
    '\u023B': 'C',
    '\uA73E': 'C',
    '\u24B9': 'D',
    '\uFF24': 'D',
    '\u1E0A': 'D',
    '\u010E': 'D',
    '\u1E0C': 'D',
    '\u1E10': 'D',
    '\u1E12': 'D',
    '\u1E0E': 'D',
    '\u0110': 'D',
    '\u018B': 'D',
    '\u018A': 'D',
    '\u0189': 'D',
    '\uA779': 'D',
    '\u01F1': 'DZ',
    '\u01C4': 'DZ',
    '\u01F2': 'Dz',
    '\u01C5': 'Dz',
    '\u24BA': 'E',
    '\uFF25': 'E',
    '\u00C8': 'E',
    '\u00C9': 'E',
    '\u00CA': 'E',
    '\u1EC0': 'E',
    '\u1EBE': 'E',
    '\u1EC4': 'E',
    '\u1EC2': 'E',
    '\u1EBC': 'E',
    '\u0112': 'E',
    '\u1E14': 'E',
    '\u1E16': 'E',
    '\u0114': 'E',
    '\u0116': 'E',
    '\u00CB': 'E',
    '\u1EBA': 'E',
    '\u011A': 'E',
    '\u0204': 'E',
    '\u0206': 'E',
    '\u1EB8': 'E',
    '\u1EC6': 'E',
    '\u0228': 'E',
    '\u1E1C': 'E',
    '\u0118': 'E',
    '\u1E18': 'E',
    '\u1E1A': 'E',
    '\u0190': 'E',
    '\u018E': 'E',
    '\u24BB': 'F',
    '\uFF26': 'F',
    '\u1E1E': 'F',
    '\u0191': 'F',
    '\uA77B': 'F',
    '\u24BC': 'G',
    '\uFF27': 'G',
    '\u01F4': 'G',
    '\u011C': 'G',
    '\u1E20': 'G',
    '\u011E': 'G',
    '\u0120': 'G',
    '\u01E6': 'G',
    '\u0122': 'G',
    '\u01E4': 'G',
    '\u0193': 'G',
    '\uA7A0': 'G',
    '\uA77D': 'G',
    '\uA77E': 'G',
    '\u24BD': 'H',
    '\uFF28': 'H',
    '\u0124': 'H',
    '\u1E22': 'H',
    '\u1E26': 'H',
    '\u021E': 'H',
    '\u1E24': 'H',
    '\u1E28': 'H',
    '\u1E2A': 'H',
    '\u0126': 'H',
    '\u2C67': 'H',
    '\u2C75': 'H',
    '\uA78D': 'H',
    '\u24BE': 'I',
    '\uFF29': 'I',
    '\u00CC': 'I',
    '\u00CD': 'I',
    '\u00CE': 'I',
    '\u0128': 'I',
    '\u012A': 'I',
    '\u012C': 'I',
    '\u0130': 'I',
    '\u00CF': 'I',
    '\u1E2E': 'I',
    '\u1EC8': 'I',
    '\u01CF': 'I',
    '\u0208': 'I',
    '\u020A': 'I',
    '\u1ECA': 'I',
    '\u012E': 'I',
    '\u1E2C': 'I',
    '\u0197': 'I',
    '\u24BF': 'J',
    '\uFF2A': 'J',
    '\u0134': 'J',
    '\u0248': 'J',
    '\u24C0': 'K',
    '\uFF2B': 'K',
    '\u1E30': 'K',
    '\u01E8': 'K',
    '\u1E32': 'K',
    '\u0136': 'K',
    '\u1E34': 'K',
    '\u0198': 'K',
    '\u2C69': 'K',
    '\uA740': 'K',
    '\uA742': 'K',
    '\uA744': 'K',
    '\uA7A2': 'K',
    '\u24C1': 'L',
    '\uFF2C': 'L',
    '\u013F': 'L',
    '\u0139': 'L',
    '\u013D': 'L',
    '\u1E36': 'L',
    '\u1E38': 'L',
    '\u013B': 'L',
    '\u1E3C': 'L',
    '\u1E3A': 'L',
    '\u0141': 'L',
    '\u023D': 'L',
    '\u2C62': 'L',
    '\u2C60': 'L',
    '\uA748': 'L',
    '\uA746': 'L',
    '\uA780': 'L',
    '\u01C7': 'LJ',
    '\u01C8': 'Lj',
    '\u24C2': 'M',
    '\uFF2D': 'M',
    '\u1E3E': 'M',
    '\u1E40': 'M',
    '\u1E42': 'M',
    '\u2C6E': 'M',
    '\u019C': 'M',
    '\u24C3': 'N',
    '\uFF2E': 'N',
    '\u01F8': 'N',
    '\u0143': 'N',
    '\u00D1': 'N',
    '\u1E44': 'N',
    '\u0147': 'N',
    '\u1E46': 'N',
    '\u0145': 'N',
    '\u1E4A': 'N',
    '\u1E48': 'N',
    '\u0220': 'N',
    '\u019D': 'N',
    '\uA790': 'N',
    '\uA7A4': 'N',
    '\u01CA': 'NJ',
    '\u01CB': 'Nj',
    '\u24C4': 'O',
    '\uFF2F': 'O',
    '\u00D2': 'O',
    '\u00D3': 'O',
    '\u00D4': 'O',
    '\u1ED2': 'O',
    '\u1ED0': 'O',
    '\u1ED6': 'O',
    '\u1ED4': 'O',
    '\u00D5': 'O',
    '\u1E4C': 'O',
    '\u022C': 'O',
    '\u1E4E': 'O',
    '\u014C': 'O',
    '\u1E50': 'O',
    '\u1E52': 'O',
    '\u014E': 'O',
    '\u022E': 'O',
    '\u0230': 'O',
    '\u00D6': 'O',
    '\u022A': 'O',
    '\u1ECE': 'O',
    '\u0150': 'O',
    '\u01D1': 'O',
    '\u020C': 'O',
    '\u020E': 'O',
    '\u01A0': 'O',
    '\u1EDC': 'O',
    '\u1EDA': 'O',
    '\u1EE0': 'O',
    '\u1EDE': 'O',
    '\u1EE2': 'O',
    '\u1ECC': 'O',
    '\u1ED8': 'O',
    '\u01EA': 'O',
    '\u01EC': 'O',
    '\u00D8': 'O',
    '\u01FE': 'O',
    '\u0186': 'O',
    '\u019F': 'O',
    '\uA74A': 'O',
    '\uA74C': 'O',
    '\u01A2': 'OI',
    '\uA74E': 'OO',
    '\u0222': 'OU',
    '\u24C5': 'P',
    '\uFF30': 'P',
    '\u1E54': 'P',
    '\u1E56': 'P',
    '\u01A4': 'P',
    '\u2C63': 'P',
    '\uA750': 'P',
    '\uA752': 'P',
    '\uA754': 'P',
    '\u24C6': 'Q',
    '\uFF31': 'Q',
    '\uA756': 'Q',
    '\uA758': 'Q',
    '\u024A': 'Q',
    '\u24C7': 'R',
    '\uFF32': 'R',
    '\u0154': 'R',
    '\u1E58': 'R',
    '\u0158': 'R',
    '\u0210': 'R',
    '\u0212': 'R',
    '\u1E5A': 'R',
    '\u1E5C': 'R',
    '\u0156': 'R',
    '\u1E5E': 'R',
    '\u024C': 'R',
    '\u2C64': 'R',
    '\uA75A': 'R',
    '\uA7A6': 'R',
    '\uA782': 'R',
    '\u24C8': 'S',
    '\uFF33': 'S',
    '\u1E9E': 'S',
    '\u015A': 'S',
    '\u1E64': 'S',
    '\u015C': 'S',
    '\u1E60': 'S',
    '\u0160': 'S',
    '\u1E66': 'S',
    '\u1E62': 'S',
    '\u1E68': 'S',
    '\u0218': 'S',
    '\u015E': 'S',
    '\u2C7E': 'S',
    '\uA7A8': 'S',
    '\uA784': 'S',
    '\u24C9': 'T',
    '\uFF34': 'T',
    '\u1E6A': 'T',
    '\u0164': 'T',
    '\u1E6C': 'T',
    '\u021A': 'T',
    '\u0162': 'T',
    '\u1E70': 'T',
    '\u1E6E': 'T',
    '\u0166': 'T',
    '\u01AC': 'T',
    '\u01AE': 'T',
    '\u023E': 'T',
    '\uA786': 'T',
    '\uA728': 'TZ',
    '\u24CA': 'U',
    '\uFF35': 'U',
    '\u00D9': 'U',
    '\u00DA': 'U',
    '\u00DB': 'U',
    '\u0168': 'U',
    '\u1E78': 'U',
    '\u016A': 'U',
    '\u1E7A': 'U',
    '\u016C': 'U',
    '\u00DC': 'U',
    '\u01DB': 'U',
    '\u01D7': 'U',
    '\u01D5': 'U',
    '\u01D9': 'U',
    '\u1EE6': 'U',
    '\u016E': 'U',
    '\u0170': 'U',
    '\u01D3': 'U',
    '\u0214': 'U',
    '\u0216': 'U',
    '\u01AF': 'U',
    '\u1EEA': 'U',
    '\u1EE8': 'U',
    '\u1EEE': 'U',
    '\u1EEC': 'U',
    '\u1EF0': 'U',
    '\u1EE4': 'U',
    '\u1E72': 'U',
    '\u0172': 'U',
    '\u1E76': 'U',
    '\u1E74': 'U',
    '\u0244': 'U',
    '\u24CB': 'V',
    '\uFF36': 'V',
    '\u1E7C': 'V',
    '\u1E7E': 'V',
    '\u01B2': 'V',
    '\uA75E': 'V',
    '\u0245': 'V',
    '\uA760': 'VY',
    '\u24CC': 'W',
    '\uFF37': 'W',
    '\u1E80': 'W',
    '\u1E82': 'W',
    '\u0174': 'W',
    '\u1E86': 'W',
    '\u1E84': 'W',
    '\u1E88': 'W',
    '\u2C72': 'W',
    '\u24CD': 'X',
    '\uFF38': 'X',
    '\u1E8A': 'X',
    '\u1E8C': 'X',
    '\u24CE': 'Y',
    '\uFF39': 'Y',
    '\u1EF2': 'Y',
    '\u00DD': 'Y',
    '\u0176': 'Y',
    '\u1EF8': 'Y',
    '\u0232': 'Y',
    '\u1E8E': 'Y',
    '\u0178': 'Y',
    '\u1EF6': 'Y',
    '\u1EF4': 'Y',
    '\u01B3': 'Y',
    '\u024E': 'Y',
    '\u1EFE': 'Y',
    '\u24CF': 'Z',
    '\uFF3A': 'Z',
    '\u0179': 'Z',
    '\u1E90': 'Z',
    '\u017B': 'Z',
    '\u017D': 'Z',
    '\u1E92': 'Z',
    '\u1E94': 'Z',
    '\u01B5': 'Z',
    '\u0224': 'Z',
    '\u2C7F': 'Z',
    '\u2C6B': 'Z',
    '\uA762': 'Z',
    '\u24D0': 'a',
    '\uFF41': 'a',
    '\u1E9A': 'a',
    '\u00E0': 'a',
    '\u00E1': 'a',
    '\u00E2': 'a',
    '\u1EA7': 'a',
    '\u1EA5': 'a',
    '\u1EAB': 'a',
    '\u1EA9': 'a',
    '\u00E3': 'a',
    '\u0101': 'a',
    '\u0103': 'a',
    '\u1EB1': 'a',
    '\u1EAF': 'a',
    '\u1EB5': 'a',
    '\u1EB3': 'a',
    '\u0227': 'a',
    '\u01E1': 'a',
    '\u00E4': 'a',
    '\u01DF': 'a',
    '\u1EA3': 'a',
    '\u00E5': 'a',
    '\u01FB': 'a',
    '\u01CE': 'a',
    '\u0201': 'a',
    '\u0203': 'a',
    '\u1EA1': 'a',
    '\u1EAD': 'a',
    '\u1EB7': 'a',
    '\u1E01': 'a',
    '\u0105': 'a',
    '\u2C65': 'a',
    '\u0250': 'a',
    '\uA733': 'aa',
    '\u00E6': 'ae',
    '\u01FD': 'ae',
    '\u01E3': 'ae',
    '\uA735': 'ao',
    '\uA737': 'au',
    '\uA739': 'av',
    '\uA73B': 'av',
    '\uA73D': 'ay',
    '\u24D1': 'b',
    '\uFF42': 'b',
    '\u1E03': 'b',
    '\u1E05': 'b',
    '\u1E07': 'b',
    '\u0180': 'b',
    '\u0183': 'b',
    '\u0253': 'b',
    '\u24D2': 'c',
    '\uFF43': 'c',
    '\u0107': 'c',
    '\u0109': 'c',
    '\u010B': 'c',
    '\u010D': 'c',
    '\u00E7': 'c',
    '\u1E09': 'c',
    '\u0188': 'c',
    '\u023C': 'c',
    '\uA73F': 'c',
    '\u2184': 'c',
    '\u24D3': 'd',
    '\uFF44': 'd',
    '\u1E0B': 'd',
    '\u010F': 'd',
    '\u1E0D': 'd',
    '\u1E11': 'd',
    '\u1E13': 'd',
    '\u1E0F': 'd',
    '\u0111': 'd',
    '\u018C': 'd',
    '\u0256': 'd',
    '\u0257': 'd',
    '\uA77A': 'd',
    '\u01F3': 'dz',
    '\u01C6': 'dz',
    '\u24D4': 'e',
    '\uFF45': 'e',
    '\u00E8': 'e',
    '\u00E9': 'e',
    '\u00EA': 'e',
    '\u1EC1': 'e',
    '\u1EBF': 'e',
    '\u1EC5': 'e',
    '\u1EC3': 'e',
    '\u1EBD': 'e',
    '\u0113': 'e',
    '\u1E15': 'e',
    '\u1E17': 'e',
    '\u0115': 'e',
    '\u0117': 'e',
    '\u00EB': 'e',
    '\u1EBB': 'e',
    '\u011B': 'e',
    '\u0205': 'e',
    '\u0207': 'e',
    '\u1EB9': 'e',
    '\u1EC7': 'e',
    '\u0229': 'e',
    '\u1E1D': 'e',
    '\u0119': 'e',
    '\u1E19': 'e',
    '\u1E1B': 'e',
    '\u0247': 'e',
    '\u025B': 'e',
    '\u01DD': 'e',
    '\u24D5': 'f',
    '\uFF46': 'f',
    '\u1E1F': 'f',
    '\u0192': 'f',
    '\uA77C': 'f',
    '\u24D6': 'g',
    '\uFF47': 'g',
    '\u01F5': 'g',
    '\u011D': 'g',
    '\u1E21': 'g',
    '\u011F': 'g',
    '\u0121': 'g',
    '\u01E7': 'g',
    '\u0123': 'g',
    '\u01E5': 'g',
    '\u0260': 'g',
    '\uA7A1': 'g',
    '\u1D79': 'g',
    '\uA77F': 'g',
    '\u24D7': 'h',
    '\uFF48': 'h',
    '\u0125': 'h',
    '\u1E23': 'h',
    '\u1E27': 'h',
    '\u021F': 'h',
    '\u1E25': 'h',
    '\u1E29': 'h',
    '\u1E2B': 'h',
    '\u1E96': 'h',
    '\u0127': 'h',
    '\u2C68': 'h',
    '\u2C76': 'h',
    '\u0265': 'h',
    '\u0195': 'hv',
    '\u24D8': 'i',
    '\uFF49': 'i',
    '\u00EC': 'i',
    '\u00ED': 'i',
    '\u00EE': 'i',
    '\u0129': 'i',
    '\u012B': 'i',
    '\u012D': 'i',
    '\u00EF': 'i',
    '\u1E2F': 'i',
    '\u1EC9': 'i',
    '\u01D0': 'i',
    '\u0209': 'i',
    '\u020B': 'i',
    '\u1ECB': 'i',
    '\u012F': 'i',
    '\u1E2D': 'i',
    '\u0268': 'i',
    '\u0131': 'i',
    '\u24D9': 'j',
    '\uFF4A': 'j',
    '\u0135': 'j',
    '\u01F0': 'j',
    '\u0249': 'j',
    '\u24DA': 'k',
    '\uFF4B': 'k',
    '\u1E31': 'k',
    '\u01E9': 'k',
    '\u1E33': 'k',
    '\u0137': 'k',
    '\u1E35': 'k',
    '\u0199': 'k',
    '\u2C6A': 'k',
    '\uA741': 'k',
    '\uA743': 'k',
    '\uA745': 'k',
    '\uA7A3': 'k',
    '\u24DB': 'l',
    '\uFF4C': 'l',
    '\u0140': 'l',
    '\u013A': 'l',
    '\u013E': 'l',
    '\u1E37': 'l',
    '\u1E39': 'l',
    '\u013C': 'l',
    '\u1E3D': 'l',
    '\u1E3B': 'l',
    '\u017F': 'l',
    '\u0142': 'l',
    '\u019A': 'l',
    '\u026B': 'l',
    '\u2C61': 'l',
    '\uA749': 'l',
    '\uA781': 'l',
    '\uA747': 'l',
    '\u01C9': 'lj',
    '\u24DC': 'm',
    '\uFF4D': 'm',
    '\u1E3F': 'm',
    '\u1E41': 'm',
    '\u1E43': 'm',
    '\u0271': 'm',
    '\u026F': 'm',
    '\u24DD': 'n',
    '\uFF4E': 'n',
    '\u01F9': 'n',
    '\u0144': 'n',
    '\u00F1': 'n',
    '\u1E45': 'n',
    '\u0148': 'n',
    '\u1E47': 'n',
    '\u0146': 'n',
    '\u1E4B': 'n',
    '\u1E49': 'n',
    '\u019E': 'n',
    '\u0272': 'n',
    '\u0149': 'n',
    '\uA791': 'n',
    '\uA7A5': 'n',
    '\u01CC': 'nj',
    '\u24DE': 'o',
    '\uFF4F': 'o',
    '\u00F2': 'o',
    '\u00F3': 'o',
    '\u00F4': 'o',
    '\u1ED3': 'o',
    '\u1ED1': 'o',
    '\u1ED7': 'o',
    '\u1ED5': 'o',
    '\u00F5': 'o',
    '\u1E4D': 'o',
    '\u022D': 'o',
    '\u1E4F': 'o',
    '\u014D': 'o',
    '\u1E51': 'o',
    '\u1E53': 'o',
    '\u014F': 'o',
    '\u022F': 'o',
    '\u0231': 'o',
    '\u00F6': 'o',
    '\u022B': 'o',
    '\u1ECF': 'o',
    '\u0151': 'o',
    '\u01D2': 'o',
    '\u020D': 'o',
    '\u020F': 'o',
    '\u01A1': 'o',
    '\u1EDD': 'o',
    '\u1EDB': 'o',
    '\u1EE1': 'o',
    '\u1EDF': 'o',
    '\u1EE3': 'o',
    '\u1ECD': 'o',
    '\u1ED9': 'o',
    '\u01EB': 'o',
    '\u01ED': 'o',
    '\u00F8': 'o',
    '\u01FF': 'o',
    '\u0254': 'o',
    '\uA74B': 'o',
    '\uA74D': 'o',
    '\u0275': 'o',
    '\u01A3': 'oi',
    '\u0223': 'ou',
    '\uA74F': 'oo',
    '\u24DF': 'p',
    '\uFF50': 'p',
    '\u1E55': 'p',
    '\u1E57': 'p',
    '\u01A5': 'p',
    '\u1D7D': 'p',
    '\uA751': 'p',
    '\uA753': 'p',
    '\uA755': 'p',
    '\u24E0': 'q',
    '\uFF51': 'q',
    '\u024B': 'q',
    '\uA757': 'q',
    '\uA759': 'q',
    '\u24E1': 'r',
    '\uFF52': 'r',
    '\u0155': 'r',
    '\u1E59': 'r',
    '\u0159': 'r',
    '\u0211': 'r',
    '\u0213': 'r',
    '\u1E5B': 'r',
    '\u1E5D': 'r',
    '\u0157': 'r',
    '\u1E5F': 'r',
    '\u024D': 'r',
    '\u027D': 'r',
    '\uA75B': 'r',
    '\uA7A7': 'r',
    '\uA783': 'r',
    '\u24E2': 's',
    '\uFF53': 's',
    '\u00DF': 's',
    '\u015B': 's',
    '\u1E65': 's',
    '\u015D': 's',
    '\u1E61': 's',
    '\u0161': 's',
    '\u1E67': 's',
    '\u1E63': 's',
    '\u1E69': 's',
    '\u0219': 's',
    '\u015F': 's',
    '\u023F': 's',
    '\uA7A9': 's',
    '\uA785': 's',
    '\u1E9B': 's',
    '\u24E3': 't',
    '\uFF54': 't',
    '\u1E6B': 't',
    '\u1E97': 't',
    '\u0165': 't',
    '\u1E6D': 't',
    '\u021B': 't',
    '\u0163': 't',
    '\u1E71': 't',
    '\u1E6F': 't',
    '\u0167': 't',
    '\u01AD': 't',
    '\u0288': 't',
    '\u2C66': 't',
    '\uA787': 't',
    '\uA729': 'tz',
    '\u24E4': 'u',
    '\uFF55': 'u',
    '\u00F9': 'u',
    '\u00FA': 'u',
    '\u00FB': 'u',
    '\u0169': 'u',
    '\u1E79': 'u',
    '\u016B': 'u',
    '\u1E7B': 'u',
    '\u016D': 'u',
    '\u00FC': 'u',
    '\u01DC': 'u',
    '\u01D8': 'u',
    '\u01D6': 'u',
    '\u01DA': 'u',
    '\u1EE7': 'u',
    '\u016F': 'u',
    '\u0171': 'u',
    '\u01D4': 'u',
    '\u0215': 'u',
    '\u0217': 'u',
    '\u01B0': 'u',
    '\u1EEB': 'u',
    '\u1EE9': 'u',
    '\u1EEF': 'u',
    '\u1EED': 'u',
    '\u1EF1': 'u',
    '\u1EE5': 'u',
    '\u1E73': 'u',
    '\u0173': 'u',
    '\u1E77': 'u',
    '\u1E75': 'u',
    '\u0289': 'u',
    '\u24E5': 'v',
    '\uFF56': 'v',
    '\u1E7D': 'v',
    '\u1E7F': 'v',
    '\u028B': 'v',
    '\uA75F': 'v',
    '\u028C': 'v',
    '\uA761': 'vy',
    '\u24E6': 'w',
    '\uFF57': 'w',
    '\u1E81': 'w',
    '\u1E83': 'w',
    '\u0175': 'w',
    '\u1E87': 'w',
    '\u1E85': 'w',
    '\u1E98': 'w',
    '\u1E89': 'w',
    '\u2C73': 'w',
    '\u24E7': 'x',
    '\uFF58': 'x',
    '\u1E8B': 'x',
    '\u1E8D': 'x',
    '\u24E8': 'y',
    '\uFF59': 'y',
    '\u1EF3': 'y',
    '\u00FD': 'y',
    '\u0177': 'y',
    '\u1EF9': 'y',
    '\u0233': 'y',
    '\u1E8F': 'y',
    '\u00FF': 'y',
    '\u1EF7': 'y',
    '\u1E99': 'y',
    '\u1EF5': 'y',
    '\u01B4': 'y',
    '\u024F': 'y',
    '\u1EFF': 'y',
    '\u24E9': 'z',
    '\uFF5A': 'z',
    '\u017A': 'z',
    '\u1E91': 'z',
    '\u017C': 'z',
    '\u017E': 'z',
    '\u1E93': 'z',
    '\u1E95': 'z',
    '\u01B6': 'z',
    '\u0225': 'z',
    '\u0240': 'z',
    '\u2C6C': 'z',
    '\uA763': 'z',
    '\u0386': '\u0391',
    '\u0388': '\u0395',
    '\u0389': '\u0397',
    '\u038A': '\u0399',
    '\u03AA': '\u0399',
    '\u038C': '\u039F',
    '\u038E': '\u03A5',
    '\u03AB': '\u03A5',
    '\u038F': '\u03A9',
    '\u03AC': '\u03B1',
    '\u03AD': '\u03B5',
    '\u03AE': '\u03B7',
    '\u03AF': '\u03B9',
    '\u03CA': '\u03B9',
    '\u0390': '\u03B9',
    '\u03CC': '\u03BF',
    '\u03CD': '\u03C5',
    '\u03CB': '\u03C5',
    '\u03B0': '\u03C5',
    '\u03C9': '\u03C9',
    '\u03C2': '\u03C3'
  };

  return diacritics;
});

S2.define('select2/data/base',[
  '../utils'
], function (Utils) {
  function BaseAdapter ($element, options) {
    BaseAdapter.__super__.constructor.call(this);
  }

  Utils.Extend(BaseAdapter, Utils.Observable);

  BaseAdapter.prototype.current = function (callback) {
    throw new Error('The `current` method must be defined in child classes.');
  };

  BaseAdapter.prototype.query = function (params, callback) {
    throw new Error('The `query` method must be defined in child classes.');
  };

  BaseAdapter.prototype.bind = function (container, $container) {
    // Can be implemented in subclasses
  };

  BaseAdapter.prototype.destroy = function () {
    // Can be implemented in subclasses
  };

  BaseAdapter.prototype.generateResultId = function (container, data) {
    var id = container.id + '-result-';

    id += Utils.generateChars(4);

    if (data.id != null) {
      id += '-' + data.id.toString();
    } else {
      id += '-' + Utils.generateChars(4);
    }
    return id;
  };

  return BaseAdapter;
});

S2.define('select2/data/select',[
  './base',
  '../utils',
  'jquery'
], function (BaseAdapter, Utils, $) {
  function SelectAdapter ($element, options) {
    this.$element = $element;
    this.options = options;

    SelectAdapter.__super__.constructor.call(this);
  }

  Utils.Extend(SelectAdapter, BaseAdapter);

  SelectAdapter.prototype.current = function (callback) {
    var data = [];
    var self = this;

    this.$element.find(':selected').each(function () {
      var $option = $(this);

      var option = self.item($option);

      data.push(option);
    });

    callback(data);
  };

  SelectAdapter.prototype.select = function (data) {
    var self = this;

    data.selected = true;

    // If data.element is a DOM node, use it instead
    if ($(data.element).is('option')) {
      data.element.selected = true;

      this.$element.trigger('change');

      return;
    }

    if (this.$element.prop('multiple')) {
      this.current(function (currentData) {
        var val = [];

        data = [data];
        data.push.apply(data, currentData);

        for (var d = 0; d < data.length; d++) {
          var id = data[d].id;

          if ($.inArray(id, val) === -1) {
            val.push(id);
          }
        }

        self.$element.val(val);
        self.$element.trigger('change');
      });
    } else {
      var val = data.id;

      this.$element.val(val);
      this.$element.trigger('change');
    }
  };

  SelectAdapter.prototype.unselect = function (data) {
    var self = this;

    if (!this.$element.prop('multiple')) {
      return;
    }

    data.selected = false;

    if ($(data.element).is('option')) {
      data.element.selected = false;

      this.$element.trigger('change');

      return;
    }

    this.current(function (currentData) {
      var val = [];

      for (var d = 0; d < currentData.length; d++) {
        var id = currentData[d].id;

        if (id !== data.id && $.inArray(id, val) === -1) {
          val.push(id);
        }
      }

      self.$element.val(val);

      self.$element.trigger('change');
    });
  };

  SelectAdapter.prototype.bind = function (container, $container) {
    var self = this;

    this.container = container;

    container.on('select', function (params) {
      self.select(params.data);
    });

    container.on('unselect', function (params) {
      self.unselect(params.data);
    });
  };

  SelectAdapter.prototype.destroy = function () {
    // Remove anything added to child elements
    this.$element.find('*').each(function () {
      // Remove any custom data set by Select2
      $.removeData(this, 'data');
    });
  };

  SelectAdapter.prototype.query = function (params, callback) {
    var data = [];
    var self = this;

    var $options = this.$element.children();

    $options.each(function () {
      var $option = $(this);

      if (!$option.is('option') && !$option.is('optgroup')) {
        return;
      }

      var option = self.item($option);

      var matches = self.matches(params, option);

      if (matches !== null) {
        data.push(matches);
      }
    });

    callback({
      results: data
    });
  };

  SelectAdapter.prototype.addOptions = function ($options) {
    Utils.appendMany(this.$element, $options);
  };

  SelectAdapter.prototype.option = function (data) {
    var option;

    if (data.children) {
      option = document.createElement('optgroup');
      option.label = data.text;
    } else {
      option = document.createElement('option');

      if (option.textContent !== undefined) {
        option.textContent = data.text;
      } else {
        option.innerText = data.text;
      }
    }

    if (data.id) {
      option.value = data.id;
    }

    if (data.disabled) {
      option.disabled = true;
    }

    if (data.selected) {
      option.selected = true;
    }

    if (data.title) {
      option.title = data.title;
    }

    var $option = $(option);

    var normalizedData = this._normalizeItem(data);
    normalizedData.element = option;

    // Override the option's data with the combined data
    $.data(option, 'data', normalizedData);

    return $option;
  };

  SelectAdapter.prototype.item = function ($option) {
    var data = {};

    data = $.data($option[0], 'data');

    if (data != null) {
      return data;
    }

    if ($option.is('option')) {
      data = {
        id: $option.val(),
        text: $option.text(),
        disabled: $option.prop('disabled'),
        selected: $option.prop('selected'),
        title: $option.prop('title')
      };
    } else if ($option.is('optgroup')) {
      data = {
        text: $option.prop('label'),
        children: [],
        title: $option.prop('title')
      };

      var $children = $option.children('option');
      var children = [];

      for (var c = 0; c < $children.length; c++) {
        var $child = $($children[c]);

        var child = this.item($child);

        children.push(child);
      }

      data.children = children;
    }

    data = this._normalizeItem(data);
    data.element = $option[0];

    $.data($option[0], 'data', data);

    return data;
  };

  SelectAdapter.prototype._normalizeItem = function (item) {
    if (!$.isPlainObject(item)) {
      item = {
        id: item,
        text: item
      };
    }

    item = $.extend({}, {
      text: ''
    }, item);

    var defaults = {
      selected: false,
      disabled: false
    };

    if (item.id != null) {
      item.id = item.id.toString();
    }

    if (item.text != null) {
      item.text = item.text.toString();
    }

    if (item._resultId == null && item.id && this.container != null) {
      item._resultId = this.generateResultId(this.container, item);
    }

    return $.extend({}, defaults, item);
  };

  SelectAdapter.prototype.matches = function (params, data) {
    var matcher = this.options.get('matcher');

    return matcher(params, data);
  };

  return SelectAdapter;
});

S2.define('select2/data/array',[
  './select',
  '../utils',
  'jquery'
], function (SelectAdapter, Utils, $) {
  function ArrayAdapter ($element, options) {
    var data = options.get('data') || [];

    ArrayAdapter.__super__.constructor.call(this, $element, options);

    this.addOptions(this.convertToOptions(data));
  }

  Utils.Extend(ArrayAdapter, SelectAdapter);

  ArrayAdapter.prototype.select = function (data) {
    var $option = this.$element.find('option').filter(function (i, elm) {
      return elm.value == data.id.toString();
    });

    if ($option.length === 0) {
      $option = this.option(data);

      this.addOptions($option);
    }

    ArrayAdapter.__super__.select.call(this, data);
  };

  ArrayAdapter.prototype.convertToOptions = function (data) {
    var self = this;

    var $existing = this.$element.find('option');
    var existingIds = $existing.map(function () {
      return self.item($(this)).id;
    }).get();

    var $options = [];

    // Filter out all items except for the one passed in the argument
    function onlyItem (item) {
      return function () {
        return $(this).val() == item.id;
      };
    }

    for (var d = 0; d < data.length; d++) {
      var item = this._normalizeItem(data[d]);

      // Skip items which were pre-loaded, only merge the data
      if ($.inArray(item.id, existingIds) >= 0) {
        var $existingOption = $existing.filter(onlyItem(item));

        var existingData = this.item($existingOption);
        var newData = $.extend(true, {}, item, existingData);

        var $newOption = this.option(newData);

        $existingOption.replaceWith($newOption);

        continue;
      }

      var $option = this.option(item);

      if (item.children) {
        var $children = this.convertToOptions(item.children);

        Utils.appendMany($option, $children);
      }

      $options.push($option);
    }

    return $options;
  };

  return ArrayAdapter;
});

S2.define('select2/data/ajax',[
  './array',
  '../utils',
  'jquery'
], function (ArrayAdapter, Utils, $) {
  function AjaxAdapter ($element, options) {
    this.ajaxOptions = this._applyDefaults(options.get('ajax'));

    if (this.ajaxOptions.processResults != null) {
      this.processResults = this.ajaxOptions.processResults;
    }

    AjaxAdapter.__super__.constructor.call(this, $element, options);
  }

  Utils.Extend(AjaxAdapter, ArrayAdapter);

  AjaxAdapter.prototype._applyDefaults = function (options) {
    var defaults = {
      data: function (params) {
        return $.extend({}, params, {
          q: params.term
        });
      },
      transport: function (params, success, failure) {
        var $request = $.ajax(params);

        $request.then(success);
        $request.fail(failure);

        return $request;
      }
    };

    return $.extend({}, defaults, options, true);
  };

  AjaxAdapter.prototype.processResults = function (results) {
    return results;
  };

  AjaxAdapter.prototype.query = function (params, callback) {
    var matches = [];
    var self = this;

    if (this._request != null) {
      // JSONP requests cannot always be aborted
      if ($.isFunction(this._request.abort)) {
        this._request.abort();
      }

      this._request = null;
    }

    var options = $.extend({
      type: 'GET'
    }, this.ajaxOptions);

    if (typeof options.url === 'function') {
      options.url = options.url.call(this.$element, params);
    }

    if (typeof options.data === 'function') {
      options.data = options.data.call(this.$element, params);
    }

    function request () {
      var $request = options.transport(options, function (data) {
        var results = self.processResults(data, params);

        if (self.options.get('debug') && window.console && console.error) {
          // Check to make sure that the response included a `results` key.
          if (!results || !results.results || !$.isArray(results.results)) {
            console.error(
              'Select2: The AJAX results did not return an array in the ' +
              '`results` key of the response.'
            );
          }
        }

        callback(results);
      }, function () {
        // Attempt to detect if a request was aborted
        // Only works if the transport exposes a status property
        if ($request.status && $request.status === '0') {
          return;
        }

        self.trigger('results:message', {
          message: 'errorLoading'
        });
      });

      self._request = $request;
    }

    if (this.ajaxOptions.delay && params.term != null) {
      if (this._queryTimeout) {
        window.clearTimeout(this._queryTimeout);
      }

      this._queryTimeout = window.setTimeout(request, this.ajaxOptions.delay);
    } else {
      request();
    }
  };

  return AjaxAdapter;
});

S2.define('select2/data/tags',[
  'jquery'
], function ($) {
  function Tags (decorated, $element, options) {
    var tags = options.get('tags');

    var createTag = options.get('createTag');

    if (createTag !== undefined) {
      this.createTag = createTag;
    }

    var insertTag = options.get('insertTag');

    if (insertTag !== undefined) {
        this.insertTag = insertTag;
    }

    decorated.call(this, $element, options);

    if ($.isArray(tags)) {
      for (var t = 0; t < tags.length; t++) {
        var tag = tags[t];
        var item = this._normalizeItem(tag);

        var $option = this.option(item);

        this.$element.append($option);
      }
    }
  }

  Tags.prototype.query = function (decorated, params, callback) {
    var self = this;

    this._removeOldTags();

    if (params.term == null || params.page != null) {
      decorated.call(this, params, callback);
      return;
    }

    function wrapper (obj, child) {
      var data = obj.results;

      for (var i = 0; i < data.length; i++) {
        var option = data[i];

        var checkChildren = (
          option.children != null &&
          !wrapper({
            results: option.children
          }, true)
        );

        var checkText = option.text === params.term;

        if (checkText || checkChildren) {
          if (child) {
            return false;
          }

          obj.data = data;
          callback(obj);

          return;
        }
      }

      if (child) {
        return true;
      }

      var tag = self.createTag(params);

      if (tag != null) {
        var $option = self.option(tag);
        $option.attr('data-select2-tag', true);

        self.addOptions([$option]);

        self.insertTag(data, tag);
      }

      obj.results = data;

      callback(obj);
    }

    decorated.call(this, params, wrapper);
  };

  Tags.prototype.createTag = function (decorated, params) {
    var term = $.trim(params.term);

    if (term === '') {
      return null;
    }

    return {
      id: term,
      text: term
    };
  };

  Tags.prototype.insertTag = function (_, data, tag) {
    data.unshift(tag);
  };

  Tags.prototype._removeOldTags = function (_) {
    var tag = this._lastTag;

    var $options = this.$element.find('option[data-select2-tag]');

    $options.each(function () {
      if (this.selected) {
        return;
      }

      $(this).remove();
    });
  };

  return Tags;
});

S2.define('select2/data/tokenizer',[
  'jquery'
], function ($) {
  function Tokenizer (decorated, $element, options) {
    var tokenizer = options.get('tokenizer');

    if (tokenizer !== undefined) {
      this.tokenizer = tokenizer;
    }

    decorated.call(this, $element, options);
  }

  Tokenizer.prototype.bind = function (decorated, container, $container) {
    decorated.call(this, container, $container);

    this.$search =  container.dropdown.$search || container.selection.$search ||
      $container.find('.select2-search__field');
  };

  Tokenizer.prototype.query = function (decorated, params, callback) {
    var self = this;

    function createAndSelect (data) {
      // Normalize the data object so we can use it for checks
      var item = self._normalizeItem(data);

      // Check if the data object already exists as a tag
      // Select it if it doesn't
      var $existingOptions = self.$element.find('option').filter(function () {
        return $(this).val() === item.id;
      });

      // If an existing option wasn't found for it, create the option
      if (!$existingOptions.length) {
        var $option = self.option(item);
        $option.attr('data-select2-tag', true);

        self._removeOldTags();
        self.addOptions([$option]);
      }

      // Select the item, now that we know there is an option for it
      select(item);
    }

    function select (data) {
      self.trigger('select', {
        data: data
      });
    }

    params.term = params.term || '';

    var tokenData = this.tokenizer(params, this.options, createAndSelect);

    if (tokenData.term !== params.term) {
      // Replace the search term if we have the search box
      if (this.$search.length) {
        this.$search.val(tokenData.term);
        this.$search.focus();
      }

      params.term = tokenData.term;
    }

    decorated.call(this, params, callback);
  };

  Tokenizer.prototype.tokenizer = function (_, params, options, callback) {
    var separators = options.get('tokenSeparators') || [];
    var term = params.term;
    var i = 0;

    var createTag = this.createTag || function (params) {
      return {
        id: params.term,
        text: params.term
      };
    };

    while (i < term.length) {
      var termChar = term[i];

      if ($.inArray(termChar, separators) === -1) {
        i++;

        continue;
      }

      var part = term.substr(0, i);
      var partParams = $.extend({}, params, {
        term: part
      });

      var data = createTag(partParams);

      if (data == null) {
        i++;
        continue;
      }

      callback(data);

      // Reset the term to not include the tokenized portion
      term = term.substr(i + 1) || '';
      i = 0;
    }

    return {
      term: term
    };
  };

  return Tokenizer;
});

S2.define('select2/data/minimumInputLength',[

], function () {
  function MinimumInputLength (decorated, $e, options) {
    this.minimumInputLength = options.get('minimumInputLength');

    decorated.call(this, $e, options);
  }

  MinimumInputLength.prototype.query = function (decorated, params, callback) {
    params.term = params.term || '';

    if (params.term.length < this.minimumInputLength) {
      this.trigger('results:message', {
        message: 'inputTooShort',
        args: {
          minimum: this.minimumInputLength,
          input: params.term,
          params: params
        }
      });

      return;
    }

    decorated.call(this, params, callback);
  };

  return MinimumInputLength;
});

S2.define('select2/data/maximumInputLength',[

], function () {
  function MaximumInputLength (decorated, $e, options) {
    this.maximumInputLength = options.get('maximumInputLength');

    decorated.call(this, $e, options);
  }

  MaximumInputLength.prototype.query = function (decorated, params, callback) {
    params.term = params.term || '';

    if (this.maximumInputLength > 0 &&
        params.term.length > this.maximumInputLength) {
      this.trigger('results:message', {
        message: 'inputTooLong',
        args: {
          maximum: this.maximumInputLength,
          input: params.term,
          params: params
        }
      });

      return;
    }

    decorated.call(this, params, callback);
  };

  return MaximumInputLength;
});

S2.define('select2/data/maximumSelectionLength',[

], function (){
  function MaximumSelectionLength (decorated, $e, options) {
    this.maximumSelectionLength = options.get('maximumSelectionLength');

    decorated.call(this, $e, options);
  }

  MaximumSelectionLength.prototype.query =
    function (decorated, params, callback) {
      var self = this;

      this.current(function (currentData) {
        var count = currentData != null ? currentData.length : 0;
        if (self.maximumSelectionLength > 0 &&
          count >= self.maximumSelectionLength) {
          self.trigger('results:message', {
            message: 'maximumSelected',
            args: {
              maximum: self.maximumSelectionLength
            }
          });
          return;
        }
        decorated.call(self, params, callback);
      });
  };

  return MaximumSelectionLength;
});

S2.define('select2/dropdown',[
  'jquery',
  './utils'
], function ($, Utils) {
  function Dropdown ($element, options) {
    this.$element = $element;
    this.options = options;

    Dropdown.__super__.constructor.call(this);
  }

  Utils.Extend(Dropdown, Utils.Observable);

  Dropdown.prototype.render = function () {
    var $dropdown = $(
      '<span class="select2-dropdown">' +
        '<span class="select2-results"></span>' +
      '</span>'
    );

    $dropdown.attr('dir', this.options.get('dir'));

    this.$dropdown = $dropdown;

    return $dropdown;
  };

  Dropdown.prototype.bind = function () {
    // Should be implemented in subclasses
  };

  Dropdown.prototype.position = function ($dropdown, $container) {
    // Should be implmented in subclasses
  };

  Dropdown.prototype.destroy = function () {
    // Remove the dropdown from the DOM
    this.$dropdown.remove();
  };

  return Dropdown;
});

S2.define('select2/dropdown/search',[
  'jquery',
  '../utils'
], function ($, Utils) {
  function Search () { }

  Search.prototype.render = function (decorated) {
    var $rendered = decorated.call(this);

    var $search = $(
      '<span class="select2-search select2-search--dropdown">' +
        '<input class="select2-search__field" type="search" tabindex="-1"' +
        ' autocomplete="off" autocorrect="off" autocapitalize="off"' +
        ' spellcheck="false" role="textbox" />' +
      '</span>'
    );

    this.$searchContainer = $search;
    this.$search = $search.find('input');

    $rendered.prepend($search);

    return $rendered;
  };

  Search.prototype.bind = function (decorated, container, $container) {
    var self = this;

    decorated.call(this, container, $container);

    this.$search.on('keydown', function (evt) {
      self.trigger('keypress', evt);

      self._keyUpPrevented = evt.isDefaultPrevented();
    });

    // Workaround for browsers which do not support the `input` event
    // This will prevent double-triggering of events for browsers which support
    // both the `keyup` and `input` events.
    this.$search.on('input', function (evt) {
      // Unbind the duplicated `keyup` event
      $(this).off('keyup');
    });

    this.$search.on('keyup input', function (evt) {
      self.handleSearch(evt);
    });

    container.on('open', function () {
      self.$search.attr('tabindex', 0);

      self.$search.focus();

      window.setTimeout(function () {
        self.$search.focus();
      }, 0);
    });

    container.on('close', function () {
      self.$search.attr('tabindex', -1);

      self.$search.val('');
    });

    container.on('focus', function () {
      if (container.isOpen()) {
        self.$search.focus();
      }
    });

    container.on('results:all', function (params) {
      if (params.query.term == null || params.query.term === '') {
        var showSearch = self.showSearch(params);

        if (showSearch) {
          self.$searchContainer.removeClass('select2-search--hide');
        } else {
          self.$searchContainer.addClass('select2-search--hide');
        }
      }
    });
  };

  Search.prototype.handleSearch = function (evt) {
    if (!this._keyUpPrevented) {
      var input = this.$search.val();

      this.trigger('query', {
        term: input
      });
    }

    this._keyUpPrevented = false;
  };

  Search.prototype.showSearch = function (_, params) {
    return true;
  };

  return Search;
});

S2.define('select2/dropdown/hidePlaceholder',[

], function () {
  function HidePlaceholder (decorated, $element, options, dataAdapter) {
    this.placeholder = this.normalizePlaceholder(options.get('placeholder'));

    decorated.call(this, $element, options, dataAdapter);
  }

  HidePlaceholder.prototype.append = function (decorated, data) {
    data.results = this.removePlaceholder(data.results);

    decorated.call(this, data);
  };

  HidePlaceholder.prototype.normalizePlaceholder = function (_, placeholder) {
    if (typeof placeholder === 'string') {
      placeholder = {
        id: '',
        text: placeholder
      };
    }

    return placeholder;
  };

  HidePlaceholder.prototype.removePlaceholder = function (_, data) {
    var modifiedData = data.slice(0);

    for (var d = data.length - 1; d >= 0; d--) {
      var item = data[d];

      if (this.placeholder.id === item.id) {
        modifiedData.splice(d, 1);
      }
    }

    return modifiedData;
  };

  return HidePlaceholder;
});

S2.define('select2/dropdown/infiniteScroll',[
  'jquery'
], function ($) {
  function InfiniteScroll (decorated, $element, options, dataAdapter) {
    this.lastParams = {};

    decorated.call(this, $element, options, dataAdapter);

    this.$loadingMore = this.createLoadingMore();
    this.loading = false;
  }

  InfiniteScroll.prototype.append = function (decorated, data) {
    this.$loadingMore.remove();
    this.loading = false;

    decorated.call(this, data);

    if (this.showLoadingMore(data)) {
      this.$results.append(this.$loadingMore);
    }
  };

  InfiniteScroll.prototype.bind = function (decorated, container, $container) {
    var self = this;

    decorated.call(this, container, $container);

    container.on('query', function (params) {
      self.lastParams = params;
      self.loading = true;
    });

    container.on('query:append', function (params) {
      self.lastParams = params;
      self.loading = true;
    });

    this.$results.on('scroll', function () {
      var isLoadMoreVisible = $.contains(
        document.documentElement,
        self.$loadingMore[0]
      );

      if (self.loading || !isLoadMoreVisible) {
        return;
      }

      var currentOffset = self.$results.offset().top +
        self.$results.outerHeight(false);
      var loadingMoreOffset = self.$loadingMore.offset().top +
        self.$loadingMore.outerHeight(false);

      if (currentOffset + 50 >= loadingMoreOffset) {
        self.loadMore();
      }
    });
  };

  InfiniteScroll.prototype.loadMore = function () {
    this.loading = true;

    var params = $.extend({}, {page: 1}, this.lastParams);

    params.page++;

    this.trigger('query:append', params);
  };

  InfiniteScroll.prototype.showLoadingMore = function (_, data) {
    return data.pagination && data.pagination.more;
  };

  InfiniteScroll.prototype.createLoadingMore = function () {
    var $option = $(
      '<li ' +
      'class="select2-results__option select2-results__option--load-more"' +
      'role="treeitem" aria-disabled="true"></li>'
    );

    var message = this.options.get('translations').get('loadingMore');

    $option.html(message(this.lastParams));

    return $option;
  };

  return InfiniteScroll;
});

S2.define('select2/dropdown/attachBody',[
  'jquery',
  '../utils'
], function ($, Utils) {
  function AttachBody (decorated, $element, options) {
    this.$dropdownParent = options.get('dropdownParent') || $(document.body);

    decorated.call(this, $element, options);
  }

  AttachBody.prototype.bind = function (decorated, container, $container) {
    var self = this;

    var setupResultsEvents = false;

    decorated.call(this, container, $container);

    container.on('open', function () {
      self._showDropdown();
      self._attachPositioningHandler(container);

      if (!setupResultsEvents) {
        setupResultsEvents = true;

        container.on('results:all', function () {
          self._positionDropdown();
          self._resizeDropdown();
        });

        container.on('results:append', function () {
          self._positionDropdown();
          self._resizeDropdown();
        });
      }
    });

    container.on('close', function () {
      self._hideDropdown();
      self._detachPositioningHandler(container);
    });

    this.$dropdownContainer.on('mousedown', function (evt) {
      evt.stopPropagation();
    });
  };

  AttachBody.prototype.destroy = function (decorated) {
    decorated.call(this);

    this.$dropdownContainer.remove();
  };

  AttachBody.prototype.position = function (decorated, $dropdown, $container) {
    // Clone all of the container classes
    $dropdown.attr('class', $container.attr('class'));

    $dropdown.removeClass('select2');
    $dropdown.addClass('select2-container--open');

    $dropdown.css({
      position: 'absolute',
      top: -999999
    });

    this.$container = $container;
  };

  AttachBody.prototype.render = function (decorated) {
    var $container = $('<span></span>');

    var $dropdown = decorated.call(this);
    $container.append($dropdown);

    this.$dropdownContainer = $container;

    return $container;
  };

  AttachBody.prototype._hideDropdown = function (decorated) {
    this.$dropdownContainer.detach();
  };

  AttachBody.prototype._attachPositioningHandler =
      function (decorated, container) {
    var self = this;

    var scrollEvent = 'scroll.select2.' + container.id;
    var resizeEvent = 'resize.select2.' + container.id;
    var orientationEvent = 'orientationchange.select2.' + container.id;

    var $watchers = this.$container.parents().filter(Utils.hasScroll);
    $watchers.each(function () {
      $(this).data('select2-scroll-position', {
        x: $(this).scrollLeft(),
        y: $(this).scrollTop()
      });
    });

    $watchers.on(scrollEvent, function (ev) {
      var position = $(this).data('select2-scroll-position');
      $(this).scrollTop(position.y);
    });

    $(window).on(scrollEvent + ' ' + resizeEvent + ' ' + orientationEvent,
      function (e) {
      self._positionDropdown();
      self._resizeDropdown();
    });
  };

  AttachBody.prototype._detachPositioningHandler =
      function (decorated, container) {
    var scrollEvent = 'scroll.select2.' + container.id;
    var resizeEvent = 'resize.select2.' + container.id;
    var orientationEvent = 'orientationchange.select2.' + container.id;

    var $watchers = this.$container.parents().filter(Utils.hasScroll);
    $watchers.off(scrollEvent);

    $(window).off(scrollEvent + ' ' + resizeEvent + ' ' + orientationEvent);
  };

  AttachBody.prototype._positionDropdown = function () {
    var $window = $(window);

    var isCurrentlyAbove = this.$dropdown.hasClass('select2-dropdown--above');
    var isCurrentlyBelow = this.$dropdown.hasClass('select2-dropdown--below');

    var newDirection = null;

    var offset = this.$container.offset();

    offset.bottom = offset.top + this.$container.outerHeight(false);

    var container = {
      height: this.$container.outerHeight(false)
    };

    container.top = offset.top;
    container.bottom = offset.top + container.height;

    var dropdown = {
      height: this.$dropdown.outerHeight(false)
    };

    var viewport = {
      top: $window.scrollTop(),
      bottom: $window.scrollTop() + $window.height()
    };

    var enoughRoomAbove = viewport.top < (offset.top - dropdown.height);
    var enoughRoomBelow = viewport.bottom > (offset.bottom + dropdown.height);

    var css = {
      left: offset.left,
      top: container.bottom
    };

    // Determine what the parent element is to use for calciulating the offset
    var $offsetParent = this.$dropdownParent;

    // For statically positoned elements, we need to get the element
    // that is determining the offset
    if ($offsetParent.css('position') === 'static') {
      $offsetParent = $offsetParent.offsetParent();
    }

    var parentOffset = $offsetParent.offset();

    css.top -= parentOffset.top;
    css.left -= parentOffset.left;

    if (!isCurrentlyAbove && !isCurrentlyBelow) {
      newDirection = 'below';
    }

    if (!enoughRoomBelow && enoughRoomAbove && !isCurrentlyAbove) {
      newDirection = 'above';
    } else if (!enoughRoomAbove && enoughRoomBelow && isCurrentlyAbove) {
      newDirection = 'below';
    }

    if (newDirection == 'above' ||
      (isCurrentlyAbove && newDirection !== 'below')) {
      css.top = container.top - parentOffset.top - dropdown.height;
    }

    if (newDirection != null) {
      this.$dropdown
        .removeClass('select2-dropdown--below select2-dropdown--above')
        .addClass('select2-dropdown--' + newDirection);
      this.$container
        .removeClass('select2-container--below select2-container--above')
        .addClass('select2-container--' + newDirection);
    }

    this.$dropdownContainer.css(css);
  };

  AttachBody.prototype._resizeDropdown = function () {
    var css = {
      width: this.$container.outerWidth(false) + 'px'
    };

    if (this.options.get('dropdownAutoWidth')) {
      css.minWidth = css.width;
      css.position = 'relative';
      css.width = 'auto';
    }

    this.$dropdown.css(css);
  };

  AttachBody.prototype._showDropdown = function (decorated) {
    this.$dropdownContainer.appendTo(this.$dropdownParent);

    this._positionDropdown();
    this._resizeDropdown();
  };

  return AttachBody;
});

S2.define('select2/dropdown/minimumResultsForSearch',[

], function () {
  function countResults (data) {
    var count = 0;

    for (var d = 0; d < data.length; d++) {
      var item = data[d];

      if (item.children) {
        count += countResults(item.children);
      } else {
        count++;
      }
    }

    return count;
  }

  function MinimumResultsForSearch (decorated, $element, options, dataAdapter) {
    this.minimumResultsForSearch = options.get('minimumResultsForSearch');

    if (this.minimumResultsForSearch < 0) {
      this.minimumResultsForSearch = Infinity;
    }

    decorated.call(this, $element, options, dataAdapter);
  }

  MinimumResultsForSearch.prototype.showSearch = function (decorated, params) {
    if (countResults(params.data.results) < this.minimumResultsForSearch) {
      return false;
    }

    return decorated.call(this, params);
  };

  return MinimumResultsForSearch;
});

S2.define('select2/dropdown/selectOnClose',[

], function () {
  function SelectOnClose () { }

  SelectOnClose.prototype.bind = function (decorated, container, $container) {
    var self = this;

    decorated.call(this, container, $container);

    container.on('close', function (params) {
      self._handleSelectOnClose(params);
    });
  };

  SelectOnClose.prototype._handleSelectOnClose = function (_, params) {
    if (params && params.originalSelect2Event != null) {
      var event = params.originalSelect2Event;

      // Don't select an item if the close event was triggered from a select or
      // unselect event
      if (event._type === 'select' || event._type === 'unselect') {
        return;
      }
    }

    var $highlightedResults = this.getHighlightedResults();

    // Only select highlighted results
    if ($highlightedResults.length < 1) {
      return;
    }

    var data = $highlightedResults.data('data');

    // Don't re-select already selected resulte
    if (
      (data.element != null && data.element.selected) ||
      (data.element == null && data.selected)
    ) {
      return;
    }

    this.trigger('select', {
        data: data
    });
  };

  return SelectOnClose;
});

S2.define('select2/dropdown/closeOnSelect',[

], function () {
  function CloseOnSelect () { }

  CloseOnSelect.prototype.bind = function (decorated, container, $container) {
    var self = this;

    decorated.call(this, container, $container);

    container.on('select', function (evt) {
      self._selectTriggered(evt);
    });

    container.on('unselect', function (evt) {
      self._selectTriggered(evt);
    });
  };

  CloseOnSelect.prototype._selectTriggered = function (_, evt) {
    var originalEvent = evt.originalEvent;

    // Don't close if the control key is being held
    if (originalEvent && originalEvent.ctrlKey) {
      return;
    }

    this.trigger('close', {
      originalEvent: originalEvent,
      originalSelect2Event: evt
    });
  };

  return CloseOnSelect;
});

S2.define('select2/i18n/en',[],function () {
  // English
  return {
    errorLoading: function () {
      return 'The results could not be loaded.';
    },
    inputTooLong: function (args) {
      var overChars = args.input.length - args.maximum;

      var message = 'Please delete ' + overChars + ' character';

      if (overChars != 1) {
        message += 's';
      }

      return message;
    },
    inputTooShort: function (args) {
      var remainingChars = args.minimum - args.input.length;

      var message = 'Please enter ' + remainingChars + ' or more characters';

      return message;
    },
    loadingMore: function () {
      return 'Loading more results…';
    },
    maximumSelected: function (args) {
      var message = 'You can only select ' + args.maximum + ' item';

      if (args.maximum != 1) {
        message += 's';
      }

      return message;
    },
    noResults: function () {
      return 'No results found';
    },
    searching: function () {
      return 'Searching…';
    }
  };
});

S2.define('select2/defaults',[
  'jquery',
  'require',

  './results',

  './selection/single',
  './selection/multiple',
  './selection/placeholder',
  './selection/allowClear',
  './selection/search',
  './selection/eventRelay',

  './utils',
  './translation',
  './diacritics',

  './data/select',
  './data/array',
  './data/ajax',
  './data/tags',
  './data/tokenizer',
  './data/minimumInputLength',
  './data/maximumInputLength',
  './data/maximumSelectionLength',

  './dropdown',
  './dropdown/search',
  './dropdown/hidePlaceholder',
  './dropdown/infiniteScroll',
  './dropdown/attachBody',
  './dropdown/minimumResultsForSearch',
  './dropdown/selectOnClose',
  './dropdown/closeOnSelect',

  './i18n/en'
], function ($, require,

             ResultsList,

             SingleSelection, MultipleSelection, Placeholder, AllowClear,
             SelectionSearch, EventRelay,

             Utils, Translation, DIACRITICS,

             SelectData, ArrayData, AjaxData, Tags, Tokenizer,
             MinimumInputLength, MaximumInputLength, MaximumSelectionLength,

             Dropdown, DropdownSearch, HidePlaceholder, InfiniteScroll,
             AttachBody, MinimumResultsForSearch, SelectOnClose, CloseOnSelect,

             EnglishTranslation) {
  function Defaults () {
    this.reset();
  }

  Defaults.prototype.apply = function (options) {
    options = $.extend(true, {}, this.defaults, options);

    if (options.dataAdapter == null) {
      if (options.ajax != null) {
        options.dataAdapter = AjaxData;
      } else if (options.data != null) {
        options.dataAdapter = ArrayData;
      } else {
        options.dataAdapter = SelectData;
      }

      if (options.minimumInputLength > 0) {
        options.dataAdapter = Utils.Decorate(
          options.dataAdapter,
          MinimumInputLength
        );
      }

      if (options.maximumInputLength > 0) {
        options.dataAdapter = Utils.Decorate(
          options.dataAdapter,
          MaximumInputLength
        );
      }

      if (options.maximumSelectionLength > 0) {
        options.dataAdapter = Utils.Decorate(
          options.dataAdapter,
          MaximumSelectionLength
        );
      }

      if (options.tags) {
        options.dataAdapter = Utils.Decorate(options.dataAdapter, Tags);
      }

      if (options.tokenSeparators != null || options.tokenizer != null) {
        options.dataAdapter = Utils.Decorate(
          options.dataAdapter,
          Tokenizer
        );
      }

      if (options.query != null) {
        var Query = require(options.amdBase + 'compat/query');

        options.dataAdapter = Utils.Decorate(
          options.dataAdapter,
          Query
        );
      }

      if (options.initSelection != null) {
        var InitSelection = require(options.amdBase + 'compat/initSelection');

        options.dataAdapter = Utils.Decorate(
          options.dataAdapter,
          InitSelection
        );
      }
    }

    if (options.resultsAdapter == null) {
      options.resultsAdapter = ResultsList;

      if (options.ajax != null) {
        options.resultsAdapter = Utils.Decorate(
          options.resultsAdapter,
          InfiniteScroll
        );
      }

      if (options.placeholder != null) {
        options.resultsAdapter = Utils.Decorate(
          options.resultsAdapter,
          HidePlaceholder
        );
      }

      if (options.selectOnClose) {
        options.resultsAdapter = Utils.Decorate(
          options.resultsAdapter,
          SelectOnClose
        );
      }
    }

    if (options.dropdownAdapter == null) {
      if (options.multiple) {
        options.dropdownAdapter = Dropdown;
      } else {
        var SearchableDropdown = Utils.Decorate(Dropdown, DropdownSearch);

        options.dropdownAdapter = SearchableDropdown;
      }

      if (options.minimumResultsForSearch !== 0) {
        options.dropdownAdapter = Utils.Decorate(
          options.dropdownAdapter,
          MinimumResultsForSearch
        );
      }

      if (options.closeOnSelect) {
        options.dropdownAdapter = Utils.Decorate(
          options.dropdownAdapter,
          CloseOnSelect
        );
      }

      if (
        options.dropdownCssClass != null ||
        options.dropdownCss != null ||
        options.adaptDropdownCssClass != null
      ) {
        var DropdownCSS = require(options.amdBase + 'compat/dropdownCss');

        options.dropdownAdapter = Utils.Decorate(
          options.dropdownAdapter,
          DropdownCSS
        );
      }

      options.dropdownAdapter = Utils.Decorate(
        options.dropdownAdapter,
        AttachBody
      );
    }

    if (options.selectionAdapter == null) {
      if (options.multiple) {
        options.selectionAdapter = MultipleSelection;
      } else {
        options.selectionAdapter = SingleSelection;
      }

      // Add the placeholder mixin if a placeholder was specified
      if (options.placeholder != null) {
        options.selectionAdapter = Utils.Decorate(
          options.selectionAdapter,
          Placeholder
        );
      }

      if (options.allowClear) {
        options.selectionAdapter = Utils.Decorate(
          options.selectionAdapter,
          AllowClear
        );
      }

      if (options.multiple) {
        options.selectionAdapter = Utils.Decorate(
          options.selectionAdapter,
          SelectionSearch
        );
      }

      if (
        options.containerCssClass != null ||
        options.containerCss != null ||
        options.adaptContainerCssClass != null
      ) {
        var ContainerCSS = require(options.amdBase + 'compat/containerCss');

        options.selectionAdapter = Utils.Decorate(
          options.selectionAdapter,
          ContainerCSS
        );
      }

      options.selectionAdapter = Utils.Decorate(
        options.selectionAdapter,
        EventRelay
      );
    }

    if (typeof options.language === 'string') {
      // Check if the language is specified with a region
      if (options.language.indexOf('-') > 0) {
        // Extract the region information if it is included
        var languageParts = options.language.split('-');
        var baseLanguage = languageParts[0];

        options.language = [options.language, baseLanguage];
      } else {
        options.language = [options.language];
      }
    }

    if ($.isArray(options.language)) {
      var languages = new Translation();
      options.language.push('en');

      var languageNames = options.language;

      for (var l = 0; l < languageNames.length; l++) {
        var name = languageNames[l];
        var language = {};

        try {
          // Try to load it with the original name
          language = Translation.loadPath(name);
        } catch (e) {
          try {
            // If we couldn't load it, check if it wasn't the full path
            name = this.defaults.amdLanguageBase + name;
            language = Translation.loadPath(name);
          } catch (ex) {
            // The translation could not be loaded at all. Sometimes this is
            // because of a configuration problem, other times this can be
            // because of how Select2 helps load all possible translation files.
            if (options.debug && window.console && console.warn) {
              console.warn(
                'Select2: The language file for "' + name + '" could not be ' +
                'automatically loaded. A fallback will be used instead.'
              );
            }

            continue;
          }
        }

        languages.extend(language);
      }

      options.translations = languages;
    } else {
      var baseTranslation = Translation.loadPath(
        this.defaults.amdLanguageBase + 'en'
      );
      var customTranslation = new Translation(options.language);

      customTranslation.extend(baseTranslation);

      options.translations = customTranslation;
    }

    return options;
  };

  Defaults.prototype.reset = function () {
    function stripDiacritics (text) {
      // Used 'uni range + named function' from http://jsperf.com/diacritics/18
      function match(a) {
        return DIACRITICS[a] || a;
      }

      return text.replace(/[^\u0000-\u007E]/g, match);
    }

    function matcher (params, data) {
      // Always return the object if there is nothing to compare
      if ($.trim(params.term) === '') {
        return data;
      }

      // Do a recursive check for options with children
      if (data.children && data.children.length > 0) {
        // Clone the data object if there are children
        // This is required as we modify the object to remove any non-matches
        var match = $.extend(true, {}, data);

        // Check each child of the option
        for (var c = data.children.length - 1; c >= 0; c--) {
          var child = data.children[c];

          var matches = matcher(params, child);

          // If there wasn't a match, remove the object in the array
          if (matches == null) {
            match.children.splice(c, 1);
          }
        }

        // If any children matched, return the new object
        if (match.children.length > 0) {
          return match;
        }

        // If there were no matching children, check just the plain object
        return matcher(params, match);
      }

      var original = stripDiacritics(data.text).toUpperCase();
      var term = stripDiacritics(params.term).toUpperCase();

      // Check if the text contains the term
      if (original.indexOf(term) > -1) {
        return data;
      }

      // If it doesn't contain the term, don't return anything
      return null;
    }

    this.defaults = {
      amdBase: './',
      amdLanguageBase: './i18n/',
      closeOnSelect: true,
      debug: false,
      dropdownAutoWidth: false,
      escapeMarkup: Utils.escapeMarkup,
      language: EnglishTranslation,
      matcher: matcher,
      minimumInputLength: 0,
      maximumInputLength: 0,
      maximumSelectionLength: 0,
      minimumResultsForSearch: 0,
      selectOnClose: false,
      sorter: function (data) {
        return data;
      },
      templateResult: function (result) {
        return result.text;
      },
      templateSelection: function (selection) {
        return selection.text;
      },
      theme: 'default',
      width: 'resolve'
    };
  };

  Defaults.prototype.set = function (key, value) {
    var camelKey = $.camelCase(key);

    var data = {};
    data[camelKey] = value;

    var convertedData = Utils._convertData(data);

    $.extend(this.defaults, convertedData);
  };

  var defaults = new Defaults();

  return defaults;
});

S2.define('select2/options',[
  'require',
  'jquery',
  './defaults',
  './utils'
], function (require, $, Defaults, Utils) {
  function Options (options, $element) {
    this.options = options;

    if ($element != null) {
      this.fromElement($element);
    }

    this.options = Defaults.apply(this.options);

    if ($element && $element.is('input')) {
      var InputCompat = require(this.get('amdBase') + 'compat/inputData');

      this.options.dataAdapter = Utils.Decorate(
        this.options.dataAdapter,
        InputCompat
      );
    }
  }

  Options.prototype.fromElement = function ($e) {
    var excludedData = ['select2'];

    if (this.options.multiple == null) {
      this.options.multiple = $e.prop('multiple');
    }

    if (this.options.disabled == null) {
      this.options.disabled = $e.prop('disabled');
    }

    if (this.options.language == null) {
      if ($e.prop('lang')) {
        this.options.language = $e.prop('lang').toLowerCase();
      } else if ($e.closest('[lang]').prop('lang')) {
        this.options.language = $e.closest('[lang]').prop('lang');
      }
    }

    if (this.options.dir == null) {
      if ($e.prop('dir')) {
        this.options.dir = $e.prop('dir');
      } else if ($e.closest('[dir]').prop('dir')) {
        this.options.dir = $e.closest('[dir]').prop('dir');
      } else {
        this.options.dir = 'ltr';
      }
    }

    $e.prop('disabled', this.options.disabled);
    $e.prop('multiple', this.options.multiple);

    if ($e.data('select2Tags')) {
      if (this.options.debug && window.console && console.warn) {
        console.warn(
          'Select2: The `data-select2-tags` attribute has been changed to ' +
          'use the `data-data` and `data-tags="true"` attributes and will be ' +
          'removed in future versions of Select2.'
        );
      }

      $e.data('data', $e.data('select2Tags'));
      $e.data('tags', true);
    }

    if ($e.data('ajaxUrl')) {
      if (this.options.debug && window.console && console.warn) {
        console.warn(
          'Select2: The `data-ajax-url` attribute has been changed to ' +
          '`data-ajax--url` and support for the old attribute will be removed' +
          ' in future versions of Select2.'
        );
      }

      $e.attr('ajax--url', $e.data('ajaxUrl'));
      $e.data('ajax--url', $e.data('ajaxUrl'));
    }

    var dataset = {};

    // Prefer the element's `dataset` attribute if it exists
    // jQuery 1.x does not correctly handle data attributes with multiple dashes
    if ($.fn.jquery && $.fn.jquery.substr(0, 2) == '1.' && $e[0].dataset) {
      dataset = $.extend(true, {}, $e[0].dataset, $e.data());
    } else {
      dataset = $e.data();
    }

    var data = $.extend(true, {}, dataset);

    data = Utils._convertData(data);

    for (var key in data) {
      if ($.inArray(key, excludedData) > -1) {
        continue;
      }

      if ($.isPlainObject(this.options[key])) {
        $.extend(this.options[key], data[key]);
      } else {
        this.options[key] = data[key];
      }
    }

    return this;
  };

  Options.prototype.get = function (key) {
    return this.options[key];
  };

  Options.prototype.set = function (key, val) {
    this.options[key] = val;
  };

  return Options;
});

S2.define('select2/core',[
  'jquery',
  './options',
  './utils',
  './keys'
], function ($, Options, Utils, KEYS) {
  var Select2 = function ($element, options) {
    if ($element.data('select2') != null) {
      $element.data('select2').destroy();
    }

    this.$element = $element;

    this.id = this._generateId($element);

    options = options || {};

    this.options = new Options(options, $element);

    Select2.__super__.constructor.call(this);

    // Set up the tabindex

    var tabindex = $element.attr('tabindex') || 0;
    $element.data('old-tabindex', tabindex);
    $element.attr('tabindex', '-1');

    // Set up containers and adapters

    var DataAdapter = this.options.get('dataAdapter');
    this.dataAdapter = new DataAdapter($element, this.options);

    var $container = this.render();

    this._placeContainer($container);

    var SelectionAdapter = this.options.get('selectionAdapter');
    this.selection = new SelectionAdapter($element, this.options);
    this.$selection = this.selection.render();

    this.selection.position(this.$selection, $container);

    var DropdownAdapter = this.options.get('dropdownAdapter');
    this.dropdown = new DropdownAdapter($element, this.options);
    this.$dropdown = this.dropdown.render();

    this.dropdown.position(this.$dropdown, $container);

    var ResultsAdapter = this.options.get('resultsAdapter');
    this.results = new ResultsAdapter($element, this.options, this.dataAdapter);
    this.$results = this.results.render();

    this.results.position(this.$results, this.$dropdown);

    // Bind events

    var self = this;

    // Bind the container to all of the adapters
    this._bindAdapters();

    // Register any DOM event handlers
    this._registerDomEvents();

    // Register any internal event handlers
    this._registerDataEvents();
    this._registerSelectionEvents();
    this._registerDropdownEvents();
    this._registerResultsEvents();
    this._registerEvents();

    // Set the initial state
    this.dataAdapter.current(function (initialData) {
      self.trigger('selection:update', {
        data: initialData
      });
    });

    // Hide the original select
    $element.addClass('select2-hidden-accessible');
    $element.attr('aria-hidden', 'true');

    // Synchronize any monitored attributes
    this._syncAttributes();

    $element.data('select2', this);
  };

  Utils.Extend(Select2, Utils.Observable);

  Select2.prototype._generateId = function ($element) {
    var id = '';

    if ($element.attr('id') != null) {
      id = $element.attr('id');
    } else if ($element.attr('name') != null) {
      id = $element.attr('name') + '-' + Utils.generateChars(2);
    } else {
      id = Utils.generateChars(4);
    }

    id = id.replace(/(:|\.|\[|\]|,)/g, '');
    id = 'select2-' + id;

    return id;
  };

  Select2.prototype._placeContainer = function ($container) {
    $container.insertAfter(this.$element);

    var width = this._resolveWidth(this.$element, this.options.get('width'));

    if (width != null) {
      $container.css('width', width);
    }
  };

  Select2.prototype._resolveWidth = function ($element, method) {
    var WIDTH = /^width:(([-+]?([0-9]*\.)?[0-9]+)(px|em|ex|%|in|cm|mm|pt|pc))/i;

    if (method == 'resolve') {
      var styleWidth = this._resolveWidth($element, 'style');

      if (styleWidth != null) {
        return styleWidth;
      }

      return this._resolveWidth($element, 'element');
    }

    if (method == 'element') {
      var elementWidth = $element.outerWidth(false);

      if (elementWidth <= 0) {
        return 'auto';
      }

      return elementWidth + 'px';
    }

    if (method == 'style') {
      var style = $element.attr('style');

      if (typeof(style) !== 'string') {
        return null;
      }

      var attrs = style.split(';');

      for (var i = 0, l = attrs.length; i < l; i = i + 1) {
        var attr = attrs[i].replace(/\s/g, '');
        var matches = attr.match(WIDTH);

        if (matches !== null && matches.length >= 1) {
          return matches[1];
        }
      }

      return null;
    }

    return method;
  };

  Select2.prototype._bindAdapters = function () {
    this.dataAdapter.bind(this, this.$container);
    this.selection.bind(this, this.$container);

    this.dropdown.bind(this, this.$container);
    this.results.bind(this, this.$container);
  };

  Select2.prototype._registerDomEvents = function () {
    var self = this;

    this.$element.on('change.select2', function () {
      self.dataAdapter.current(function (data) {
        self.trigger('selection:update', {
          data: data
        });
      });
    });

    this.$element.on('focus.select2', function (evt) {
      self.trigger('focus', evt);
    });

    this._syncA = Utils.bind(this._syncAttributes, this);
    this._syncS = Utils.bind(this._syncSubtree, this);

    if (this.$element[0].attachEvent) {
      this.$element[0].attachEvent('onpropertychange', this._syncA);
    }

    var observer = window.MutationObserver ||
      window.WebKitMutationObserver ||
      window.MozMutationObserver
    ;

    if (observer != null) {
      this._observer = new observer(function (mutations) {
        $.each(mutations, self._syncA);
        $.each(mutations, self._syncS);
      });
      this._observer.observe(this.$element[0], {
        attributes: true,
        childList: true,
        subtree: false
      });
    } else if (this.$element[0].addEventListener) {
      this.$element[0].addEventListener(
        'DOMAttrModified',
        self._syncA,
        false
      );
      this.$element[0].addEventListener(
        'DOMNodeInserted',
        self._syncS,
        false
      );
      this.$element[0].addEventListener(
        'DOMNodeRemoved',
        self._syncS,
        false
      );
    }
  };

  Select2.prototype._registerDataEvents = function () {
    var self = this;

    this.dataAdapter.on('*', function (name, params) {
      self.trigger(name, params);
    });
  };

  Select2.prototype._registerSelectionEvents = function () {
    var self = this;
    var nonRelayEvents = ['toggle', 'focus'];

    this.selection.on('toggle', function () {
      self.toggleDropdown();
    });

    this.selection.on('focus', function (params) {
      self.focus(params);
    });

    this.selection.on('*', function (name, params) {
      if ($.inArray(name, nonRelayEvents) !== -1) {
        return;
      }

      self.trigger(name, params);
    });
  };

  Select2.prototype._registerDropdownEvents = function () {
    var self = this;

    this.dropdown.on('*', function (name, params) {
      self.trigger(name, params);
    });
  };

  Select2.prototype._registerResultsEvents = function () {
    var self = this;

    this.results.on('*', function (name, params) {
      self.trigger(name, params);
    });
  };

  Select2.prototype._registerEvents = function () {
    var self = this;

    this.on('open', function () {
      self.$container.addClass('select2-container--open');
    });

    this.on('close', function () {
      self.$container.removeClass('select2-container--open');
    });

    this.on('enable', function () {
      self.$container.removeClass('select2-container--disabled');
    });

    this.on('disable', function () {
      self.$container.addClass('select2-container--disabled');
    });

    this.on('blur', function () {
      self.$container.removeClass('select2-container--focus');
    });

    this.on('query', function (params) {
      if (!self.isOpen()) {
        self.trigger('open', {});
      }

      this.dataAdapter.query(params, function (data) {
        self.trigger('results:all', {
          data: data,
          query: params
        });
      });
    });

    this.on('query:append', function (params) {
      this.dataAdapter.query(params, function (data) {
        self.trigger('results:append', {
          data: data,
          query: params
        });
      });
    });

    this.on('keypress', function (evt) {
      var key = evt.which;

      if (self.isOpen()) {
        if (key === KEYS.ESC || key === KEYS.TAB ||
            (key === KEYS.UP && evt.altKey)) {
          self.close();

          evt.preventDefault();
        } else if (key === KEYS.ENTER) {
          self.trigger('results:select', {});

          evt.preventDefault();
        } else if ((key === KEYS.SPACE && evt.ctrlKey)) {
          self.trigger('results:toggle', {});

          evt.preventDefault();
        } else if (key === KEYS.UP) {
          self.trigger('results:previous', {});

          evt.preventDefault();
        } else if (key === KEYS.DOWN) {
          self.trigger('results:next', {});

          evt.preventDefault();
        }
      } else {
        if (key === KEYS.ENTER || key === KEYS.SPACE ||
            (key === KEYS.DOWN && evt.altKey)) {
          self.open();

          evt.preventDefault();
        }
      }
    });
  };

  Select2.prototype._syncAttributes = function () {
    this.options.set('disabled', this.$element.prop('disabled'));

    if (this.options.get('disabled')) {
      if (this.isOpen()) {
        this.close();
      }

      this.trigger('disable', {});
    } else {
      this.trigger('enable', {});
    }
  };

  Select2.prototype._syncSubtree = function (evt, mutations) {
    var changed = false;
    var self = this;

    // Ignore any mutation events raised for elements that aren't options or
    // optgroups. This handles the case when the select element is destroyed
    if (
      evt && evt.target && (
        evt.target.nodeName !== 'OPTION' && evt.target.nodeName !== 'OPTGROUP'
      )
    ) {
      return;
    }

    if (!mutations) {
      // If mutation events aren't supported, then we can only assume that the
      // change affected the selections
      changed = true;
    } else if (mutations.addedNodes && mutations.addedNodes.length > 0) {
      for (var n = 0; n < mutations.addedNodes.length; n++) {
        var node = mutations.addedNodes[n];

        if (node.selected) {
          changed = true;
        }
      }
    } else if (mutations.removedNodes && mutations.removedNodes.length > 0) {
      changed = true;
    }

    // Only re-pull the data if we think there is a change
    if (changed) {
      this.dataAdapter.current(function (currentData) {
        self.trigger('selection:update', {
          data: currentData
        });
      });
    }
  };

  /**
   * Override the trigger method to automatically trigger pre-events when
   * there are events that can be prevented.
   */
  Select2.prototype.trigger = function (name, args) {
    var actualTrigger = Select2.__super__.trigger;
    var preTriggerMap = {
      'open': 'opening',
      'close': 'closing',
      'select': 'selecting',
      'unselect': 'unselecting'
    };

    if (args === undefined) {
      args = {};
    }

    if (name in preTriggerMap) {
      var preTriggerName = preTriggerMap[name];
      var preTriggerArgs = {
        prevented: false,
        name: name,
        args: args
      };

      actualTrigger.call(this, preTriggerName, preTriggerArgs);

      if (preTriggerArgs.prevented) {
        args.prevented = true;

        return;
      }
    }

    actualTrigger.call(this, name, args);
  };

  Select2.prototype.toggleDropdown = function () {
    if (this.options.get('disabled')) {
      return;
    }

    if (this.isOpen()) {
      this.close();
    } else {
      this.open();
    }
  };

  Select2.prototype.open = function () {
    if (this.isOpen()) {
      return;
    }

    this.trigger('query', {});
  };

  Select2.prototype.close = function () {
    if (!this.isOpen()) {
      return;
    }

    this.trigger('close', {});
  };

  Select2.prototype.isOpen = function () {
    return this.$container.hasClass('select2-container--open');
  };

  Select2.prototype.hasFocus = function () {
    return this.$container.hasClass('select2-container--focus');
  };

  Select2.prototype.focus = function (data) {
    // No need to re-trigger focus events if we are already focused
    if (this.hasFocus()) {
      return;
    }

    this.$container.addClass('select2-container--focus');
    this.trigger('focus', {});
  };

  Select2.prototype.enable = function (args) {
    if (this.options.get('debug') && window.console && console.warn) {
      console.warn(
        'Select2: The `select2("enable")` method has been deprecated and will' +
        ' be removed in later Select2 versions. Use $element.prop("disabled")' +
        ' instead.'
      );
    }

    if (args == null || args.length === 0) {
      args = [true];
    }

    var disabled = !args[0];

    this.$element.prop('disabled', disabled);
  };

  Select2.prototype.data = function () {
    if (this.options.get('debug') &&
        arguments.length > 0 && window.console && console.warn) {
      console.warn(
        'Select2: Data can no longer be set using `select2("data")`. You ' +
        'should consider setting the value instead using `$element.val()`.'
      );
    }

    var data = [];

    this.dataAdapter.current(function (currentData) {
      data = currentData;
    });

    return data;
  };

  Select2.prototype.val = function (args) {
    if (this.options.get('debug') && window.console && console.warn) {
      console.warn(
        'Select2: The `select2("val")` method has been deprecated and will be' +
        ' removed in later Select2 versions. Use $element.val() instead.'
      );
    }

    if (args == null || args.length === 0) {
      return this.$element.val();
    }

    var newVal = args[0];

    if ($.isArray(newVal)) {
      newVal = $.map(newVal, function (obj) {
        return obj.toString();
      });
    }

    this.$element.val(newVal).trigger('change');
  };

  Select2.prototype.destroy = function () {
    this.$container.remove();

    if (this.$element[0].detachEvent) {
      this.$element[0].detachEvent('onpropertychange', this._syncA);
    }

    if (this._observer != null) {
      this._observer.disconnect();
      this._observer = null;
    } else if (this.$element[0].removeEventListener) {
      this.$element[0]
        .removeEventListener('DOMAttrModified', this._syncA, false);
      this.$element[0]
        .removeEventListener('DOMNodeInserted', this._syncS, false);
      this.$element[0]
        .removeEventListener('DOMNodeRemoved', this._syncS, false);
    }

    this._syncA = null;
    this._syncS = null;

    this.$element.off('.select2');
    this.$element.attr('tabindex', this.$element.data('old-tabindex'));

    this.$element.removeClass('select2-hidden-accessible');
    this.$element.attr('aria-hidden', 'false');
    this.$element.removeData('select2');

    this.dataAdapter.destroy();
    this.selection.destroy();
    this.dropdown.destroy();
    this.results.destroy();

    this.dataAdapter = null;
    this.selection = null;
    this.dropdown = null;
    this.results = null;
  };

  Select2.prototype.render = function () {
    var $container = $(
      '<span class="select2 select2-container">' +
        '<span class="selection"></span>' +
        '<span class="dropdown-wrapper" aria-hidden="true"></span>' +
      '</span>'
    );

    $container.attr('dir', this.options.get('dir'));

    this.$container = $container;

    this.$container.addClass('select2-container--' + this.options.get('theme'));

    $container.data('element', this.$element);

    return $container;
  };

  return Select2;
});

S2.define('select2/compat/utils',[
  'jquery'
], function ($) {
  function syncCssClasses ($dest, $src, adapter) {
    var classes, replacements = [], adapted;

    classes = $.trim($dest.attr('class'));

    if (classes) {
      classes = '' + classes; // for IE which returns object

      $(classes.split(/\s+/)).each(function () {
        // Save all Select2 classes
        if (this.indexOf('select2-') === 0) {
          replacements.push(this);
        }
      });
    }

    classes = $.trim($src.attr('class'));

    if (classes) {
      classes = '' + classes; // for IE which returns object

      $(classes.split(/\s+/)).each(function () {
        // Only adapt non-Select2 classes
        if (this.indexOf('select2-') !== 0) {
          adapted = adapter(this);

          if (adapted != null) {
            replacements.push(adapted);
          }
        }
      });
    }

    $dest.attr('class', replacements.join(' '));
  }

  return {
    syncCssClasses: syncCssClasses
  };
});

S2.define('select2/compat/containerCss',[
  'jquery',
  './utils'
], function ($, CompatUtils) {
  // No-op CSS adapter that discards all classes by default
  function _containerAdapter (clazz) {
    return null;
  }

  function ContainerCSS () { }

  ContainerCSS.prototype.render = function (decorated) {
    var $container = decorated.call(this);

    var containerCssClass = this.options.get('containerCssClass') || '';

    if ($.isFunction(containerCssClass)) {
      containerCssClass = containerCssClass(this.$element);
    }

    var containerCssAdapter = this.options.get('adaptContainerCssClass');
    containerCssAdapter = containerCssAdapter || _containerAdapter;

    if (containerCssClass.indexOf(':all:') !== -1) {
      containerCssClass = containerCssClass.replace(':all:', '');

      var _cssAdapter = containerCssAdapter;

      containerCssAdapter = function (clazz) {
        var adapted = _cssAdapter(clazz);

        if (adapted != null) {
          // Append the old one along with the adapted one
          return adapted + ' ' + clazz;
        }

        return clazz;
      };
    }

    var containerCss = this.options.get('containerCss') || {};

    if ($.isFunction(containerCss)) {
      containerCss = containerCss(this.$element);
    }

    CompatUtils.syncCssClasses($container, this.$element, containerCssAdapter);

    $container.css(containerCss);
    $container.addClass(containerCssClass);

    return $container;
  };

  return ContainerCSS;
});

S2.define('select2/compat/dropdownCss',[
  'jquery',
  './utils'
], function ($, CompatUtils) {
  // No-op CSS adapter that discards all classes by default
  function _dropdownAdapter (clazz) {
    return null;
  }

  function DropdownCSS () { }

  DropdownCSS.prototype.render = function (decorated) {
    var $dropdown = decorated.call(this);

    var dropdownCssClass = this.options.get('dropdownCssClass') || '';

    if ($.isFunction(dropdownCssClass)) {
      dropdownCssClass = dropdownCssClass(this.$element);
    }

    var dropdownCssAdapter = this.options.get('adaptDropdownCssClass');
    dropdownCssAdapter = dropdownCssAdapter || _dropdownAdapter;

    if (dropdownCssClass.indexOf(':all:') !== -1) {
      dropdownCssClass = dropdownCssClass.replace(':all:', '');

      var _cssAdapter = dropdownCssAdapter;

      dropdownCssAdapter = function (clazz) {
        var adapted = _cssAdapter(clazz);

        if (adapted != null) {
          // Append the old one along with the adapted one
          return adapted + ' ' + clazz;
        }

        return clazz;
      };
    }

    var dropdownCss = this.options.get('dropdownCss') || {};

    if ($.isFunction(dropdownCss)) {
      dropdownCss = dropdownCss(this.$element);
    }

    CompatUtils.syncCssClasses($dropdown, this.$element, dropdownCssAdapter);

    $dropdown.css(dropdownCss);
    $dropdown.addClass(dropdownCssClass);

    return $dropdown;
  };

  return DropdownCSS;
});

S2.define('select2/compat/initSelection',[
  'jquery'
], function ($) {
  function InitSelection (decorated, $element, options) {
    if (options.get('debug') && window.console && console.warn) {
      console.warn(
        'Select2: The `initSelection` option has been deprecated in favor' +
        ' of a custom data adapter that overrides the `current` method. ' +
        'This method is now called multiple times instead of a single ' +
        'time when the instance is initialized. Support will be removed ' +
        'for the `initSelection` option in future versions of Select2'
      );
    }

    this.initSelection = options.get('initSelection');
    this._isInitialized = false;

    decorated.call(this, $element, options);
  }

  InitSelection.prototype.current = function (decorated, callback) {
    var self = this;

    if (this._isInitialized) {
      decorated.call(this, callback);

      return;
    }

    this.initSelection.call(null, this.$element, function (data) {
      self._isInitialized = true;

      if (!$.isArray(data)) {
        data = [data];
      }

      callback(data);
    });
  };

  return InitSelection;
});

S2.define('select2/compat/inputData',[
  'jquery'
], function ($) {
  function InputData (decorated, $element, options) {
    this._currentData = [];
    this._valueSeparator = options.get('valueSeparator') || ',';

    if ($element.prop('type') === 'hidden') {
      if (options.get('debug') && console && console.warn) {
        console.warn(
          'Select2: Using a hidden input with Select2 is no longer ' +
          'supported and may stop working in the future. It is recommended ' +
          'to use a `<select>` element instead.'
        );
      }
    }

    decorated.call(this, $element, options);
  }

  InputData.prototype.current = function (_, callback) {
    function getSelected (data, selectedIds) {
      var selected = [];

      if (data.selected || $.inArray(data.id, selectedIds) !== -1) {
        data.selected = true;
        selected.push(data);
      } else {
        data.selected = false;
      }

      if (data.children) {
        selected.push.apply(selected, getSelected(data.children, selectedIds));
      }

      return selected;
    }

    var selected = [];

    for (var d = 0; d < this._currentData.length; d++) {
      var data = this._currentData[d];

      selected.push.apply(
        selected,
        getSelected(
          data,
          this.$element.val().split(
            this._valueSeparator
          )
        )
      );
    }

    callback(selected);
  };

  InputData.prototype.select = function (_, data) {
    if (!this.options.get('multiple')) {
      this.current(function (allData) {
        $.map(allData, function (data) {
          data.selected = false;
        });
      });

      this.$element.val(data.id);
      this.$element.trigger('change');
    } else {
      var value = this.$element.val();
      value += this._valueSeparator + data.id;

      this.$element.val(value);
      this.$element.trigger('change');
    }
  };

  InputData.prototype.unselect = function (_, data) {
    var self = this;

    data.selected = false;

    this.current(function (allData) {
      var values = [];

      for (var d = 0; d < allData.length; d++) {
        var item = allData[d];

        if (data.id == item.id) {
          continue;
        }

        values.push(item.id);
      }

      self.$element.val(values.join(self._valueSeparator));
      self.$element.trigger('change');
    });
  };

  InputData.prototype.query = function (_, params, callback) {
    var results = [];

    for (var d = 0; d < this._currentData.length; d++) {
      var data = this._currentData[d];

      var matches = this.matches(params, data);

      if (matches !== null) {
        results.push(matches);
      }
    }

    callback({
      results: results
    });
  };

  InputData.prototype.addOptions = function (_, $options) {
    var options = $.map($options, function ($option) {
      return $.data($option[0], 'data');
    });

    this._currentData.push.apply(this._currentData, options);
  };

  return InputData;
});

S2.define('select2/compat/matcher',[
  'jquery'
], function ($) {
  function oldMatcher (matcher) {
    function wrappedMatcher (params, data) {
      var match = $.extend(true, {}, data);

      if (params.term == null || $.trim(params.term) === '') {
        return match;
      }

      if (data.children) {
        for (var c = data.children.length - 1; c >= 0; c--) {
          var child = data.children[c];

          // Check if the child object matches
          // The old matcher returned a boolean true or false
          var doesMatch = matcher(params.term, child.text, child);

          // If the child didn't match, pop it off
          if (!doesMatch) {
            match.children.splice(c, 1);
          }
        }

        if (match.children.length > 0) {
          return match;
        }
      }

      if (matcher(params.term, data.text, data)) {
        return match;
      }

      return null;
    }

    return wrappedMatcher;
  }

  return oldMatcher;
});

S2.define('select2/compat/query',[

], function () {
  function Query (decorated, $element, options) {
    if (options.get('debug') && window.console && console.warn) {
      console.warn(
        'Select2: The `query` option has been deprecated in favor of a ' +
        'custom data adapter that overrides the `query` method. Support ' +
        'will be removed for the `query` option in future versions of ' +
        'Select2.'
      );
    }

    decorated.call(this, $element, options);
  }

  Query.prototype.query = function (_, params, callback) {
    params.callback = callback;

    var query = this.options.get('query');

    query.call(null, params);
  };

  return Query;
});

S2.define('select2/dropdown/attachContainer',[

], function () {
  function AttachContainer (decorated, $element, options) {
    decorated.call(this, $element, options);
  }

  AttachContainer.prototype.position =
    function (decorated, $dropdown, $container) {
    var $dropdownContainer = $container.find('.dropdown-wrapper');
    $dropdownContainer.append($dropdown);

    $dropdown.addClass('select2-dropdown--below');
    $container.addClass('select2-container--below');
  };

  return AttachContainer;
});

S2.define('select2/dropdown/stopPropagation',[

], function () {
  function StopPropagation () { }

  StopPropagation.prototype.bind = function (decorated, container, $container) {
    decorated.call(this, container, $container);

    var stoppedEvents = [
    'blur',
    'change',
    'click',
    'dblclick',
    'focus',
    'focusin',
    'focusout',
    'input',
    'keydown',
    'keyup',
    'keypress',
    'mousedown',
    'mouseenter',
    'mouseleave',
    'mousemove',
    'mouseover',
    'mouseup',
    'search',
    'touchend',
    'touchstart'
    ];

    this.$dropdown.on(stoppedEvents.join(' '), function (evt) {
      evt.stopPropagation();
    });
  };

  return StopPropagation;
});

S2.define('select2/selection/stopPropagation',[

], function () {
  function StopPropagation () { }

  StopPropagation.prototype.bind = function (decorated, container, $container) {
    decorated.call(this, container, $container);

    var stoppedEvents = [
      'blur',
      'change',
      'click',
      'dblclick',
      'focus',
      'focusin',
      'focusout',
      'input',
      'keydown',
      'keyup',
      'keypress',
      'mousedown',
      'mouseenter',
      'mouseleave',
      'mousemove',
      'mouseover',
      'mouseup',
      'search',
      'touchend',
      'touchstart'
    ];

    this.$selection.on(stoppedEvents.join(' '), function (evt) {
      evt.stopPropagation();
    });
  };

  return StopPropagation;
});

/*!
 * jQuery Mousewheel 3.1.13
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 */

(function (factory) {
    if ( typeof S2.define === 'function' && S2.define.amd ) {
        // AMD. Register as an anonymous module.
        S2.define('jquery-mousewheel',['jquery'], factory);
    } else if (typeof exports === 'object') {
        // Node/CommonJS style for Browserify
        module.exports = factory;
    } else {
        // Browser globals
        factory(jQuery);
    }
}(function ($) {

    var toFix  = ['wheel', 'mousewheel', 'DOMMouseScroll', 'MozMousePixelScroll'],
        toBind = ( 'onwheel' in document || document.documentMode >= 9 ) ?
                    ['wheel'] : ['mousewheel', 'DomMouseScroll', 'MozMousePixelScroll'],
        slice  = Array.prototype.slice,
        nullLowestDeltaTimeout, lowestDelta;

    if ( $.event.fixHooks ) {
        for ( var i = toFix.length; i; ) {
            $.event.fixHooks[ toFix[--i] ] = $.event.mouseHooks;
        }
    }

    var special = $.event.special.mousewheel = {
        version: '3.1.12',

        setup: function() {
            if ( this.addEventListener ) {
                for ( var i = toBind.length; i; ) {
                    this.addEventListener( toBind[--i], handler, false );
                }
            } else {
                this.onmousewheel = handler;
            }
            // Store the line height and page height for this particular element
            $.data(this, 'mousewheel-line-height', special.getLineHeight(this));
            $.data(this, 'mousewheel-page-height', special.getPageHeight(this));
        },

        teardown: function() {
            if ( this.removeEventListener ) {
                for ( var i = toBind.length; i; ) {
                    this.removeEventListener( toBind[--i], handler, false );
                }
            } else {
                this.onmousewheel = null;
            }
            // Clean up the data we added to the element
            $.removeData(this, 'mousewheel-line-height');
            $.removeData(this, 'mousewheel-page-height');
        },

        getLineHeight: function(elem) {
            var $elem = $(elem),
                $parent = $elem['offsetParent' in $.fn ? 'offsetParent' : 'parent']();
            if (!$parent.length) {
                $parent = $('body');
            }
            return parseInt($parent.css('fontSize'), 10) || parseInt($elem.css('fontSize'), 10) || 16;
        },

        getPageHeight: function(elem) {
            return $(elem).height();
        },

        settings: {
            adjustOldDeltas: true, // see shouldAdjustOldDeltas() below
            normalizeOffset: true  // calls getBoundingClientRect for each event
        }
    };

    $.fn.extend({
        mousewheel: function(fn) {
            return fn ? this.bind('mousewheel', fn) : this.trigger('mousewheel');
        },

        unmousewheel: function(fn) {
            return this.unbind('mousewheel', fn);
        }
    });


    function handler(event) {
        var orgEvent   = event || window.event,
            args       = slice.call(arguments, 1),
            delta      = 0,
            deltaX     = 0,
            deltaY     = 0,
            absDelta   = 0,
            offsetX    = 0,
            offsetY    = 0;
        event = $.event.fix(orgEvent);
        event.type = 'mousewheel';

        // Old school scrollwheel delta
        if ( 'detail'      in orgEvent ) { deltaY = orgEvent.detail * -1;      }
        if ( 'wheelDelta'  in orgEvent ) { deltaY = orgEvent.wheelDelta;       }
        if ( 'wheelDeltaY' in orgEvent ) { deltaY = orgEvent.wheelDeltaY;      }
        if ( 'wheelDeltaX' in orgEvent ) { deltaX = orgEvent.wheelDeltaX * -1; }

        // Firefox < 17 horizontal scrolling related to DOMMouseScroll event
        if ( 'axis' in orgEvent && orgEvent.axis === orgEvent.HORIZONTAL_AXIS ) {
            deltaX = deltaY * -1;
            deltaY = 0;
        }

        // Set delta to be deltaY or deltaX if deltaY is 0 for backwards compatabilitiy
        delta = deltaY === 0 ? deltaX : deltaY;

        // New school wheel delta (wheel event)
        if ( 'deltaY' in orgEvent ) {
            deltaY = orgEvent.deltaY * -1;
            delta  = deltaY;
        }
        if ( 'deltaX' in orgEvent ) {
            deltaX = orgEvent.deltaX;
            if ( deltaY === 0 ) { delta  = deltaX * -1; }
        }

        // No change actually happened, no reason to go any further
        if ( deltaY === 0 && deltaX === 0 ) { return; }

        // Need to convert lines and pages to pixels if we aren't already in pixels
        // There are three delta modes:
        //   * deltaMode 0 is by pixels, nothing to do
        //   * deltaMode 1 is by lines
        //   * deltaMode 2 is by pages
        if ( orgEvent.deltaMode === 1 ) {
            var lineHeight = $.data(this, 'mousewheel-line-height');
            delta  *= lineHeight;
            deltaY *= lineHeight;
            deltaX *= lineHeight;
        } else if ( orgEvent.deltaMode === 2 ) {
            var pageHeight = $.data(this, 'mousewheel-page-height');
            delta  *= pageHeight;
            deltaY *= pageHeight;
            deltaX *= pageHeight;
        }

        // Store lowest absolute delta to normalize the delta values
        absDelta = Math.max( Math.abs(deltaY), Math.abs(deltaX) );

        if ( !lowestDelta || absDelta < lowestDelta ) {
            lowestDelta = absDelta;

            // Adjust older deltas if necessary
            if ( shouldAdjustOldDeltas(orgEvent, absDelta) ) {
                lowestDelta /= 40;
            }
        }

        // Adjust older deltas if necessary
        if ( shouldAdjustOldDeltas(orgEvent, absDelta) ) {
            // Divide all the things by 40!
            delta  /= 40;
            deltaX /= 40;
            deltaY /= 40;
        }

        // Get a whole, normalized value for the deltas
        delta  = Math[ delta  >= 1 ? 'floor' : 'ceil' ](delta  / lowestDelta);
        deltaX = Math[ deltaX >= 1 ? 'floor' : 'ceil' ](deltaX / lowestDelta);
        deltaY = Math[ deltaY >= 1 ? 'floor' : 'ceil' ](deltaY / lowestDelta);

        // Normalise offsetX and offsetY properties
        if ( special.settings.normalizeOffset && this.getBoundingClientRect ) {
            var boundingRect = this.getBoundingClientRect();
            offsetX = event.clientX - boundingRect.left;
            offsetY = event.clientY - boundingRect.top;
        }

        // Add information to the event object
        event.deltaX = deltaX;
        event.deltaY = deltaY;
        event.deltaFactor = lowestDelta;
        event.offsetX = offsetX;
        event.offsetY = offsetY;
        // Go ahead and set deltaMode to 0 since we converted to pixels
        // Although this is a little odd since we overwrite the deltaX/Y
        // properties with normalized deltas.
        event.deltaMode = 0;

        // Add event and delta to the front of the arguments
        args.unshift(event, delta, deltaX, deltaY);

        // Clearout lowestDelta after sometime to better
        // handle multiple device types that give different
        // a different lowestDelta
        // Ex: trackpad = 3 and mouse wheel = 120
        if (nullLowestDeltaTimeout) { clearTimeout(nullLowestDeltaTimeout); }
        nullLowestDeltaTimeout = setTimeout(nullLowestDelta, 200);

        return ($.event.dispatch || $.event.handle).apply(this, args);
    }

    function nullLowestDelta() {
        lowestDelta = null;
    }

    function shouldAdjustOldDeltas(orgEvent, absDelta) {
        // If this is an older event and the delta is divisable by 120,
        // then we are assuming that the browser is treating this as an
        // older mouse wheel event and that we should divide the deltas
        // by 40 to try and get a more usable deltaFactor.
        // Side note, this actually impacts the reported scroll distance
        // in older browsers and can cause scrolling to be slower than native.
        // Turn this off by setting $.event.special.mousewheel.settings.adjustOldDeltas to false.
        return special.settings.adjustOldDeltas && orgEvent.type === 'mousewheel' && absDelta % 120 === 0;
    }

}));

S2.define('jquery.select2',[
  'jquery',
  'jquery-mousewheel',

  './select2/core',
  './select2/defaults'
], function ($, _, Select2, Defaults) {
  if ($.fn.select2 == null) {
    // All methods that should return the element
    var thisMethods = ['open', 'close', 'destroy'];

    $.fn.select2 = function (options) {
      options = options || {};

      if (typeof options === 'object') {
        this.each(function () {
          var instanceOptions = $.extend(true, {}, options);

          var instance = new Select2($(this), instanceOptions);
        });

        return this;
      } else if (typeof options === 'string') {
        var ret;
        var args = Array.prototype.slice.call(arguments, 1);

        this.each(function () {
          var instance = $(this).data('select2');

          if (instance == null && window.console && console.error) {
            console.error(
              'The select2(\'' + options + '\') method was called on an ' +
              'element that is not using Select2.'
            );
          }

          ret = instance[options].apply(instance, args);
        });

        // Check if we should be returning `this`
        if ($.inArray(options, thisMethods) > -1) {
          return this;
        }

        return ret;
      } else {
        throw new Error('Invalid arguments for Select2: ' + options);
      }
    };
  }

  if ($.fn.select2.defaults == null) {
    $.fn.select2.defaults = Defaults;
  }

  return Select2;
});

  // Return the AMD loader configuration so it can be used outside of this file
  return {
    define: S2.define,
    require: S2.require
  };
}());

  // Autoload the jQuery bindings
  // We know that all of the modules exist above this, so we're safe
  var select2 = S2.require('jquery.select2');

  // Hold the AMD module references on the jQuery function that was just loaded
  // This allows Select2 to use the internal loader outside of this file, such
  // as in the language files.
  jQuery.fn.select2.amd = S2;

  // Return the Select2 instance for anyone who is importing it.
  return select2;
}));

(function() {
  this.Specto = this.Specto || {};
  this.Specto.ui = this.Specto.ui || {};

  var ns = this.Specto.ui;

  /****************************************************************************************************/
  /******************************************** Phone Edit ********************************************/

  /*
        options: { 
            items: [{ id:.., text:.., countryCode:.., phoneCode:.. }], 
            defaultCountryCode:.., 
            value:.., 
            isReadOnly: true/false(default), 
            phoneSeparator: "#"(default),
            numberOfDigits: 9(default),
            min: 0(default),
            max: 999999999(default),
            attr: {}, 
            hiddenField:.., 
            validationMessageField:.., 
            dir: "ltr"(default)/"rtl"
        }

        IMPORTANT NOTE: (The following js files are required and must be imported before this class)
          jqueryExtensions.js
    */
  ns.PhoneEdit = (function() {
    //#region ______ CONST ______

    const CLASS_NAME = {
      plugin: {
        select: "phone-edit-select",
        countryAddon: "phone-edit-country-addon",
        phoneNumber: "phone-edit-phone-number-input",
        controlValidationError: "control-validation-error",
        phoneInputGroup: "phone-edit-input-group",
        phoneEdit: "phone-edit",
        countryName: "country-name",
        phoneCode: "phone-code",
        rtl: "dir-rtl",
        flag: "flag",
        customFlag: "flag-"
      }
    };

    //#endregion ___ CONST ______

    var defaults = {
      isReadOnly: false,
      phoneSeparator: "#",
      numberOfDigits: 9, // maximum digits allowed
      min: 0,
      max: 999999999,
      dir: "ltr"
    };

    function PhoneEdit(options) {
      // When use $.extend, if the second object contains null or 0, those two values override the default values from the first object, but the undefined does not.
      // So, for this reason, we use our created $.customExtend instead of $.extend.
      this.options = $.customExtend(true, {}, defaults, options);

      // Initialize the PhoneEdit
      init.call(this);
    }

    //#region ___________________________ Private Methods ___________________________

    var init = function() {
      sortOptions.call(this, this.options.items);
      this.options.items.unshift({ id: "", text: "", code: "" });

      this.countrySelect = $("<select>")
        .addClass(CLASS_NAME.plugin.select)
        .addBsClass("formControl");

      this.countryAddon = $("<span>")
        .addClass(CLASS_NAME.plugin.countryAddon)
        .addBsClass("inputGroupPrepend");

      var me = this;
      this.phoneNumber = $("<input type='number'>")
        .addClass(CLASS_NAME.plugin.phoneNumber)
        .addBsClass("formControl")
        .attr({
          min: this.options.min.toString(),
          max: this.options.max.toString()
        })
        .keydown(function(e) {
          // 0-9 = 48-57
          // 0-9 = 96-105 (numpad)
          // left = 37, up = 38, right = 39, down = 40
          // backspace = 8, tab = 9, delete = 46
          // ctrl + c = ctrl + 67
          // ctrl + v = ctrl + 86
          // ctrl + x = ctrl + 88
          var ctrlDown = e.ctrlKey || e.metaKey; // Mac support

          if (
            !(
              (
                (e.keyCode >= 48 && e.keyCode <= 57) ||
                (e.keyCode >= 96 && e.keyCode <= 105) ||
                (e.keyCode >= 37 && e.keyCode <= 40) ||
                e.keyCode == 8 ||
                e.keyCode == 9 ||
                e.keyCode == 46 ||
                (ctrlDown && e.keyCode == 67) || // c
                (ctrlDown && e.keyCode == 86) || // v
                (ctrlDown && e.keyCode == 88)
              ) // x
            )
          ) {
            // Prevent type negative sign or any other key
            return false;
          }

          if (
            (e.keyCode >= 48 && e.keyCode <= 57) ||
            (e.keyCode >= 96 && e.keyCode <= 105)
          ) {
            // Prevent type number with length grater than the specified on the options
            var value = $(this).val();
            if (value && value.toString().length == me.options.numberOfDigits) {
              return false;
            }
          }
        })
        .keyup(function(e) {
          var ctrlDown = e.ctrlKey || e.metaKey; // Mac support

          if (
            !(
              (
                (e.keyCode >= 48 && e.keyCode <= 57) ||
                (e.keyCode >= 96 && e.keyCode <= 105) ||
                (e.keyCode >= 37 && e.keyCode <= 40) ||
                e.keyCode == 8 ||
                e.keyCode == 9 ||
                e.keyCode == 46 ||
                (ctrlDown && e.keyCode == 67) || // c
                (ctrlDown && e.keyCode == 86) || // v
                (ctrlDown && e.keyCode == 88)
              ) // x
            )
          ) {
            // Prevent type negative sign or any other key
            return false;
          } else {
            onAfterChange.call(me);
          }
        });
    };

    var sortOptions = function(items) {
      items.sort(function(a, b) {
        if (a.text < b.text) return -1;
        if (a.text > b.text) return 1;
        return 0;
      });
    };

    var setValue = function(value) {
      var splitedValue = value.split(this.options.phoneSeparator);

      if (splitedValue.length != 2) {
        throw "The value should consist of 'Phone Code' and 'Phone Number' separated by " +
          this.options.phoneSeparator +
          ". ex: 962" +
          this.options.phoneSeparator +
          "779434343";
      }

      var selectedId = getIdByPhoneCode.call(this, splitedValue[0]);
      var phoneNumber = splitedValue[1];

      // Important Note:
      //  We should set the phone number before set country, coz the country dropdown trigger the on change that calls a shared method,
      //   and this method gets the phone number from the phoneNumber input field.
      this.phoneNumber.val(phoneNumber);

      // IMPORTANT NOTE: There is a bug when trying to set value using select2:
      //  If the id digit number is more than 1 digit, select2 always considers only the first digit as value and ignore the rest digits.
      //this.countrySelect.select2('val', selectedId.toString());

      this.countrySelect.val(selectedId.toString()).trigger("change");
    };

    var getItemById = function(id) {
      var item;

      if (this.options.items) {
        for (var i = 0; i < this.options.items.length; i++) {
          if (this.options.items[i].id == id) {
            item = this.options.items[i];
            break;
          }
        }
      }

      return item;
    };

    var getPhoneCodeById = function(id) {
      var phoneCode = "";

      if (id) {
        var item = getItemById.call(this, id);
        if (item) {
          phoneCode = item.phoneCode;
        }
      }

      return phoneCode;
    };

    var getIdByPhoneCode = function(phoneCode) {
      var id = "";

      if (this.options.items) {
        for (var i = 0; i < this.options.items.length; i++) {
          if (this.options.items[i].phoneCode == phoneCode) {
            id = this.options.items[i].id;
            break;
          }
        }
      }

      return id;
    };

    var getIdByCountryCode = function(countryCode) {
      var id = "";

      if (this.options.items) {
        for (var i = 0; i < this.options.items.length; i++) {
          if (this.options.items[i].countryCode == countryCode) {
            id = this.options.items[i].id;
            break;
          }
        }
      }

      return id;
    };

    var onAfterChange = function() {
      var selectedCountryId = this.countrySelect.val();
      var phoneCode = getPhoneCodeById.call(this, selectedCountryId);
      var phoneNumber = this.phoneNumber.val();

      var value = "";
      if (phoneNumber) {
        value = phoneCode + this.options.phoneSeparator + phoneNumber;
      }

      this.hiddenField.val(value);

      // Check if state of document to avoid call valid() method for the first time on setValue,
      //   if we don't set this check and there is a value for the first time so this will cause to stop the whole form validation.
      if (document.readyState === "complete") {
        if (this.hiddenField.valid instanceof Function)
          this.hiddenField.valid();
      }
    };

    var onValidationSuccess = function() {
      this.phoneNumber.removeClass(CLASS_NAME.plugin.controlValidationError);
      this.countryAddon.removeClass(CLASS_NAME.plugin.controlValidationError);
    };

    var onValidationFail = function() {
      this.phoneNumber.addClass(CLASS_NAME.plugin.controlValidationError);
      this.countryAddon.addClass(CLASS_NAME.plugin.controlValidationError);
    };

    //#endregion ________________________ Private Methods ___________________________

    PhoneEdit.prototype.renderOn = function(controlContainer) {
      // 1. Create input group
      var inputGroup = $("<div>")
        .addClass(CLASS_NAME.plugin.phoneInputGroup)
        .addBsClass("inputGroup")
        .addBsClass("select2BootstrapAppend");

      this.countryAddon.append(this.countrySelect);

      if (this.options.dir == "rtl") {
        this.countryAddon.addClass(CLASS_NAME.plugin.rtl);
      }

      inputGroup.append(this.countryAddon).append(this.phoneNumber);

      controlContainer.append(inputGroup);

      // 2. Create select2 from country select control
      var me = this;
      this.countrySelect.select2({
        //dropdownParent: inputGroup,
        data: this.options.items,
        dropdownAutoWidth: true,
        placeholder: "",
        minimumResultsForSearch: 1,
        theme: BootstrapKey.select2Theme, //theme: "classic"
        width: "100px",
        dir: this.options.dir,
        disabled: this.options.isReadOnly,
        tags: false, //Important Note: Prevent select2 from dynamically create new options from text input by the user in the search box.
        templateResult: function(item) {
          if (!item.id) {
            return item.text;
          }

          var flag = $("<div>")
            .addClass(CLASS_NAME.plugin.phoneEdit)
            .addClass(CLASS_NAME.plugin.flag)
            .addClass(CLASS_NAME.plugin.customFlag + item.countryCode);

          var countryName = $("<span>")
            .addClass(CLASS_NAME.plugin.phoneEdit)
            .addClass(CLASS_NAME.plugin.countryName)
            .append(item.text);

          var phoneCode = $("<span>")
            .addClass(CLASS_NAME.plugin.phoneEdit)
            .addClass(CLASS_NAME.plugin.phoneCode)
            .append(item.phoneCode);

          if (me.options.dir == "rtl") {
            flag.addClass(CLASS_NAME.plugin.rtl);
            countryName.addClass(CLASS_NAME.plugin.rtl);
          }

          var $item = $(
            flag.prop("outerHTML") +
              countryName.prop("outerHTML") +
              phoneCode.prop("outerHTML")
          );
          //var $item = $('<div class="phone-edit flag flag-' + item.countryCode + '"></div><span class="phone-edit country-name">' + item.text + '</span><span class="phone-edit phone-code">' + item.phoneCode + '</span>');
          return $item;
        },
        templateSelection: function(item) {
          if (!item.id) {
            return item.text;
          }

          var flag = $("<div>")
            .addClass(CLASS_NAME.plugin.phoneEdit)
            .addClass(CLASS_NAME.plugin.flag)
            .addClass(CLASS_NAME.plugin.customFlag + item.countryCode);

          if (me.options.dir == "rtl") {
            flag.addClass(CLASS_NAME.plugin.rtl);
          }

          var phoneCode = $("<span>")
            .addClass(CLASS_NAME.plugin.phoneEdit)
            .addClass(CLASS_NAME.plugin.phoneCode)
            .append(item.phoneCode);

          var $item = $(flag.prop("outerHTML") + phoneCode.prop("outerHTML"));
          //var $item = $('<div class="phone-edit flag flag-' + item.countryCode + '"></div><span class="phone-edit phone-code">' + item.phoneCode + '</span>');
          return $item;
        }
        //dropdownParent: this.countryAddon
      });

      if (this.options.isReadOnly) {
        this.phoneNumber.attr("disabled", "disabled");
      }

      var me = this;
      this.countrySelect.change(function() {
        onAfterChange.call(me);
      });

      // 3. Create hidden field
      if (this.options.hiddenField) {
        this.hiddenField = $(this.options.hiddenField);
        controlContainer.append(this.hiddenField);

        var me = this;
        this.hiddenField.bind("onSuccess", function() {
          onValidationSuccess.call(me);
        });

        this.hiddenField.bind("onError", function() {
          onValidationFail.call(me);
        });
      }

      // 4. Create validation message field
      if (this.options.validationMessageField) {
        var validationMessageField = $(this.options.validationMessageField);
        controlContainer.append(validationMessageField);
      }

      // 5. Select default country id
      if (!this.options.value && this.options.defaultCountryCode) {
        var countryId = getIdByCountryCode.call(
          this,
          this.options.defaultCountryCode
        );
        this.countrySelect.select2("val", countryId.toString());
      }

      // 6. Set value (Important Note: The set value should be after select2 creation)
      if (this.options.value) {
        setValue.call(this, this.options.value);
      }
    };

    return PhoneEdit;
  })();
})();

/*!
 * Datepicker for Bootstrap v1.9.0 (https://github.com/uxsolutions/bootstrap-datepicker)
 *
 * Licensed under the Apache License v2.0 (http://www.apache.org/licenses/LICENSE-2.0)
 */

(function(factory){
    if (typeof define === 'function' && define.amd) {
        define(['jquery'], factory);
    } else if (typeof exports === 'object') {
        factory(require('jquery'));
    } else {
        factory(jQuery);
    }
}(function($, undefined){
	function UTCDate(){
		return new Date(Date.UTC.apply(Date, arguments));
	}
	function UTCToday(){
		var today = new Date();
		return UTCDate(today.getFullYear(), today.getMonth(), today.getDate());
	}
	function isUTCEquals(date1, date2) {
		return (
			date1.getUTCFullYear() === date2.getUTCFullYear() &&
			date1.getUTCMonth() === date2.getUTCMonth() &&
			date1.getUTCDate() === date2.getUTCDate()
		);
	}
	function alias(method, deprecationMsg){
		return function(){
			if (deprecationMsg !== undefined) {
				$.fn.datepicker.deprecated(deprecationMsg);
			}

			return this[method].apply(this, arguments);
		};
	}
	function isValidDate(d) {
		return d && !isNaN(d.getTime());
	}

	var DateArray = (function(){
		var extras = {
			get: function(i){
				return this.slice(i)[0];
			},
			contains: function(d){
				// Array.indexOf is not cross-browser;
				// $.inArray doesn't work with Dates
				var val = d && d.valueOf();
				for (var i=0, l=this.length; i < l; i++)
          // Use date arithmetic to allow dates with different times to match
          if (0 <= this[i].valueOf() - val && this[i].valueOf() - val < 1000*60*60*24)
						return i;
				return -1;
			},
			remove: function(i){
				this.splice(i,1);
			},
			replace: function(new_array){
				if (!new_array)
					return;
				if (!$.isArray(new_array))
					new_array = [new_array];
				this.clear();
				this.push.apply(this, new_array);
			},
			clear: function(){
				this.length = 0;
			},
			copy: function(){
				var a = new DateArray();
				a.replace(this);
				return a;
			}
		};

		return function(){
			var a = [];
			a.push.apply(a, arguments);
			$.extend(a, extras);
			return a;
		};
	})();


	// Picker object

	var Datepicker = function(element, options){
		$.data(element, 'datepicker', this);

		this._events = [];
		this._secondaryEvents = [];

		this._process_options(options);

		this.dates = new DateArray();
		this.viewDate = this.o.defaultViewDate;
		this.focusDate = null;

		this.element = $(element);
		this.isInput = this.element.is('input');
		this.inputField = this.isInput ? this.element : this.element.find('input');
		this.component = this.element.hasClass('date') ? this.element.find('.add-on, .input-group-addon, .input-group-append, .input-group-prepend, .btn') : false;
		if (this.component && this.component.length === 0)
			this.component = false;
		this.isInline = !this.component && this.element.is('div');

		this.picker = $(DPGlobal.template);

		// Checking templates and inserting
		if (this._check_template(this.o.templates.leftArrow)) {
			this.picker.find('.prev').html(this.o.templates.leftArrow);
		}

		if (this._check_template(this.o.templates.rightArrow)) {
			this.picker.find('.next').html(this.o.templates.rightArrow);
		}

		this._buildEvents();
		this._attachEvents();

		if (this.isInline){
			this.picker.addClass('datepicker-inline').appendTo(this.element);
		}
		else {
			this.picker.addClass('datepicker-dropdown dropdown-menu');
		}

		if (this.o.rtl){
			this.picker.addClass('datepicker-rtl');
		}

		if (this.o.calendarWeeks) {
			this.picker.find('.datepicker-days .datepicker-switch, thead .datepicker-title, tfoot .today, tfoot .clear')
				.attr('colspan', function(i, val){
					return Number(val) + 1;
				});
		}

		this._process_options({
			startDate: this._o.startDate,
			endDate: this._o.endDate,
			daysOfWeekDisabled: this.o.daysOfWeekDisabled,
			daysOfWeekHighlighted: this.o.daysOfWeekHighlighted,
			datesDisabled: this.o.datesDisabled
		});

		this._allow_update = false;
		this.setViewMode(this.o.startView);
		this._allow_update = true;

		this.fillDow();
		this.fillMonths();

		this.update();

		if (this.isInline){
			this.show();
		}
	};

	Datepicker.prototype = {
		constructor: Datepicker,

		_resolveViewName: function(view){
			$.each(DPGlobal.viewModes, function(i, viewMode){
				if (view === i || $.inArray(view, viewMode.names) !== -1){
					view = i;
					return false;
				}
			});

			return view;
		},

		_resolveDaysOfWeek: function(daysOfWeek){
			if (!$.isArray(daysOfWeek))
				daysOfWeek = daysOfWeek.split(/[,\s]*/);
			return $.map(daysOfWeek, Number);
		},

		_check_template: function(tmp){
			try {
				// If empty
				if (tmp === undefined || tmp === "") {
					return false;
				}
				// If no html, everything ok
				if ((tmp.match(/[<>]/g) || []).length <= 0) {
					return true;
				}
				// Checking if html is fine
				var jDom = $(tmp);
				return jDom.length > 0;
			}
			catch (ex) {
				return false;
			}
		},

		_process_options: function(opts){
			// Store raw options for reference
			this._o = $.extend({}, this._o, opts);
			// Processed options
			var o = this.o = $.extend({}, this._o);

			// Check if "de-DE" style date is available, if not language should
			// fallback to 2 letter code eg "de"
			var lang = o.language;
			if (!dates[lang]){
				lang = lang.split('-')[0];
				if (!dates[lang])
					lang = defaults.language;
			}
			o.language = lang;

			// Retrieve view index from any aliases
			o.startView = this._resolveViewName(o.startView);
			o.minViewMode = this._resolveViewName(o.minViewMode);
			o.maxViewMode = this._resolveViewName(o.maxViewMode);

			// Check view is between min and max
			o.startView = Math.max(this.o.minViewMode, Math.min(this.o.maxViewMode, o.startView));

			// true, false, or Number > 0
			if (o.multidate !== true){
				o.multidate = Number(o.multidate) || false;
				if (o.multidate !== false)
					o.multidate = Math.max(0, o.multidate);
			}
			o.multidateSeparator = String(o.multidateSeparator);

			o.weekStart %= 7;
			o.weekEnd = (o.weekStart + 6) % 7;

			var format = DPGlobal.parseFormat(o.format);
			if (o.startDate !== -Infinity){
				if (!!o.startDate){
					if (o.startDate instanceof Date)
						o.startDate = this._local_to_utc(this._zero_time(o.startDate));
					else
						o.startDate = DPGlobal.parseDate(o.startDate, format, o.language, o.assumeNearbyYear);
				}
				else {
					o.startDate = -Infinity;
				}
			}
			if (o.endDate !== Infinity){
				if (!!o.endDate){
					if (o.endDate instanceof Date)
						o.endDate = this._local_to_utc(this._zero_time(o.endDate));
					else
						o.endDate = DPGlobal.parseDate(o.endDate, format, o.language, o.assumeNearbyYear);
				}
				else {
					o.endDate = Infinity;
				}
			}

			o.daysOfWeekDisabled = this._resolveDaysOfWeek(o.daysOfWeekDisabled||[]);
			o.daysOfWeekHighlighted = this._resolveDaysOfWeek(o.daysOfWeekHighlighted||[]);

			o.datesDisabled = o.datesDisabled||[];
			if (!$.isArray(o.datesDisabled)) {
				o.datesDisabled = o.datesDisabled.split(',');
			}
			o.datesDisabled = $.map(o.datesDisabled, function(d){
				return DPGlobal.parseDate(d, format, o.language, o.assumeNearbyYear);
			});

			var plc = String(o.orientation).toLowerCase().split(/\s+/g),
				_plc = o.orientation.toLowerCase();
			plc = $.grep(plc, function(word){
				return /^auto|left|right|top|bottom$/.test(word);
			});
			o.orientation = {x: 'auto', y: 'auto'};
			if (!_plc || _plc === 'auto')
				; // no action
			else if (plc.length === 1){
				switch (plc[0]){
					case 'top':
					case 'bottom':
						o.orientation.y = plc[0];
						break;
					case 'left':
					case 'right':
						o.orientation.x = plc[0];
						break;
				}
			}
			else {
				_plc = $.grep(plc, function(word){
					return /^left|right$/.test(word);
				});
				o.orientation.x = _plc[0] || 'auto';

				_plc = $.grep(plc, function(word){
					return /^top|bottom$/.test(word);
				});
				o.orientation.y = _plc[0] || 'auto';
			}
			if (o.defaultViewDate instanceof Date || typeof o.defaultViewDate === 'string') {
				o.defaultViewDate = DPGlobal.parseDate(o.defaultViewDate, format, o.language, o.assumeNearbyYear);
			} else if (o.defaultViewDate) {
				var year = o.defaultViewDate.year || new Date().getFullYear();
				var month = o.defaultViewDate.month || 0;
				var day = o.defaultViewDate.day || 1;
				o.defaultViewDate = UTCDate(year, month, day);
			} else {
				o.defaultViewDate = UTCToday();
			}
		},
		_applyEvents: function(evs){
			for (var i=0, el, ch, ev; i < evs.length; i++){
				el = evs[i][0];
				if (evs[i].length === 2){
					ch = undefined;
					ev = evs[i][1];
				} else if (evs[i].length === 3){
					ch = evs[i][1];
					ev = evs[i][2];
				}
				el.on(ev, ch);
			}
		},
		_unapplyEvents: function(evs){
			for (var i=0, el, ev, ch; i < evs.length; i++){
				el = evs[i][0];
				if (evs[i].length === 2){
					ch = undefined;
					ev = evs[i][1];
				} else if (evs[i].length === 3){
					ch = evs[i][1];
					ev = evs[i][2];
				}
				el.off(ev, ch);
			}
		},
		_buildEvents: function(){
            var events = {
                keyup: $.proxy(function(e){
                    if ($.inArray(e.keyCode, [27, 37, 39, 38, 40, 32, 13, 9]) === -1)
                        this.update();
                }, this),
                keydown: $.proxy(this.keydown, this),
                paste: $.proxy(this.paste, this)
            };

            if (this.o.showOnFocus === true) {
                events.focus = $.proxy(this.show, this);
            }

            if (this.isInput) { // single input
                this._events = [
                    [this.element, events]
                ];
            }
            // component: input + button
            else if (this.component && this.inputField.length) {
                this._events = [
                    // For components that are not readonly, allow keyboard nav
                    [this.inputField, events],
                    [this.component, {
                        click: $.proxy(this.show, this)
                    }]
                ];
            }
			else {
				this._events = [
					[this.element, {
						click: $.proxy(this.show, this),
						keydown: $.proxy(this.keydown, this)
					}]
				];
			}
			this._events.push(
				// Component: listen for blur on element descendants
				[this.element, '*', {
					blur: $.proxy(function(e){
						this._focused_from = e.target;
					}, this)
				}],
				// Input: listen for blur on element
				[this.element, {
					blur: $.proxy(function(e){
						this._focused_from = e.target;
					}, this)
				}]
			);

			if (this.o.immediateUpdates) {
				// Trigger input updates immediately on changed year/month
				this._events.push([this.element, {
					'changeYear changeMonth': $.proxy(function(e){
						this.update(e.date);
					}, this)
				}]);
			}

			this._secondaryEvents = [
				[this.picker, {
					click: $.proxy(this.click, this)
				}],
				[this.picker, '.prev, .next', {
					click: $.proxy(this.navArrowsClick, this)
				}],
				[this.picker, '.day:not(.disabled)', {
					click: $.proxy(this.dayCellClick, this)
				}],
				[$(window), {
					resize: $.proxy(this.place, this)
				}],
				[$(document), {
					'mousedown touchstart': $.proxy(function(e){
						// Clicked outside the datepicker, hide it
						if (!(
							this.element.is(e.target) ||
							this.element.find(e.target).length ||
							this.picker.is(e.target) ||
							this.picker.find(e.target).length ||
							this.isInline
						)){
							this.hide();
						}
					}, this)
				}]
			];
		},
		_attachEvents: function(){
			this._detachEvents();
			this._applyEvents(this._events);
		},
		_detachEvents: function(){
			this._unapplyEvents(this._events);
		},
		_attachSecondaryEvents: function(){
			this._detachSecondaryEvents();
			this._applyEvents(this._secondaryEvents);
		},
		_detachSecondaryEvents: function(){
			this._unapplyEvents(this._secondaryEvents);
		},
		_trigger: function(event, altdate){
			var date = altdate || this.dates.get(-1),
				local_date = this._utc_to_local(date);

			this.element.trigger({
				type: event,
				date: local_date,
				viewMode: this.viewMode,
				dates: $.map(this.dates, this._utc_to_local),
				format: $.proxy(function(ix, format){
					if (arguments.length === 0){
						ix = this.dates.length - 1;
						format = this.o.format;
					} else if (typeof ix === 'string'){
						format = ix;
						ix = this.dates.length - 1;
					}
					format = format || this.o.format;
					var date = this.dates.get(ix);
					return DPGlobal.formatDate(date, format, this.o.language);
				}, this)
			});
		},

		show: function(){
			if (this.inputField.is(':disabled') || (this.inputField.prop('readonly') && this.o.enableOnReadonly === false))
				return;
			if (!this.isInline)
				this.picker.appendTo(this.o.container);
			this.place();
			this.picker.show();
			this._attachSecondaryEvents();
			this._trigger('show');
			if ((window.navigator.msMaxTouchPoints || 'ontouchstart' in document) && this.o.disableTouchKeyboard) {
				$(this.element).blur();
			}
			return this;
		},

		hide: function(){
			if (this.isInline || !this.picker.is(':visible'))
				return this;
			this.focusDate = null;
			this.picker.hide().detach();
			this._detachSecondaryEvents();
			this.setViewMode(this.o.startView);

			if (this.o.forceParse && this.inputField.val())
				this.setValue();
			this._trigger('hide');
			return this;
		},

		destroy: function(){
			this.hide();
			this._detachEvents();
			this._detachSecondaryEvents();
			this.picker.remove();
			delete this.element.data().datepicker;
			if (!this.isInput){
				delete this.element.data().date;
			}
			return this;
		},

		paste: function(e){
			var dateString;
			if (e.originalEvent.clipboardData && e.originalEvent.clipboardData.types
				&& $.inArray('text/plain', e.originalEvent.clipboardData.types) !== -1) {
				dateString = e.originalEvent.clipboardData.getData('text/plain');
			} else if (window.clipboardData) {
				dateString = window.clipboardData.getData('Text');
			} else {
				return;
			}
			this.setDate(dateString);
			this.update();
			e.preventDefault();
		},

		_utc_to_local: function(utc){
			if (!utc) {
				return utc;
			}

			var local = new Date(utc.getTime() + (utc.getTimezoneOffset() * 60000));

			if (local.getTimezoneOffset() !== utc.getTimezoneOffset()) {
				local = new Date(utc.getTime() + (local.getTimezoneOffset() * 60000));
			}

			return local;
		},
		_local_to_utc: function(local){
			return local && new Date(local.getTime() - (local.getTimezoneOffset()*60000));
		},
		_zero_time: function(local){
			return local && new Date(local.getFullYear(), local.getMonth(), local.getDate());
		},
		_zero_utc_time: function(utc){
			return utc && UTCDate(utc.getUTCFullYear(), utc.getUTCMonth(), utc.getUTCDate());
		},

		getDates: function(){
			return $.map(this.dates, this._utc_to_local);
		},

		getUTCDates: function(){
			return $.map(this.dates, function(d){
				return new Date(d);
			});
		},

		getDate: function(){
			return this._utc_to_local(this.getUTCDate());
		},

		getUTCDate: function(){
			var selected_date = this.dates.get(-1);
			if (selected_date !== undefined) {
				return new Date(selected_date);
			} else {
				return null;
			}
		},

		clearDates: function(){
			this.inputField.val('');
			this.update();
			this._trigger('changeDate');

			if (this.o.autoclose) {
				this.hide();
			}
		},

		setDates: function(){
			var args = $.isArray(arguments[0]) ? arguments[0] : arguments;
			this.update.apply(this, args);
			this._trigger('changeDate');
			this.setValue();
			return this;
		},

		setUTCDates: function(){
			var args = $.isArray(arguments[0]) ? arguments[0] : arguments;
			this.setDates.apply(this, $.map(args, this._utc_to_local));
			return this;
		},

		setDate: alias('setDates'),
		setUTCDate: alias('setUTCDates'),
		remove: alias('destroy', 'Method `remove` is deprecated and will be removed in version 2.0. Use `destroy` instead'),

		setValue: function(){
			var formatted = this.getFormattedDate();
			this.inputField.val(formatted);
			return this;
		},

		getFormattedDate: function(format){
			if (format === undefined)
				format = this.o.format;

			var lang = this.o.language;
			return $.map(this.dates, function(d){
				return DPGlobal.formatDate(d, format, lang);
			}).join(this.o.multidateSeparator);
		},

		getStartDate: function(){
			return this.o.startDate;
		},

		setStartDate: function(startDate){
			this._process_options({startDate: startDate});
			this.update();
			this.updateNavArrows();
			return this;
		},

		getEndDate: function(){
			return this.o.endDate;
		},

		setEndDate: function(endDate){
			this._process_options({endDate: endDate});
			this.update();
			this.updateNavArrows();
			return this;
		},

		setDaysOfWeekDisabled: function(daysOfWeekDisabled){
			this._process_options({daysOfWeekDisabled: daysOfWeekDisabled});
			this.update();
			return this;
		},

		setDaysOfWeekHighlighted: function(daysOfWeekHighlighted){
			this._process_options({daysOfWeekHighlighted: daysOfWeekHighlighted});
			this.update();
			return this;
		},

		setDatesDisabled: function(datesDisabled){
			this._process_options({datesDisabled: datesDisabled});
			this.update();
			return this;
		},

		place: function(){
			if (this.isInline)
				return this;
			var calendarWidth = this.picker.outerWidth(),
				calendarHeight = this.picker.outerHeight(),
				visualPadding = 10,
				container = $(this.o.container),
				windowWidth = container.width(),
				scrollTop = this.o.container === 'body' ? $(document).scrollTop() : container.scrollTop(),
				appendOffset = container.offset();

			var parentsZindex = [0];
			this.element.parents().each(function(){
				var itemZIndex = $(this).css('z-index');
				if (itemZIndex !== 'auto' && Number(itemZIndex) !== 0) parentsZindex.push(Number(itemZIndex));
			});
			var zIndex = Math.max.apply(Math, parentsZindex) + this.o.zIndexOffset;
			var offset = this.component ? this.component.parent().offset() : this.element.offset();
			var height = this.component ? this.component.outerHeight(true) : this.element.outerHeight(false);
			var width = this.component ? this.component.outerWidth(true) : this.element.outerWidth(false);
			var left = offset.left - appendOffset.left;
			var top = offset.top - appendOffset.top;

			if (this.o.container !== 'body') {
				top += scrollTop;
			}

			this.picker.removeClass(
				'datepicker-orient-top datepicker-orient-bottom '+
				'datepicker-orient-right datepicker-orient-left'
			);

			if (this.o.orientation.x !== 'auto'){
				this.picker.addClass('datepicker-orient-' + this.o.orientation.x);
				if (this.o.orientation.x === 'right')
					left -= calendarWidth - width;
			}
			// auto x orientation is best-placement: if it crosses a window
			// edge, fudge it sideways
			else {
				if (offset.left < 0) {
					// component is outside the window on the left side. Move it into visible range
					this.picker.addClass('datepicker-orient-left');
					left -= offset.left - visualPadding;
				} else if (left + calendarWidth > windowWidth) {
					// the calendar passes the widow right edge. Align it to component right side
					this.picker.addClass('datepicker-orient-right');
					left += width - calendarWidth;
				} else {
					if (this.o.rtl) {
						// Default to right
						this.picker.addClass('datepicker-orient-right');
					} else {
						// Default to left
						this.picker.addClass('datepicker-orient-left');
					}
				}
			}

			// auto y orientation is best-situation: top or bottom, no fudging,
			// decision based on which shows more of the calendar
			var yorient = this.o.orientation.y,
				top_overflow;
			if (yorient === 'auto'){
				top_overflow = -scrollTop + top - calendarHeight;
				yorient = top_overflow < 0 ? 'bottom' : 'top';
			}

			this.picker.addClass('datepicker-orient-' + yorient);
			if (yorient === 'top')
				top -= calendarHeight + parseInt(this.picker.css('padding-top'));
			else
				top += height;

			if (this.o.rtl) {
				var right = windowWidth - (left + width);
				this.picker.css({
					top: top,
					right: right,
					zIndex: zIndex
				});
			} else {
				this.picker.css({
					top: top,
					left: left,
					zIndex: zIndex
				});
			}
			return this;
		},

		_allow_update: true,
		update: function(){
			if (!this._allow_update)
				return this;

			var oldDates = this.dates.copy(),
				dates = [],
				fromArgs = false;
			if (arguments.length){
				$.each(arguments, $.proxy(function(i, date){
					if (date instanceof Date)
						date = this._local_to_utc(date);
					dates.push(date);
				}, this));
				fromArgs = true;
			} else {
				dates = this.isInput
						? this.element.val()
						: this.element.data('date') || this.inputField.val();
				if (dates && this.o.multidate)
					dates = dates.split(this.o.multidateSeparator);
				else
					dates = [dates];
				delete this.element.data().date;
			}

			dates = $.map(dates, $.proxy(function(date){
				return DPGlobal.parseDate(date, this.o.format, this.o.language, this.o.assumeNearbyYear);
			}, this));
			dates = $.grep(dates, $.proxy(function(date){
				return (
					!this.dateWithinRange(date) ||
					!date
				);
			}, this), true);
			this.dates.replace(dates);

			if (this.o.updateViewDate) {
				if (this.dates.length)
					this.viewDate = new Date(this.dates.get(-1));
				else if (this.viewDate < this.o.startDate)
					this.viewDate = new Date(this.o.startDate);
				else if (this.viewDate > this.o.endDate)
					this.viewDate = new Date(this.o.endDate);
				else
					this.viewDate = this.o.defaultViewDate;
			}

			if (fromArgs){
				// setting date by clicking
				this.setValue();
				this.element.change();
			}
			else if (this.dates.length){
				// setting date by typing
				if (String(oldDates) !== String(this.dates) && fromArgs) {
					this._trigger('changeDate');
					this.element.change();
				}
			}
			if (!this.dates.length && oldDates.length) {
				this._trigger('clearDate');
				this.element.change();
			}

			this.fill();
			return this;
		},

		fillDow: function(){
      if (this.o.showWeekDays) {
			var dowCnt = this.o.weekStart,
				html = '<tr>';
			if (this.o.calendarWeeks){
				html += '<th class="cw">&#160;</th>';
			}
			while (dowCnt < this.o.weekStart + 7){
				html += '<th class="dow';
        if ($.inArray(dowCnt, this.o.daysOfWeekDisabled) !== -1)
          html += ' disabled';
        html += '">'+dates[this.o.language].daysMin[(dowCnt++)%7]+'</th>';
			}
			html += '</tr>';
			this.picker.find('.datepicker-days thead').append(html);
      }
		},

		fillMonths: function(){
      var localDate = this._utc_to_local(this.viewDate);
			var html = '';
			var focused;
			for (var i = 0; i < 12; i++){
				focused = localDate && localDate.getMonth() === i ? ' focused' : '';
				html += '<span class="month' + focused + '">' + dates[this.o.language].monthsShort[i] + '</span>';
			}
			this.picker.find('.datepicker-months td').html(html);
		},

		setRange: function(range){
			if (!range || !range.length)
				delete this.range;
			else
				this.range = $.map(range, function(d){
					return d.valueOf();
				});
			this.fill();
		},

		getClassNames: function(date){
			var cls = [],
				year = this.viewDate.getUTCFullYear(),
				month = this.viewDate.getUTCMonth(),
				today = UTCToday();
			if (date.getUTCFullYear() < year || (date.getUTCFullYear() === year && date.getUTCMonth() < month)){
				cls.push('old');
			} else if (date.getUTCFullYear() > year || (date.getUTCFullYear() === year && date.getUTCMonth() > month)){
				cls.push('new');
			}
			if (this.focusDate && date.valueOf() === this.focusDate.valueOf())
				cls.push('focused');
			// Compare internal UTC date with UTC today, not local today
			if (this.o.todayHighlight && isUTCEquals(date, today)) {
				cls.push('today');
			}
			if (this.dates.contains(date) !== -1)
				cls.push('active');
			if (!this.dateWithinRange(date)){
				cls.push('disabled');
			}
			if (this.dateIsDisabled(date)){
				cls.push('disabled', 'disabled-date');
			}
			if ($.inArray(date.getUTCDay(), this.o.daysOfWeekHighlighted) !== -1){
				cls.push('highlighted');
			}

			if (this.range){
				if (date > this.range[0] && date < this.range[this.range.length-1]){
					cls.push('range');
				}
				if ($.inArray(date.valueOf(), this.range) !== -1){
					cls.push('selected');
				}
				if (date.valueOf() === this.range[0]){
          cls.push('range-start');
        }
        if (date.valueOf() === this.range[this.range.length-1]){
          cls.push('range-end');
        }
			}
			return cls;
		},

		_fill_yearsView: function(selector, cssClass, factor, year, startYear, endYear, beforeFn){
			var html = '';
			var step = factor / 10;
			var view = this.picker.find(selector);
			var startVal = Math.floor(year / factor) * factor;
			var endVal = startVal + step * 9;
			var focusedVal = Math.floor(this.viewDate.getFullYear() / step) * step;
			var selected = $.map(this.dates, function(d){
				return Math.floor(d.getUTCFullYear() / step) * step;
			});

			var classes, tooltip, before;
			for (var currVal = startVal - step; currVal <= endVal + step; currVal += step) {
				classes = [cssClass];
				tooltip = null;

				if (currVal === startVal - step) {
					classes.push('old');
				} else if (currVal === endVal + step) {
					classes.push('new');
				}
				if ($.inArray(currVal, selected) !== -1) {
					classes.push('active');
				}
				if (currVal < startYear || currVal > endYear) {
					classes.push('disabled');
				}
				if (currVal === focusedVal) {
				  classes.push('focused');
        }

				if (beforeFn !== $.noop) {
					before = beforeFn(new Date(currVal, 0, 1));
					if (before === undefined) {
						before = {};
					} else if (typeof before === 'boolean') {
						before = {enabled: before};
					} else if (typeof before === 'string') {
						before = {classes: before};
					}
					if (before.enabled === false) {
						classes.push('disabled');
					}
					if (before.classes) {
						classes = classes.concat(before.classes.split(/\s+/));
					}
					if (before.tooltip) {
						tooltip = before.tooltip;
					}
				}

				html += '<span class="' + classes.join(' ') + '"' + (tooltip ? ' title="' + tooltip + '"' : '') + '>' + currVal + '</span>';
			}

			view.find('.datepicker-switch').text(startVal + '-' + endVal);
			view.find('td').html(html);
		},

		fill: function(){
			var d = new Date(this.viewDate),
				year = d.getUTCFullYear(),
				month = d.getUTCMonth(),
				startYear = this.o.startDate !== -Infinity ? this.o.startDate.getUTCFullYear() : -Infinity,
				startMonth = this.o.startDate !== -Infinity ? this.o.startDate.getUTCMonth() : -Infinity,
				endYear = this.o.endDate !== Infinity ? this.o.endDate.getUTCFullYear() : Infinity,
				endMonth = this.o.endDate !== Infinity ? this.o.endDate.getUTCMonth() : Infinity,
				todaytxt = dates[this.o.language].today || dates['en'].today || '',
				cleartxt = dates[this.o.language].clear || dates['en'].clear || '',
        titleFormat = dates[this.o.language].titleFormat || dates['en'].titleFormat,
        todayDate = UTCToday(),
        titleBtnVisible = (this.o.todayBtn === true || this.o.todayBtn === 'linked') && todayDate >= this.o.startDate && todayDate <= this.o.endDate && !this.weekOfDateIsDisabled(todayDate),
				tooltip,
				before;
			if (isNaN(year) || isNaN(month))
				return;
			this.picker.find('.datepicker-days .datepicker-switch')
						.text(DPGlobal.formatDate(d, titleFormat, this.o.language));
			this.picker.find('tfoot .today')
						.text(todaytxt)
            .css('display', titleBtnVisible ? 'table-cell' : 'none');
			this.picker.find('tfoot .clear')
						.text(cleartxt)
						.css('display', this.o.clearBtn === true ? 'table-cell' : 'none');
			this.picker.find('thead .datepicker-title')
						.text(this.o.title)
						.css('display', typeof this.o.title === 'string' && this.o.title !== '' ? 'table-cell' : 'none');
			this.updateNavArrows();
			this.fillMonths();
			var prevMonth = UTCDate(year, month, 0),
				day = prevMonth.getUTCDate();
			prevMonth.setUTCDate(day - (prevMonth.getUTCDay() - this.o.weekStart + 7)%7);
			var nextMonth = new Date(prevMonth);
			if (prevMonth.getUTCFullYear() < 100){
        nextMonth.setUTCFullYear(prevMonth.getUTCFullYear());
      }
			nextMonth.setUTCDate(nextMonth.getUTCDate() + 42);
			nextMonth = nextMonth.valueOf();
			var html = [];
			var weekDay, clsName;
			while (prevMonth.valueOf() < nextMonth){
				weekDay = prevMonth.getUTCDay();
				if (weekDay === this.o.weekStart){
					html.push('<tr>');
					if (this.o.calendarWeeks){
						// ISO 8601: First week contains first thursday.
						// ISO also states week starts on Monday, but we can be more abstract here.
						var
							// Start of current week: based on weekstart/current date
							ws = new Date(+prevMonth + (this.o.weekStart - weekDay - 7) % 7 * 864e5),
							// Thursday of this week
							th = new Date(Number(ws) + (7 + 4 - ws.getUTCDay()) % 7 * 864e5),
							// First Thursday of year, year from thursday
							yth = new Date(Number(yth = UTCDate(th.getUTCFullYear(), 0, 1)) + (7 + 4 - yth.getUTCDay()) % 7 * 864e5),
							// Calendar week: ms between thursdays, div ms per day, div 7 days
							calWeek = (th - yth) / 864e5 / 7 + 1;
						html.push('<td class="cw">'+ calWeek +'</td>');
					}
				}
				clsName = this.getClassNames(prevMonth);
				clsName.push('day');

				var content = prevMonth.getUTCDate();

				if (this.o.beforeShowDay !== $.noop){
					before = this.o.beforeShowDay(this._utc_to_local(prevMonth));
					if (before === undefined)
						before = {};
					else if (typeof before === 'boolean')
						before = {enabled: before};
					else if (typeof before === 'string')
						before = {classes: before};
					if (before.enabled === false)
						clsName.push('disabled');
					if (before.classes)
						clsName = clsName.concat(before.classes.split(/\s+/));
					if (before.tooltip)
						tooltip = before.tooltip;
					if (before.content)
						content = before.content;
				}

				//Check if uniqueSort exists (supported by jquery >=1.12 and >=2.2)
				//Fallback to unique function for older jquery versions
				if ($.isFunction($.uniqueSort)) {
					clsName = $.uniqueSort(clsName);
				} else {
					clsName = $.unique(clsName);
				}

				html.push('<td class="'+clsName.join(' ')+'"' + (tooltip ? ' title="'+tooltip+'"' : '') + ' data-date="' + prevMonth.getTime().toString() + '">' + content + '</td>');
				tooltip = null;
				if (weekDay === this.o.weekEnd){
					html.push('</tr>');
				}
				prevMonth.setUTCDate(prevMonth.getUTCDate() + 1);
			}
			this.picker.find('.datepicker-days tbody').html(html.join(''));

			var monthsTitle = dates[this.o.language].monthsTitle || dates['en'].monthsTitle || 'Months';
			var months = this.picker.find('.datepicker-months')
						.find('.datepicker-switch')
							.text(this.o.maxViewMode < 2 ? monthsTitle : year)
							.end()
						.find('tbody span').removeClass('active');

			$.each(this.dates, function(i, d){
				if (d.getUTCFullYear() === year)
					months.eq(d.getUTCMonth()).addClass('active');
			});

			if (year < startYear || year > endYear){
				months.addClass('disabled');
			}
			if (year === startYear){
				months.slice(0, startMonth).addClass('disabled');
			}
			if (year === endYear){
				months.slice(endMonth+1).addClass('disabled');
			}

			if (this.o.beforeShowMonth !== $.noop){
				var that = this;
				$.each(months, function(i, month){
          var moDate = new Date(year, i, 1);
          var before = that.o.beforeShowMonth(moDate);
					if (before === undefined)
						before = {};
					else if (typeof before === 'boolean')
						before = {enabled: before};
					else if (typeof before === 'string')
						before = {classes: before};
					if (before.enabled === false && !$(month).hasClass('disabled'))
					    $(month).addClass('disabled');
					if (before.classes)
					    $(month).addClass(before.classes);
					if (before.tooltip)
					    $(month).prop('title', before.tooltip);
				});
			}

			// Generating decade/years picker
			this._fill_yearsView(
				'.datepicker-years',
				'year',
				10,
				year,
				startYear,
				endYear,
				this.o.beforeShowYear
			);

			// Generating century/decades picker
			this._fill_yearsView(
				'.datepicker-decades',
				'decade',
				100,
				year,
				startYear,
				endYear,
				this.o.beforeShowDecade
			);

			// Generating millennium/centuries picker
			this._fill_yearsView(
				'.datepicker-centuries',
				'century',
				1000,
				year,
				startYear,
				endYear,
				this.o.beforeShowCentury
			);
		},

		updateNavArrows: function(){
			if (!this._allow_update)
				return;

			var d = new Date(this.viewDate),
				year = d.getUTCFullYear(),
				month = d.getUTCMonth(),
				startYear = this.o.startDate !== -Infinity ? this.o.startDate.getUTCFullYear() : -Infinity,
				startMonth = this.o.startDate !== -Infinity ? this.o.startDate.getUTCMonth() : -Infinity,
				endYear = this.o.endDate !== Infinity ? this.o.endDate.getUTCFullYear() : Infinity,
				endMonth = this.o.endDate !== Infinity ? this.o.endDate.getUTCMonth() : Infinity,
				prevIsDisabled,
				nextIsDisabled,
				factor = 1;
			switch (this.viewMode){
				case 4:
					factor *= 10;
					/* falls through */
				case 3:
					factor *= 10;
					/* falls through */
				case 2:
					factor *= 10;
					/* falls through */
				case 1:
					prevIsDisabled = Math.floor(year / factor) * factor <= startYear;
					nextIsDisabled = Math.floor(year / factor) * factor + factor > endYear;
					break;
				case 0:
					prevIsDisabled = year <= startYear && month <= startMonth;
					nextIsDisabled = year >= endYear && month >= endMonth;
					break;
			}

			this.picker.find('.prev').toggleClass('disabled', prevIsDisabled);
			this.picker.find('.next').toggleClass('disabled', nextIsDisabled);
		},

		click: function(e){
			e.preventDefault();
			e.stopPropagation();

			var target, dir, day, year, month;
			target = $(e.target);

			// Clicked on the switch
			if (target.hasClass('datepicker-switch') && this.viewMode !== this.o.maxViewMode){
				this.setViewMode(this.viewMode + 1);
			}

			// Clicked on today button
			if (target.hasClass('today') && !target.hasClass('day')){
				this.setViewMode(0);
				this._setDate(UTCToday(), this.o.todayBtn === 'linked' ? null : 'view');
			}

			// Clicked on clear button
			if (target.hasClass('clear')){
				this.clearDates();
			}

			if (!target.hasClass('disabled')){
				// Clicked on a month, year, decade, century
				if (target.hasClass('month')
						|| target.hasClass('year')
						|| target.hasClass('decade')
						|| target.hasClass('century')) {
					this.viewDate.setUTCDate(1);

					day = 1;
					if (this.viewMode === 1){
						month = target.parent().find('span').index(target);
						year = this.viewDate.getUTCFullYear();
						this.viewDate.setUTCMonth(month);
					} else {
						month = 0;
						year = Number(target.text());
						this.viewDate.setUTCFullYear(year);
					}

					this._trigger(DPGlobal.viewModes[this.viewMode - 1].e, this.viewDate);

					if (this.viewMode === this.o.minViewMode){
						this._setDate(UTCDate(year, month, day));
					} else {
						this.setViewMode(this.viewMode - 1);
						this.fill();
					}
				}
			}

			if (this.picker.is(':visible') && this._focused_from){
				this._focused_from.focus();
			}
			delete this._focused_from;
		},

		dayCellClick: function(e){
			var $target = $(e.currentTarget);
			var timestamp = $target.data('date');
			var date = new Date(timestamp);

			if (this.o.updateViewDate) {
				if (date.getUTCFullYear() !== this.viewDate.getUTCFullYear()) {
					this._trigger('changeYear', this.viewDate);
				}

				if (date.getUTCMonth() !== this.viewDate.getUTCMonth()) {
					this._trigger('changeMonth', this.viewDate);
				}
			}
			this._setDate(date);
		},

		// Clicked on prev or next
		navArrowsClick: function(e){
			var $target = $(e.currentTarget);
			var dir = $target.hasClass('prev') ? -1 : 1;
			if (this.viewMode !== 0){
				dir *= DPGlobal.viewModes[this.viewMode].navStep * 12;
			}
			this.viewDate = this.moveMonth(this.viewDate, dir);
			this._trigger(DPGlobal.viewModes[this.viewMode].e, this.viewDate);
			this.fill();
		},

		_toggle_multidate: function(date){
			var ix = this.dates.contains(date);
			if (!date){
				this.dates.clear();
			}

			if (ix !== -1){
				if (this.o.multidate === true || this.o.multidate > 1 || this.o.toggleActive){
					this.dates.remove(ix);
				}
			} else if (this.o.multidate === false) {
				this.dates.clear();
				this.dates.push(date);
			}
			else {
				this.dates.push(date);
			}

			if (typeof this.o.multidate === 'number')
				while (this.dates.length > this.o.multidate)
					this.dates.remove(0);
		},

		_setDate: function(date, which){
			if (!which || which === 'date')
				this._toggle_multidate(date && new Date(date));
			if ((!which && this.o.updateViewDate) || which === 'view')
				this.viewDate = date && new Date(date);

			this.fill();
			this.setValue();
			if (!which || which !== 'view') {
				this._trigger('changeDate');
			}
			this.inputField.trigger('change');
			if (this.o.autoclose && (!which || which === 'date')){
				this.hide();
			}
		},

		moveDay: function(date, dir){
			var newDate = new Date(date);
			newDate.setUTCDate(date.getUTCDate() + dir);

			return newDate;
		},

		moveWeek: function(date, dir){
			return this.moveDay(date, dir * 7);
		},

		moveMonth: function(date, dir){
			if (!isValidDate(date))
				return this.o.defaultViewDate;
			if (!dir)
				return date;
			var new_date = new Date(date.valueOf()),
				day = new_date.getUTCDate(),
				month = new_date.getUTCMonth(),
				mag = Math.abs(dir),
				new_month, test;
			dir = dir > 0 ? 1 : -1;
			if (mag === 1){
				test = dir === -1
					// If going back one month, make sure month is not current month
					// (eg, Mar 31 -> Feb 31 == Feb 28, not Mar 02)
					? function(){
						return new_date.getUTCMonth() === month;
					}
					// If going forward one month, make sure month is as expected
					// (eg, Jan 31 -> Feb 31 == Feb 28, not Mar 02)
					: function(){
						return new_date.getUTCMonth() !== new_month;
					};
				new_month = month + dir;
				new_date.setUTCMonth(new_month);
				// Dec -> Jan (12) or Jan -> Dec (-1) -- limit expected date to 0-11
				new_month = (new_month + 12) % 12;
			}
			else {
				// For magnitudes >1, move one month at a time...
				for (var i=0; i < mag; i++)
					// ...which might decrease the day (eg, Jan 31 to Feb 28, etc)...
					new_date = this.moveMonth(new_date, dir);
				// ...then reset the day, keeping it in the new month
				new_month = new_date.getUTCMonth();
				new_date.setUTCDate(day);
				test = function(){
					return new_month !== new_date.getUTCMonth();
				};
			}
			// Common date-resetting loop -- if date is beyond end of month, make it
			// end of month
			while (test()){
				new_date.setUTCDate(--day);
				new_date.setUTCMonth(new_month);
			}
			return new_date;
		},

		moveYear: function(date, dir){
			return this.moveMonth(date, dir*12);
		},

		moveAvailableDate: function(date, dir, fn){
			do {
				date = this[fn](date, dir);

				if (!this.dateWithinRange(date))
					return false;

				fn = 'moveDay';
			}
			while (this.dateIsDisabled(date));

			return date;
		},

		weekOfDateIsDisabled: function(date){
			return $.inArray(date.getUTCDay(), this.o.daysOfWeekDisabled) !== -1;
		},

		dateIsDisabled: function(date){
			return (
				this.weekOfDateIsDisabled(date) ||
				$.grep(this.o.datesDisabled, function(d){
					return isUTCEquals(date, d);
				}).length > 0
			);
		},

		dateWithinRange: function(date){
			return date >= this.o.startDate && date <= this.o.endDate;
		},

		keydown: function(e){
			if (!this.picker.is(':visible')){
				if (e.keyCode === 40 || e.keyCode === 27) { // allow down to re-show picker
					this.show();
					e.stopPropagation();
        }
				return;
			}
			var dateChanged = false,
				dir, newViewDate,
				focusDate = this.focusDate || this.viewDate;
			switch (e.keyCode){
				case 27: // escape
					if (this.focusDate){
						this.focusDate = null;
						this.viewDate = this.dates.get(-1) || this.viewDate;
						this.fill();
					}
					else
						this.hide();
					e.preventDefault();
					e.stopPropagation();
					break;
				case 37: // left
				case 38: // up
				case 39: // right
				case 40: // down
					if (!this.o.keyboardNavigation || this.o.daysOfWeekDisabled.length === 7)
						break;
					dir = e.keyCode === 37 || e.keyCode === 38 ? -1 : 1;
          if (this.viewMode === 0) {
  					if (e.ctrlKey){
  						newViewDate = this.moveAvailableDate(focusDate, dir, 'moveYear');

  						if (newViewDate)
  							this._trigger('changeYear', this.viewDate);
  					} else if (e.shiftKey){
  						newViewDate = this.moveAvailableDate(focusDate, dir, 'moveMonth');

  						if (newViewDate)
  							this._trigger('changeMonth', this.viewDate);
  					} else if (e.keyCode === 37 || e.keyCode === 39){
  						newViewDate = this.moveAvailableDate(focusDate, dir, 'moveDay');
  					} else if (!this.weekOfDateIsDisabled(focusDate)){
  						newViewDate = this.moveAvailableDate(focusDate, dir, 'moveWeek');
  					}
          } else if (this.viewMode === 1) {
            if (e.keyCode === 38 || e.keyCode === 40) {
              dir = dir * 4;
            }
            newViewDate = this.moveAvailableDate(focusDate, dir, 'moveMonth');
          } else if (this.viewMode === 2) {
            if (e.keyCode === 38 || e.keyCode === 40) {
              dir = dir * 4;
            }
            newViewDate = this.moveAvailableDate(focusDate, dir, 'moveYear');
          }
					if (newViewDate){
						this.focusDate = this.viewDate = newViewDate;
						this.setValue();
						this.fill();
						e.preventDefault();
					}
					break;
				case 13: // enter
					if (!this.o.forceParse)
						break;
					focusDate = this.focusDate || this.dates.get(-1) || this.viewDate;
					if (this.o.keyboardNavigation) {
						this._toggle_multidate(focusDate);
						dateChanged = true;
					}
					this.focusDate = null;
					this.viewDate = this.dates.get(-1) || this.viewDate;
					this.setValue();
					this.fill();
					if (this.picker.is(':visible')){
						e.preventDefault();
						e.stopPropagation();
						if (this.o.autoclose)
							this.hide();
					}
					break;
				case 9: // tab
					this.focusDate = null;
					this.viewDate = this.dates.get(-1) || this.viewDate;
					this.fill();
					this.hide();
					break;
			}
			if (dateChanged){
				if (this.dates.length)
					this._trigger('changeDate');
				else
					this._trigger('clearDate');
				this.inputField.trigger('change');
			}
		},

		setViewMode: function(viewMode){
			this.viewMode = viewMode;
			this.picker
				.children('div')
				.hide()
				.filter('.datepicker-' + DPGlobal.viewModes[this.viewMode].clsName)
					.show();
			this.updateNavArrows();
      this._trigger('changeViewMode', new Date(this.viewDate));
		}
	};

	var DateRangePicker = function(element, options){
		$.data(element, 'datepicker', this);
		this.element = $(element);
		this.inputs = $.map(options.inputs, function(i){
			return i.jquery ? i[0] : i;
		});
		delete options.inputs;

		this.keepEmptyValues = options.keepEmptyValues;
		delete options.keepEmptyValues;

		datepickerPlugin.call($(this.inputs), options)
			.on('changeDate', $.proxy(this.dateUpdated, this));

		this.pickers = $.map(this.inputs, function(i){
			return $.data(i, 'datepicker');
		});
		this.updateDates();
	};
	DateRangePicker.prototype = {
		updateDates: function(){
			this.dates = $.map(this.pickers, function(i){
				return i.getUTCDate();
			});
			this.updateRanges();
		},
		updateRanges: function(){
			var range = $.map(this.dates, function(d){
				return d.valueOf();
			});
			$.each(this.pickers, function(i, p){
				p.setRange(range);
			});
		},
		clearDates: function(){
			$.each(this.pickers, function(i, p){
				p.clearDates();
			});
		},
		dateUpdated: function(e){
			// `this.updating` is a workaround for preventing infinite recursion
			// between `changeDate` triggering and `setUTCDate` calling.  Until
			// there is a better mechanism.
			if (this.updating)
				return;
			this.updating = true;

			var dp = $.data(e.target, 'datepicker');

			if (dp === undefined) {
				return;
			}

			var new_date = dp.getUTCDate(),
				keep_empty_values = this.keepEmptyValues,
				i = $.inArray(e.target, this.inputs),
				j = i - 1,
				k = i + 1,
				l = this.inputs.length;
			if (i === -1)
				return;

			$.each(this.pickers, function(i, p){
				if (!p.getUTCDate() && (p === dp || !keep_empty_values))
					p.setUTCDate(new_date);
			});

			if (new_date < this.dates[j]){
				// Date being moved earlier/left
				while (j >= 0 && new_date < this.dates[j]){
					this.pickers[j--].setUTCDate(new_date);
				}
			} else if (new_date > this.dates[k]){
				// Date being moved later/right
				while (k < l && new_date > this.dates[k]){
					this.pickers[k++].setUTCDate(new_date);
				}
			}
			this.updateDates();

			delete this.updating;
		},
		destroy: function(){
			$.map(this.pickers, function(p){ p.destroy(); });
			$(this.inputs).off('changeDate', this.dateUpdated);
			delete this.element.data().datepicker;
		},
		remove: alias('destroy', 'Method `remove` is deprecated and will be removed in version 2.0. Use `destroy` instead')
	};

	function opts_from_el(el, prefix){
		// Derive options from element data-attrs
		var data = $(el).data(),
			out = {}, inkey,
			replace = new RegExp('^' + prefix.toLowerCase() + '([A-Z])');
		prefix = new RegExp('^' + prefix.toLowerCase());
		function re_lower(_,a){
			return a.toLowerCase();
		}
		for (var key in data)
			if (prefix.test(key)){
				inkey = key.replace(replace, re_lower);
				out[inkey] = data[key];
			}
		return out;
	}

	function opts_from_locale(lang){
		// Derive options from locale plugins
		var out = {};
		// Check if "de-DE" style date is available, if not language should
		// fallback to 2 letter code eg "de"
		if (!dates[lang]){
			lang = lang.split('-')[0];
			if (!dates[lang])
				return;
		}
		var d = dates[lang];
		$.each(locale_opts, function(i,k){
			if (k in d)
				out[k] = d[k];
		});
		return out;
	}

	var old = $.fn.datepicker;
	var datepickerPlugin = function(option){
		var args = Array.apply(null, arguments);
		args.shift();
		var internal_return;
		this.each(function(){
			var $this = $(this),
				data = $this.data('datepicker'),
				options = typeof option === 'object' && option;
			if (!data){
				var elopts = opts_from_el(this, 'date'),
					// Preliminary otions
					xopts = $.extend({}, defaults, elopts, options),
					locopts = opts_from_locale(xopts.language),
					// Options priority: js args, data-attrs, locales, defaults
					opts = $.extend({}, defaults, locopts, elopts, options);
				if ($this.hasClass('input-daterange') || opts.inputs){
					$.extend(opts, {
						inputs: opts.inputs || $this.find('input').toArray()
					});
					data = new DateRangePicker(this, opts);
				}
				else {
					data = new Datepicker(this, opts);
				}
				$this.data('datepicker', data);
			}
			if (typeof option === 'string' && typeof data[option] === 'function'){
				internal_return = data[option].apply(data, args);
			}
		});

		if (
			internal_return === undefined ||
			internal_return instanceof Datepicker ||
			internal_return instanceof DateRangePicker
		)
			return this;

		if (this.length > 1)
			throw new Error('Using only allowed for the collection of a single element (' + option + ' function)');
		else
			return internal_return;
	};
	$.fn.datepicker = datepickerPlugin;

	var defaults = $.fn.datepicker.defaults = {
		assumeNearbyYear: false,
		autoclose: false,
		beforeShowDay: $.noop,
		beforeShowMonth: $.noop,
		beforeShowYear: $.noop,
		beforeShowDecade: $.noop,
		beforeShowCentury: $.noop,
		calendarWeeks: false,
		clearBtn: false,
		toggleActive: false,
		daysOfWeekDisabled: [],
		daysOfWeekHighlighted: [],
		datesDisabled: [],
		endDate: Infinity,
		forceParse: true,
		format: 'mm/dd/yyyy',
		keepEmptyValues: false,
		keyboardNavigation: true,
		language: 'en',
		minViewMode: 0,
		maxViewMode: 4,
		multidate: false,
		multidateSeparator: ',',
		orientation: "auto",
		rtl: false,
		startDate: -Infinity,
		startView: 0,
		todayBtn: false,
		todayHighlight: false,
		updateViewDate: true,
		weekStart: 0,
		disableTouchKeyboard: false,
		enableOnReadonly: true,
		showOnFocus: true,
		zIndexOffset: 10,
		container: 'body',
		immediateUpdates: false,
		title: '',
		templates: {
			leftArrow: '&#x00AB;',
			rightArrow: '&#x00BB;'
		},
    showWeekDays: true
	};
	var locale_opts = $.fn.datepicker.locale_opts = [
		'format',
		'rtl',
		'weekStart'
	];
	$.fn.datepicker.Constructor = Datepicker;
	var dates = $.fn.datepicker.dates = {
		en: {
			days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
			daysShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
			daysMin: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
			months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
			monthsShort: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
			today: "Today",
			clear: "Clear",
			titleFormat: "MM yyyy"
		}
	};

	var DPGlobal = {
		viewModes: [
			{
				names: ['days', 'month'],
				clsName: 'days',
				e: 'changeMonth'
			},
			{
				names: ['months', 'year'],
				clsName: 'months',
				e: 'changeYear',
				navStep: 1
			},
			{
				names: ['years', 'decade'],
				clsName: 'years',
				e: 'changeDecade',
				navStep: 10
			},
			{
				names: ['decades', 'century'],
				clsName: 'decades',
				e: 'changeCentury',
				navStep: 100
			},
			{
				names: ['centuries', 'millennium'],
				clsName: 'centuries',
				e: 'changeMillennium',
				navStep: 1000
			}
		],
		validParts: /dd?|DD?|mm?|MM?|yy(?:yy)?/g,
		nonpunctuation: /[^ -\/:-@\u5e74\u6708\u65e5\[-`{-~\t\n\r]+/g,
		parseFormat: function(format){
			if (typeof format.toValue === 'function' && typeof format.toDisplay === 'function')
                return format;
            // IE treats \0 as a string end in inputs (truncating the value),
			// so it's a bad format delimiter, anyway
			var separators = format.replace(this.validParts, '\0').split('\0'),
				parts = format.match(this.validParts);
			if (!separators || !separators.length || !parts || parts.length === 0){
				throw new Error("Invalid date format.");
			}
			return {separators: separators, parts: parts};
		},
		parseDate: function(date, format, language, assumeNearby){
			if (!date)
				return undefined;
			if (date instanceof Date)
				return date;
			if (typeof format === 'string')
				format = DPGlobal.parseFormat(format);
			if (format.toValue)
				return format.toValue(date, format, language);
			var fn_map = {
					d: 'moveDay',
					m: 'moveMonth',
					w: 'moveWeek',
					y: 'moveYear'
				},
				dateAliases = {
					yesterday: '-1d',
					today: '+0d',
					tomorrow: '+1d'
				},
				parts, part, dir, i, fn;
			if (date in dateAliases){
				date = dateAliases[date];
			}
			if (/^[\-+]\d+[dmwy]([\s,]+[\-+]\d+[dmwy])*$/i.test(date)){
				parts = date.match(/([\-+]\d+)([dmwy])/gi);
				date = new Date();
				for (i=0; i < parts.length; i++){
					part = parts[i].match(/([\-+]\d+)([dmwy])/i);
					dir = Number(part[1]);
					fn = fn_map[part[2].toLowerCase()];
					date = Datepicker.prototype[fn](date, dir);
				}
				return Datepicker.prototype._zero_utc_time(date);
			}

			parts = date && date.match(this.nonpunctuation) || [];

			function applyNearbyYear(year, threshold){
				if (threshold === true)
					threshold = 10;

				// if year is 2 digits or less, than the user most likely is trying to get a recent century
				if (year < 100){
					year += 2000;
					// if the new year is more than threshold years in advance, use last century
					if (year > ((new Date()).getFullYear()+threshold)){
						year -= 100;
					}
				}

				return year;
			}

			var parsed = {},
				setters_order = ['yyyy', 'yy', 'M', 'MM', 'm', 'mm', 'd', 'dd'],
				setters_map = {
					yyyy: function(d,v){
						return d.setUTCFullYear(assumeNearby ? applyNearbyYear(v, assumeNearby) : v);
					},
					m: function(d,v){
						if (isNaN(d))
							return d;
						v -= 1;
						while (v < 0) v += 12;
						v %= 12;
						d.setUTCMonth(v);
						while (d.getUTCMonth() !== v)
							d.setUTCDate(d.getUTCDate()-1);
						return d;
					},
					d: function(d,v){
						return d.setUTCDate(v);
					}
				},
				val, filtered;
			setters_map['yy'] = setters_map['yyyy'];
			setters_map['M'] = setters_map['MM'] = setters_map['mm'] = setters_map['m'];
			setters_map['dd'] = setters_map['d'];
			date = UTCToday();
			var fparts = format.parts.slice();
			// Remove noop parts
			if (parts.length !== fparts.length){
				fparts = $(fparts).filter(function(i,p){
					return $.inArray(p, setters_order) !== -1;
				}).toArray();
			}
			// Process remainder
			function match_part(){
				var m = this.slice(0, parts[i].length),
					p = parts[i].slice(0, m.length);
				return m.toLowerCase() === p.toLowerCase();
			}
			if (parts.length === fparts.length){
				var cnt;
				for (i=0, cnt = fparts.length; i < cnt; i++){
					val = parseInt(parts[i], 10);
					part = fparts[i];
					if (isNaN(val)){
						switch (part){
							case 'MM':
								filtered = $(dates[language].months).filter(match_part);
								val = $.inArray(filtered[0], dates[language].months) + 1;
								break;
							case 'M':
								filtered = $(dates[language].monthsShort).filter(match_part);
								val = $.inArray(filtered[0], dates[language].monthsShort) + 1;
								break;
						}
					}
					parsed[part] = val;
				}
				var _date, s;
				for (i=0; i < setters_order.length; i++){
					s = setters_order[i];
					if (s in parsed && !isNaN(parsed[s])){
						_date = new Date(date);
						setters_map[s](_date, parsed[s]);
						if (!isNaN(_date))
							date = _date;
					}
				}
			}
			return date;
		},
		formatDate: function(date, format, language){
			if (!date)
				return '';
			if (typeof format === 'string')
				format = DPGlobal.parseFormat(format);
			if (format.toDisplay)
                return format.toDisplay(date, format, language);
            var val = {
				d: date.getUTCDate(),
				D: dates[language].daysShort[date.getUTCDay()],
				DD: dates[language].days[date.getUTCDay()],
				m: date.getUTCMonth() + 1,
				M: dates[language].monthsShort[date.getUTCMonth()],
				MM: dates[language].months[date.getUTCMonth()],
				yy: date.getUTCFullYear().toString().substring(2),
				yyyy: date.getUTCFullYear()
			};
			val.dd = (val.d < 10 ? '0' : '') + val.d;
			val.mm = (val.m < 10 ? '0' : '') + val.m;
			date = [];
			var seps = $.extend([], format.separators);
			for (var i=0, cnt = format.parts.length; i <= cnt; i++){
				if (seps.length)
					date.push(seps.shift());
				date.push(val[format.parts[i]]);
			}
			return date.join('');
		},
		headTemplate: '<thead>'+
			              '<tr>'+
			                '<th colspan="7" class="datepicker-title"></th>'+
			              '</tr>'+
							'<tr>'+
								'<th class="prev">'+defaults.templates.leftArrow+'</th>'+
								'<th colspan="5" class="datepicker-switch"></th>'+
								'<th class="next">'+defaults.templates.rightArrow+'</th>'+
							'</tr>'+
						'</thead>',
		contTemplate: '<tbody><tr><td colspan="7"></td></tr></tbody>',
		footTemplate: '<tfoot>'+
							'<tr>'+
								'<th colspan="7" class="today"></th>'+
							'</tr>'+
							'<tr>'+
								'<th colspan="7" class="clear"></th>'+
							'</tr>'+
						'</tfoot>'
	};
	DPGlobal.template = '<div class="datepicker">'+
							'<div class="datepicker-days">'+
								'<table class="table-condensed">'+
									DPGlobal.headTemplate+
									'<tbody></tbody>'+
									DPGlobal.footTemplate+
								'</table>'+
							'</div>'+
							'<div class="datepicker-months">'+
								'<table class="table-condensed">'+
									DPGlobal.headTemplate+
									DPGlobal.contTemplate+
									DPGlobal.footTemplate+
								'</table>'+
							'</div>'+
							'<div class="datepicker-years">'+
								'<table class="table-condensed">'+
									DPGlobal.headTemplate+
									DPGlobal.contTemplate+
									DPGlobal.footTemplate+
								'</table>'+
							'</div>'+
							'<div class="datepicker-decades">'+
								'<table class="table-condensed">'+
									DPGlobal.headTemplate+
									DPGlobal.contTemplate+
									DPGlobal.footTemplate+
								'</table>'+
							'</div>'+
							'<div class="datepicker-centuries">'+
								'<table class="table-condensed">'+
									DPGlobal.headTemplate+
									DPGlobal.contTemplate+
									DPGlobal.footTemplate+
								'</table>'+
							'</div>'+
						'</div>';

	$.fn.datepicker.DPGlobal = DPGlobal;


	/* DATEPICKER NO CONFLICT
	* =================== */

	$.fn.datepicker.noConflict = function(){
		$.fn.datepicker = old;
		return this;
	};

	/* DATEPICKER VERSION
	 * =================== */
	$.fn.datepicker.version = '1.9.0';

	$.fn.datepicker.deprecated = function(msg){
		var console = window.console;
		if (console && console.warn) {
			console.warn('DEPRECATED: ' + msg);
		}
	};


	/* DATEPICKER DATA-API
	* ================== */

	$(document).on(
		'focus.datepicker.data-api click.datepicker.data-api',
		'[data-provide="datepicker"]',
		function(e){
			var $this = $(this);
			if ($this.data('datepicker'))
				return;
			e.preventDefault();
			// component click requires us to explicitly show it
			datepickerPlugin.call($this, 'show');
		}
	);
	$(function(){
		datepickerPlugin.call($('[data-provide="datepicker-inline"]'));
	});

}));

window.HtmlTemplates = {
  ButtonOutlinePrimary: `
  <button type="button" class="btn btn-outline-primary waves-effect waves-themed ml-2"
          style="margin-bottom: 1rem;">
    <span class="mr-1"></span>
  </button>`,
  
  VerticalTabList:
`<div class="panel-content">
	<div class="row">
		<div class="col-auto">
			<div class="nav flex-column nav-pills" role="tablist" aria-orientation="vertical">
			</div>
		</div>
		<div class="col">
			<div class="tab-content">
			</div>
		</div>
	</div>
</div>`,

MenuTab: `
<a class="nav-link" data-toggle="pill" role="tab">
  <span class="hidden-sm-down ml-1"></span>
</a>`,

MenuTabConent:
`<div class="tab-pane fade" role="tabpanel"></div>`,

StripedTable:
`<table class="table table-striped m-0"></table>`,

TableRowLabelValue:`
<tr>
  <td class="label p-2"></td>
  <td class="value p-2"></td>
</tr>`,

};
;(function (root, factory) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory();
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define([], factory);
	}
	else {
		// Global (browser)
		root.CryptoJS = factory();
	}
}(this, function () {

	/**
	 * CryptoJS core components.
	 */
	var CryptoJS = CryptoJS || (function (Math, undefined) {
	    /*
	     * Local polyfil of Object.create
	     */
	    var create = Object.create || (function () {
	        function F() {};

	        return function (obj) {
	            var subtype;

	            F.prototype = obj;

	            subtype = new F();

	            F.prototype = null;

	            return subtype;
	        };
	    }())

	    /**
	     * CryptoJS namespace.
	     */
	    var C = {};

	    /**
	     * Library namespace.
	     */
	    var C_lib = C.lib = {};

	    /**
	     * Base object for prototypal inheritance.
	     */
	    var Base = C_lib.Base = (function () {


	        return {
	            /**
	             * Creates a new object that inherits from this object.
	             *
	             * @param {Object} overrides Properties to copy into the new object.
	             *
	             * @return {Object} The new object.
	             *
	             * @static
	             *
	             * @example
	             *
	             *     var MyType = CryptoJS.lib.Base.extend({
	             *         field: 'value',
	             *
	             *         method: function () {
	             *         }
	             *     });
	             */
	            extend: function (overrides) {
	                // Spawn
	                var subtype = create(this);

	                // Augment
	                if (overrides) {
	                    subtype.mixIn(overrides);
	                }

	                // Create default initializer
	                if (!subtype.hasOwnProperty('init') || this.init === subtype.init) {
	                    subtype.init = function () {
	                        subtype.$super.init.apply(this, arguments);
	                    };
	                }

	                // Initializer's prototype is the subtype object
	                subtype.init.prototype = subtype;

	                // Reference supertype
	                subtype.$super = this;

	                return subtype;
	            },

	            /**
	             * Extends this object and runs the init method.
	             * Arguments to create() will be passed to init().
	             *
	             * @return {Object} The new object.
	             *
	             * @static
	             *
	             * @example
	             *
	             *     var instance = MyType.create();
	             */
	            create: function () {
	                var instance = this.extend();
	                instance.init.apply(instance, arguments);

	                return instance;
	            },

	            /**
	             * Initializes a newly created object.
	             * Override this method to add some logic when your objects are created.
	             *
	             * @example
	             *
	             *     var MyType = CryptoJS.lib.Base.extend({
	             *         init: function () {
	             *             // ...
	             *         }
	             *     });
	             */
	            init: function () {
	            },

	            /**
	             * Copies properties into this object.
	             *
	             * @param {Object} properties The properties to mix in.
	             *
	             * @example
	             *
	             *     MyType.mixIn({
	             *         field: 'value'
	             *     });
	             */
	            mixIn: function (properties) {
	                for (var propertyName in properties) {
	                    if (properties.hasOwnProperty(propertyName)) {
	                        this[propertyName] = properties[propertyName];
	                    }
	                }

	                // IE won't copy toString using the loop above
	                if (properties.hasOwnProperty('toString')) {
	                    this.toString = properties.toString;
	                }
	            },

	            /**
	             * Creates a copy of this object.
	             *
	             * @return {Object} The clone.
	             *
	             * @example
	             *
	             *     var clone = instance.clone();
	             */
	            clone: function () {
	                return this.init.prototype.extend(this);
	            }
	        };
	    }());

	    /**
	     * An array of 32-bit words.
	     *
	     * @property {Array} words The array of 32-bit words.
	     * @property {number} sigBytes The number of significant bytes in this word array.
	     */
	    var WordArray = C_lib.WordArray = Base.extend({
	        /**
	         * Initializes a newly created word array.
	         *
	         * @param {Array} words (Optional) An array of 32-bit words.
	         * @param {number} sigBytes (Optional) The number of significant bytes in the words.
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.lib.WordArray.create();
	         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);
	         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);
	         */
	        init: function (words, sigBytes) {
	            words = this.words = words || [];

	            if (sigBytes != undefined) {
	                this.sigBytes = sigBytes;
	            } else {
	                this.sigBytes = words.length * 4;
	            }
	        },

	        /**
	         * Converts this word array to a string.
	         *
	         * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex
	         *
	         * @return {string} The stringified word array.
	         *
	         * @example
	         *
	         *     var string = wordArray + '';
	         *     var string = wordArray.toString();
	         *     var string = wordArray.toString(CryptoJS.enc.Utf8);
	         */
	        toString: function (encoder) {
	            return (encoder || Hex).stringify(this);
	        },

	        /**
	         * Concatenates a word array to this word array.
	         *
	         * @param {WordArray} wordArray The word array to append.
	         *
	         * @return {WordArray} This word array.
	         *
	         * @example
	         *
	         *     wordArray1.concat(wordArray2);
	         */
	        concat: function (wordArray) {
	            // Shortcuts
	            var thisWords = this.words;
	            var thatWords = wordArray.words;
	            var thisSigBytes = this.sigBytes;
	            var thatSigBytes = wordArray.sigBytes;

	            // Clamp excess bits
	            this.clamp();

	            // Concat
	            if (thisSigBytes % 4) {
	                // Copy one byte at a time
	                for (var i = 0; i < thatSigBytes; i++) {
	                    var thatByte = (thatWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
	                    thisWords[(thisSigBytes + i) >>> 2] |= thatByte << (24 - ((thisSigBytes + i) % 4) * 8);
	                }
	            } else {
	                // Copy one word at a time
	                for (var i = 0; i < thatSigBytes; i += 4) {
	                    thisWords[(thisSigBytes + i) >>> 2] = thatWords[i >>> 2];
	                }
	            }
	            this.sigBytes += thatSigBytes;

	            // Chainable
	            return this;
	        },

	        /**
	         * Removes insignificant bits.
	         *
	         * @example
	         *
	         *     wordArray.clamp();
	         */
	        clamp: function () {
	            // Shortcuts
	            var words = this.words;
	            var sigBytes = this.sigBytes;

	            // Clamp
	            words[sigBytes >>> 2] &= 0xffffffff << (32 - (sigBytes % 4) * 8);
	            words.length = Math.ceil(sigBytes / 4);
	        },

	        /**
	         * Creates a copy of this word array.
	         *
	         * @return {WordArray} The clone.
	         *
	         * @example
	         *
	         *     var clone = wordArray.clone();
	         */
	        clone: function () {
	            var clone = Base.clone.call(this);
	            clone.words = this.words.slice(0);

	            return clone;
	        },

	        /**
	         * Creates a word array filled with random bytes.
	         *
	         * @param {number} nBytes The number of random bytes to generate.
	         *
	         * @return {WordArray} The random word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.lib.WordArray.random(16);
	         */
	        random: function (nBytes) {
	            var words = [];

	            var r = (function (m_w) {
	                var m_w = m_w;
	                var m_z = 0x3ade68b1;
	                var mask = 0xffffffff;

	                return function () {
	                    m_z = (0x9069 * (m_z & 0xFFFF) + (m_z >> 0x10)) & mask;
	                    m_w = (0x4650 * (m_w & 0xFFFF) + (m_w >> 0x10)) & mask;
	                    var result = ((m_z << 0x10) + m_w) & mask;
	                    result /= 0x100000000;
	                    result += 0.5;
	                    return result * (Math.random() > .5 ? 1 : -1);
	                }
	            });

	            for (var i = 0, rcache; i < nBytes; i += 4) {
	                var _r = r((rcache || Math.random()) * 0x100000000);

	                rcache = _r() * 0x3ade67b7;
	                words.push((_r() * 0x100000000) | 0);
	            }

	            return new WordArray.init(words, nBytes);
	        }
	    });

	    /**
	     * Encoder namespace.
	     */
	    var C_enc = C.enc = {};

	    /**
	     * Hex encoding strategy.
	     */
	    var Hex = C_enc.Hex = {
	        /**
	         * Converts a word array to a hex string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The hex string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;

	            // Convert
	            var hexChars = [];
	            for (var i = 0; i < sigBytes; i++) {
	                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
	                hexChars.push((bite >>> 4).toString(16));
	                hexChars.push((bite & 0x0f).toString(16));
	            }

	            return hexChars.join('');
	        },

	        /**
	         * Converts a hex string to a word array.
	         *
	         * @param {string} hexStr The hex string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Hex.parse(hexString);
	         */
	        parse: function (hexStr) {
	            // Shortcut
	            var hexStrLength = hexStr.length;

	            // Convert
	            var words = [];
	            for (var i = 0; i < hexStrLength; i += 2) {
	                words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << (24 - (i % 8) * 4);
	            }

	            return new WordArray.init(words, hexStrLength / 2);
	        }
	    };

	    /**
	     * Latin1 encoding strategy.
	     */
	    var Latin1 = C_enc.Latin1 = {
	        /**
	         * Converts a word array to a Latin1 string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The Latin1 string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;

	            // Convert
	            var latin1Chars = [];
	            for (var i = 0; i < sigBytes; i++) {
	                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
	                latin1Chars.push(String.fromCharCode(bite));
	            }

	            return latin1Chars.join('');
	        },

	        /**
	         * Converts a Latin1 string to a word array.
	         *
	         * @param {string} latin1Str The Latin1 string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);
	         */
	        parse: function (latin1Str) {
	            // Shortcut
	            var latin1StrLength = latin1Str.length;

	            // Convert
	            var words = [];
	            for (var i = 0; i < latin1StrLength; i++) {
	                words[i >>> 2] |= (latin1Str.charCodeAt(i) & 0xff) << (24 - (i % 4) * 8);
	            }

	            return new WordArray.init(words, latin1StrLength);
	        }
	    };

	    /**
	     * UTF-8 encoding strategy.
	     */
	    var Utf8 = C_enc.Utf8 = {
	        /**
	         * Converts a word array to a UTF-8 string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The UTF-8 string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            try {
	                return decodeURIComponent(escape(Latin1.stringify(wordArray)));
	            } catch (e) {
	                throw new Error('Malformed UTF-8 data');
	            }
	        },

	        /**
	         * Converts a UTF-8 string to a word array.
	         *
	         * @param {string} utf8Str The UTF-8 string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);
	         */
	        parse: function (utf8Str) {
	            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
	        }
	    };

	    /**
	     * Abstract buffered block algorithm template.
	     *
	     * The property blockSize must be implemented in a concrete subtype.
	     *
	     * @property {number} _minBufferSize The number of blocks that should be kept unprocessed in the buffer. Default: 0
	     */
	    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({
	        /**
	         * Resets this block algorithm's data buffer to its initial state.
	         *
	         * @example
	         *
	         *     bufferedBlockAlgorithm.reset();
	         */
	        reset: function () {
	            // Initial values
	            this._data = new WordArray.init();
	            this._nDataBytes = 0;
	        },

	        /**
	         * Adds new data to this block algorithm's buffer.
	         *
	         * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.
	         *
	         * @example
	         *
	         *     bufferedBlockAlgorithm._append('data');
	         *     bufferedBlockAlgorithm._append(wordArray);
	         */
	        _append: function (data) {
	            // Convert string to WordArray, else assume WordArray already
	            if (typeof data == 'string') {
	                data = Utf8.parse(data);
	            }

	            // Append
	            this._data.concat(data);
	            this._nDataBytes += data.sigBytes;
	        },

	        /**
	         * Processes available data blocks.
	         *
	         * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.
	         *
	         * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.
	         *
	         * @return {WordArray} The processed data.
	         *
	         * @example
	         *
	         *     var processedData = bufferedBlockAlgorithm._process();
	         *     var processedData = bufferedBlockAlgorithm._process(!!'flush');
	         */
	        _process: function (doFlush) {
	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;
	            var dataSigBytes = data.sigBytes;
	            var blockSize = this.blockSize;
	            var blockSizeBytes = blockSize * 4;

	            // Count blocks ready
	            var nBlocksReady = dataSigBytes / blockSizeBytes;
	            if (doFlush) {
	                // Round up to include partial blocks
	                nBlocksReady = Math.ceil(nBlocksReady);
	            } else {
	                // Round down to include only full blocks,
	                // less the number of blocks that must remain in the buffer
	                nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);
	            }

	            // Count words ready
	            var nWordsReady = nBlocksReady * blockSize;

	            // Count bytes ready
	            var nBytesReady = Math.min(nWordsReady * 4, dataSigBytes);

	            // Process blocks
	            if (nWordsReady) {
	                for (var offset = 0; offset < nWordsReady; offset += blockSize) {
	                    // Perform concrete-algorithm logic
	                    this._doProcessBlock(dataWords, offset);
	                }

	                // Remove processed words
	                var processedWords = dataWords.splice(0, nWordsReady);
	                data.sigBytes -= nBytesReady;
	            }

	            // Return processed words
	            return new WordArray.init(processedWords, nBytesReady);
	        },

	        /**
	         * Creates a copy of this object.
	         *
	         * @return {Object} The clone.
	         *
	         * @example
	         *
	         *     var clone = bufferedBlockAlgorithm.clone();
	         */
	        clone: function () {
	            var clone = Base.clone.call(this);
	            clone._data = this._data.clone();

	            return clone;
	        },

	        _minBufferSize: 0
	    });

	    /**
	     * Abstract hasher template.
	     *
	     * @property {number} blockSize The number of 32-bit words this hasher operates on. Default: 16 (512 bits)
	     */
	    var Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({
	        /**
	         * Configuration options.
	         */
	        cfg: Base.extend(),

	        /**
	         * Initializes a newly created hasher.
	         *
	         * @param {Object} cfg (Optional) The configuration options to use for this hash computation.
	         *
	         * @example
	         *
	         *     var hasher = CryptoJS.algo.SHA256.create();
	         */
	        init: function (cfg) {
	            // Apply config defaults
	            this.cfg = this.cfg.extend(cfg);

	            // Set initial values
	            this.reset();
	        },

	        /**
	         * Resets this hasher to its initial state.
	         *
	         * @example
	         *
	         *     hasher.reset();
	         */
	        reset: function () {
	            // Reset data buffer
	            BufferedBlockAlgorithm.reset.call(this);

	            // Perform concrete-hasher logic
	            this._doReset();
	        },

	        /**
	         * Updates this hasher with a message.
	         *
	         * @param {WordArray|string} messageUpdate The message to append.
	         *
	         * @return {Hasher} This hasher.
	         *
	         * @example
	         *
	         *     hasher.update('message');
	         *     hasher.update(wordArray);
	         */
	        update: function (messageUpdate) {
	            // Append
	            this._append(messageUpdate);

	            // Update the hash
	            this._process();

	            // Chainable
	            return this;
	        },

	        /**
	         * Finalizes the hash computation.
	         * Note that the finalize operation is effectively a destructive, read-once operation.
	         *
	         * @param {WordArray|string} messageUpdate (Optional) A final message update.
	         *
	         * @return {WordArray} The hash.
	         *
	         * @example
	         *
	         *     var hash = hasher.finalize();
	         *     var hash = hasher.finalize('message');
	         *     var hash = hasher.finalize(wordArray);
	         */
	        finalize: function (messageUpdate) {
	            // Final message update
	            if (messageUpdate) {
	                this._append(messageUpdate);
	            }

	            // Perform concrete-hasher logic
	            var hash = this._doFinalize();

	            return hash;
	        },

	        blockSize: 512/32,

	        /**
	         * Creates a shortcut function to a hasher's object interface.
	         *
	         * @param {Hasher} hasher The hasher to create a helper for.
	         *
	         * @return {Function} The shortcut function.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);
	         */
	        _createHelper: function (hasher) {
	            return function (message, cfg) {
	                return new hasher.init(cfg).finalize(message);
	            };
	        },

	        /**
	         * Creates a shortcut function to the HMAC's object interface.
	         *
	         * @param {Hasher} hasher The hasher to use in this HMAC helper.
	         *
	         * @return {Function} The shortcut function.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);
	         */
	        _createHmacHelper: function (hasher) {
	            return function (message, key) {
	                return new C_algo.HMAC.init(hasher, key).finalize(message);
	            };
	        }
	    });

	    /**
	     * Algorithm namespace.
	     */
	    var C_algo = C.algo = {};

	    return C;
	}(Math));


	return CryptoJS;

}));
;(function (root, factory) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function (Math) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var Hasher = C_lib.Hasher;
	    var C_algo = C.algo;

	    // Constants table
	    var T = [];

	    // Compute constants
	    (function () {
	        for (var i = 0; i < 64; i++) {
	            T[i] = (Math.abs(Math.sin(i + 1)) * 0x100000000) | 0;
	        }
	    }());

	    /**
	     * MD5 hash algorithm.
	     */
	    var MD5 = C_algo.MD5 = Hasher.extend({
	        _doReset: function () {
	            this._hash = new WordArray.init([
	                0x67452301, 0xefcdab89,
	                0x98badcfe, 0x10325476
	            ]);
	        },

	        _doProcessBlock: function (M, offset) {
	            // Swap endian
	            for (var i = 0; i < 16; i++) {
	                // Shortcuts
	                var offset_i = offset + i;
	                var M_offset_i = M[offset_i];

	                M[offset_i] = (
	                    (((M_offset_i << 8)  | (M_offset_i >>> 24)) & 0x00ff00ff) |
	                    (((M_offset_i << 24) | (M_offset_i >>> 8))  & 0xff00ff00)
	                );
	            }

	            // Shortcuts
	            var H = this._hash.words;

	            var M_offset_0  = M[offset + 0];
	            var M_offset_1  = M[offset + 1];
	            var M_offset_2  = M[offset + 2];
	            var M_offset_3  = M[offset + 3];
	            var M_offset_4  = M[offset + 4];
	            var M_offset_5  = M[offset + 5];
	            var M_offset_6  = M[offset + 6];
	            var M_offset_7  = M[offset + 7];
	            var M_offset_8  = M[offset + 8];
	            var M_offset_9  = M[offset + 9];
	            var M_offset_10 = M[offset + 10];
	            var M_offset_11 = M[offset + 11];
	            var M_offset_12 = M[offset + 12];
	            var M_offset_13 = M[offset + 13];
	            var M_offset_14 = M[offset + 14];
	            var M_offset_15 = M[offset + 15];

	            // Working varialbes
	            var a = H[0];
	            var b = H[1];
	            var c = H[2];
	            var d = H[3];

	            // Computation
	            a = FF(a, b, c, d, M_offset_0,  7,  T[0]);
	            d = FF(d, a, b, c, M_offset_1,  12, T[1]);
	            c = FF(c, d, a, b, M_offset_2,  17, T[2]);
	            b = FF(b, c, d, a, M_offset_3,  22, T[3]);
	            a = FF(a, b, c, d, M_offset_4,  7,  T[4]);
	            d = FF(d, a, b, c, M_offset_5,  12, T[5]);
	            c = FF(c, d, a, b, M_offset_6,  17, T[6]);
	            b = FF(b, c, d, a, M_offset_7,  22, T[7]);
	            a = FF(a, b, c, d, M_offset_8,  7,  T[8]);
	            d = FF(d, a, b, c, M_offset_9,  12, T[9]);
	            c = FF(c, d, a, b, M_offset_10, 17, T[10]);
	            b = FF(b, c, d, a, M_offset_11, 22, T[11]);
	            a = FF(a, b, c, d, M_offset_12, 7,  T[12]);
	            d = FF(d, a, b, c, M_offset_13, 12, T[13]);
	            c = FF(c, d, a, b, M_offset_14, 17, T[14]);
	            b = FF(b, c, d, a, M_offset_15, 22, T[15]);

	            a = GG(a, b, c, d, M_offset_1,  5,  T[16]);
	            d = GG(d, a, b, c, M_offset_6,  9,  T[17]);
	            c = GG(c, d, a, b, M_offset_11, 14, T[18]);
	            b = GG(b, c, d, a, M_offset_0,  20, T[19]);
	            a = GG(a, b, c, d, M_offset_5,  5,  T[20]);
	            d = GG(d, a, b, c, M_offset_10, 9,  T[21]);
	            c = GG(c, d, a, b, M_offset_15, 14, T[22]);
	            b = GG(b, c, d, a, M_offset_4,  20, T[23]);
	            a = GG(a, b, c, d, M_offset_9,  5,  T[24]);
	            d = GG(d, a, b, c, M_offset_14, 9,  T[25]);
	            c = GG(c, d, a, b, M_offset_3,  14, T[26]);
	            b = GG(b, c, d, a, M_offset_8,  20, T[27]);
	            a = GG(a, b, c, d, M_offset_13, 5,  T[28]);
	            d = GG(d, a, b, c, M_offset_2,  9,  T[29]);
	            c = GG(c, d, a, b, M_offset_7,  14, T[30]);
	            b = GG(b, c, d, a, M_offset_12, 20, T[31]);

	            a = HH(a, b, c, d, M_offset_5,  4,  T[32]);
	            d = HH(d, a, b, c, M_offset_8,  11, T[33]);
	            c = HH(c, d, a, b, M_offset_11, 16, T[34]);
	            b = HH(b, c, d, a, M_offset_14, 23, T[35]);
	            a = HH(a, b, c, d, M_offset_1,  4,  T[36]);
	            d = HH(d, a, b, c, M_offset_4,  11, T[37]);
	            c = HH(c, d, a, b, M_offset_7,  16, T[38]);
	            b = HH(b, c, d, a, M_offset_10, 23, T[39]);
	            a = HH(a, b, c, d, M_offset_13, 4,  T[40]);
	            d = HH(d, a, b, c, M_offset_0,  11, T[41]);
	            c = HH(c, d, a, b, M_offset_3,  16, T[42]);
	            b = HH(b, c, d, a, M_offset_6,  23, T[43]);
	            a = HH(a, b, c, d, M_offset_9,  4,  T[44]);
	            d = HH(d, a, b, c, M_offset_12, 11, T[45]);
	            c = HH(c, d, a, b, M_offset_15, 16, T[46]);
	            b = HH(b, c, d, a, M_offset_2,  23, T[47]);

	            a = II(a, b, c, d, M_offset_0,  6,  T[48]);
	            d = II(d, a, b, c, M_offset_7,  10, T[49]);
	            c = II(c, d, a, b, M_offset_14, 15, T[50]);
	            b = II(b, c, d, a, M_offset_5,  21, T[51]);
	            a = II(a, b, c, d, M_offset_12, 6,  T[52]);
	            d = II(d, a, b, c, M_offset_3,  10, T[53]);
	            c = II(c, d, a, b, M_offset_10, 15, T[54]);
	            b = II(b, c, d, a, M_offset_1,  21, T[55]);
	            a = II(a, b, c, d, M_offset_8,  6,  T[56]);
	            d = II(d, a, b, c, M_offset_15, 10, T[57]);
	            c = II(c, d, a, b, M_offset_6,  15, T[58]);
	            b = II(b, c, d, a, M_offset_13, 21, T[59]);
	            a = II(a, b, c, d, M_offset_4,  6,  T[60]);
	            d = II(d, a, b, c, M_offset_11, 10, T[61]);
	            c = II(c, d, a, b, M_offset_2,  15, T[62]);
	            b = II(b, c, d, a, M_offset_9,  21, T[63]);

	            // Intermediate hash value
	            H[0] = (H[0] + a) | 0;
	            H[1] = (H[1] + b) | 0;
	            H[2] = (H[2] + c) | 0;
	            H[3] = (H[3] + d) | 0;
	        },

	        _doFinalize: function () {
	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;

	            var nBitsTotal = this._nDataBytes * 8;
	            var nBitsLeft = data.sigBytes * 8;

	            // Add padding
	            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);

	            var nBitsTotalH = Math.floor(nBitsTotal / 0x100000000);
	            var nBitsTotalL = nBitsTotal;
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = (
	                (((nBitsTotalH << 8)  | (nBitsTotalH >>> 24)) & 0x00ff00ff) |
	                (((nBitsTotalH << 24) | (nBitsTotalH >>> 8))  & 0xff00ff00)
	            );
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = (
	                (((nBitsTotalL << 8)  | (nBitsTotalL >>> 24)) & 0x00ff00ff) |
	                (((nBitsTotalL << 24) | (nBitsTotalL >>> 8))  & 0xff00ff00)
	            );

	            data.sigBytes = (dataWords.length + 1) * 4;

	            // Hash final blocks
	            this._process();

	            // Shortcuts
	            var hash = this._hash;
	            var H = hash.words;

	            // Swap endian
	            for (var i = 0; i < 4; i++) {
	                // Shortcut
	                var H_i = H[i];

	                H[i] = (((H_i << 8)  | (H_i >>> 24)) & 0x00ff00ff) |
	                       (((H_i << 24) | (H_i >>> 8))  & 0xff00ff00);
	            }

	            // Return final computed hash
	            return hash;
	        },

	        clone: function () {
	            var clone = Hasher.clone.call(this);
	            clone._hash = this._hash.clone();

	            return clone;
	        }
	    });

	    function FF(a, b, c, d, x, s, t) {
	        var n = a + ((b & c) | (~b & d)) + x + t;
	        return ((n << s) | (n >>> (32 - s))) + b;
	    }

	    function GG(a, b, c, d, x, s, t) {
	        var n = a + ((b & d) | (c & ~d)) + x + t;
	        return ((n << s) | (n >>> (32 - s))) + b;
	    }

	    function HH(a, b, c, d, x, s, t) {
	        var n = a + (b ^ c ^ d) + x + t;
	        return ((n << s) | (n >>> (32 - s))) + b;
	    }

	    function II(a, b, c, d, x, s, t) {
	        var n = a + (c ^ (b | ~d)) + x + t;
	        return ((n << s) | (n >>> (32 - s))) + b;
	    }

	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.MD5('message');
	     *     var hash = CryptoJS.MD5(wordArray);
	     */
	    C.MD5 = Hasher._createHelper(MD5);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacMD5(message, key);
	     */
	    C.HmacMD5 = Hasher._createHmacHelper(MD5);
	}(Math));


	return CryptoJS.MD5;

}));
(function ($) {
  this.Specto = this.Specto || {};
  this.Specto.ui = this.Specto.ui || {};
  var ns = this.Specto.ui; //name space

  //If is called directly, it is considered function,
  //else , if is defined as (new), it is considered a class
  ns.PubliclyAdvertisedViewer = function () {
    var defaults = {
      isReadOnly: false,
      item: {}
    };

    //Constructor
    function PubliclyAdvertisedViewer(options) {
      //options.isReadOnly = options.isReadOnly || false;
      this.options = $.extend(false, {}, defaults, options);

      //this._init();
      init.call(this);
    };

    //#region _____________________ Private Methods _____________________

    var init = function () {

    };
    var renderItemDetails = function (item, container, index) {
      var itemName;
      if (item.name) {
        itemName = item.name;
      }
      else {
        itemName = `${item.type} #${index + 1}`;
      }
      var cardDiv = $('<div class="card mb-1">').appendTo(container);
      var cardHeader = $(`<div class="card-header" data-toggle="collapse" href="#${item._id2}"
        style="padding: 10px 15px 10px 15px; background:white !important"></div>`)
        .appendTo(cardDiv);
      var rowHeader = $('<div class="row">').appendTo(cardHeader);
      var col9 = $('<div class="col-lg-8">').appendTo(rowHeader);
      var col3 = $('<div class="col-lg-4">').appendTo(rowHeader);
      var cardLink = $(`<a class="card-link" style="font-size: 18px;">${itemName}</a>`).appendTo(col9);
      var cardCollapse = $(`<div id="${item._id2}" class="collapse show"></div>`).appendTo(cardDiv);
      if (item.description) {
        $(`<span style="font-size: 14px;">: ${item.description}</span>`).appendTo(cardLink);
      }
      if (item.Photos && item.Photos.length > 0) {
        var cardBody = $(`<div class="card-body pt-0 pl-4">`).appendTo(cardCollapse);
        var rowPhotosDiv = $('<div class="row">').appendTo(cardBody);
        // if (WIRE.d(item.Photos[0]).picture) {
        //   $(`<img class="mr-2" src="${WIRE.d(item.Photos[0]).picture}" style="width:100%; height: 200px" />`)
        //   .appendTo(rowPhotosDiv);
        // }
        var gallery = $(`<div class="lightgallery" style="display: flex; 
          overflow: auto; width: 1072px;">`).appendTo(rowPhotosDiv);
        $.each(item.Photos, function (index, value) {
          if (WIRE.d(value).picture)
            $(`<a href="${WIRE.d(value).picture}"><img class="mr-2 mt-2" src="${WIRE.d(value).picture}" style="height: 225px; 
              width: 320px; border-radius: 1px; cursor: pointer"/></a>`)
              .appendTo(gallery);
        });
      }
      if (item.Beds && item.Beds.length) {
        $(`<span class="text-primary ml-1 float-right"
          style="padding: 8px 5px 6px 6px; font-size: 13px;">
          <i class="fal fa-bed" style="font-size: 18px"></i> ${item.Beds.length} Bed${item.Beds.length == 1 ? '' : 's'}</span>`)
          .appendTo(col3);
      }
      if (item.balcony && item.balcony == 'Yes') {
        $(`<span class="text-primary ml-1 float-right"
          style="padding: 6px 5px 6px 6px; font-size: 13px;">
          <i class="kr-ico-balcony" style="font-size: 15px"></i> Balcony</span>`)
          .appendTo(col3);
      }
      if (item.square_area && item.square_area.value) {
        $(`<span class="text-primary ml-1 float-right"
          style="padding: 6px 5px 6px 6px; font-size: 13px;">
          <i class="kr-ico-square-area" style="font-size: 15px"></i> ${item.square_area.value} sqft</span>`)
          .appendTo(col3);
      }
    };

    //#endregion _____________________ Private Methods _____________________

    //#region ______________ Public Method ______________

    PubliclyAdvertisedViewer.prototype.renderOn = function (container) {
      const account = WIRE.data['account'] ? WIRE.d(WIRE.data['account']) : null;
      var minWidth550 = window.matchMedia('(min-width: 550px)').matches;
      if (minWidth550)
        container.addClass('card');
      else
        container.removeClass('container');
      var item = this.options.item;
      var schemaFields = this.options.itemSchema ? this.options.itemSchema.fields : [];

      var itemId;
      var item_id;
      if(this.options.item_id) {
        itemId = this.options.item_id.split(':')[1];
        item_id = this.options.item_id.replace(':', '_');
      } else if(item._id) {
        itemId = item._id.split(':')[1];
        item_id = item._id.replace(':', '_');
      }
      //var offerSummary = this.options.offerSummary;
      getItemFieldsAndSubFields(schemaFields, item.type);

      //#region Item Details (Left Div)

      var contactName = this.options.contactName;
      var contactPhone = this.options.contactPhone;
      var contactEmail = this.options.contactEmail;
      var contactAddress = this.options.contactAddress;
      var contactWhatsappNumber = this.options.contactWhatsappNumber;
      var listingAgentEmail = this.options.listingAgentEmail;
      var listingAgentName = this.options.listingAgentName;
      var listingAgentPhone = this.options.listingAgentPhone;
      var proItemNumber = this.options.proItemNumber;
      var hasContactInfo = contactName || contactPhone || contactEmail ||
        contactAddress || contactWhatsappNumber || proItemNumber;
      var row = $('<div>').addClass('row');
      if (hasContactInfo) {
        row.appendTo(container);
      }
      // tabs div
      var tabsContainer = $('<div>').addClass(hasContactInfo ? 'col-lg-9 col-md-9 col-sm-12 col-xs-12 mt-3' : 'mt-3')
        .appendTo(hasContactInfo ? row : container);
      var modalDom;
      var modalBody;
      if (minWidth550) {
        var tabsList = $('<ul role="tablist">').addClass('nav nav-tabs')
          .appendTo(tabsContainer);
        var tabsContent = $('<div>').addClass('tab-content border border-top-0 p-3')
          .appendTo(tabsContainer);
      }
      else {
        modalDom = $(`<div class="modal" aria-hidden="true">
          <div class="modal-dialog">
            <div class="modal-content">
              <div class="modal-header" style="background: white; box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.25);">
                <h5 class="h4 mb-0 text-primary modal-subtitle">{0}</h5>
                <span class="close-modal-btn"><i class="fa fa-times text-primary mt-1" style="font-size: 18px;"></i></span>
              </div>
              <div class="modal-body">
              </div>
            </div>
          </div>
        </div>`).appendTo(tabsContainer);
        modalDom.find('.close-modal-btn').click(function () {
          modalDom.removeClass('show').css('display', 'none');
        });
        modalBody = modalDom.find('.modal-subtitle')[0];
      };
      //#region Inquiry (Right Dom)
      if (hasContactInfo) {
        var inquiryDiv = $('<div>')
          .addClass('col-lg-3 col-md-3 col-sm-12 col-xs-12 p-2')
          .appendTo(row);
        // $(`<div class="box-container" style="padding: 5px; display: grid; margin-bottom: 3px"></div>`).appendTo(inquiryDiv)
        //  .append($('<span>').addClass("text-center").html('<i class="fa fa-key mr-2" aria-hidden="true"></i>Property ID'));
        var gridDiv = $(`<div class="d-grid text-center" style="display: grid;"></div>`).appendTo(inquiryDiv)
          .append($('<h2 class="text-dark text-center" style="word-break: break-all;">').html("")); //itemId
        $('<img class="mx-auto" style="width: 100%; max-width: 200px">').attr('src', this.options.listing_logo ?
          this.options.listing_logo : "img/logo.png")
          .appendTo(gridDiv);
        $(`<div class="box-container my-2" style="padding: 5px; display: grid; margin-bottom: 3px"></div>`).appendTo(inquiryDiv)
          .append($('<span>').addClass("text-center").html('<i class="fa fa-phone mr-2" aria-hidden="true"></i>Contact Info'));
        var formGroup = $('<div>')
          .addClass('px-2')
          .appendTo(inquiryDiv);
        // Contact name
        if (contactName) {
          $(`<a class="d-block fs-lg fw-400 text-dark">
            <i class="fa fa-user text-muted mr-2"></i>${contactName}</a>`)
            .appendTo(formGroup);
        }
        // Contact phone number
        if (contactPhone) {
          $(`<a href="tel:${contactPhone}" class="mt-1 d-block fs-lg fw-400 text-dark">
            <i class="fa fa-mobile text-muted mr-2"></i>${contactPhone}</a>`)
            .appendTo(formGroup);
        }
        // Contact whatsapp number
        if (contactWhatsappNumber) {
          $(`<a href="https://wa.me/${contactWhatsappNumber.replaceAll('+', '').replaceAll('-', '')}" target="_blank" class="mt-1 d-block fs-lg fw-400 text-dark"  style="text-decoration: none !important;">
            <i class="fa fa-whatsapp text-muted mr-2"></i>${contactWhatsappNumber}</a>`)
            .appendTo(formGroup);
        }
        // Contact email
        if (contactEmail) {
          $(`<a href="mailto:${contactEmail}" class="mt-1 d-block fs-lg fw-400 text-dark">
            <i class="fa fa-envelope text-muted mr-2"></i>${contactEmail}</a>`)
            .appendTo(formGroup);
        }
        // Contact address
        if (contactAddress) {
          $(`<address class="fs-lg fw-400 mt-2 mb-0 text-muted">
            <i class="fa fa-map-pin mr-2"></i>${contactAddress.address}</address>`)
            .appendTo(formGroup);
        }
        // item pro number
        if (proItemNumber) {
          $(`<a class="mt-1 d-block fs-lg fw-400 text-dark">
            <i class="fa fa-building-o text-muted mr-2"></i>${proItemNumber}</a>`)
            .appendTo(formGroup);
        }

        let hasListingAgentInfo = listingAgentEmail || listingAgentName || listingAgentPhone;

        if(hasListingAgentInfo) {
          $(`<div class="box-container my-2" style="padding: 5px; display: grid; margin-bottom: 3px"></div>`).appendTo(inquiryDiv)
              .append($('<span>').addClass("text-center").html('<i class="fa fa-phone mr-2" aria-hidden="true"></i>Listing Agent'));
        }

        if(hasListingAgentInfo) {
          var $listingAgent = $(`<div class="px-2"></div>`)
              .appendTo(inquiryDiv)
              .append($('<span>').addClass("text-center"));

          if (listingAgentEmail) {
            $(`<a class="mt-1 d-block fs-lg fw-400 text-dark">${listingAgentEmail}</a>`)
                .appendTo($listingAgent);
          }

          if (listingAgentName) {
            $(`<a class="mt-1 d-block fs-lg fw-400 text-dark">${listingAgentName}</a>`)
                .appendTo($listingAgent);
          }

          if (listingAgentPhone) {
            $(`<a class="mt-1 d-block fs-lg fw-400 text-dark">${listingAgentPhone}</a>`)
                .appendTo($listingAgent);
          }
        }

        var priceList = [];
        // Render item's price list
        if (item['yearly_rent_value'] && item['yearly_rent_value']['value']) {
          var yearlyValue = item['yearly_rent_value']['value'];
          var currency = item['yearly_rent_value']['currency'] || 'AED';

          (item['rent_payments'] || []).forEach(payment => {
            var frequency = payment['frequency'];
            var amount = yearlyValue;
            if (payment['amount_type'] == 'specified_amount') {
              amount = payment['more_than_annual'];
            } else if (payment['amount_type'] == 'fixed_more') {
              amount += payment['more_than_annual'];
            } else if (payment['amount_type'] == 'percent_more') {
              amount *= 1 + (payment['more_than_annual'] / 100.0);
            }

            var frequencyIndex = 1;
            if (frequency == 'quarter') {
              amount = payment['amount_type'] != 'specified_amount' ? Math.round(amount / 4) : amount;
              frequencyIndex = 2;
            } else if (frequency == 'month') {
              amount = payment['amount_type'] != 'specified_amount' ? Math.round(amount / 12) : amount;
              frequencyIndex = 3;
            } else if (frequency == 'day') {
              amount = payment['amount_type'] != 'specified_amount' ? Math.round(amount / 365) : amount;
              frequencyIndex = 4;
            }

            if (amount) {
              priceList.push({ 'amount': amount, 'currency': currency, 'frequency': frequency, 'frequencyIndex': frequencyIndex });
            }
          });
          priceList.sort((a, b) => (a.frequencyIndex > b.frequencyIndex) ? 1 : -1);
        }
        const titleRow = $(`
        <div class="media title-row row no-gutters mb-2">
          <div class="media-body ${priceList.length > 0 ? 'col-xl-8 col-lg-8 col-md-8 col-sm-12' : 'col-12'}">
            <div class="row no-gutters">
              <h3 class="property-title text-primary mb-1">${item.name}</h3>
            </div>
            <div class="mb-1 text-dark" style="font-size: 15px;">
              <i class="fal fa-map-marker-alt text-primary mr-1"></i>
              <span>${item.address ? item.address.address : ""}</span>
            </div>
          </div>
        </div>`).prependTo(tabsContainer);
        if (account) {
          WIRE.call('business::get_favorites', { 'desc': false }, function (response) {
            var items = response.list;
            (items || []).forEach(function (item) {
              // var itemObj = WIRE.d(item['o']);
              const itemIcon = container.find(`.wishlist-icon[_id="${item['o']}"]`);
              if (itemIcon.length) {
                Utils.setWishList(itemIcon, item['o'], account, container, true);
              }
            });
          });
        }
      }

      if (item.Photos && item.Photos.length > 0) {
        var photosContainer = $('<div class="details-mobile-carousel mb-2 parent-grid"></div>').prependTo(tabsContainer);
        // var temp = "<div class='cell' style='width:{width}px; height: {height}px; background-image: url(src)'></div>";
        var temp = "<div class='details-img-gallery cursor-pointer' data-index='idx'><img src='url' onerror=(this.src='img/placeholder_keyras.png') height='100%' width='100%' style='object-fit: cover;'></div>";
        var html = '', limitItem = 6, index = 0;
        var allPhotos = item.Photos.map(function (element) {
          return {
            "src": WIRE.d(element)['picture'],
            'thumb': WIRE.d(element)['picture'], "index": index++
          }
        });
        if (item.Photos.length == 1) {
          var photoObj = WIRE.d(item.Photos[0]);
          if (photoObj && photoObj.picture) {
            var src = photoObj.picture;
            html += temp.replace("idx", 0).replace("url", src);
            photosContainer.addClass('grid-1');
          }
        } else {
          for (var i = 0; i < limitItem; i++) {
            var photoObj = WIRE.d(item.Photos[i]);
            if (photoObj && photoObj.picture) {
              var src = photoObj.picture;
              if (i == limitItem - 1 && item.Photos.length != limitItem && item.Photos.length > limitItem) {
                html += `<div class='details-img-gallery show-more-images cursor-pointer position-relative' data-index=${i}>
                      <img src='${src}' style="
                      filter: brightness(50%) saturate(140%); object-fit: cover;" height='100%' width='100%'>
                      <div class='more-images position-absolute'>+${item.Photos.length - limitItem} More</div>
                      </div>`;
              } else if (item.Photos.length > 3 && item.Photos.length < limitItem && i == 2) {
                html += `<div class='details-img-gallery show-more-images cursor-pointer position-relative' data-index=${i}>
                  <img src='${src}' style="
                  filter: brightness(50%) saturate(140%); object-fit: cover;" height='100%' width='100%'>
                  <div class='more-images position-absolute'>+${limitItem - 4} More</div>
                  </div>`;
                photosContainer.addClass('grid-3');
                break;
              }
              else if (item.Photos.length < 3 && i == 1) {
                html += temp.replace("idx", i.toString()).replace("url", src);
                photosContainer.addClass('grid-2');
                break;
              }
              else if (item.Photos.length < limitItem && i == 2 && item.Photos.length == 3) {
                html += temp.replace("idx", i.toString()).replace("url", src);
                photosContainer.addClass('grid-3');
                break;
              }
              else {
                html += temp.replace("idx", i.toString()).replace("url", src);
              }
            }
          }
        }
        photosContainer.html(html);
        $(photosContainer).find('.details-img-gallery').on('click', function () {
          var idx = $(this).attr('data-index');
          $(this).lightGallery({
            thumbnail: true,
            index: idx,
            dynamic: true,
            dynamicEl: allPhotos,
            escKey: true,
            keyPress: true,
            hash: false
          })
        });
      }

      var listRow = $(`<div class="${priceList && priceList.length > 0? "mb-1 col-xl-4 col-lg-4 col-md-4 col-sm-12": ""}><h1 class="subheader-title"></h1></div>`).appendTo(tabsContainer.find('.title-row'));
      var priceContainer = $('<div class="price-hdr">')
        .appendTo(listRow);
      if (priceList && priceList.length > 0) {
        var priceSpan = $('<p>').addClass('price-span mb-2 text-primary').css('font-size', '20px').attr("id", itemId)
          .appendTo(priceContainer);
        if (priceList.length > 1) {
          var priceFrequenciesContainer = $(`<div class="btn-xs px-0 btn-group btn-group-toggle btn-group-xs mb-2" data-toggle="buttons" style="z-index:18; display: flex"></div>`)
            .appendTo(priceContainer);
          (priceList || []).forEach(function (price, index) {
            // Activate/Select the first frquency label.
            if (index == 0) {
              var priceLabel = price.amount.toLocaleString() + ' ' + price.currency.toUpperCase() + ' / ' + price.frequency.titleCase();
              priceSpan.html(`<i class="fa fa-tag mr-1" style="font-size: 15px;"></i>${priceLabel}`);
            }

            var frequencyLabel = $(`<label class="btn ${index == 0 ? 'bg-primary-400 active' : ''} btn-xs" id=${price.frequency.titleCase()}>
                <input type="radio" name="options"> ${price.frequency.titleCase()}
              </label>`)
              .css(index == 0 ? { 'box-shadow': '0 0 0 0.1rem rgba(154,128,192,.5)', 'background-color': '' } :
                { 'box-shadow': '', 'background-color': '#d6d6d6' })
              .appendTo(priceFrequenciesContainer);

            frequencyLabel.on('click', function () {
              var priceLabel = price.amount.toLocaleString() + ' ' + price.currency.toUpperCase() + ' / ' + price.frequency.titleCase();
              // Find price span related to the current property item, to update its price label
              $(this.parentElement).siblings('.price-span')
                .html(`<i class="fa fa-tag mr-1" style="font-size: 15px;"></i>${priceLabel}`);
              // Find all 'frequencies labels' related to the current property item, to update their style.
              $(this).siblings().removeClass('bg-primary-400').css({ 'box-shadow': '', 'background-color': '#d6d6d6' });
              // Update the clicked 'frequency label' style.
              $(this).addClass('bg-primary-400').css({ 'box-shadow': '0 0 0 0.1rem rgba(154,128,192,.5)', 'background-color': '' });
            });
          });
        }
        else if (priceList.length == 1) {
          var price = priceList[0];
          var priceLabel = price.amount.toLocaleString() + ' ' + price.currency.toUpperCase() + ' / ' + price.frequency.titleCase();
          priceSpan.html(`<i class="fa fa-tag mr-1" style="font-size: 15px;"></i>${priceLabel}`);
          priceSpan.removeClass('mb-2').addClass('mb-0');
        }

        // Render value of security deposit after rendering price list
        // if (this.options.itemSecurityDeposit) {
        //   $(`<p><i class="fa fa-money mr-1"></i>Security Deposit: ${this.options.itemSecurityDeposit}</p>`)
        //     .addClass('deposit-span mb-2 text-primary')
        //     .css('font-size', '18px')
        //     .attr("id", itemId)
        //     .appendTo(priceContainer);
        // }
        //   moreInfoDiv.append(`<hr class="mb-2 mt-2" style="
        // background-color: #8c72b9;
        // border: none;
        // border-bottom: 2px solid #eee;
        // ">`);
      }
      //#endregion Inquiry (Right Div)

      var moreInfoId = 'tab_Info';
      var moreInfoTitle = '<i class="fal fa-info-circle mr-1"></i> Overview';
      var infoNavContent;
      if (minWidth550) {
        $(`
          <li class="nav-item">
            <a class="nav-link fs-lg active" data-toggle="tab" href="#${moreInfoId}" 
              role="tab" aria-selected="true">${moreInfoTitle}</a>
          </li>`).appendTo(tabsList);
        infoNavContent = $(`<div class="tab-pane active show fade" id="${moreInfoId}" role="tabpanel">`)
          .appendTo(tabsContent);
      }
      else {
        modalBody.innerHTML = moreInfoTitle;
        $(`<span class="d-block py-2 waves-effect waves-themed" style="border-top: 1px solid #e0e0e0;
            ">${moreInfoTitle}<i class="fa fa-angle-right float-right mt-1" style="font-size: 18px"></i></span>`)
          .appendTo(tabsContainer)
          .click(function () {
            modalBody.innerHTML = moreInfoTitle;
            modalDom.addClass('show').css('display', 'block');
            modalDom.find('.modal-body').find('.nav-content').hide();
            infoNavContent.show();
          });
        infoNavContent = $('<div class="nav-content">').appendTo(modalDom.find('.modal-body'));
      }
      var moreInfoDiv = $(`<div class="box-container"></div>`).appendTo(infoNavContent);

      // row no-gutters mb-2 d-flex flex-wrap  
      var amenitiesSummary = $('<div class="row no-gutters mb-2">')
        .appendTo(moreInfoDiv);

      var drawAdditionalFeature = function (icon, name, value) {
        $(`
          <div class="d-inline-flex flex-column ml-2 pl-2" style="min-width: 100px; max-width: 100px;">
              <span class="fw-300 fs-xs d-block">
                  <div class="d-flex flex-column"><span class="${icon} text-primary mr-2 mt-1" style="font-size: 19px;"></span>${name}</div>
              </span>
              <span class="fw-500 fs-xl d-block color-primary-500">
                  ${value}
              </span>
          </div>`).appendTo(amenitiesSummary);
      };
      // number of Rooms
      if (item['Rooms'] && item['Rooms'].length > 0) {
        drawAdditionalFeature('fal fa-bed', 'Rooms', item['Rooms'].length);
      } else {
        drawAdditionalFeature('fal fa-bed', 'Rooms', '-');
      }
      // number of Bathrooms
      if (item['Bathrooms'] && item['Bathrooms'].length > 0) {
        drawAdditionalFeature('fal fa-bath', 'Bathrooms', item['Bathrooms'].length);
      } else {
        drawAdditionalFeature('fal fa-bath', 'Bathrooms', '-');
      }
      // number of parkings
      if (item['number_of_parkings']) {
        drawAdditionalFeature('fal fa-car', 'Parkings', item['number_of_parkings']);
      } else {
        drawAdditionalFeature('fal fa-car', 'Parkings', '-');
      }
      //plot_number
      if (item.plot_number) {
        drawAdditionalFeature('fal fa-id-card', 'Plot Number', item.plot_number);
      }
      //utilities
      if (item.utilities) {
        drawAdditionalFeature('fal fa-wrench', 'Utilities', item.utilities);
      }
      //squared_area
      if (item['square_area'] && item['square_area']['value']) {
        drawAdditionalFeature('fal kr-ico-square-area', 'Square Area', item.square_area.value);
      } else {
        drawAdditionalFeature('fal kr-ico-square-area', 'Square Area', '-');
      }
      //view
      if (item.view) {
        drawAdditionalFeature('fal fa-eye', 'View', item.view);
      }
      //id
      if (item.itemId) {
        drawAdditionalFeature('fal fa-square', 'Id', item.itemId);
      }

      // Property Description
      if (item.description) {
        // var propertyDescHeader = $('<h2>').html("Property Description").appendTo(moreInfoDiv);
        moreInfoDiv.append(`<hr class="mb-2 mt-2" style="
        background-color: #8c72b9;
        border: none;
        border-bottom: 2px solid #eee;
        ">`);

        $(`<div id="description-details mt-2">
        <p class="content-desc ml-3" id="collapseDesc">${item.description}
        </p>
        <a role="button" class="collapsed read-text ml-3" data-toggle="collapse" href="#collapseDesc"></a>
        </div>`).appendTo(moreInfoDiv)
      }
      if( (moreInfoDiv.find('#collapseDesc').text().length <= 313) && !Utils.isMobile)
      { moreInfoDiv.find('.read-text').addClass('d-none');}
      if (item.amenities && item.amenities.length > 0) {
        moreInfoDiv.append($('<h3 class="ml-3 mt-2 text-primary" style="font-weight: 600;">')
          .html("Amenities"));
        var moreInfoSummary = $('<div class="row mt-sm-3 ml-sm-3 mt-2 ml-2">').appendTo(moreInfoDiv);

        var amenities = item.amenities.map(a => $('<div class="mb-sm-2 mb-3">')
          .html(WIRE.itemManager.amenities[a]));

        amenities.forEach(amenity => {
          amenity.addClass('mr-sm-4 mr-2 d-flex flex-column')
            .attr({ "style": "min-width: 100px; max-width: 100px; text-align: center;" });
          amenity.find("span").removeClass('fa')
            .addClass('fal').addClass('mr-1')
            .css('font-size', '21px');
          moreInfoSummary.append(amenity);
        });
      }

      if (item.address && item.address.l) {
        // Property Map
        var mapId = 'tab_map';
        var mapTitle = '<i class="fal fa-map-marker-alt mr-1"></i> Map & Street View';
        var mapNavContent;
        if (minWidth550) {
          $(`<li class="nav-item">
          <a class="nav-link fs-lg" data-toggle="tab" href="#${mapId}" 
            role="tab" aria-selected="true">${mapTitle}</a>
        </li>`).appendTo(tabsList);
          mapNavContent = $(`<div class="tab-pane fade" id="${mapId}" role="tabpanel">`)
            .appendTo(tabsContent);
        }
        else {
          modalBody.innerHTML = mapTitle;
          $(`<span class="d-block py-2 waves-effect waves-themed" style="border-top: 1px solid #e0e0e0;
            ">${mapTitle}<i class="fa fa-angle-right float-right mt-1" style="font-size: 18px"></i></span>`)
            .appendTo(tabsContainer)
            .click(function () {
              modalBody.innerHTML = mapTitle;
              modalDom.addClass('show').css('display', 'block');
              modalDom.find('.modal-body').find('.nav-content').hide();
              mapNavContent.show();
            });
          mapNavContent = $('<div class="nav-content">').appendTo(modalDom.find('.modal-body'));
        }
        var toggleMarkersDiv = $('<div id="toggleMarkersDiv">').addClass('float-right ml-2')
          .appendTo(mapNavContent);

        var propertyMapDiv = $(`<div>`).appendTo(mapNavContent);
        var itemMap = $('<div id="itemMap" style="height: 400px;">')
          .text(`${item.address.l.lat},${item.address.l.lng}`)
          .appendTo(propertyMapDiv);
        // Nearby Places
        var placesDiv = $(`<div class="box-container mt-2"></div>`).appendTo(mapNavContent)
          .append($('<h2>').html("Nearby Places"));
        $(`<div id="nearbyPlacesContainer" class="row" style="margin-right: -1.75rem; margin-left: -1.75rem;"></div>`)
          .appendTo(placesDiv);
      }
      else {
        $(`<div style="height: 400px; border: 2px dashed #c7c7c7; font-size: 30px;
          color: #c1c1c1; text-align: center; padding-top: 185px;">`).text('MAP NOT AVAILABLE')
          .appendTo(mapNavContent);
      }
      // var scrollableDiv = $('<div>') //id="pavScrollableDiv">')
      //   .appendTo(container);
      // Main Photo
      // var photoDiv = $(`<div class="box-container"></div>`).appendTo(container)
      // .append($(`<img class="jg-entry entry-visible" src="${getMainPhoto(item)}" style="width:100%; height: 100%">`));
      // More Info
      if (item.Rooms && item.Rooms.length > 0) {
        var roomsNavId = 'tab_rooms';
        var roomsNavTitle = '<i class="fal fa-bed mr-1"></i> Rooms';
        var roomsNavContent;
        if (minWidth550) {
          $(`<li class="nav-item">
              <a class="nav-link fs-lg" data-toggle="tab" href="#${roomsNavId}" 
                role="tab" aria-selected="true">${roomsNavTitle}</a>
            </li>`).appendTo(tabsList);
          roomsNavContent = $(`<div class="tab-pane fade" id="${roomsNavId}" role="tabpanel">`)
            .appendTo(tabsContent);
        }
        else {
          modalBody.innerHTML = roomsNavTitle;
          $(`<span class="d-block py-2 waves-effect waves-themed" style="border-top: 1px solid #e0e0e0;
            ">${roomsNavTitle}<i class="fa fa-angle-right float-right mt-1" style="font-size: 18px"></i></span>`)
            .appendTo(tabsContainer)
            .click(function () {
              modalBody.innerHTML = roomsNavTitle;
              modalDom.addClass('show').css('display', 'block');
              modalDom.find('.modal-body').find('.nav-content').hide();
              roomsNavContent.show();
            });
          roomsNavContent = $('<div class="nav-content">').appendTo(modalDom.find('.modal-body'));
        }
        var allRoomesDiv = $('<div class="box-container">').appendTo(roomsNavContent).append($('<h2>').html("Rooms"));
        $.each(item.Rooms, function (index, value) {
          renderItemDetails(WIRE.d(value), allRoomesDiv, index);
        });
      }

      if (item.floor_plan) {
        var floorPlanNavId = 'tab_floorPlan';
        var floorPlanTitle = '<i class="fal fa-columns mr-1"></i> Floor Plan';
        var floorPlanNavContent;
        if (minWidth550) {
          $(`<li class="nav-item">
                <a class="nav-link fs-lg" data-toggle="tab" href="#${floorPlanNavId}" 
                  role="tab" aria-selected="true">${floorPlanTitle}</a>
              </li>`).appendTo(tabsList);
          floorPlanNavContent = $(`<div class="tab-pane fade" id="${floorPlanNavId}" role="tabpanel">`)
            .appendTo(tabsContent);
        }
        else {
          modalBody.innerHTML = floorPlanTitle;
          $(`<span class="d-block py-2 waves-effect waves-themed" style="border-top: 1px solid #e0e0e0;
          ">${floorPlanTitle}<i class="fa fa-angle-right float-right mt-1" style="font-size: 18px"></i></span>`)
            .appendTo(tabsContainer)
            .click(function () {
              modalBody.innerHTML = floorPlanTitle;
              modalDom.addClass('show').css('display', 'block');
              modalDom.find('.modal-body').children().hide();
              floorPlanNavContent.show();
            });
          floorPlanNavContent = $('<div class="nav-content">').appendTo(modalDom.find('.modal-body'));
        }
        var allfloorsPlanDiv = $('<div class="box-container">').appendTo(floorPlanNavContent).append($('<h2>').html("Floor Plan"));;
        // renderItemDetails(WIRE.d(item.floor_plan), allfloorsPlanDiv, 1);
        $(`<img class="mr-2 mt-2" src="${item.floor_plan}" style="width: 100%; max-width: 700px; border-radius: 1px; cursor: pointer"/>`)
          .appendTo(allfloorsPlanDiv);
      }
      if (item['virtual_tour']) {
        var vtourId = 'tab_vtour';
        var vtourTitle = '<i class="fa fa-street-view mr-1"></i> Virtual Tour 360';
        var navContent;
        var panel;
        if (minWidth550) {
          $(`<li class="nav-item" id="virtual_tour_tab">
        <a class="nav-link fs-lg" data-toggle="tab" href="#${vtourId}" 
          role="tab" aria-selected="true">${vtourTitle}</a>
      </li>`).appendTo(tabsList);
          navContent = $(`<div class="tab-pane fade" id="${vtourId}" role="tabpanel">`)
            .appendTo(tabsContent);
        }
        else {
          modalBody.innerHTML = vtourTitle;
          $(`<span class="d-block py-2 waves-effect waves-themed" style="border-top: 1px solid #e0e0e0;
          border-bottom: 1px solid #e0e0e0;">${vtourTitle}<i class="fa fa-angle-right float-right mt-1" style="font-size: 18px"></i></span>`)
            .appendTo(tabsContainer)
            .click(function () {
              modalBody.innerHTML = vtourTitle;
              modalDom.addClass('show').css('display', 'block');
              modalDom.find('.modal-body').find('.nav-content').hide();
              navContent.show();
            });
          navContent = $('<div class="nav-content">').appendTo(modalDom.find('.modal-body'));
        }
        panel = $(`<div id="panel-15" class="panel vt-main-panel">
          <div class="panel-hdr  vt-panel-header text-primary" style="min-height: 2rem !important;">
          <h2 class="float-left"></h2>
              <div class="panel-toolbar">
                  <button id='fullscreenBtn' class="btn btn-panel bg-transparent fs-xl w-auto h-auto rounded-0 waves-effect waves-themed" data-action="panel-fullscreen" data-toggle="tooltip" data-offset="0,10" data-original-title="Fullscreen"><i class="fal fa-expand"></i></button>
              </div>
          </div>
          <div class="panel-container collapse show">
              <div class="panel-content p-0 panel-vt" >            
              </div>
           </div>
          </div>`).appendTo(navContent);
        var url = item['virtual_tour'];
        if (url.includes('matterport')) {
          if (url.includes('play=0')) {
            url = url.replace("play=0", "play=1");
          } else if (!url.includes('&play')) {
            url = url + "&play=1";
          }
        }
        var iFrameContainer = $('<div>').addClass('embed-responsive embed-responsive-16by9');
        $(`<iframe class="w-100 embed-responsive-item" 
                           style=" border: dashed 1px #886ab5;"
                           frameborder="0"
                           src="${url}"></iframe>`).appendTo(iFrameContainer);
        iFrameContainer.appendTo(panel.find('.panel-vt'));

        $(panel).find('#fullscreenBtn').click(function () {
          $(panel).toggleClass('panel-fullscreen');
        });


      }
      // append wishlist/share icons to tabs list
      const wishlistShareDiv = $(`
        <div>
          <i class="wishlist-icon fa fa-gratipay" _id=${this.options.item_id.replace(':', '_')}></i>
          <i class="share-icon fa fa-share-alt-square"></i>
        </div>`);
      if (!Utils.isMobile) {
        wishlistShareDiv.addClass('d-inline ml-auto');
        wishlistShareDiv.appendTo(tabsList);
      }
      else {
        wishlistShareDiv.addClass('text-right');
        wishlistShareDiv.appendTo(tabsContainer.find('.media-body'));
      }
      
      wishlistShareDiv.find('.share-icon')
        .tooltip({ 'title': 'Share', 'placement': 'bottom' })
        .on('click', function (e) {
          e.stopPropagation();
          $(this).tooltip('hide');

          let propertyObject = {
            id: item["_id"],
            title: item["name"],
            description: item["address"]["address"],
            image: item['Photos'] && item['Photos'].length && WIRE.d(item['Photos'][0])['picture'],
            destination: window.location.href
          };

          Utils.showShareModal(propertyObject);
        });
      wishlistShareDiv.find('.wishlist-icon')
        .tooltip({ 'title': 'Favourite', 'placement': 'bottom' })
        .on('click', function (e) {
          e.stopPropagation();
          $(this).tooltip('hide');
          var residentialItemIcons;
          if (account) {
            residentialItemIcons = $(document).find(`.wishlist-icon[_id="${item_id}"]`);
            $(residentialItemIcons).each(function (index, obj) {
              Utils.setWishList($(obj), item_id, account, $(document));
            });
            if ($(residentialItemIcons).hasClass('active')) {
              Utils.wishItemsCount = Utils.wishItemsCount - 1;
            } else {
              Utils.wishItemsCount = Utils.wishItemsCount + 1;
            }
          }
          else {
            residentialItemIcons = container.find(`.wishlist-icon[_id="${item_id}"]`);
            Utils.setWishList(residentialItemIcons, item_id, account, $(document));
          }
          $(document).find('#wishlistContainer .badge').text(Utils.wishItemsCount || 0);
        });
      //#endregion Item Details (Left Div)
    };
    //#endregion ______________ Public Method ______________

    return PubliclyAdvertisedViewer;
  }();

  var createCarouselMobile = function (photos, mapCarouselItem = '') {
    photos = photos || [];
    // filter loaded photos 
    var photosObjects = photos.map(photo => {
      var photoObj = WIRE.d(photo);
      return photoObj;
    }).filter(photo => {
      if (photo && photo.picture) {
        return photo;
      }
    });

    var randomId = Guid.generate();
    var carouselId = "carousel" + randomId;
    var carouselIdHref = "#" + carouselId;

    var carousel = $("<div>")
      .addClass("carousel slide")
      .addClass("rsv-carousel-slide")
      .attr({ "id": carouselId, "data-ride": "carousel" });

    var carouselInner = $("<div>")
      .addClass("carousel-inner")
      .addClass("mobile-carousel-inner h-100")
    carousel.append(carouselInner);
    var isActivePhoto = true;

    for (var i = 0; i < photosObjects.length; i++) {
      var photoObj = photosObjects[i];
      if (photoObj && photoObj.picture) {
        var carouselItem = $("<div>")
          .addClass("carousel-item")
          .addClass("rsv-carousel-item")
          .addClass("rsv-gallery-item")
          .attr({ "data-src": photoObj.picture });
        if (isActivePhoto && !mapCarouselItem) {
          carouselItem.addClass("active");
        }
        isActivePhoto = false;

        carouselInner.append(carouselItem);

        var imageThumbnail = $("<div>").addClass("img-thumbnail").addClass("rsv-carousel-img-thumbnail");
        carouselItem.append(imageThumbnail);
        var lightBoxImageLink = $("<a>")
          .addClass("jg-entry-mob entry-visible-mob")
          .addClass("rsv-light-box-img-link-mobile")
          .attr({ "href": photoObj.picture, "data-src": photoObj.picture });
        imageThumbnail.append(lightBoxImageLink);



        // 1. Render image
        var img = $("<img>")
          .addClass("img-responsive d-block w-100")
          .addClass("rsv-carousel-img-mobile")
          .attr({ "src": photoObj.picture, "data-src": photoObj.picture });
        if (photoObj.id) {
          img.data("id", photoObj.id)
        }
        lightBoxImageLink.append(img);
      }

    }
    carouselInner.lightGallery({ thumbnail: true });


    if (photosObjects.length > 1) {
      // Left Control
      var leftCarouselLink = $("<a>")
        .addClass("carousel-control-prev")
        .addClass("rsv-carousel-control-prev")
        .attr({ "href": carouselIdHref, "role": "button", "data-slide": "prev" });
      carousel.append(leftCarouselLink);

      var leftIcon = $("<span>")
        .addClass("carousel-control-prev-icon")
        .addClass("rsv-carousel-control-prev-icon")
        .attr("aria-hidden", "true");
      leftCarouselLink.append(leftIcon);

      var leftLabel = $("<span>").addClass("sr-only").text("Previous");
      leftCarouselLink.append(leftLabel);

      //Right Control
      var rightCarouselLink = $("<a>")
        .addClass("carousel-control-next")
        .addClass("rsv-carousel-control-next")
        .attr({ "href": carouselIdHref, "role": "button", "data-slide": "next" });
      carousel.append(rightCarouselLink);

      var rightIcon = $("<span>")
        .addClass("carousel-control-next-icon")
        .addClass("rsv-carousel-control-next-icon")
        .attr("aria-hidden", "true");
      rightCarouselLink.append(rightIcon);

      var rightLabel = $("<span>").addClass("sr-only").text("Next");
      rightCarouselLink.append(rightLabel);
    }

    carousel.carousel({
      interval: false
    });
    return carousel;
  };

  var renderCarouselMobile = function (carousel, container) {
    var slideShow = $("<div>")
      .css('min-height', '169px');
    slideShow.append(carousel);
    container.append(slideShow);

  };

  $.fn.PubliclyAdvertisedViewer = function (options) {
    $(this).each(function () {
      if (!$.data(this, 'PubliclyAdvertisedViewer')) {
        var viewer = new Specto.ui.PubliclyAdvertisedViewer(options);
        viewer.renderOn($(this));

        $.data(this, 'PubliclyAdvertisedViewer', viewer);
      }
    });
    return this;
  };

})(jQuery);
/**
 * Must be called on popup JQuery directly.
 */
function autoResizePopup(jq) {
  if (!jq) {
    jq = $(this);
  }

  //jq.dialog({'width': jq[0].scrollWidth + 54});

  var heightDiff = jq[0].scrollHeight + 10 - jq.height();
  var widthDiff = jq[0].scrollWidth + 10 - jq.width();
  var left = ($("body").width() - (jq.parent().width() + widthDiff)) / 2;

  jq.parent().animate(
    {
      height: jq.parent().height() + heightDiff,
      width: jq.parent().width() + widthDiff,
      top: 0,
      left: left
    },
    200
  );
  jq.animate(
    {
      height: jq.height() + heightDiff,
      width: jq.width() + widthDiff
    },
    200
  );
}

/**
 * Returns a function that when called, is equivalent to calling func(),
 * except that if the return function gets called very frequently, some of the calls
 * are ignored.
 * @param {Function} func
 * From: https://stackoverflow.com/questions/27078285/simple-throttle-in-js
 */
function throttle(func) {
  //return func;
  var wait = 500;
  var options = { leading: false };

  var context, args, result;
  var timeout = null;
  var previous = 0;
  if (!options) options = {};
  var later = function () {
    previous = options.leading === false ? 0 : Date.now();
    timeout = null;
    result = func.apply(context, args);
    if (!timeout) context = args = null;
  };
  return function () {
    var now = Date.now();
    if (!previous && options.leading === false) previous = now;
    var remaining = wait - (now - previous);
    context = this;
    args = arguments;
    if (remaining <= 0 || remaining > wait) {
      if (timeout) {
        clearTimeout(timeout);
        timeout = null;
      }
      previous = now;
      result = func.apply(context, args);
      if (!timeout) context = args = null;
    } else if (!timeout && options.trailing !== false) {
      timeout = setTimeout(later, remaining);
    }
    return result;
  };
}

// function getFromServer(callback) {
//   //   expensive
//   //   callback({});
//   console.log("Hi, throttle function testing i = " + i);
//   callback({ val: "hello" });
// }
// var i = 0;
// function test() {
//   var foo = throttle(getFromServer, null, { leading: true });
//   for (i = 0; i < 100; i++) {
//     foo(function(data) {
//       console.log("finish, throttling " + data.val);
//     });
//   }
//   //   foo(function(data) {
//   //     console.log("finish");
//   //   });
// }

/**
 * Can be called on a child of a JQuery dialog popup.
 * @param {JQuery} childJq JQuery object that is a (sub-)child of the dialog
 *   popup.
 * @param {boolean} ignoreOrphanError if set, no errors will be thrown in the
 *   case that `childJq` is not a descendant of a popup dialog.
 */
function autoResizeOwnerPopup(childJq, ignoreOrphanError) {
  while (!childJq.hasClass("ui-dialog-content")) {
    childJq = childJq.parent();
    if (!childJq.length) {
      if (ignoreOrphanError) {
        return;
      } else {
        //TODO_khalid ask sami about this line
        return;
        throw "Object not part of a popup";
      }
    }
  }
  autoResizePopup(childJq);
}

class Wire {
  constructor(endpoint = "/a", appSelector = "body") {
    this.ngControllerCounter = 0;
    this.endpoint = endpoint;
    this.appJQ = $(appSelector);

    /**
     * @type {io}
     */
    this.socket = null;

    /**
     * @type {JQuery}
     * If set, will be DOM of jquery element that is publicly viewed (before login).
     */
    this.publicJq = null;

    /**
     * dictionary from its name (string) to u.EditableObject)
     */
    this.editableObjects = {};

    /**
     * list of modals that are stacked (invoked when someone logs in).
     * Populated by stackOpenModals() and emptied on unstackOpenModals();
     * @type {Array<object>}
     */
    this.stackedModals = [];

    /**
     * @type {ActionManager}
     */
    this.actionManager = new ActionManager(this);

    /**
     * @type {object<string, InvokablePopup>}
     * Name to jquery selector with dialog() called on it.
     */
    this.popups = {};
    this.modals = {};

    /**
     * @type {object <string, object> }
     * Table name to item with pending action.
     */
    this.tableItems = {};

    /**
     * @type {object<string, object>}
     * Keys are like "!obj!<type>:id". Each key points to the actual object.
     */
    this.objects = {};

    /**
     * @type {object<string, number>}
     * From object ID to number:
     *   0: no permission to view or edit [likely, wont arrive i.e. absense implies no perm]
     *   1: permission to view
     *   2: permission to edit
     *   3: permission to view and edit.
     */
    this.edgeP = {};

    /**
     * All data accessible to the system.
     */
    this.data = {};

    // Data name -> list of callbacks.
    this.onObjectAddCallbacks_ = {};
    this.onObjectRemoveCallbacks_ = {};

    // For re-routing AJS data to the controller functions.
    this.ajsObjects = {};
    this.ajsCallbacks = {};

    /** @type {EdgeSchemaManager} */
    this.edgeSchemaManager = new EdgeSchemaManager(this);

    /** @type {ItemManager} */
    this.itemManager = new ItemManager(this);

    this.depictor = new Depictor(this);
    this.objInterfaces = new ObjInterfaces(this);

    /** @type {Lister} */
    this.lister = new Lister(this);

    this.edgeDb = new EdgeDatabase(this);

    /** @type {SchemaManager} */
    this.schemaManager = new SchemaManager(this);

    /** @type {Cache} */
    this.cache = new Cache();

    this.objectChangeNotificationCallbacks = {};
  }

  notifyObjectChange(obj) {
    if(this.objectChangeNotificationCallbacks[obj["_id"]]) {
      debugger;
      this.objectChangeNotificationCallbacks[obj["_id"]]();
    }
  }

  registerObjectChangeNotification(objId, callback, lifetimeDom) {
    //TODO callback is single, consider making it a list in the future
    this.objectChangeNotificationCallbacks[objId] = callback;
    lifetimeDom.on("remove", function() {
      this.objectChangeNotificationCallbacks[objId] = null;
    }.bind(this));
  }

  /**
   * Opens a (model) popup on some content. The popup can be later closed using
   * closePopups().
   *
   * @param {string} popupTitle Shows on the top-bar of the popup.
   * @param {unroll} popupContent unroll element i.e. constructed using u().
   */
  popup(popupTitle, popupContent) {
    // NOTE(sami): HAck to make twitter bootstrap's items not on top of everything.
    $(".page-sidebar").css("z-index", 19);
    $(".page-header").css("z-index", 19);
    var popup = new Unroll.Popup();
    popup.wire = this;
    popup.invoke([popupTitle, popupContent]);
  }

  /**
   * Pops-up a modal
   * @param {string} modalTitle Title to display.
   * @param {string} modalContent Return of u().
   * @param {Array} modalButtons Array of buttons. Each is dict with keys (some are optional):
   *   label, onClick, color [e.g. btn-primary].
   * @param {Object} modalOptions includes keys:
   *   sizeMode: Possible values "auto", "custom", "large", "xLarge", "full"
   */
  modal(modalTitle, modalContent, modalButtons, modalOptions) {
    if (typeof modalContent != 'string' && !(modalContent instanceof String)) {
      var modal = new Unroll.Modal();
      modal.wire = this;
      return modal.invoke([modalTitle, modalContent, modalButtons, modalOptions]);
    }
    else {
      return Specto.ui.Modal.showModal(modalContent, modalTitle, modalButtons, modalOptions);
    }
  }

  warningModal(modalContent) {
    var modal = new Unroll.WarningModal();
    modal.wire = this;
    return modal.invoke([modalContent]);
  }

  informModal(modalContent, modalOptions, callback) {
    var modal = new Unroll.InformModal();
    modal.wire = this;
    return modal.invoke([modalContent, modalOptions, callback]);
  }

  informMessageModal(message) {
    this.informModal($('<div>').html(message))
  }

  confirmModal(modalContent, modalOptions, yesCallback, noCallBack) {
    var modal = new Unroll.ConfirmModal();
    modal.wire = this;
    return modal.invoke([modalContent, modalOptions, yesCallback, noCallBack]);
  }

  errorModal(modalContent) {
    var modal = new Unroll.ErrorModal();
    modal.wire = this;
    return modal.invoke([modalContent]);
  }

  errorMessageModal(msg) {
    this.errorModal($('<div class="error">').html(msg));
  }

  popupObjectView(object, options, refetchShallow = false) {
    if (refetchShallow) {
      this.callWithSpinner('interactions::fetch_object_shallow', {'obj': object._id}, function() {
        this.popupObjectView(this.d(object._id), options, false);
      }.bind(this));
      return;
    }

    options = options || {};
    var modalTitle = 'View';
    if (object['type']) {
      modalTitle += ' ' + object['type'];
    }
    if (object['name']) {
      modalTitle += ': ' + object['name'];
    }

    options = {
      ...options,
      ...{ objectId: object['_id'] }
    };

    var modal;
    // Add Action Buttons.
    var buttons = [];


    this.actionManager.forEachAction(object['_id'], function (interactionName, action) {
      if (action['visibleFn']) {
        var visibleFn = eval(action['visibleFn']);
        if (!visibleFn(object)) {
          return;
        }
      }
      buttons.push({
        'label': action['d'] || action['n'],
        'color': action['color'] || 'btn-primary',  // 'btn-primary',
        'onClick': function () {
          var actionArgs = {
            'interaction': interactionName,
            'action': action['n'],
            'i_type': action['i_type'],
            'i_idx': action['i_idx'],
            'obj_id': object['_id'],
            // TODO(sami): Add full object path.
          };

          if (action['ajs']) {
            var submodal;
            var innerScope;
            var subbuttons = [{
              'color': 'btn-primary',
              'label': action['dInner'] || action['d'] || action['n'],
              'onClick': function () {
                actionArgs['values'] = innerScope.getValue();
                if (actionArgs['values'].error) {
                  return;
                }
                this.call('interactions::act', actionArgs, function (response) {
                  if (response['_closeObjectModal']) {
                    submodal.close();
                    modal.close();
                  }
                  firingActionExecutedEvent(action);
                });
              }.bind(this),
            }];
            submodal = this.modal(action['d'] || action['n'], u('AJS', [action['ajs'], { 'objId': object._id }, function (scope) {
              innerScope = scope;
            }]), subbuttons, { 'sizeMode': actionArgs['sizeMode'] || 'large' });
          } else if (action['schemaName'] || action['schema']) {
            var schema = action['schema'] || this.schemaManager.schema[action['schemaName']];
            if (!schema) {
              console.error('invalid schema: ' + action['schemaName']);
            }
            console.log('SCHEMA SCHEMA');
            var submodal;
            submodal = this.modal(action['d'] || action['n'], u('EditableObject', ['actionEditable', schema]), [
              // Buttons.
              {
                'color': 'btn-primary', 'label': action['dInner'] || action['d'] || action['n'], 'onClick': function () {
                  actionArgs['values'] = WIRE.getEditableValues('actionEditable');
                  if (actionArgs['values'].error) {
                    return;
                  }
                  WIRE.call('interactions::act', actionArgs, function (response) {
                    if (response['_closeObjectModal']) {
                      submodal.close();
                      modal.close();
                    }
                    firingActionExecutedEvent(action);
                  });
                }
              }
            ], { 'sizeMode': actionArgs['sizeMode'] || 'large' });
          } else {
            // No schema. Directly send action.
            this.call('interactions::act', actionArgs, function (response) {
              if (response['_closeObjectModal']) {
                modal.close();
              }
              firingActionExecutedEvent(action);
            });
          }
        }.bind(this),
      });
    }.bind(this));
    // Fire Modal
    modal = this.modal(modalTitle, u('AJS', ['common/object_view', options]), buttons, { 'sizeMode': 'full', 'expandButton': false });
  }

  isImmutableType(objType) {
    const immutableTypes = new Set(['item_offer', 'fund_account', 'signature', 'calendar_response']);
    return (immutableTypes.has(objType) || objType.endsWith('_wt'));
  }

  getRegisteredWalletTypes(ignoreWtSuffix=true) {
    var walletTypes = (this.data['wallets'] || []).map(function(objId) {
      if (objId.startsWith('!obj!')) {
        objId = objId.substr(5);
      }
      var objType = objId.split(':')[0];
      if (ignoreWtSuffix) {
        objType = objType.replace(/_wt$/, '');
      }
      return objType;
    });
    return walletTypes;
  }

  createSpinner() {
    return $(`
    <div class="wire-spinner d-flex justify-content-center align-items-center h-100 mb-6">
      <button class="btn btn-primary" type="button" disabled>
        <span class="spinner-border" role="status" aria-hidden="true"></span>
        <span class="sr-only">Loading...</span>
      </button>
    </div>`);
  }

  callWithSpinner(fnName, data = null, callback = null) {
    callback = callback || function () { };
    // Spinner to be added during an AJAX requests
    var spinner = this.createSpinner();

    $.ajax(this.endpoint, {
      method: "POST",
      data: JSON.stringify({
        fn: fnName,
        data: data
      }),
      processData: false,
      beforeSend: function () {
        //  show spinner ...   
        $('body').append(spinner);
      }
    }).done(
      function (response) {
        this.processResponse(response);
        if (!response['error']) {
          if (callback(response)) {
            console.log("callback of callWithSpinner() returned True. Should stop?");
          }
        }
      }.bind(this)
    ).always(
      function () {
        spinner.remove();
      }
    );
  }

  call(fnName, data = null, callback = null, failureCallback = null) {
    //debugger;
    callback = callback || function () { };
    // TODO(sami): Use sockets instead of $. but after validating connection.
    //
    $.ajax(this.endpoint, {
      method: "POST",
      data: JSON.stringify({
        fn: fnName,
        data: data
      }),
      processData: false,
    }).done(
      function (response) {
        if (response) {
          this.processResponse(response, { catchError: $.isFunction(failureCallback) ? false : true });
          if (!response['error']) {
            if (callback(response)) {
              console.log("callback of call() returned True. Should stop?");
            }
          }
          else {
            if ($.isFunction(failureCallback)) {
              failureCallback(response);
            }
          }
        }
      }.bind(this)
    ); //(function() { console.log('ERROR'); });
  }

  /**
   * 
   * @param {String} fnName represents the name of server function to be called
   * @param {Object} data represents the function args
   * @param {Function} callback represents the function that should be executed on the respone
   * @param {int} expiry represents the expiry duration of cache in miliseconds
   */
  callWithCache(fnName, data = null, callback = null, onFailCallback = null, expiry = null) {
    // default cache time is 30 minutes
    expiry = expiry || 30 * 60 * 1000;
    var cacheKey = JSON.stringify({
      fn: fnName,
      data: data
    });

    // try to get the response from cache
    var response = this.cache.get(cacheKey);
    if (response) {
      callback(response);
    } else {
      // if there is no cached data, call the server
      this.call(fnName, data, function (response) {
        this.cache.set(cacheKey, response, expiry);
        callback(response);
      }.bind(this), onFailCallback);
    }
  }

  handleAJSController($scope) {
    var obj = this.ajsObjects[$scope.fnName];
    var callback = this.ajsCallbacks[$scope.fnName];
    AJS_FUNCTIONS[$scope.fnName]($scope, this, obj, callback);
  }

  /**
   * @param {renderOn} jquery selector to append on.
   * @param {path} string name of controller and view (without extension).
   */
  renderAJS(renderOn, path, dataObject, optCallback) {
    optCallback = optCallback || function () { };
    var pathDict = { vc: path };
    var www = getUrlParam("www");
    if (www) {
      pathDict["www"] = www;
    }

    var spinner = this.createSpinner();
    $('body').append(spinner);

    this.callWithCache(
      "business::get_ajs",
      pathDict,
      function (response) { // On success
        setTimeout(function() {
          var dom = $(response["_html"]);
          var fnName = "f" + this.ngControllerCounter;
          this.ngControllerCounter += 1;
          dom.attr("ng-controller", "mainCtrl");
          renderOn.append(dom);

          try {
            //console.log('AJS: ' + path);
            eval("AJS_FUNCTIONS." + fnName + " = " + response["_js"]);
          } catch (error) {
            console.error('Error in AJS ' + path);
            throw (error);
          }

          this.ajsObjects[fnName] = dataObject;
          this.ajsCallbacks[fnName] = optCallback;

          // Ask Angular to re-run.
          angular
            .element(document.body)
            .injector()
            .invoke(function ($compile, $rootScope) {
              $rootScope.$apply(function () {
                var scope = angular.element(dom).scope();
                scope.fnName = fnName;
                scope.dom = dom;
                $compile(dom)(scope);
                // Remove spinner
                spinner.remove();
              });
            });

          AJS_CONTOLLERS = {};
        }.bind(this), 0);
      }.bind(this), 
      function () { // On fail
        // Remove spinner
        spinner.remove();
      }
    );
  }

  processResponse(response, options) {
    var options = $.extend({}, { catchError: true }, options);

    // TODO(sami): Actions from left

    if (response['logout']) {
      this.data = {};
    }

    if (response["s"]) {
      // Socket order.
      if (response["s"] == "c") {
        //2nd condition: checking if socketio is loaded or not
        if (!this.socket && document.getElementById('socketio')) {
          // If not connected, connect.
          this.socket = io("/s", { transports: ["websocket"] });

          this.socket.on(
            "msg",
            function (msg, cb) {
              this.processResponse(JSON.parse(msg));
            }.bind(this)
          );
        }
      } else if (response["s"] == "d") {
        if (this.socket) {
          // If connected, disconnect.
          this.socket.disconnect();
          this.socket = null;
        }
      }
    }

    this.attemptToUpdateObjectsCache(response);

    if (response["data"]) {
      for (var key in response["data"]) {
        this.data[key] = response["data"][key];
      }
    }

    if (response['edge_p']) {
      for (var objId in response['edge_p']) {
        this.edgeP[objId] = response['edge_p'][objId];
      }
    }

    if (response['dashboard']) {
      this.dashboard = new Dashboard(response["dashboard"]);
    }

    if (response['live']) {
      this.lister.handleUpdatedObject(response);
    }

    if (response['actions']) {
      this.actionManager.process(response['actions']);
    }
    if (response["msg"]) {
      this.informMessageModal(response["msg"]);
    }
    if (response["error"] && options.catchError) {
      this.errorMessageModal(response["error"]);
    }
    if (response["schema"]) {
      this.schemaManager.schema = response["schema"];
    }
    if (response["hotschema"]) {
      this.itemManager.schema = response["hotschema"];
      this.itemManager.processSchema();
    }
    if (response['edgeschema']) {
      this.edgeSchemaManager.schema = response['edgeschema'];
      this.edgeSchemaManager.processSchema();
    }
    if (response["derror"]) {
      // Debug error.
      console.log("Debug Error: " + response["error"]);
    }
    if (response["ui"]) {
      if (this.publicJq) {
        this.publicJq.detach();
        this.stackOpenModals();
      }
      this.appJQ.empty();
      this.unrollRecursive(response["ui"], this.appJQ);

      if (this.publicJq) {
        this.unstackOpenModals();
      }
    }
    this.edgeDb.process(response);

    if (response["x"]) {
      this.execute(response["x"]);
    }

    for (var key in response) {
      if (key[0] != "+" && key[0] != "-") {
        continue;
      }
      var dataName = key.substr(1);
      var subscribers;
      if (key[0] == "+") {
        this.data[dataName] = (this.data[dataName] || []).concat(response[key]);
        subscribers = this.onObjectAddCallbacks_[dataName] || [];
      } else if (key[0] == "-") {
        response[key].forEach(
          function (item) {
            var ii = this.data[dataName].indexOf(item);
            if (ii >= 0) {
              this.data[dataName].splice(ii, 1);
            }
          }.bind(this)
        );
        subscribers = this.onObjectRemoveCallbacks_[dataName] || [];
      }
      var arr = this.assembleData(response[key]);
      subscribers
        .map(x => x)
        .forEach(function (subscriber) {
          subscriber(arr);
        });
    }
  }

  attemptToUpdateObjectsCache(response) {
    if (response["objects"]) {
      for (var key in response["objects"]) {
        this.objects[key] = response["objects"][key];
      }
    }
  }

  /**
   * Marks given DOM as "public" i.e. before login.
   * This can be restored into the UI after someone logs in (i.e. after changing the entire homepage)
   * using function `reshowPublicJq`.
   * @param {JQuery} jq 
   */
  memorizePublicJq(jq) {
    this.publicJq = jq;
  }

  reshowPublicJq(renderOn) {
    if (!this.publicJq) {
      return;
    }
    this.publicJq.appendTo(renderOn);
    this.publicJq = null;
  }

  /**
   * hides all open models; re-shows them on `unstackOpenModals`
   */
  stackOpenModals() {
    if (Specto.ui.Modal.openModals.length == 0) {
      return;
    }
    this.stackedModals = Specto.ui.Modal.openModals;
    this._stackedModalParent = this.stackedModals[0].modalContainer.parent();
    this.stackedModals.forEach(m => m.modalContainer.detach());
    Specto.ui.Modal.openModals = [];
  }

  /**
   * Shows modals that were hidden via `stackOpenModals`
   */
  unstackOpenModals() {
    if (this.stackedModals.length == 0) {
      return;
    }
    var restoreTo = this._stackedModalParent;
    this.stackedModals.forEach(m => m.modalContainer.appendTo(restoreTo));
    Specto.ui.Modal.openModals = Specto.ui.Modal.openModals.concat(this.stackedModals);
    this.stackedModals = [];
  }

  execute(execStr) {
    eval(execStr);
  }

  /**
   * Closes popups with given names.
   */
  closePopups(popupNames) {
    popupNames.forEach(
      function (popupName) {
        if (!this.popups[popupName]) {
          console.log("Error: Ordered to close unopen popup: " + popupName);
          return;
        }
        this.popups[popupName].div.dialog("close");
        delete this.popups[popupName];
      }.bind(this)
    );
  }

  uploadImage(imageData, callback) {
    this.call("business::upload_photo", imageData, callback);
  }

  uploadFile(fileData, callback){
    this.call("business::upload_file", fileData, callback);
  }

  unrollRecursive(unrollElement, unrollInJQ, parentElement) {
    if (!Unroll[unrollElement["ref"]]) {
      console.log("ERROR: Unknown UI Element " + unrollElement["ref"]);
      return;
    }

    var element = new Unroll[unrollElement["ref"]](); // construct
    element.wire = this;
    element.parent = parentElement;
    element.render(unrollElement, unrollInJQ, parentElement);
    return element;
  }

  loadMore(
    dataArray,
    renderMethod,
    loadMoreElement,
    optInitCount,
    optAddeddCount
  ) {
    optInitCount = optInitCount || 10;
    optAddeddCount = optAddeddCount || 5;
    if (dataArray.length <= optInitCount) {
      loadMoreElement.hide();
    } else {
      loadMoreElement.hide();
      loadMoreElement.click(function () { });
    }
  }

  renderData(dataArray, render) {
    dataArray.forEach(element => {
      render(element);
    });
  }

  fetchData(dataKey) {
    //return this.assembleData(this.data[dataKey]);
    return this.d(this.data[dataKey]);
  }

  fetchChoices(type, callback) {
    this.call('business::get_choices', { choice_type: type }, function (response) {
      callback(response);
    })
  }

  deleteObj(objid, callback) {
    var parts = objid.split(":");
    var type = parts[parts.length - 2];
    var id = parts[parts.length - 1];
    this.call(
      "business::delete_obj",
      { type: type, id: id },
      function (response) {
        this.informModal(type + " was deleted successfully.");
        if (callback && callback instanceof Function) callback(response);
      }.bind(this)
    );
  }

  isDeletedObj(obj) {
    return obj["__deleted"] !== undefined && obj.__deleted == true;
  }

  fetchAllData(dataKey) {
    var data = this.assembleData(this.data[dataKey]);
    data = this.filterData(data);
    return data;
    // return this.d(this.data[dataKey]);
  }
  // short for data.
  d(item) {
    var objId = idIfObjectPointer(item);
    if (objId && this.objects[objId]) {
      this.objects[objId]._id = objId;
      this.objects[objId]._id2 = objId.replace(":", "_").replace(" ", "_");

      return this.objects[objId];
    } else if (objId && objId.startsWith('e^')) {
      var edgeId = objId.substr(2);
      if (this.edgeDb.edges[edgeId]) {
        return this.edgeDb.edges[edgeId];
      } else {
        console.log("Not loaded Edge " + objId);
      }
    } else if (objId) {
    //  console.log("Not loaded objId " + objId);
    }

    return item;
  }

  getTooltipContent(field) {
    if (field) {
      var elements = [
        { title: 'Description', value: field['d'] },
        { title: 'Required', value: field['r'] === 1 ? 'Yes' : 'No' },
        { title: 'Sample', value: this.getSample(field) }
      ];
      switch (field['t']) {
        case 'categorical': {
          elements.push({ title: 'Options', value: field['choices'].join(', ') })
          break;
        }
      }
      return this.renderTooltip(elements);
    }
  }
  renderTooltip(elements) {
    var jElement = $('<ul>');
    elements.forEach(element => {
      $('<li>').text(element.title + ': ' + element.value).appendTo(jElement);
    });
    return jElement;
  }
  getSample(field) {
    if (field['eg'])
      return field['eg'];

    switch (field['t']) {
      case 'categorical': {
        return field['choices'][1];
      }
      case 'email': {
        return 'john@realstat.co';
      }
      case 'phone': {
        return '+71 000 000 0';
      }
    }
  }
  assembleData(item, shallow, ignoreFields, assembledIds) {
    //
    //TODO_khalid ask sani about this change
    // if (typeof item == 'string' && item in this.objects)
    //   return !shallow ?  this.assembleData(this.objects[item], shallow, ignoreFields, assembledIds) : this.objects[item];

    assembledIds = assembledIds || {};
    var objId = idIfObjectPointer(item);
    if (objId && this.objects[objId]) {
      this.objects[objId]._id = objId;
      this.objects[objId]._id2 = objId.replace(":", "_");

      if (assembledIds[objId]) {
        return assembledIds[objId];
      } else if (!shallow) {
        var temp = {};
        assembledIds[objId] = temp;
        var obj = this.assembleData(
          this.objects[objId],
          false,
          ignoreFields,
          assembledIds
        );
        for (var k in obj) {
          temp[k] = obj[k];
        }
        return obj;
      } else {
        return this.objects[objId];
      }
    } else if (objId && objId.startsWith('e^')) {
      var edgeId = objId.substr(2);
      if (this.edgeDb.edges[edgeId]) {
        var edgeData = this.assembleData(this.edgeDb.edges[edgeId], shallow, ignoreFields, assembledIds);

        return edgeData;
      } else {
        console.log("Not loaded Edge " + objId);
        return {}
      }
    } else if (objId) {
      console.log("Not loaded objId " + objId);
      return {}; // TODO(sami): Support lazy-loading.
    } else if (Array.isArray(item)) {
      // Object key.
      var results = [];
      for (var i = 0; i < item.length; i += 1) {
        results.push(
          this.assembleData(item[i], shallow, ignoreFields, assembledIds)
        );
      }
      return results;
    } else if (typeof item == "object") {
      var results = {};
      for (var k in item) {
        if (k == "_id" || k == "parent" || k == "name") {
          results[k] = item[k];
        } else {
          results[k] = this.assembleData(
            item[k],
            shallow,
            ignoreFields,
            assembledIds
          );
        }
      }
      return results;
    } else {
      // Primitive
      return item;
    }
  }
  filterData(v) {
    var r = v;
    if (v) {
      if (Array.isArray(v)) {
        r = v.filter(t => !this.isDeletedObj(t));
      }
      // else if (Object.getPrototypeOf(v) === Object.prototype) {
      //     if (v['__deleted'] !== undefined && v.__deleted == true) {
      //         delete v;
      //     }
      //     Object.keys(v).forEach(function (key) {
      //         this.filterData(v[key]);
      //     }.bind(this));
      // }
    }
    return r;
  }

  purgeObject(v) {
    if (v) {
      if (Array.isArray(v)) {
        v.forEach(
          function (e) {
            this.purgeObject(e);
          }.bind(this)
        );
      } else if (Object.getPrototypeOf(v) === Object.prototype) {
        if (v.$$hashKey) {
          delete v.$$hashKey;
        }
        Object.keys(v).forEach(
          function (key) {
            this.purgeObject(v[key]);
          }.bind(this)
        );
      }
    }
  }

  getEditableValues(editableObjectName) {
    var values = this.editableObjects[editableObjectName].getValues();
    if (!values) {
      throw "No values returned from object " + editableObjectName;
    }
    return values;
  }

  // TODO(sami): Move onto some subscription system (ES6 has one?)
  registerCallback_(callbackDict, dataName, callback) {
    callbackDict[dataName] = callbackDict[dataName] || [];
    callbackDict[dataName].push(callback);
  }

  unregisterCallback_(callbackDict, dataName, callback) {
    if (!callbackDict[dataName]) {
      console.log("ERROR: callbackDict does not have " + dataName);
      return;
    }

    var index = callbackDict[dataName].indexOf(callback);

    if (index <= -1) {
      console.log('ERROR: Callback not in callbackDict["' + dataName + '"]');
      return;
    }
    callbackDict[dataName].splice(index, 1);
  }

  registerOnAddObjects(dataName, callback) {
    this.registerCallback_(this.onObjectAddCallbacks_, dataName, callback);
  }

  unregisterOnAddObjects(dataName, callback) {
    this.unregisterCallback_(this.onObjectAddCallbacks_, dataName, callback);
  }

  registerOnRemoveObjects(dataName, callback) {
    this.registerCallback_(this.onObjectRemoveCallbacks_, dataName, callback);
  }

  unregisterOnRemoveObjects(dataName, callback) {
    this.unregisterCallback_(this.onObjectRemoveCallbacks_, dataName, callback);
  }

  /**
   * Fetches (textual) response from user. Once entered, invokes callback.
   * @param {string} instruction Text to display to user.
   * @param {string?} defaultText optional default text value.
   */
  promptModal(instruction, title, defaultText, callback) {
    //var value = prompt(instruction, defaultText);
    // if (value) {
    //   callback(value);
    // }
    Specto.ui.Modal.showPromptModal(instruction, title, defaultText, { sizeMode: "auto" }, function (value) {
      if (value) {
        callback(value);
      }
    });
  }

  promptFields(instruction, modalTitle, schemaName, fieldValues, callback) {
    var instructionAndForm = $('<div><p class=instruction></p><div id=editable></div></div>');
    instructionAndForm.find('p.instruction').html(instruction);
    
    var editor = new DefaultSchemaEditor(
        this,
        instructionAndForm.find('div#editable'),
        schemaName, null /* db type */, fieldValues, null /* on-edit callback */);
    var modal = null;
    modal = Specto.ui.Modal.showModal(instructionAndForm, modalTitle, [{
      label: "OK",
      color: "btn-primary",
      onClick: function() {
        var value = editor.getValue();
        modal.close();
        callback(value);
      }.bind(this),
    }]);
  }

  popupWizard(wizardCollection, wizradModalName, finishCallback) {
    var locals = {};
    var wizardContainer = $('<div id="myWizard"></div>');
    var modal = this.modal(wizradModalName, wizardContainer.prop('outerHTML'));

    locals.wizard = new Wizard(this, $('#myWizard'), wizardCollection, finishCallback);

    locals.wizard.renderPage(this, {
      nextBtnText: wizardCollection[0].nextBtnText,
      getUnrollObject: wizardCollection[0].getUnrollObject
    });
    return modal;
  }

  fieldDocumentation(fieldName) {
    var filename = '/www/field_docs/' + fieldName + '.html?r=' + Math.round(Math.random()*10000);
    $.get(filename, function(response) {
      var jq = $(response).appendTo(document.body);
      Specto.ui.Modal.showModal(jq, 'Field Documentation ' + fieldName, [], {'sizeMode': 'full'});
    }).fail(function() {
      this.errorMessageModal('Documentation not found: ' + fieldName);
    }.bind(this));
  }
}

class Cache {
  constructor() {
    this.data = {};
  }
  get(key) {
    if (this.data[key] && this.data[key].value) {
      return this.data[key].value;
    }
    return false;
  }

  set(key, value, expiry) {
    // since the key data is resetted the cache is cleared to reset the cache timeout 
    this.clear(key);
    var timeout = false;
    if (expiry && Number(expiry) > 0) {
      timeout = setTimeout(function () {
        this.clear(key);
      }.bind(this), parseInt(expiry));
    }

    this.data[key] = {
      expiry: expiry,
      value: value,
      timeout: timeout,
    };
  }
  // clear the cached data of the key provided
  clear(key) {
    if (this.data[key]) {
      if (this.data[key].timeout) {
        clearTimeout(this.data[key].timeout);
      }
      delete this.data[key];
      return true;
    }
    return false;
  }
}
/**
 * Returns object id if x is string like "!obj!<object id>".
 */
function idIfObjectPointer(x) {
  if (typeof x != "string") {
    return null;
  }
  if (x && x.startsWith("!obj!")) {
    return x.substr(5);
  }
  var parts = x.split(":");
  //TODO parseInt(" 6 Test String") will return 6.. which could be a mistaken result
  if (parts.length > 1 && parseInt(parts[1])) {
    return x;
  }
}

function sanitizeObjId(id) {
  return id ? id.replace('!obj!', '') : '';
}

function getFullObjId(id) {
  if (id && !id.startsWith('!obj!'))
    id = `!obj!${id}`;

  return id;
}

function showSpinner(container, spinner) {
  if (spinner.length > 0) {
    container.LoadingOverlay("show", {
      image: "",
      custom: spinner
    });
  } else {
    var spinner = $(`
    <div class="spinner-border text-primary" role="status">
        <span class="sr-only">Loading...</span>
    </div>`);
    container.LoadingOverlay("show", {
      image: "",
      custom: spinner
    });
  }
}

function hideSpinner(container) {
  container.LoadingOverlay("hide");
}

function firingActionExecutedEvent(myAction) {
  var actionExecuted = new CustomEvent(
    "actionExecuted",
    {
      action:
      {
        name: myAction['n']
      },
      bubbles: true,
      cancelable: true
    });
  document.dispatchEvent(actionExecuted);
}
(function ($) {
  this.Specto = this.Specto || {};
  this.Specto.ui = this.Specto.ui || {};
  var ns = this.Specto.ui; //name space

  /*
      options = {
          isReadOnly: true/false(default);
          item:{
              "type": "Building", "_id": "", "name": "", "Description": "",
              "addresslatlng": { "address": "", "l": {"lat": 16.9283907, "lng": 96.23459219999995}},
              "Swimming Pools": [{
                  "type": "Swimming Pool", "_id": "",
                  "Photos": [{ "type": "Photo", "_id": "", "Description": "", "Picture": "" }]
              }],
              "Photos": [{ "type": "Photo", "_id": "", "Description": "", "Picture": "" }],
              "Floors": [{
                  "type": "Floor", "_id": "", "Description": "",
                  "Photos": [{ "type": "Photo", "_id": "", "Description": "", "Picture": "" }],
                  "Apartments": [{
                      "type": "Apartment", "_id": "", "name": "", "Description": "",
                      "Photos": [{ "type": "Photo", "_id": "", "Description": "", "Picture": "" }],
                      "Bedrooms": [{
                          "type": "Bedroom", "_id": "", "Description": "",
                          "Area (meters squared)": "", "Balcony": "", "Master": "",
                          "Photos": [{ "type": "Photo", "_id": "", "Description": "", "Picture": "" }],
                      }],
                      "bathrooms": [{
                          "type": "Bathroom", "_id": "", "Area": "",
                          "Photos": [{ "type": "Photo", "_id": "", "Description": "", "Picture": "" }],
                      }],
                      "Kitchens": [{
                          "type": "Kitchen", "_id": "", "Area": "", "Description": "",
                          "Stove": "Atteched to Stove Top", "Stove Top": "Electric", "Vent": "",
                          "Photos": [{ "type": "Photo", "_id": "", "Description": "", "Picture": "" }],
                      }]
                  }],
              }],
          }
      }
  */

  //If is called directly, it is considered function,
  //else , if is defined as (new), it is considered a class
  ns.RealStateViewer = function () {
    var defaults = {
      isReadOnly: false,
      item: {}
    };

    //Constructor
    function RealStateViewer(options) {
      //options.isReadOnly = options.isReadOnly || false;
      this.options = $.extend(false, {}, defaults, options);

      //this._init();
      init.call(this); //TODO_LEENAH:
    };

    //#region _____________________ Private Methods _____________________

    var init = function () {

    };

    //#region _______  Shared Methods _______
    var carouselColumn;
    var itemPhotos;
    var closeBtn = $('<button><i class="fal fa-times"></i></button>')
      .addClass('close-btn btn btn-sm btn-danger btn-icon rounded-circle waves-effect waves-themed position-absolute')
      .css({ 'z-index': '14', 'right': '0px' });
    // listItems = [{ id:.., text:.. }]
    var createDropdown = function (caption, listItems, callback) {
      if (listItems && listItems.length > 0) {
        // Create list
        var itemsGroup = $("<div>")
          .addClass("btn-group")
          .addClass("rsv-btn-group");

        var itemsButton = $("<button>")
          .addClass("btn dropdown-toggle")
          .addClass("rsv-btn mx-1")
          .attr({ "type": "button", "data-toggle": "dropdown" })
          .text(caption + " ");
        itemsGroup.append(itemsButton);

        var itemsMenu = $("<div>")
          .addClass("dropdown-menu")
          .addClass("rsv-dropdown-menu");
        itemsGroup.append(itemsMenu);

        var bindListItemClick = function (itemLink, item) {
          itemLink.click(function () {
            if (callback && callback instanceof Function) {
              callback(item.id, item.text);
            }
          });
        };

        for (var i = 0; i < listItems.length; i++) {
          var listItem = listItems[i];

          var itemLink = $("<a>")
            .addClass("dropdown-item")
            .addClass("rsv-list-point-link")
            .attr("id", listItem.id)
            .text(listItem.text);

          bindListItemClick(itemLink, listItem);
          itemsMenu.append(itemLink);
        }
        return itemsGroup;
      }
    };

    var getItemTitle = function (item, itemName) {
      var name = itemName;
      var itemParent = item.parent;
      if (itemParent) {
        if (itemParent.name) {
          name = itemParent.name + " " + itemParent.type + (name ? " - " + name : "");
        }
        name = getItemTitle(itemParent, name);
      }
      return name;
    };

    //#endregion ____  Shared Methods _______

    //#region _______ Item _______

    var renderItem = function (item, itemFields, sideBar, headerBar, mainArea) {
      // 1. Render side bar item && header bar item
      appendSideAndHeaderBarItem.call(this, item.type, sideBar, headerBar, function () {
        mainArea.empty();
        renderItemMainArea.call(this, item, itemFields, sideBar, headerBar, mainArea);
      });

      // 2. Render photos, name and description, another information
      renderItemMainArea.call(this, item, itemFields, sideBar, headerBar, mainArea);
    };

    var renderPhotos = function (photos, mapCarouselItem, carouselColumn, item) {
      var carousel = createCarousel.call(this, photos, mapCarouselItem, item);
      renderCarousel.call(this, carousel, carouselColumn);

      if (mapCarouselItem) {
        renderMapInCarousel.call(this, item.addresslatlng.l.lat, item.addresslatlng.l.lng, carousel.find(".rsv-img-map-canvs"));
      }
    };

    var renderItemMainArea = function (item, itemFields, sideBar, headerBar, mainArea) {

      // 1. Render photos and map if exist
      var mapCarouselItem = (item.addresslatlng && item.addresslatlng.l && item.addresslatlng.l.lat) ?
        CreateMapCarouselItem.call(this, item.type) : "";

      var photos = item.Photos || [];
      photos = photos.filter(photo => {
        if (photo.picture) {
          return photo;
        }
      });
      itemPhotos = itemPhotos ? itemPhotos : photos;
      hasContainerStyle = mainArea.attr('style');
      carouselColumn = $("<div class='info-container' style='height: fit-content'>")
        .addClass(hasContainerStyle ? "col-xl-12" : "col-lg-5 col-xl-4")
        .appendTo(mainArea);
      renderPhotos(photos, mapCarouselItem, carouselColumn, item);
      // 2. Render detailed information
      var detailedInfoColumn = $("<div>")
        .addClass('detailed-info-col')
        .appendTo(mainArea);

      var expandDetailedArea = !photos.length > 0 && !mapCarouselItem;
      mainArea.attr('style') ? detailedInfoColumn.addClass("col-lg-12 col-xl-12") :
        detailedInfoColumn.addClass("col-lg-7 col-xl-8");

      renderDetailedInfoArea.call(this, item, itemFields, sideBar, headerBar,
        mainArea, detailedInfoColumn, expandDetailedArea);
    };

    var createCarousel = function (photos, mapCarouselItem = '', item) {
      photos = photos || [];
      photos = photos.filter(photo => {
        if (photo.picture) {
          return photo;
        }
      });
      if (!photos.length) {
        photos.push({
          // "picture": "/www/img/placeholder_keyras.png",
          "picture": getItemIcon(item.type),
        });
      }
      var randomId = Guid.generate();
      var carouselId = "carousel" + randomId;
      var carouselIdHref = "#" + carouselId;

      var carousel = $("<div>")
        .addClass("carousel slide")
        .addClass("rsv-carousel-slide")
        .attr({ "id": carouselId, "data-ride": "carousel" });

      var carouselInner = $("<div>")
        .addClass("carousel-inner")
        .addClass("rsv-carousel-inner");
      carousel.append(carouselInner);

      if (mapCarouselItem) {
        carouselInner.append(mapCarouselItem);
      }
      for (var i = 0; i < photos.length; i++) {
        if (photos[i] && photos[i].picture) {
          var photoCaption = photos[i].name || "";
          var carouselItem = $("<div>")
            .addClass("carousel-item")
            .addClass("rsv-carousel-item")
            .addClass("rsv-gallery-item")
            .attr({ "data-src": photos[i].picture, "data-sub-html": "<h4>" + photoCaption + "</h4>" });
          if (i == 0 && !mapCarouselItem) {
            carouselItem.addClass("active");
          }

          carouselInner.append(carouselItem);

          var imageThumbnail = $("<div>").addClass("img-thumbnail").addClass("rsv-carousel-img-thumbnail");
          carouselItem.append(imageThumbnail);

          var lightBoxImageLink = $("<a>")
            .addClass("jg-entry entry-visible")
            .addClass("rsv-light-box-img-link")
            .attr("href", photos[i].picture);
          imageThumbnail.append(lightBoxImageLink);

          var lightBoxExpandIcon = $("<span>").addClass("rsv-img-expand-icon");
          lightBoxImageLink.append(lightBoxExpandIcon);

          lightBoxExpandIcon.hover(function () {
            // SET OPACITY TO 70%
            $(this).stop().animate({
              opacity: .7
            }, "fast");
          },
            // ON MOUSE OUT
            function () {
              // SET OPACITY BACK TO 50%
              $(this).stop().animate({
                opacity: 0
              }, "slow");
            });

          // 1. Render image
          var img = $("<img>")
            .addClass("img-responsive d-block w-100")
            .addClass("rsv-carousel-img")
            .attr("src", photos[i].picture)
            .attr("onerror","this.src='img/placeholder_keyras.png'");
          if (photos[i].id) {
            img.data("id", photos[i].id)
          }
          lightBoxImageLink.append(img);

          // 2. Render image caption
          if (photoCaption) {
            // This custom class is needed to give image certain styles 
            // when there is image caption 
            img.addClass("rsv-carousel-expanded-img");

            var carouselCaption = $("<div>")
              .addClass("caption")
              .addClass("rsv-carousel-caption")
              .text(photoCaption);
            imageThumbnail.append(carouselCaption);
          }
        }
      }
      if (photos.length > 1 || mapCarouselItem) {
        // Left Control
        var leftCarouselLink = $("<a>")
          .addClass("carousel-control-prev")
          .addClass("rsv-carousel-control-prev")
          .attr({ "href": carouselIdHref, "role": "button", "data-slide": "prev" });
        carousel.append(leftCarouselLink);

        var leftIcon = $("<span>")
          .addClass("carousel-control-prev-icon")
          .addClass("rsv-carousel-control-prev-icon")
          .attr("aria-hidden", "true");
        leftCarouselLink.append(leftIcon);

        var leftLabel = $("<span>").addClass("sr-only").text("Previous");
        leftCarouselLink.append(leftLabel);

        //Right Control
        var rightCarouselLink = $("<a>")
          .addClass("carousel-control-next")
          .addClass("rsv-carousel-control-next")
          .attr({ "href": carouselIdHref, "role": "button", "data-slide": "next" });
        carousel.append(rightCarouselLink);

        var rightIcon = $("<span>")
          .addClass("carousel-control-next-icon")
          .addClass("rsv-carousel-control-next-icon")
          .attr("aria-hidden", "true");
        rightCarouselLink.append(rightIcon);

        var rightLabel = $("<span>").addClass("sr-only").text("Next");
        rightCarouselLink.append(rightLabel);
      }

      carousel.carousel({
        interval: false
      });
      return carousel;
    };

    var renderCarousel = function (carousel, container) {
      var slideShow = $("<div>")
        .addClass("modified-dom");
      slideShow.append(carousel);
      container.append(slideShow);

      carousel.find('.rsv-carousel-inner').lightGallery(
        {
          selector: '.rsv-gallery-item',
          thumbnail: true,
          currentPagerPosition: "middle",
          animateThumb: true,
          showThumbByDefault: true
        });
      carousel.find('.rsv-carousel-inner').on('onAfterOpen.lg', function (event) {
        $('body').addClass("overflow-hidden");
      });
      carousel.find('.rsv-carousel-inner').on('onCloseAfter.lg', function (event) {
        $('body').removeClass("overflow-hidden");
      });
    };

    var CreateMapCarouselItem = function (itemType) {
      var carouselItem = $("<div>")
        .addClass("carousel-item")
        .addClass("rsv-carousel-item")
        .addClass("rsv-map-item")
        .addClass("active");

      var imageThumbnail = $("<div>")
        .addClass("img-thumbnail")
        .addClass("rsv-carousel-img-thumbnail");
      carouselItem.append(imageThumbnail);

      var mapContainer = $("<div>")
        .addClass("rsv-img-map-container");
      imageThumbnail.append(mapContainer);

      var randomId = Guid.generate();
      var mapCanvslId = "mapCanvs" + randomId;
      var mapCanvs = $("<div>")
        .addClass("rsv-img-map-canvs")
        .attr("id", mapCanvslId);
      mapContainer.append(mapCanvs);

      var carouselCaption = $("<div>")
        .addClass("caption")
        .addClass("rsv-carousel-caption")
        .text(itemType + " " + "Location");
      imageThumbnail.append(carouselCaption);

      return carouselItem;
    };

    var renderMapInCarousel = function (lat, lng, container) {
      // init map after render photos in carousel
      initializeGMap.call(this, lat, lng, container);
      // carousel.find(".rsv-img-map-container").css({ "width": "100%", 'height': '245px', 'text-align': 'center' });
      container.css({ "width": "100%", 'height': '245px' });
      // Trigger map resize event after render photos in carousel
      google.maps.event.trigger(map, "resize");
      map.setCenter(myLatlng);
    };

    var renderDetailedInfoArea = function (item, itemFields, sideBar, headerBar, mainArea, container, expandDetailedArea) {
      var me = this;

      var overviewTabId = "overviewTab" + Guid.generate();
      // var detailsTabId = "detailsTab" + Guid.generate();

      var detailedInfoArea = $(`<div class="alert-secondary detailed-info-area mb-1">
          <div class="tab-content">
              <div class="tab-pane fade show active" id="${overviewTabId}" role="tabpanel">                                    
              </div>
          </div>
        </div>`)
        .css('background-color', 'transparent');
      detailedInfoArea.find('li.overview-item').click(function () {
        $(this).closest('.modified-dom').empty()
          .removeAttr('class')
          .removeAttr('style')
      });
      var overviewTabArea = detailedInfoArea.find("#" + overviewTabId);
      var overviewAreaHasContent = false;

      // 1. render item's name & address
      if (!$('.info-dom').length) {
        renderItemInformation.call(this, item, overviewTabArea);
      }

      // 2. render item's description in (Overview) tab
      if (item.description && typeof (item.description) != "object") {
        overviewAreaHasContent = true;
        renderDescription.call(this, item.description, overviewTabArea);
      }

      // 3. render item's related (lists) in (Details) tab
      var itemListsFields = itemFields.length > 0 ? itemFields.filter(f => f.type == "List" && f.name != "Photos") : [];
      var dropdownElementsRow = $("<div class='dropdown-row d-flex mt-2 mb-1' style='line-height: 18px'>");
      var detailsAreaHasContent = false;
      for (var i = 0; i < itemListsFields.length; i++) {
        var itemList = item[itemListsFields[i].name];
        var itemListTitle = itemListsFields[i].name;
        var itemListFields = itemListsFields[i]['subFields'] || [];

        // Check If item has any list 
        if (itemList) {
          detailsAreaHasContent = true;
          renderItemListDropdown.call(me, sideBar, headerBar, mainArea, dropdownElementsRow,
            itemList, itemListTitle, itemListFields);
        }
      }

      // 4. render item's related (Editable Object) in (Overview) tab
      var itemEditableObjectFields = itemFields.length > 0 ?
        itemFields.filter(f => f.type == "EditableObject" &&
          (f.name == "Basic Information" || f.name == "Additional Information")) : [];
      if (itemEditableObjectFields.length > 0) {
        var renderEmptyValues = expandDetailedArea ?
          (detailsAreaHasContent && !overviewAreaHasContent) : !overviewAreaHasContent;
        prepareAndRenderItemFeatures.call(this, item, itemEditableObjectFields, overviewTabArea, renderEmptyValues);
      }
      var overviewTabContent = overviewTabArea.html().trim();

      if (overviewTabContent || !expandDetailedArea) {
        container.append(detailedInfoArea);
      }
      // else {
      //   var itemIcon = item.type ? getItemIcon(item.type) : "";
      //   container.append($("<img>").addClass("rsv-item-icon").attr("src", itemIcon));
      //   container.addClass("text-center");
      // }
      if (detailsAreaHasContent) {
        carouselColumn.append(dropdownElementsRow);
      }
    };

    var renderItemInformation = function (item, container) {
      var infoDom = $('<div class="info-dom">').appendTo(container);
      $(`<div>
          <div class="pr-header d-flex mb-0">
              <div style="display: block;">
                  <span class="property-name text-primary font-weight-bold">${item.name}</span>
                  <p class="mb-2"><i class="fa fa-map-marker text-secondary mr-1"></i>${item.address ? item.address.address : ''}</p>
              </div>
          </div>
      </div>`).appendTo(infoDom);
      $(`<div class="ml-0 d-flex row mb-2">
          <div class="d-flex">
              <span class="fal fa-bed text-primary mr-2 mt-1" style="font-size: 29px;"></span>
              <div class="mr-3" style="display: grid;"><span>Rooms</span><span class="font-weight-bold my-auto">${item.Rooms ? item.Rooms.length : 0}</span></div>
          </div>
          <div class="d-flex">
              <span class="fal fa-bath text-primary mr-2 mt-1" style="font-size: 29px;"></span>
              <div class="mr-3" style="display: grid;"><span>Bathrooms</span><span class="font-weight-bold my-auto">${item.Bathrooms ? item.Bathrooms.length : 0}</span></div>
          </div>
          <div class="d-flex">
              <i class="kr-ico-square-area text-primary mr-1" style="font-size: 26px;"></i>
              <div class="mr-3" style="display: grid;"><span>Square Feet</span><span class="font-weight-bold my-auto">${item.square_area ? item.square_area.value : 0}</span></div>
          </div>
      </div>`).appendTo(infoDom);
    }
    var renderDescription = function (description, container) {
      var itemDescription = $("<div>")
        .addClass("rsv-item-description-container mb-3");
      container.append(itemDescription);

      var descriptionPara = $("<p>").addClass("rsv-item-description-paragraph mb-0").text(description);
      itemDescription.append(descriptionPara);

      if ((itemDescription[0].scrollHeight > itemDescription[0].clientHeight) ||
        (itemDescription[0].scrollWidth > itemDescription[0].clientWidth)) {

        var descriptionStr = description.toString();
        var textLength = descriptionStr.length;
        var searchString = " ";
        var preIndex = 50;
        var searchIndex = preIndex + descriptionStr.substring(preIndex).indexOf(searchString);
        var text1 = descriptionStr.slice(0, searchIndex);
        var text2 = descriptionStr.slice(searchIndex);

        descriptionPara.text(text1);
        var dots = $("<span>").addClass("rsv-description-dots").text(" ...");
        var remainingText = $("<span>").addClass("rsv-description-remaining-text").text(text2);

        descriptionPara.append(dots).append(remainingText);

        var readLink = $("<a>").addClass("rsv-description-read-more-link").text("Read more >>");
        itemDescription.append(readLink);

        readLink.click(function () {
          var dots = $(this).siblings().last().find(".rsv-description-dots");
          var remainingText = $(this).siblings().last().find(".rsv-description-remaining-text");

          if (dots.css("display") === "none") {
            dots.css("display", "inline");
            $(this).html("Read more >>");
            remainingText.css("display", "none");
          } else {
            dots.css("display", "none");
            $(this).html("Read less <<");
            remainingText.css("display", "inline");
          }
        });
      }
    };

    var prepareAndRenderItemFeatures = function (item, itemEditableObjectFields, container, renderEmptyValues) {
      var features = [];

      var anotherFeaturesContainer = $("<div>").addClass("rsv-features-container row");
      var isThereContent = false;

      for (var i = 0; i < itemEditableObjectFields.length; i++) {
        var objFeaturesTitle = itemEditableObjectFields[i].name;
        var objFeatures = itemEditableObjectFields[i].typeargs[0] || []; // [0] because its array of array

        objFeatures.forEach(feature => {
          // except item's name and description since there is an specialized area for them
          var featureName = feature.n || objFeaturesTitle;
          if (featureName != 'name'
            && featureName != 'description'
            && (item[featureName] || renderEmptyValues)) {
            features.push({ 'text': feature.d || featureName, 'value': item[featureName] || "" })
          }
        });

        if (features.length > 0) {
          isThereContent = true;
          isSubFeature = $('.modified-dom').children().length > 1;
          var featuresSubContainer = $("<div>").addClass(isSubFeature ? "col-lg-12" : "col-lg-6")
            .css('line-height', '18px');
          anotherFeaturesContainer.append(featuresSubContainer);

          var featuresTitleContainer = $("<h4>").addClass("color-primary-700").text(objFeaturesTitle);
          featuresSubContainer.append(featuresTitleContainer);

          var featuresTable = $(`
            <table class="table table-striped m-0 c rsv-features-table">
              <tbody>                                          
              </tbody>
            </table>`);
          featuresSubContainer.append(featuresTable);

          var tableRows = "";
          features.forEach(function (feature) {
            var featureValue;
            if (feature.text == "Address") {
              featureValue = feature.value.address;
            }
            else {
              featureValue = typeof (feature.value) != 'object' ? feature.value : '-';
            }
            tableRows += '<tr><th scope="row">' + feature.text + '</th><td class="text-wrap">' + featureValue + '</td>';
          });
          featuresTable.find('tbody').append(tableRows);

          // Reset the features for each editable object
          features = [];
        }
      }

      if (isThereContent) {
        container.append(anotherFeaturesContainer);
      }
    };

    // Render each list in item
    var renderItemListDropdown = function (sideBar, headerBar, mainArea, container, itemList, itemListTitle, itemListFields) {
      itemList = itemList || [];
      var listItems = itemList.map(function (item, index) {
        return {
          id: item._id,
          text: item.type + " " + ++index
        };
      });

      var me = this;
      var itemListDropdown = createDropdown.call(this, itemListTitle, listItems, function (itemId, itemText) {
        var item = itemList.find(function (element) {
          return element._id == itemId;
        });

        appendSideAndHeaderBarItem.call(me, itemText, sideBar, headerBar, function () {
          onSelectItemFromList.call(me, item, itemListFields, sideBar, headerBar);
        });

        onSelectItemFromList.call(me, item, itemListFields, sideBar, headerBar);
        // equalize heights of divs
        var leftSideHeight = $('.info-container').css('height');
        $('.detailed-info-col .tab-content').css('max-height', leftSideHeight);
      });

      container.append(itemListDropdown);
    };

    var onSelectItemFromList = function (item, itemFields, sideBar, headerBar) {
      var modifiedDom = $('.modified-dom')
      modifiedDom.empty();
      $('.container-fluid.property-container').css('padding-bottom', '8px');
      renderItemMainArea.call(this, item, itemFields, sideBar, headerBar, modifiedDom);
      var containerParent = modifiedDom.parent();
      if (!containerParent.find('.close-btn').length) {
        closeBtn.prependTo(containerParent);
      }
      if (containerParent.find('.close-btn').is(":hidden")) {
        closeBtn.show();
      }
    };

    var renderAddress = function (address, container) {
      var itemAddress = $("<div>").addClass("rsv-item-address");
      container.append(itemAddress);
      if ((typeof address) != 'object')
        address = {
          address: "United States",
          l: {
            lat: 37.09024,
            lng: -95.71289100000001
          }
        };

      var addressLink = $("<a>")
        .addClass("rsv-item-address-link")
        .attr({ "data-lat": address.l.lat, "data-lng": address.l.lng })
        .data("address-title", address.address);
      itemAddress.append(addressLink);;

      var addressIcon = $("<i>")
        .addClass("rsv-item-address-icon")
        .addClass("fa fa-map-marker fa-lg")
        .attr("aria-hidden", true);

      var addressLabel = $("<span>")
        .addClass("rsv-item-address-label")
        .text(address.address);

      addressLink.append(addressIcon).append(addressLabel);

      addressLink.click(function () {
        var mapContainer = $("<div>")
          .addClass("rsv-map-container");

        var randomId = Guid.generate();
        var mapCanvslId = "mapCanvs" + randomId;
        var mapCanvs = $("<div>")
          .addClass("rsv-map-canvs")
          .attr("id", mapCanvslId);
        mapContainer.append(mapCanvs);

        var optOptions = {
          'width': '600px',
          'onOpened': function () {
            // init map after show modal
            initializeGMap.call(this, addressLink.data('lat'), addressLink.data('lng'), mapCanvs);
            mapContainer.css("width", "100%");
            mapCanvs.css("width", "100%");
            // Trigger map resize event after modal shown
            google.maps.event.trigger(map, "resize");
            map.setCenter(myLatlng);
          },
          'onFullscreen': function (isFullScreen) {
            if (isFullScreen) {
              mapContainer.addClass("rsv-expand-map");
              mapCanvs.addClass("rsv-expand-map");
            } else {
              mapContainer.removeClass("rsv-expand-map");
              mapCanvs.removeClass("rsv-expand-map");
            }
          }
        };
        Specto.ui.Modal.showModal(mapContainer, addressLink.data('address-title'), null, optOptions);
      });
    };

    var map = null;
    var myMarker;
    var myLatlng;

    var initializeGMap = function (lat, lng, container) {
      myLatlng = new google.maps.LatLng(lat, lng);

      var myOptions = {
        zoom: 12,
        zoomControl: true,
        center: myLatlng,
        mapTypeId: google.maps.MapTypeId.ROADMAP
      };
      map = new google.maps.Map($("body").find('#' + container[0].id)[0], myOptions);

      myMarker = new google.maps.Marker({
        position: myLatlng
      });
      myMarker.setMap(map);
    };

    //#endregion _______ Item _______

    //#region _______ Side Bar , Header Bar _______

    var appendSideAndHeaderBarItem = function (title, sideBar, headerBar, callback) {
      appendSideBarItem.call(this, title, sideBar, callback);
      appendHeaderBarItem.call(this, title, headerBar, callback);
    };

    var appendSideBarItem = function (title, sideBar, callback) {
      var subSideBar = $("<div>").addClass("rsv-subside-bar");
      sideBar.append(subSideBar);

      var sideBarLink = $("<a>").addClass("rsv-subside-bar-link").text(title);
      subSideBar.append(sideBarLink);

      sideBarLink.click(function () {
        // When select specific sub side bar item, then all next sub side bars of items 
        // must be removed ...
        subSideBar.nextAll().remove();

        // and its main area & features must be retrieved
        if (callback && callback instanceof Function) {
          callback();
        }

        // and this must be reflected on header items links since they represent same view,
        // so we retrieve the "header item link" which matches(similar to) "current sub side bar item"
        var headerItemLinksParent = subSideBar.parent().parent()
          .siblings('.rsv-main-area-container')
          .find('.rsv-main-area-header-row')
          .find('.rsv-main-area-header-bar');
        var currentSubSideBarText = subSideBar[0].innerText;
        var targetHeaderItemLink = headerItemLinksParent.find($(':contains("' + currentSubSideBarText + '")'));
        targetHeaderItemLink.nextAll().remove();
      });
    };

    var appendHeaderBarItem = function (title, headerBar, callback) {
      $('.modified-dom')
        .addClass('my-2 p-1')
        .css({ 'border': '1px dashed #886ab5', 'display': 'grid' });
      var icon = $("<span>")
        .addClass('rsv-header-item-icon');
      headerBar.append(icon);

      var headerItemLink = $("<a>").addClass("rsv-header-item-link").text(title);
      $('.rsv-ribbon span').text(headerItemLink.text());
      // headerBar.text(headerItemLink.text());

      headerItemLink.click(function () {
        // When select specific header item link, then all next header item links
        // must be removed ...
        var currentHeaderItemLink = this;
        $(currentHeaderItemLink).nextAll().remove();

        // and its main area & features must be retrieved
        if (callback && callback instanceof Function) {
          callback();
        }

        // and this must be reflected on sub side bars items since they represent same view,
        // so we retrieve the "sub side bar item" which matches(similar to) "current header item link"
        var subSideBars = $(currentHeaderItemLink).parent().parent().parent()
          .siblings('.rsv-side-bar-col')
          .find('.rsv-subside-bar');
        var currentHeaderItemLinkText = $(currentHeaderItemLink)[0].innerText;
        var targetSubSideBsrItem = subSideBars.find($(':contains("' + currentHeaderItemLinkText + '")')).parent();
        targetSubSideBsrItem.nextAll().remove();
      });
    };

    //#endregion _______ Side Bar , Header Bar _______

    //#endregion _____________________ Private Methods _____________________

    //#region ______________ Public Method ______________

    RealStateViewer.prototype.renderOn = function (container) {
      var item = this.options.item;
      var itemFields = this.options.itemSchema ? this.options.itemSchema.fields : [];
      itemFields = getItemFieldsAndSubFields(itemFields, item.type);

      var itemContainer = $("<div>")
        .addClass("container-fluid property-container")
        .addClass("rsv-item-container")
        .appendTo(container);

      // First Row
      var itemRow = $("<div>")
        .addClass("row")
        .addClass("rsv-item-row")
        .appendTo(itemContainer);

      // First Row >> First column
      var sideBarColumn = $("<div>")
        .addClass("rsv-side-bar-col")
        .appendTo(itemRow);

      var sideBar = $("<div>")
        .addClass("rsv-side-bar");
      // .appendTo(sideBarColumn);

      // First Row >> Second column 
      var mainAreaContainer = $("<div>")
        .addClass("rsv-main-area-container")
        .addClass("col-lg-12 col-xl-12")
        .appendTo(itemRow);
      var itemName = getItemTitle.call(this, item, (item.name || "") + " " + item.type);
      if (itemName) {
        $(`<span class="rsv-ribbon">
            <span>${item.type}</span>
          </span>`)
          .appendTo(itemRow);
      }
      // First Row >> Second column >> First Row
      var mainAreaHeaderRow = $("<div>")
        .addClass("row")
        .addClass("rsv-main-area-header-row")
        .appendTo(mainAreaContainer);

      var headerBar = $("<div>")
        .addClass("rsv-main-area-header-bar")
        .appendTo(mainAreaHeaderRow);

      // First Row >> Second column >> Second Row
      // var itemName = getItemTitle.call(this, item, (item.name || "") + " " + item.type);
      // if (itemName) {
      //   var itemNameContainer = $(`
      //   <div class="row m-1 rsv-item-name">
      //     <p class="rsv-ribbon">
      //       <span class="rsv-text">${itemName}</span>
      //     </p>
      //   </div>`).appendTo(mainAreaContainer);
      // }
      // First Row >> Second column >> Third Row
      var mainArea = $("<div>")
        .addClass("row")
        .addClass("rsv-main-area")
        .appendTo(mainAreaContainer);

      //TODO  
      var addressRow = $("<div>")
        .addClass("row")
        .addClass("rsv-address-row");
      itemContainer.append(addressRow);
      if (item.addresslatlng) {
        renderAddress.call(this, item.addresslatlng, addressRow);
      };
      renderItem.call(this, item, itemFields, sideBar, headerBar, mainArea);
      var offerSummary = this.options.offerSummary;
      container.append(offerSummary);

      closeBtn.click(function () {
        $(this).hide();
        $('.modified-dom').removeAttr('style');
        $('.modified-dom').empty();
        $('.container-fluid.property-container').css('padding-bottom', '0px');
        $('.col-lg-5 .detailed-info-col').empty();
        carouselColumn.empty();
        renderPhotos(itemPhotos, '', $('.modified-dom'), item);
        $('.rsv-ribbon span').text(item.type);
        // equalize heights of divs
        var leftSideHeight = $('.info-container').css('height');
        $('.detailed-info-col .tab-content').css('max-height', leftSideHeight);
      });
    };

    //#endregion ______________ Public Method ______________

    return RealStateViewer;
  }();

  $.fn.RealStateViewer = function (options) {
    $(this).each(function () {
      if (!$.data(this, "RealStateViewer")) {
        var viewer = new Specto.ui.RealStateViewer(options);
        viewer.renderOn($(this));

        $.data(this, "RealStateViewer", viewer);
      }
    });
    return this;
  }

})(jQuery);
/*!
 * justifiedGallery - v3.7.0
 * http://miromannino.github.io/Justified-Gallery/
 * Copyright (c) 2018 Miro Mannino
 * Licensed under the MIT license.
 */
(function (factory) {
  if (typeof define === 'function' && define.amd) {
    // AMD. Register as an anonymous module.
    define(['jquery'], factory);
  } else if (typeof module === 'object' && module.exports) {
    // Node/CommonJS
    module.exports = function( root, jQuery ) {
      if ( jQuery === undefined ) {
        // require('jQuery') returns a factory that requires window to
        // build a jQuery instance, we normalize how we use modules
        // that require this pattern but the window provided is a noop
        // if it's defined (how jquery works)
        if ( typeof window !== 'undefined' ) {
          jQuery = require('jquery');
        }
        else {
          jQuery = require('jquery')(root);
        }
      }
      factory(jQuery);
      return jQuery;
    };
  } else {
    // Browser globals
    factory(jQuery);
  }
}(function ($) {

  /**
   * Justified Gallery controller constructor
   *
   * @param $gallery the gallery to build
   * @param settings the settings (the defaults are in JustifiedGallery.defaults)
   * @constructor
   */
  var JustifiedGallery = function ($gallery, settings) {
  
    this.settings = settings;
    this.checkSettings();
  
    this.imgAnalyzerTimeout = null;
    this.entries = null;
    this.buildingRow = {
      entriesBuff : [],
      width : 0,
      height : 0,
      aspectRatio : 0
    };
    this.lastFetchedEntry = null;
    this.lastAnalyzedIndex = -1;
    this.yield = {
      every : 2, // do a flush every n flushes (must be greater than 1)
      flushed : 0 // flushed rows without a yield
    };
    this.border = settings.border >= 0 ? settings.border : settings.margins;
    this.maxRowHeight = this.retrieveMaxRowHeight();
    this.suffixRanges = this.retrieveSuffixRanges();
    this.offY = this.border;
    this.rows = 0;
    this.spinner = {
      phase : 0,
      timeSlot : 150,
      $el : $('<div class="spinner"><span></span><span></span><span></span></div>'),
      intervalId : null
    };
    this.scrollBarOn = false;
    this.checkWidthIntervalId = null;
    this.galleryWidth = $gallery.width();
    this.$gallery = $gallery;
  
  };
  
  /** @returns {String} the best suffix given the width and the height */
  JustifiedGallery.prototype.getSuffix = function (width, height) {
    var longestSide, i;
    longestSide = (width > height) ? width : height;
    for (i = 0; i < this.suffixRanges.length; i++) {
      if (longestSide <= this.suffixRanges[i]) {
        return this.settings.sizeRangeSuffixes[this.suffixRanges[i]];
      }
    }
    return this.settings.sizeRangeSuffixes[this.suffixRanges[i - 1]];
  };
  
  /**
   * Remove the suffix from the string
   *
   * @returns {string} a new string without the suffix
   */
  JustifiedGallery.prototype.removeSuffix = function (str, suffix) {
    return str.substring(0, str.length - suffix.length);
  };
  
  /**
   * @returns {boolean} a boolean to say if the suffix is contained in the str or not
   */
  JustifiedGallery.prototype.endsWith = function (str, suffix) {
    return str.indexOf(suffix, str.length - suffix.length) !== -1;
  };
  
  /**
   * Get the used suffix of a particular url
   *
   * @param str
   * @returns {String} return the used suffix
   */
  JustifiedGallery.prototype.getUsedSuffix = function (str) {
    for (var si in this.settings.sizeRangeSuffixes) {
      if (this.settings.sizeRangeSuffixes.hasOwnProperty(si)) {
        if (this.settings.sizeRangeSuffixes[si].length === 0) continue;
        if (this.endsWith(str, this.settings.sizeRangeSuffixes[si])) return this.settings.sizeRangeSuffixes[si];
      }
    }
    return '';
  };
  
  /**
   * Given an image src, with the width and the height, returns the new image src with the
   * best suffix to show the best quality thumbnail.
   *
   * @returns {String} the suffix to use
   */
  JustifiedGallery.prototype.newSrc = function (imageSrc, imgWidth, imgHeight, image) {
    var newImageSrc;
  
    if (this.settings.thumbnailPath) {
      newImageSrc = this.settings.thumbnailPath(imageSrc, imgWidth, imgHeight, image);
    } else {
      var matchRes = imageSrc.match(this.settings.extension);
      var ext = (matchRes !== null) ? matchRes[0] : '';
      newImageSrc = imageSrc.replace(this.settings.extension, '');
      newImageSrc = this.removeSuffix(newImageSrc, this.getUsedSuffix(newImageSrc));
      newImageSrc += this.getSuffix(imgWidth, imgHeight) + ext;
    }
  
    return newImageSrc;
  };
  
  /**
   * Shows the images that is in the given entry
   *
   * @param $entry the entry
   * @param callback the callback that is called when the show animation is finished
   */
  JustifiedGallery.prototype.showImg = function ($entry, callback) {
    if (this.settings.cssAnimation) {
      $entry.addClass('entry-visible');
      if (callback) callback();
    } else {
      $entry.stop().fadeTo(this.settings.imagesAnimationDuration, 1.0, callback);
      $entry.find(this.settings.imgSelector).stop().fadeTo(this.settings.imagesAnimationDuration, 1.0, callback);
    }
  };
  
  /**
   * Extract the image src form the image, looking from the 'safe-src', and if it can't be found, from the
   * 'src' attribute. It saves in the image data the 'jg.originalSrc' field, with the extracted src.
   *
   * @param $image the image to analyze
   * @returns {String} the extracted src
   */
  JustifiedGallery.prototype.extractImgSrcFromImage = function ($image) {
    var imageSrc = (typeof $image.data('safe-src') !== 'undefined') ? $image.data('safe-src') : $image.attr('src');
    $image.data('jg.originalSrc', imageSrc);
    return imageSrc;
  };
  
  /** @returns {jQuery} the image in the given entry */
  JustifiedGallery.prototype.imgFromEntry = function ($entry) {
    var $img = $entry.find(this.settings.imgSelector);
    return $img.length === 0 ? null : $img;
  };
  
  /** @returns {jQuery} the caption in the given entry */
  JustifiedGallery.prototype.captionFromEntry = function ($entry) {
    var $caption = $entry.find('> .caption');
    return $caption.length === 0 ? null : $caption;
  };
  
  /**
   * Display the entry
   *
   * @param {jQuery} $entry the entry to display
   * @param {int} x the x position where the entry must be positioned
   * @param y the y position where the entry must be positioned
   * @param imgWidth the image width
   * @param imgHeight the image height
   * @param rowHeight the row height of the row that owns the entry
   */
  JustifiedGallery.prototype.displayEntry = function ($entry, x, y, imgWidth, imgHeight, rowHeight) {
    $entry.width(imgWidth);
    $entry.height(rowHeight);
    $entry.css('top', y);
    $entry.css('left', x);
  
    var $image = this.imgFromEntry($entry);
    if ($image !== null) {
      $image.css('width', imgWidth);
      $image.css('height', imgHeight);
      $image.css('margin-left', - imgWidth / 2);
      $image.css('margin-top', - imgHeight / 2);
  
      // Image reloading for an high quality of thumbnails
      var imageSrc = $image.attr('src');
      var newImageSrc = this.newSrc(imageSrc, imgWidth, imgHeight, $image[0]);
  
      $image.one('error', function () {
        $image.attr('src', $image.data('jg.originalSrc')); //revert to the original thumbnail, we got it.
      });
  
      var loadNewImage = function () {
        if (imageSrc !== newImageSrc) { //load the new image after the fadeIn
          $image.attr('src', newImageSrc);
        }
      };
  
      if ($entry.data('jg.loaded') === 'skipped') {
        this.onImageEvent(imageSrc, $.proxy(function() {
          this.showImg($entry, loadNewImage);
          $entry.data('jg.loaded', true);
        }, this));
      } else {
        this.showImg($entry, loadNewImage);
      }
  
    } else {
      this.showImg($entry);
    }
  
    this.displayEntryCaption($entry);
  };
  
  /**
   * Display the entry caption. If the caption element doesn't exists, it creates the caption using the 'alt'
   * or the 'title' attributes.
   *
   * @param {jQuery} $entry the entry to process
   */
  JustifiedGallery.prototype.displayEntryCaption = function ($entry) {
    var $image = this.imgFromEntry($entry);
    if ($image !== null && this.settings.captions) {
      var $imgCaption = this.captionFromEntry($entry);
  
      // Create it if it doesn't exists
      if ($imgCaption === null) {
        var caption = $image.attr('alt');
        if (!this.isValidCaption(caption)) caption = $entry.attr('title');
        if (this.isValidCaption(caption)) { // Create only we found something
          $imgCaption = $('<div class="caption">' + caption + '</div>');
          $entry.append($imgCaption);
          $entry.data('jg.createdCaption', true);
        }
      }
  
      // Create events (we check again the $imgCaption because it can be still inexistent)
      if ($imgCaption !== null) {
        if (!this.settings.cssAnimation) $imgCaption.stop().fadeTo(0, this.settings.captionSettings.nonVisibleOpacity);
        this.addCaptionEventsHandlers($entry);
      }
    } else {
      this.removeCaptionEventsHandlers($entry);
    }
  };
  
  /**
   * Validates the caption
   *
   * @param caption The caption that should be validated
   * @return {boolean} Validation result
   */
  JustifiedGallery.prototype.isValidCaption = function (caption) {
    return (typeof caption !== 'undefined' && caption.length > 0);
  };
  
  /**
   * The callback for the event 'mouseenter'. It assumes that the event currentTarget is an entry.
   * It shows the caption using jQuery (or using CSS if it is configured so)
   *
   * @param {Event} eventObject the event object
   */
  JustifiedGallery.prototype.onEntryMouseEnterForCaption = function (eventObject) {
    var $caption = this.captionFromEntry($(eventObject.currentTarget));
    if (this.settings.cssAnimation) {
      $caption.addClass('caption-visible').removeClass('caption-hidden');
    } else {
      $caption.stop().fadeTo(this.settings.captionSettings.animationDuration,
          this.settings.captionSettings.visibleOpacity);
    }
  };
  
  /**
   * The callback for the event 'mouseleave'. It assumes that the event currentTarget is an entry.
   * It hides the caption using jQuery (or using CSS if it is configured so)
   *
   * @param {Event} eventObject the event object
   */
  JustifiedGallery.prototype.onEntryMouseLeaveForCaption = function (eventObject) {
    var $caption = this.captionFromEntry($(eventObject.currentTarget));
    if (this.settings.cssAnimation) {
      $caption.removeClass('caption-visible').removeClass('caption-hidden');
    } else {
      $caption.stop().fadeTo(this.settings.captionSettings.animationDuration,
          this.settings.captionSettings.nonVisibleOpacity);
    }
  };
  
  /**
   * Add the handlers of the entry for the caption
   *
   * @param $entry the entry to modify
   */
  JustifiedGallery.prototype.addCaptionEventsHandlers = function ($entry) {
    var captionMouseEvents = $entry.data('jg.captionMouseEvents');
    if (typeof captionMouseEvents === 'undefined') {
      captionMouseEvents = {
        mouseenter: $.proxy(this.onEntryMouseEnterForCaption, this),
        mouseleave: $.proxy(this.onEntryMouseLeaveForCaption, this)
      };
      $entry.on('mouseenter', undefined, undefined, captionMouseEvents.mouseenter);
      $entry.on('mouseleave', undefined, undefined, captionMouseEvents.mouseleave);
      $entry.data('jg.captionMouseEvents', captionMouseEvents);
    }
  };
  
  /**
   * Remove the handlers of the entry for the caption
   *
   * @param $entry the entry to modify
   */
  JustifiedGallery.prototype.removeCaptionEventsHandlers = function ($entry) {
    var captionMouseEvents = $entry.data('jg.captionMouseEvents');
    if (typeof captionMouseEvents !== 'undefined') {
      $entry.off('mouseenter', undefined, captionMouseEvents.mouseenter);
      $entry.off('mouseleave', undefined, captionMouseEvents.mouseleave);
      $entry.removeData('jg.captionMouseEvents');
    }
  };
  
  /**
   * Clear the building row data to be used for a new row
   */
  JustifiedGallery.prototype.clearBuildingRow = function () {
    this.buildingRow.entriesBuff = [];
    this.buildingRow.aspectRatio = 0;
    this.buildingRow.width = 0;
  };
  
  /**
   * Justify the building row, preparing it to
   *
   * @param isLastRow
   * @returns a boolean to know if the row has been justified or not
   */
  JustifiedGallery.prototype.prepareBuildingRow = function (isLastRow) {
    var i, $entry, imgAspectRatio, newImgW, newImgH, justify = true;
    var minHeight = 0;
    var availableWidth = this.galleryWidth - 2 * this.border - (
        (this.buildingRow.entriesBuff.length - 1) * this.settings.margins);
    var rowHeight = availableWidth / this.buildingRow.aspectRatio;
    var defaultRowHeight = this.settings.rowHeight;
    var justifiable = this.buildingRow.width / availableWidth > this.settings.justifyThreshold;
  
    //Skip the last row if we can't justify it and the lastRow == 'hide'
    if (isLastRow && this.settings.lastRow === 'hide' && !justifiable) {
      for (i = 0; i < this.buildingRow.entriesBuff.length; i++) {
        $entry = this.buildingRow.entriesBuff[i];
        if (this.settings.cssAnimation)
          $entry.removeClass('entry-visible');
        else {
          $entry.stop().fadeTo(0, 0.1);
          $entry.find('> img, > a > img').fadeTo(0, 0);
        }
      }
      return -1;
    }
  
    // With lastRow = nojustify, justify if is justificable (the images will not become too big)
    if (isLastRow && !justifiable && this.settings.lastRow !== 'justify' && this.settings.lastRow !== 'hide') {
      justify = false;
  
      if (this.rows > 0) {
        defaultRowHeight = (this.offY - this.border - this.settings.margins * this.rows) / this.rows;
        justify = defaultRowHeight * this.buildingRow.aspectRatio / availableWidth > this.settings.justifyThreshold;
      }
    }
  
    for (i = 0; i < this.buildingRow.entriesBuff.length; i++) {
      $entry = this.buildingRow.entriesBuff[i];
      imgAspectRatio = $entry.data('jg.width') / $entry.data('jg.height');
  
      if (justify) {
        newImgW = (i === this.buildingRow.entriesBuff.length - 1) ? availableWidth : rowHeight * imgAspectRatio;
        newImgH = rowHeight;
      } else {
        newImgW = defaultRowHeight * imgAspectRatio;
        newImgH = defaultRowHeight;
      }
  
      availableWidth -= Math.round(newImgW);
      $entry.data('jg.jwidth', Math.round(newImgW));
      $entry.data('jg.jheight', Math.ceil(newImgH));
      if (i === 0 || minHeight > newImgH) minHeight = newImgH;
    }
  
    this.buildingRow.height = minHeight;
    return justify;
  };
  
  /**
   * Flush a row: justify it, modify the gallery height accordingly to the row height
   *
   * @param isLastRow
   */
  JustifiedGallery.prototype.flushRow = function (isLastRow) {
    var settings = this.settings;
    var $entry, buildingRowRes, offX = this.border, i;
  
    buildingRowRes = this.prepareBuildingRow(isLastRow);
    if (isLastRow && settings.lastRow === 'hide' && buildingRowRes === -1) {
      this.clearBuildingRow();
      return;
    }
  
    if(this.maxRowHeight) {
      if(this.maxRowHeight < this.buildingRow.height)  this.buildingRow.height = this.maxRowHeight;
    }
  
    //Align last (unjustified) row
    if (isLastRow && (settings.lastRow === 'center' || settings.lastRow === 'right')) {
      var availableWidth = this.galleryWidth - 2 * this.border - (this.buildingRow.entriesBuff.length - 1) * settings.margins;
  
      for (i = 0; i < this.buildingRow.entriesBuff.length; i++) {
        $entry = this.buildingRow.entriesBuff[i];
        availableWidth -= $entry.data('jg.jwidth');
      }
  
      if (settings.lastRow === 'center')
        offX += availableWidth / 2;
      else if (settings.lastRow === 'right')
        offX += availableWidth;
    }
  
    var lastEntryIdx = this.buildingRow.entriesBuff.length - 1;
    for (i = 0; i <= lastEntryIdx; i++) {
      $entry = this.buildingRow.entriesBuff[ this.settings.rtl ? lastEntryIdx - i : i ];
      this.displayEntry($entry, offX, this.offY, $entry.data('jg.jwidth'), $entry.data('jg.jheight'), this.buildingRow.height);
      offX += $entry.data('jg.jwidth') + settings.margins;
    }
  
    //Gallery Height
    this.galleryHeightToSet = this.offY + this.buildingRow.height + this.border;
    this.setGalleryTempHeight(this.galleryHeightToSet + this.getSpinnerHeight());
  
    if (!isLastRow || (this.buildingRow.height <= settings.rowHeight && buildingRowRes)) {
      //Ready for a new row
      this.offY += this.buildingRow.height + settings.margins;
      this.rows += 1;
      this.clearBuildingRow();
      this.settings.triggerEvent.call(this, 'jg.rowflush');
    }
  };
  
  
  // Scroll position not restoring: https://github.com/miromannino/Justified-Gallery/issues/221
  var galleryPrevStaticHeight = 0;
  
  JustifiedGallery.prototype.rememberGalleryHeight = function () {
    galleryPrevStaticHeight = this.$gallery.height();
    this.$gallery.height(galleryPrevStaticHeight);
  };
  
  // grow only
  JustifiedGallery.prototype.setGalleryTempHeight = function (height) {
    galleryPrevStaticHeight = Math.max(height, galleryPrevStaticHeight);
    this.$gallery.height(galleryPrevStaticHeight);
  };
  
  JustifiedGallery.prototype.setGalleryFinalHeight = function (height) {
    galleryPrevStaticHeight = height;
    this.$gallery.height(height);
  };
  
  /**
   * @returns {boolean} a boolean saying if the scrollbar is active or not
   */
  function hasScrollBar() {
    return $("body").height() > $(window).height();
  }
  
  /**
   * Checks the width of the gallery container, to know if a new justification is needed
   */
  JustifiedGallery.prototype.checkWidth = function () {
    this.checkWidthIntervalId = setInterval($.proxy(function () {
  
      // if the gallery is not currently visible, abort.
      if (!this.$gallery.is(":visible")) return;
  
      var galleryWidth = parseFloat(this.$gallery.width());
      if (hasScrollBar() === this.scrollBarOn) {
        if (Math.abs(galleryWidth - this.galleryWidth) > this.settings.refreshSensitivity) {
          this.galleryWidth = galleryWidth;
          this.rewind();
  
          this.rememberGalleryHeight();
  
          // Restart to analyze
          this.startImgAnalyzer(true);
        }
      } else {
        this.scrollBarOn = hasScrollBar();
        this.galleryWidth = galleryWidth;
      }
    }, this), this.settings.refreshTime);
  };
  
  /**
   * @returns {boolean} a boolean saying if the spinner is active or not
   */
  JustifiedGallery.prototype.isSpinnerActive = function () {
    return this.spinner.intervalId !== null;
  };
  
  /**
   * @returns {int} the spinner height
   */
  JustifiedGallery.prototype.getSpinnerHeight = function () {
    return this.spinner.$el.innerHeight();
  };
  
  /**
   * Stops the spinner animation and modify the gallery height to exclude the spinner
   */
  JustifiedGallery.prototype.stopLoadingSpinnerAnimation = function () {
    clearInterval(this.spinner.intervalId);
    this.spinner.intervalId = null;
    this.setGalleryTempHeight(this.$gallery.height() - this.getSpinnerHeight());
    this.spinner.$el.detach();
  };
  
  /**
   * Starts the spinner animation
   */
  JustifiedGallery.prototype.startLoadingSpinnerAnimation = function () {
    var spinnerContext = this.spinner;
    var $spinnerPoints = spinnerContext.$el.find('span');
    clearInterval(spinnerContext.intervalId);
    this.$gallery.append(spinnerContext.$el);
    this.setGalleryTempHeight(this.offY + this.buildingRow.height + this.getSpinnerHeight());
    spinnerContext.intervalId = setInterval(function () {
      if (spinnerContext.phase < $spinnerPoints.length) {
        $spinnerPoints.eq(spinnerContext.phase).fadeTo(spinnerContext.timeSlot, 1);
      } else {
        $spinnerPoints.eq(spinnerContext.phase - $spinnerPoints.length).fadeTo(spinnerContext.timeSlot, 0);
      }
      spinnerContext.phase = (spinnerContext.phase + 1) % ($spinnerPoints.length * 2);
    }, spinnerContext.timeSlot);
  };
  
  /**
   * Rewind the image analysis to start from the first entry.
   */
  JustifiedGallery.prototype.rewind = function () {
    this.lastFetchedEntry = null;
    this.lastAnalyzedIndex = -1;
    this.offY = this.border;
    this.rows = 0;
    this.clearBuildingRow();
  };
  
  /**
   * Update the entries searching it from the justified gallery HTML element
   *
   * @param norewind if norewind only the new entries will be changed (i.e. randomized, sorted or filtered)
   * @returns {boolean} true if some entries has been founded
   */
  JustifiedGallery.prototype.updateEntries = function (norewind) {
    var newEntries;
  
    if (norewind && this.lastFetchedEntry != null) {
      newEntries = $(this.lastFetchedEntry).nextAll(this.settings.selector).toArray();
    } else {
      this.entries = [];
      newEntries = this.$gallery.children(this.settings.selector).toArray();
    }
  
    if (newEntries.length > 0) {
  
      // Sort or randomize
      if ($.isFunction(this.settings.sort)) {
        newEntries = this.sortArray(newEntries);
      } else if (this.settings.randomize) {
        newEntries = this.shuffleArray(newEntries);
      }
      this.lastFetchedEntry = newEntries[newEntries.length - 1];
  
      // Filter
      if (this.settings.filter) {
        newEntries = this.filterArray(newEntries);
      } else {
        this.resetFilters(newEntries);
      }
  
    }
  
    this.entries = this.entries.concat(newEntries);
    return true;
  };
  
  /**
   * Apply the entries order to the DOM, iterating the entries and appending the images
   *
   * @param entries the entries that has been modified and that must be re-ordered in the DOM
   */
  JustifiedGallery.prototype.insertToGallery = function (entries) {
    var that = this;
    $.each(entries, function () {
      $(this).appendTo(that.$gallery);
    });
  };
  
  /**
   * Shuffle the array using the Fisher-Yates shuffle algorithm
   *
   * @param a the array to shuffle
   * @return the shuffled array
   */
  JustifiedGallery.prototype.shuffleArray = function (a) {
    var i, j, temp;
    for (i = a.length - 1; i > 0; i--) {
      j = Math.floor(Math.random() * (i + 1));
      temp = a[i];
      a[i] = a[j];
      a[j] = temp;
    }
    this.insertToGallery(a);
    return a;
  };
  
  /**
   * Sort the array using settings.comparator as comparator
   *
   * @param a the array to sort (it is sorted)
   * @return the sorted array
   */
  JustifiedGallery.prototype.sortArray = function (a) {
    a.sort(this.settings.sort);
    this.insertToGallery(a);
    return a;
  };
  
  /**
   * Reset the filters removing the 'jg-filtered' class from all the entries
   *
   * @param a the array to reset
   */
  JustifiedGallery.prototype.resetFilters = function (a) {
    for (var i = 0; i < a.length; i++) $(a[i]).removeClass('jg-filtered');
  };
  
  /**
   * Filter the entries considering theirs classes (if a string has been passed) or using a function for filtering.
   *
   * @param a the array to filter
   * @return the filtered array
   */
  JustifiedGallery.prototype.filterArray = function (a) {
    var settings = this.settings;
    if ($.type(settings.filter) === 'string') {
      // Filter only keeping the entries passed in the string
      return a.filter(function (el) {
        var $el = $(el);
        if ($el.is(settings.filter)) {
          $el.removeClass('jg-filtered');
          return true;
        } else {
          $el.addClass('jg-filtered').removeClass('jg-visible');
          return false;
        }
      });
    } else if ($.isFunction(settings.filter)) {
      // Filter using the passed function
      var filteredArr = a.filter(settings.filter);
      for (var i = 0; i < a.length; i++) {
        if (filteredArr.indexOf(a[i]) === -1) {
          $(a[i]).addClass('jg-filtered').removeClass('jg-visible');
        } else {
          $(a[i]).removeClass('jg-filtered');
        }
      }
      return filteredArr;
    }
  };
  
  /**
   * Destroy the Justified Gallery instance.
   *
   * It clears all the css properties added in the style attributes. We doesn't backup the original
   * values for those css attributes, because it costs (performance) and because in general one
   * shouldn't use the style attribute for an uniform set of images (where we suppose the use of
   * classes). Creating a backup is also difficult because JG could be called multiple times and
   * with different style attributes.
   */
  JustifiedGallery.prototype.destroy = function () {
    clearInterval(this.checkWidthIntervalId);
  
    $.each(this.entries, $.proxy(function(_, entry) {
      var $entry = $(entry);
  
      // Reset entry style
      $entry.css('width', '');
      $entry.css('height', '');
      $entry.css('top', '');
      $entry.css('left', '');
      $entry.data('jg.loaded', undefined);
      $entry.removeClass('jg-entry');
  
      // Reset image style
      var $img = this.imgFromEntry($entry);
      $img.css('width', '');
      $img.css('height', '');
      $img.css('margin-left', '');
      $img.css('margin-top', '');
      $img.attr('src', $img.data('jg.originalSrc'));
      $img.data('jg.originalSrc', undefined);
  
      // Remove caption
      this.removeCaptionEventsHandlers($entry);
      var $caption = this.captionFromEntry($entry);
      if ($entry.data('jg.createdCaption')) {
        // remove also the caption element (if created by jg)
        $entry.data('jg.createdCaption', undefined);
        if ($caption !== null) $caption.remove();
      } else {
        if ($caption !== null) $caption.fadeTo(0, 1);
      }
  
    }, this));
  
    this.$gallery.css('height', '');
    this.$gallery.removeClass('justified-gallery');
    this.$gallery.data('jg.controller', undefined);
  };
  
  /**
   * Analyze the images and builds the rows. It returns if it found an image that is not loaded.
   *
   * @param isForResize if the image analyzer is called for resizing or not, to call a different callback at the end
   */
  JustifiedGallery.prototype.analyzeImages = function (isForResize) {
    for (var i = this.lastAnalyzedIndex + 1; i < this.entries.length; i++) {
      var $entry = $(this.entries[i]);
      if ($entry.data('jg.loaded') === true || $entry.data('jg.loaded') === 'skipped') {
        var availableWidth = this.galleryWidth - 2 * this.border - (
            (this.buildingRow.entriesBuff.length - 1) * this.settings.margins);
        var imgAspectRatio = $entry.data('jg.width') / $entry.data('jg.height');
        if (availableWidth / (this.buildingRow.aspectRatio + imgAspectRatio) < this.settings.rowHeight) {
          this.flushRow(false);
  
          if(++this.yield.flushed >= this.yield.every) {
            this.startImgAnalyzer(isForResize);
            return;
          }
        }
  
        this.buildingRow.entriesBuff.push($entry);
        this.buildingRow.aspectRatio += imgAspectRatio;
        this.buildingRow.width += imgAspectRatio * this.settings.rowHeight;
        this.lastAnalyzedIndex = i;
  
      } else if ($entry.data('jg.loaded') !== 'error') {
        return;
      }
    }
  
    // Last row flush (the row is not full)
    if (this.buildingRow.entriesBuff.length > 0) this.flushRow(true);
  
    if (this.isSpinnerActive()) {
      this.stopLoadingSpinnerAnimation();
    }
  
    /* Stop, if there is, the timeout to start the analyzeImages.
     This is because an image can be set loaded, and the timeout can be set,
     but this image can be analyzed yet.
     */
    this.stopImgAnalyzerStarter();
  
    //On complete callback
    this.settings.triggerEvent.call(this, isForResize ? 'jg.resize' : 'jg.complete');
    this.setGalleryFinalHeight(this.galleryHeightToSet);
  };
  
  /**
   * Stops any ImgAnalyzer starter (that has an assigned timeout)
   */
  JustifiedGallery.prototype.stopImgAnalyzerStarter = function () {
    this.yield.flushed = 0;
    if (this.imgAnalyzerTimeout !== null) {
      clearTimeout(this.imgAnalyzerTimeout);
      this.imgAnalyzerTimeout = null;
    }
  };
  
  /**
   * Starts the image analyzer. It is not immediately called to let the browser to update the view
   *
   * @param isForResize specifies if the image analyzer must be called for resizing or not
   */
  JustifiedGallery.prototype.startImgAnalyzer = function (isForResize) {
    var that = this;
    this.stopImgAnalyzerStarter();
    this.imgAnalyzerTimeout = setTimeout(function () {
      that.analyzeImages(isForResize);
    }, 0.001); // we can't start it immediately due to a IE different behaviour
  };
  
  /**
   * Checks if the image is loaded or not using another image object. We cannot use the 'complete' image property,
   * because some browsers, with a 404 set complete = true.
   *
   * @param imageSrc the image src to load
   * @param onLoad callback that is called when the image has been loaded
   * @param onError callback that is called in case of an error
   */
  JustifiedGallery.prototype.onImageEvent = function (imageSrc, onLoad, onError) {
    if (!onLoad && !onError) return;
  
    var memImage = new Image();
    var $memImage = $(memImage);
    if (onLoad) {
      $memImage.one('load', function () {
        $memImage.off('load error');
        onLoad(memImage);
      });
    }
    if (onError) {
      $memImage.one('error', function() {
        $memImage.off('load error');
        onError(memImage);
      });
    }
    memImage.src = imageSrc;
  };
  
  /**
   * Init of Justified Gallery controlled
   * It analyzes all the entries starting theirs loading and calling the image analyzer (that works with loaded images)
   */
  JustifiedGallery.prototype.init = function () {
    var imagesToLoad = false, skippedImages = false, that = this;
    $.each(this.entries, function (index, entry) {
      var $entry = $(entry);
      var $image = that.imgFromEntry($entry);
  
      $entry.addClass('jg-entry');
  
      if ($entry.data('jg.loaded') !== true && $entry.data('jg.loaded') !== 'skipped') {
  
        // Link Rel global overwrite
        if (that.settings.rel !== null) $entry.attr('rel', that.settings.rel);
  
        // Link Target global overwrite
        if (that.settings.target !== null) $entry.attr('target', that.settings.target);
  
        if ($image !== null) {
  
          // Image src
          var imageSrc = that.extractImgSrcFromImage($image);
          $image.attr('src', imageSrc);
  
          /* If we have the height and the width, we don't wait that the image is loaded, but we start directly
           * with the justification */
          if (that.settings.waitThumbnailsLoad === false) {
            var width = parseFloat($image.prop('width'));
            var height = parseFloat($image.prop('height'));
            if (!isNaN(width) && !isNaN(height)) {
              $entry.data('jg.width', width);
              $entry.data('jg.height', height);
              $entry.data('jg.loaded', 'skipped');
              skippedImages = true;
              that.startImgAnalyzer(false);
              return true; // continue
            }
          }
  
          $entry.data('jg.loaded', false);
          imagesToLoad = true;
  
          // Spinner start
          if (!that.isSpinnerActive()) that.startLoadingSpinnerAnimation();
  
          that.onImageEvent(imageSrc, function (loadImg) { // image loaded
            $entry.data('jg.width', loadImg.width);
            $entry.data('jg.height', loadImg.height);
            $entry.data('jg.loaded', true);
            that.startImgAnalyzer(false);
          }, function () { // image load error
            $entry.data('jg.loaded', 'error');
            that.startImgAnalyzer(false);
          });
  
        } else {
          $entry.data('jg.loaded', true);
          $entry.data('jg.width', $entry.width() | parseFloat($entry.css('width')) | 1);
          $entry.data('jg.height', $entry.height() | parseFloat($entry.css('height')) | 1);
        }
  
      }
  
    });
  
    if (!imagesToLoad && !skippedImages) this.startImgAnalyzer(false);
    this.checkWidth();
  };
  
  /**
   * Checks that it is a valid number. If a string is passed it is converted to a number
   *
   * @param settingContainer the object that contains the setting (to allow the conversion)
   * @param settingName the setting name
   */
  JustifiedGallery.prototype.checkOrConvertNumber = function (settingContainer, settingName) {
    if ($.type(settingContainer[settingName]) === 'string') {
      settingContainer[settingName] = parseFloat(settingContainer[settingName]);
    }
  
    if ($.type(settingContainer[settingName]) === 'number') {
      if (isNaN(settingContainer[settingName])) throw 'invalid number for ' + settingName;
    } else {
      throw settingName + ' must be a number';
    }
  };
  
  /**
   * Checks the sizeRangeSuffixes and, if necessary, converts
   * its keys from string (e.g. old settings with 'lt100') to int.
   */
  JustifiedGallery.prototype.checkSizeRangesSuffixes = function () {
    if ($.type(this.settings.sizeRangeSuffixes) !== 'object') {
      throw 'sizeRangeSuffixes must be defined and must be an object';
    }
  
    var suffixRanges = [];
    for (var rangeIdx in this.settings.sizeRangeSuffixes) {
      if (this.settings.sizeRangeSuffixes.hasOwnProperty(rangeIdx)) suffixRanges.push(rangeIdx);
    }
  
    var newSizeRngSuffixes = {0: ''};
    for (var i = 0; i < suffixRanges.length; i++) {
      if ($.type(suffixRanges[i]) === 'string') {
        try {
          var numIdx = parseInt(suffixRanges[i].replace(/^[a-z]+/, ''), 10);
          newSizeRngSuffixes[numIdx] = this.settings.sizeRangeSuffixes[suffixRanges[i]];
        } catch (e) {
          throw 'sizeRangeSuffixes keys must contains correct numbers (' + e + ')';
        }
      } else {
        newSizeRngSuffixes[suffixRanges[i]] = this.settings.sizeRangeSuffixes[suffixRanges[i]];
      }
    }
  
    this.settings.sizeRangeSuffixes = newSizeRngSuffixes;
  };
  
  /**
   * check and convert the maxRowHeight setting
   * requires rowHeight to be already set
   * TODO: should be always called when only rowHeight is changed
   * @return number or null
   */
  JustifiedGallery.prototype.retrieveMaxRowHeight = function () {
    var newMaxRowHeight = null;
    var rowHeight = this.settings.rowHeight;
  
    if ($.type(this.settings.maxRowHeight) === 'string') {
      if (this.settings.maxRowHeight.match(/^[0-9]+%$/)) {
        newMaxRowHeight = rowHeight * parseFloat(this.settings.maxRowHeight.match(/^([0-9]+)%$/)[1]) / 100;
      } else {
        newMaxRowHeight = parseFloat(this.settings.maxRowHeight);
      }
    } else if ($.type(this.settings.maxRowHeight) === 'number') {
      newMaxRowHeight = this.settings.maxRowHeight;
    } else if (this.settings.maxRowHeight === false || this.settings.maxRowHeight == null) {
      return null;
    } else {
      throw 'maxRowHeight must be a number or a percentage';
    }
  
    // check if the converted value is not a number
    if (isNaN(newMaxRowHeight)) throw 'invalid number for maxRowHeight';
  
    // check values, maxRowHeight must be >= rowHeight
    if (newMaxRowHeight < rowHeight) newMaxRowHeight = rowHeight;
  
    return newMaxRowHeight;
  };
  
  /**
   * Checks the settings
   */
  JustifiedGallery.prototype.checkSettings = function () {
    this.checkSizeRangesSuffixes();
  
    this.checkOrConvertNumber(this.settings, 'rowHeight');
    this.checkOrConvertNumber(this.settings, 'margins');
    this.checkOrConvertNumber(this.settings, 'border');
  
    var lastRowModes = [
      'justify',
      'nojustify',
      'left',
      'center',
      'right',
      'hide'
    ];
    if (lastRowModes.indexOf(this.settings.lastRow) === -1) {
      throw 'lastRow must be one of: ' + lastRowModes.join(', ');
    }
  
    this.checkOrConvertNumber(this.settings, 'justifyThreshold');
    if (this.settings.justifyThreshold < 0 || this.settings.justifyThreshold > 1) {
      throw 'justifyThreshold must be in the interval [0,1]';
    }
    if ($.type(this.settings.cssAnimation) !== 'boolean') {
      throw 'cssAnimation must be a boolean';
    }
  
    if ($.type(this.settings.captions) !== 'boolean') throw 'captions must be a boolean';
    this.checkOrConvertNumber(this.settings.captionSettings, 'animationDuration');
  
    this.checkOrConvertNumber(this.settings.captionSettings, 'visibleOpacity');
    if (this.settings.captionSettings.visibleOpacity < 0 ||
        this.settings.captionSettings.visibleOpacity > 1) {
      throw 'captionSettings.visibleOpacity must be in the interval [0, 1]';
    }
  
    this.checkOrConvertNumber(this.settings.captionSettings, 'nonVisibleOpacity');
    if (this.settings.captionSettings.nonVisibleOpacity < 0 ||
        this.settings.captionSettings.nonVisibleOpacity > 1) {
      throw 'captionSettings.nonVisibleOpacity must be in the interval [0, 1]';
    }
  
    this.checkOrConvertNumber(this.settings, 'imagesAnimationDuration');
    this.checkOrConvertNumber(this.settings, 'refreshTime');
    this.checkOrConvertNumber(this.settings, 'refreshSensitivity');
    if ($.type(this.settings.randomize) !== 'boolean') throw 'randomize must be a boolean';
    if ($.type(this.settings.selector) !== 'string') throw 'selector must be a string';
  
    if (this.settings.sort !== false && !$.isFunction(this.settings.sort)) {
      throw 'sort must be false or a comparison function';
    }
  
    if (this.settings.filter !== false && !$.isFunction(this.settings.filter) &&
        $.type(this.settings.filter) !== 'string') {
      throw 'filter must be false, a string or a filter function';
    }
  };
  
  /**
   * It brings all the indexes from the sizeRangeSuffixes and it orders them. They are then sorted and returned.
   * @returns {Array} sorted suffix ranges
   */
  JustifiedGallery.prototype.retrieveSuffixRanges = function () {
    var suffixRanges = [];
    for (var rangeIdx in this.settings.sizeRangeSuffixes) {
      if (this.settings.sizeRangeSuffixes.hasOwnProperty(rangeIdx)) suffixRanges.push(parseInt(rangeIdx, 10));
    }
    suffixRanges.sort(function (a, b) { return a > b ? 1 : a < b ? -1 : 0; });
    return suffixRanges;
  };
  
  /**
   * Update the existing settings only changing some of them
   *
   * @param newSettings the new settings (or a subgroup of them)
   */
  JustifiedGallery.prototype.updateSettings = function (newSettings) {
    // In this case Justified Gallery has been called again changing only some options
    this.settings = $.extend({}, this.settings, newSettings);
    this.checkSettings();
  
    // As reported in the settings: negative value = same as margins, 0 = disabled
    this.border = this.settings.border >= 0 ? this.settings.border : this.settings.margins;
  
    this.maxRowHeight = this.retrieveMaxRowHeight();
    this.suffixRanges = this.retrieveSuffixRanges();
  };
  
  JustifiedGallery.prototype.defaults = {
    sizeRangeSuffixes: { }, /* e.g. Flickr configuration
        {
          100: '_t',  // used when longest is less than 100px
          240: '_m',  // used when longest is between 101px and 240px
          320: '_n',  // ...
          500: '',
          640: '_z',
          1024: '_b'  // used as else case because it is the last
        }
    */
    thumbnailPath: undefined, /* If defined, sizeRangeSuffixes is not used, and this function is used to determine the
    path relative to a specific thumbnail size. The function should accept respectively three arguments:
    current path, width and height */
    rowHeight: 120, // required? required to be > 0?
    maxRowHeight: false, // false or negative value to deactivate. Positive number to express the value in pixels,
                         // A string '[0-9]+%' to express in percentage (e.g. 300% means that the row height
                         // can't exceed 3 * rowHeight)
    margins: 1,
    border: -1, // negative value = same as margins, 0 = disabled, any other value to set the border
  
    lastRow: 'nojustify', // … which is the same as 'left', or can be 'justify', 'center', 'right' or 'hide'
  
    justifyThreshold: 0.90, /* if row width / available space > 0.90 it will be always justified
                             * (i.e. lastRow setting is not considered) */
    waitThumbnailsLoad: true,
    captions: true,
    cssAnimation: true,
    imagesAnimationDuration: 500, // ignored with css animations
    captionSettings: { // ignored with css animations
      animationDuration: 500,
      visibleOpacity: 0.7,
      nonVisibleOpacity: 0.0
    },
    rel: null, // rewrite the rel of each analyzed links
    target: null, // rewrite the target of all links
    extension: /\.[^.\\/]+$/, // regexp to capture the extension of an image
    refreshTime: 200, // time interval (in ms) to check if the page changes its width
    refreshSensitivity: 0, // change in width allowed (in px) without re-building the gallery
    randomize: false,
    rtl: false, // right-to-left mode
    sort: false, /*
      - false: to do not sort
      - function: to sort them using the function as comparator (see Array.prototype.sort())
    */
    filter: false, /*
      - false, null or undefined: for a disabled filter
      - a string: an entry is kept if entry.is(filter string) returns true
                  see jQuery's .is() function for further information
      - a function: invoked with arguments (entry, index, array). Return true to keep the entry, false otherwise.
                    It follows the specifications of the Array.prototype.filter() function of JavaScript.
    */
    selector: 'a, div:not(.spinner)', // The selector that is used to know what are the entries of the gallery
    imgSelector: '> img, > a > img', // The selector that is used to know what are the images of each entry
    triggerEvent: function (event) { // This is called to trigger events, the default behavior is to call $.trigger
      this.$gallery.trigger(event);  // Consider that 'this' is this set to the JustifiedGallery object, so it can
    }                                // access to fields such as $gallery, useful to trigger events with jQuery.
  };

  /**
   * Justified Gallery plugin for jQuery
   *
   * Events
   *  - jg.complete : called when all the gallery has been created
   *  - jg.resize : called when the gallery has been resized
   *  - jg.rowflush : when a new row appears
   *
   * @param arg the action (or the settings) passed when the plugin is called
   * @returns {*} the object itself
   */
  $.fn.justifiedGallery = function (arg) {
    return this.each(function (index, gallery) {

      var $gallery = $(gallery);
      $gallery.addClass('justified-gallery');

      var controller = $gallery.data('jg.controller');
      if (typeof controller === 'undefined') {
        // Create controller and assign it to the object data
        if (typeof arg !== 'undefined' && arg !== null && $.type(arg) !== 'object') {
          if (arg === 'destroy') return; // Just a call to an unexisting object
          throw 'The argument must be an object';
        }
        controller = new JustifiedGallery($gallery, $.extend({}, JustifiedGallery.prototype.defaults, arg));
        $gallery.data('jg.controller', controller);
      } else if (arg === 'norewind') {
        // In this case we don't rewind: we analyze only the latest images (e.g. to complete the last unfinished row
        // ... left to be more readable
      } else if (arg === 'destroy') {
        controller.destroy();
        return;
      } else {
        // In this case Justified Gallery has been called again changing only some options
        controller.updateSettings(arg);
        controller.rewind();
      }

      // Update the entries list
      if (!controller.updateEntries(arg === 'norewind')) return;

      // Init justified gallery
      controller.init();

    });
  };

}));
/*!
 * jQuery Mousewheel 3.1.13
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 */

(function (factory) {
    if ( typeof define === 'function' && define.amd ) {
        // AMD. Register as an anonymous module.
        define(['jquery'], factory);
    } else if (typeof exports === 'object') {
        // Node/CommonJS style for Browserify
        module.exports = factory;
    } else {
        // Browser globals
        factory(jQuery);
    }
}(function ($) {

    var toFix  = ['wheel', 'mousewheel', 'DOMMouseScroll', 'MozMousePixelScroll'],
        toBind = ( 'onwheel' in document || document.documentMode >= 9 ) ?
                    ['wheel'] : ['mousewheel', 'DomMouseScroll', 'MozMousePixelScroll'],
        slice  = Array.prototype.slice,
        nullLowestDeltaTimeout, lowestDelta;

    if ( $.event.fixHooks ) {
        for ( var i = toFix.length; i; ) {
            $.event.fixHooks[ toFix[--i] ] = $.event.mouseHooks;
        }
    }

    var special = $.event.special.mousewheel = {
        version: '3.1.12',

        setup: function() {
            if ( this.addEventListener ) {
                for ( var i = toBind.length; i; ) {
                    this.addEventListener( toBind[--i], handler, false );
                }
            } else {
                this.onmousewheel = handler;
            }
            // Store the line height and page height for this particular element
            $.data(this, 'mousewheel-line-height', special.getLineHeight(this));
            $.data(this, 'mousewheel-page-height', special.getPageHeight(this));
        },

        teardown: function() {
            if ( this.removeEventListener ) {
                for ( var i = toBind.length; i; ) {
                    this.removeEventListener( toBind[--i], handler, false );
                }
            } else {
                this.onmousewheel = null;
            }
            // Clean up the data we added to the element
            $.removeData(this, 'mousewheel-line-height');
            $.removeData(this, 'mousewheel-page-height');
        },

        getLineHeight: function(elem) {
            var $elem = $(elem),
                $parent = $elem['offsetParent' in $.fn ? 'offsetParent' : 'parent']();
            if (!$parent.length) {
                $parent = $('body');
            }
            return parseInt($parent.css('fontSize'), 10) || parseInt($elem.css('fontSize'), 10) || 16;
        },

        getPageHeight: function(elem) {
            return $(elem).height();
        },

        settings: {
            adjustOldDeltas: true, // see shouldAdjustOldDeltas() below
            normalizeOffset: true  // calls getBoundingClientRect for each event
        }
    };

    $.fn.extend({
        mousewheel: function(fn) {
            return fn ? this.bind('mousewheel', fn) : this.trigger('mousewheel');
        },

        unmousewheel: function(fn) {
            return this.unbind('mousewheel', fn);
        }
    });


    function handler(event) {
        var orgEvent   = event || window.event,
            args       = slice.call(arguments, 1),
            delta      = 0,
            deltaX     = 0,
            deltaY     = 0,
            absDelta   = 0,
            offsetX    = 0,
            offsetY    = 0;
        event = $.event.fix(orgEvent);
        event.type = 'mousewheel';

        // Old school scrollwheel delta
        if ( 'detail'      in orgEvent ) { deltaY = orgEvent.detail * -1;      }
        if ( 'wheelDelta'  in orgEvent ) { deltaY = orgEvent.wheelDelta;       }
        if ( 'wheelDeltaY' in orgEvent ) { deltaY = orgEvent.wheelDeltaY;      }
        if ( 'wheelDeltaX' in orgEvent ) { deltaX = orgEvent.wheelDeltaX * -1; }

        // Firefox < 17 horizontal scrolling related to DOMMouseScroll event
        if ( 'axis' in orgEvent && orgEvent.axis === orgEvent.HORIZONTAL_AXIS ) {
            deltaX = deltaY * -1;
            deltaY = 0;
        }

        // Set delta to be deltaY or deltaX if deltaY is 0 for backwards compatabilitiy
        delta = deltaY === 0 ? deltaX : deltaY;

        // New school wheel delta (wheel event)
        if ( 'deltaY' in orgEvent ) {
            deltaY = orgEvent.deltaY * -1;
            delta  = deltaY;
        }
        if ( 'deltaX' in orgEvent ) {
            deltaX = orgEvent.deltaX;
            if ( deltaY === 0 ) { delta  = deltaX * -1; }
        }

        // No change actually happened, no reason to go any further
        if ( deltaY === 0 && deltaX === 0 ) { return; }

        // Need to convert lines and pages to pixels if we aren't already in pixels
        // There are three delta modes:
        //   * deltaMode 0 is by pixels, nothing to do
        //   * deltaMode 1 is by lines
        //   * deltaMode 2 is by pages
        if ( orgEvent.deltaMode === 1 ) {
            var lineHeight = $.data(this, 'mousewheel-line-height');
            delta  *= lineHeight;
            deltaY *= lineHeight;
            deltaX *= lineHeight;
        } else if ( orgEvent.deltaMode === 2 ) {
            var pageHeight = $.data(this, 'mousewheel-page-height');
            delta  *= pageHeight;
            deltaY *= pageHeight;
            deltaX *= pageHeight;
        }

        // Store lowest absolute delta to normalize the delta values
        absDelta = Math.max( Math.abs(deltaY), Math.abs(deltaX) );

        if ( !lowestDelta || absDelta < lowestDelta ) {
            lowestDelta = absDelta;

            // Adjust older deltas if necessary
            if ( shouldAdjustOldDeltas(orgEvent, absDelta) ) {
                lowestDelta /= 40;
            }
        }

        // Adjust older deltas if necessary
        if ( shouldAdjustOldDeltas(orgEvent, absDelta) ) {
            // Divide all the things by 40!
            delta  /= 40;
            deltaX /= 40;
            deltaY /= 40;
        }

        // Get a whole, normalized value for the deltas
        delta  = Math[ delta  >= 1 ? 'floor' : 'ceil' ](delta  / lowestDelta);
        deltaX = Math[ deltaX >= 1 ? 'floor' : 'ceil' ](deltaX / lowestDelta);
        deltaY = Math[ deltaY >= 1 ? 'floor' : 'ceil' ](deltaY / lowestDelta);

        // Normalise offsetX and offsetY properties
        if ( special.settings.normalizeOffset && this.getBoundingClientRect ) {
            var boundingRect = this.getBoundingClientRect();
            offsetX = event.clientX - boundingRect.left;
            offsetY = event.clientY - boundingRect.top;
        }

        // Add information to the event object
        event.deltaX = deltaX;
        event.deltaY = deltaY;
        event.deltaFactor = lowestDelta;
        event.offsetX = offsetX;
        event.offsetY = offsetY;
        // Go ahead and set deltaMode to 0 since we converted to pixels
        // Although this is a little odd since we overwrite the deltaX/Y
        // properties with normalized deltas.
        event.deltaMode = 0;

        // Add event and delta to the front of the arguments
        args.unshift(event, delta, deltaX, deltaY);

        // Clearout lowestDelta after sometime to better
        // handle multiple device types that give different
        // a different lowestDelta
        // Ex: trackpad = 3 and mouse wheel = 120
        if (nullLowestDeltaTimeout) { clearTimeout(nullLowestDeltaTimeout); }
        nullLowestDeltaTimeout = setTimeout(nullLowestDelta, 200);

        return ($.event.dispatch || $.event.handle).apply(this, args);
    }

    function nullLowestDelta() {
        lowestDelta = null;
    }

    function shouldAdjustOldDeltas(orgEvent, absDelta) {
        // If this is an older event and the delta is divisable by 120,
        // then we are assuming that the browser is treating this as an
        // older mouse wheel event and that we should divide the deltas
        // by 40 to try and get a more usable deltaFactor.
        // Side note, this actually impacts the reported scroll distance
        // in older browsers and can cause scrolling to be slower than native.
        // Turn this off by setting $.event.special.mousewheel.settings.adjustOldDeltas to false.
        return special.settings.adjustOldDeltas && orgEvent.type === 'mousewheel' && absDelta % 120 === 0;
    }

}));

(function() {
    'use strict';

    var defaults = {

        mode: 'lg-slide',

        // Ex : 'ease'
        cssEasing: 'ease',

        //'for jquery animation'
        easing: 'linear',
        speed: 600,
        height: '100%',
        width: '100%',
        addClass: '',
        startClass: 'lg-start-zoom',
        backdropDuration: 150,
        hideBarsDelay: 6000,

        useLeft: false,

        closable: true,
        loop: true,
        escKey: true,
        keyPress: true,
        controls: true,
        slideEndAnimatoin: true,
        hideControlOnEnd: false,
        mousewheel: true,

        getCaptionFromTitleOrAlt: true,

        // .lg-item || '.lg-sub-html'
        appendSubHtmlTo: '.lg-sub-html',

        subHtmlSelectorRelative: false,

        /**
         * @desc number of preload slides
         * will exicute only after the current slide is fully loaded.
         *
         * @ex you clicked on 4th image and if preload = 1 then 3rd slide and 5th
         * slide will be loaded in the background after the 4th slide is fully loaded..
         * if preload is 2 then 2nd 3rd 5th 6th slides will be preloaded.. ... ...
         *
         */
        preload: 1,
        showAfterLoad: true,
        selector: '',
        selectWithin: '',
        nextHtml: '',
        prevHtml: '',

        // 0, 1
        index: false,

        iframeMaxWidth: '100%',

        download: true,
        counter: true,
        appendCounterTo: '.lg-toolbar',

        swipeThreshold: 50,
        enableSwipe: true,
        enableDrag: true,

        dynamic: false,
        dynamicEl: [],
        galleryId: 1
    };

    function Plugin(element, options) {

        // Current lightGallery element
        this.el = element;

        // Current jquery element
        this.$el = $(element);

        // lightGallery settings
        this.s = $.extend({}, defaults, options);

        // When using dynamic mode, ensure dynamicEl is an array
        if (this.s.dynamic && this.s.dynamicEl !== 'undefined' && this.s.dynamicEl.constructor === Array && !this.s.dynamicEl.length) {
            throw ('When using dynamic mode, you must also define dynamicEl as an Array.');
        }

        // lightGallery modules
        this.modules = {};

        // false when lightgallery complete first slide;
        this.lGalleryOn = false;

        this.lgBusy = false;

        // Timeout function for hiding controls;
        this.hideBartimeout = false;

        // To determine browser supports for touch events;
        this.isTouch = ('ontouchstart' in document.documentElement);

        // Disable hideControlOnEnd if sildeEndAnimation is true
        if (this.s.slideEndAnimatoin) {
            this.s.hideControlOnEnd = false;
        }

        // Gallery items
        if (this.s.dynamic) {
            this.$items = this.s.dynamicEl;
        } else {
            if (this.s.selector === 'this') {
                this.$items = this.$el;
            } else if (this.s.selector !== '') {
                if (this.s.selectWithin) {
                    this.$items = $(this.s.selectWithin).find(this.s.selector);
                } else {
                    this.$items = this.$el.find($(this.s.selector));
                }
            } else {
                this.$items = this.$el.children();
            }
        }

        // .lg-item
        this.$slide = '';

        // .lg-outer
        this.$outer = '';

        this.init();

        return this;
    }

    Plugin.prototype.init = function() {

        var _this = this;

        // s.preload should not be more than $item.length
        if (_this.s.preload > _this.$items.length) {
            _this.s.preload = _this.$items.length;
        }

        // if dynamic option is enabled execute immediately
        var _hash = window.location.hash;
        if (_hash.indexOf('lg=' + this.s.galleryId) > 0) {

            _this.index = parseInt(_hash.split('&slide=')[1], 10);

            $('body').addClass('lg-from-hash');
            if (!$('body').hasClass('lg-on')) {
                setTimeout(function() {
                    _this.build(_this.index);
                });

                $('body').addClass('lg-on');
            }
        }

        if (_this.s.dynamic) {

            _this.$el.trigger('onBeforeOpen.lg');

            _this.index = _this.s.index || 0;

            // prevent accidental double execution
            if (!$('body').hasClass('lg-on')) {
                setTimeout(function() {
                    _this.build(_this.index);
                    $('body').addClass('lg-on');
                });
            }
        } else {

            // Using different namespace for click because click event should not unbind if selector is same object('this')
            _this.$items.on('click.lgcustom', function(event) {

                // For IE8
                try {
                    event.preventDefault();
                    event.preventDefault();
                } catch (er) {
                    event.returnValue = false;
                }

                _this.$el.trigger('onBeforeOpen.lg');

                _this.index = _this.s.index || _this.$items.index(this);

                // prevent accidental double execution
                if (!$('body').hasClass('lg-on')) {
                    _this.build(_this.index);
                    $('body').addClass('lg-on');
                }
            });
        }

    };

    Plugin.prototype.build = function(index) {

        var _this = this;

        _this.structure();

        // module constructor
        $.each($.fn.lightGallery.modules, function(key) {
            _this.modules[key] = new $.fn.lightGallery.modules[key](_this.el);
        });

        // initiate slide function
        _this.slide(index, false, false, false);

        if (_this.s.keyPress) {
            _this.keyPress();
        }

        if (_this.$items.length > 1) {

            _this.arrow();

            setTimeout(function() {
                _this.enableDrag();
                _this.enableSwipe();
            }, 50);

            if (_this.s.mousewheel) {
                _this.mousewheel();
            }
        } else {
            _this.$slide.on('click.lg', function() {
                _this.$el.trigger('onSlideClick.lg');
            });
        }

        _this.counter();

        _this.closeGallery();

        _this.$el.trigger('onAfterOpen.lg');

        // Hide controllers if mouse doesn't move for some period
        _this.$outer.on('mousemove.lg click.lg touchstart.lg', function() {

            _this.$outer.removeClass('lg-hide-items');

            clearTimeout(_this.hideBartimeout);

            // Timeout will be cleared on each slide movement also
            _this.hideBartimeout = setTimeout(function() {
                _this.$outer.addClass('lg-hide-items');
            }, _this.s.hideBarsDelay);

        });

        _this.$outer.trigger('mousemove.lg');

    };

    Plugin.prototype.structure = function() {
        var list = '';
        var controls = '';
        var i = 0;
        var subHtmlCont = '';
        var template;
        var _this = this;

        $('body').append('<div class="lg-backdrop"></div>');
        $('.lg-backdrop').css('transition-duration', this.s.backdropDuration + 'ms');

        // Create gallery items
        for (i = 0; i < this.$items.length; i++) {
            list += '<div class="lg-item"></div>';
        }

        // Create controlls
        if (this.s.controls && this.$items.length > 1) {
            controls = '<div class="lg-actions">' +
                '<button class="lg-prev lg-icon">' + this.s.prevHtml + '</button>' +
                '<button class="lg-next lg-icon">' + this.s.nextHtml + '</button>' +
                '</div>';
        }

        if (this.s.appendSubHtmlTo === '.lg-sub-html') {
            subHtmlCont = '<div class="lg-sub-html"></div>';
        }

        template = '<div class="lg-outer ' + this.s.addClass + ' ' + this.s.startClass + '">' +
            '<div class="lg" style="width:' + this.s.width + '; height:' + this.s.height + '">' +
            '<div class="lg-inner">' + list + '</div>' +
            '<div class="lg-toolbar lg-group">' +
            '<span class="lg-close lg-icon"></span>' +
            '</div>' +
            controls +
            subHtmlCont +
            '</div>' +
            '</div>';

        $('body').append(template);
        this.$outer = $('.lg-outer');
        this.$slide = this.$outer.find('.lg-item');

        if (this.s.useLeft) {
            this.$outer.addClass('lg-use-left');

            // Set mode lg-slide if use left is true;
            this.s.mode = 'lg-slide';
        } else {
            this.$outer.addClass('lg-use-css3');
        }

        // For fixed height gallery
        _this.setTop();
        $(window).on('resize.lg orientationchange.lg', function() {
            setTimeout(function() {
                _this.setTop();
            }, 100);
        });

        // add class lg-current to remove initial transition
        this.$slide.eq(this.index).addClass('lg-current');

        // add Class for css support and transition mode
        if (this.doCss()) {
            this.$outer.addClass('lg-css3');
        } else {
            this.$outer.addClass('lg-css');

            // Set speed 0 because no animation will happen if browser doesn't support css3
            this.s.speed = 0;
        }

        this.$outer.addClass(this.s.mode);

        if (this.s.enableDrag && this.$items.length > 1) {
            this.$outer.addClass('lg-grab');
        }

        if (this.s.showAfterLoad) {
            this.$outer.addClass('lg-show-after-load');
        }

        if (this.doCss()) {
            var $inner = this.$outer.find('.lg-inner');
            $inner.css('transition-timing-function', this.s.cssEasing);
            $inner.css('transition-duration', this.s.speed + 'ms');
        }

        setTimeout(function() {
            $('.lg-backdrop').addClass('in');
        });

        setTimeout(function() {
            _this.$outer.addClass('lg-visible');
        }, this.s.backdropDuration);

        if (this.s.download) {
            this.$outer.find('.lg-toolbar').append('<a id="lg-download" target="_blank" download class="lg-download lg-icon"></a>');
        }

        // Store the current scroll top value to scroll back after closing the gallery..
        this.prevScrollTop = $(window).scrollTop();

    };

    // For fixed height gallery
    Plugin.prototype.setTop = function() {
        if (this.s.height !== '100%') {
            var wH = $(window).height();
            var top = (wH - parseInt(this.s.height, 10)) / 2;
            var $lGallery = this.$outer.find('.lg');
            if (wH >= parseInt(this.s.height, 10)) {
                $lGallery.css('top', top + 'px');
            } else {
                $lGallery.css('top', '0px');
            }
        }
    };

    // Find css3 support
    Plugin.prototype.doCss = function() {
        // check for css animation support
        var support = function() {
            var transition = ['transition', 'MozTransition', 'WebkitTransition', 'OTransition', 'msTransition', 'KhtmlTransition'];
            var root = document.documentElement;
            var i = 0;
            for (i = 0; i < transition.length; i++) {
                if (transition[i] in root.style) {
                    return true;
                }
            }
        };

        if (support()) {
            return true;
        }

        return false;
    };

    /**
     *  @desc Check the given src is video
     *  @param {String} src
     *  @return {Object} video type
     *  Ex:{ youtube  :  ["//www.youtube.com/watch?v=c0asJgSyxcY", "c0asJgSyxcY"] }
     */
    Plugin.prototype.isVideo = function(src, index) {

        var html;
        if (this.s.dynamic) {
            html = this.s.dynamicEl[index].html;
        } else {
            html = this.$items.eq(index).attr('data-html');
        }

        if (!src) {
            if(html) {
                return {
                    html5: true
                };
            } else {
                console.error('lightGallery :- data-src is not pvovided on slide item ' + (index + 1) + '. Please make sure the selector property is properly configured. More info - http://sachinchoolur.github.io/lightGallery/demos/html-markup.html');
                return false;
            }
        }

        var youtube = src.match(/\/\/(?:www\.)?youtu(?:\.be|be\.com|be-nocookie\.com)\/(?:watch\?v=|embed\/)?([a-z0-9\-\_\%]+)/i);
        var vimeo = src.match(/\/\/(?:www\.)?vimeo.com\/([0-9a-z\-_]+)/i);
        var dailymotion = src.match(/\/\/(?:www\.)?dai.ly\/([0-9a-z\-_]+)/i);
        var vk = src.match(/\/\/(?:www\.)?(?:vk\.com|vkontakte\.ru)\/(?:video_ext\.php\?)(.*)/i);

        if (youtube) {
            return {
                youtube: youtube
            };
        } else if (vimeo) {
            return {
                vimeo: vimeo
            };
        } else if (dailymotion) {
            return {
                dailymotion: dailymotion
            };
        } else if (vk) {
            return {
                vk: vk
            };
        }
    };

    /**
     *  @desc Create image counter
     *  Ex: 1/10
     */
    Plugin.prototype.counter = function() {
        if (this.s.counter) {
            $(this.s.appendCounterTo).append('<div id="lg-counter"><span id="lg-counter-current">' + (parseInt(this.index, 10) + 1) + '</span> / <span id="lg-counter-all">' + this.$items.length + '</span></div>');
        }
    };

    /**
     *  @desc add sub-html into the slide
     *  @param {Number} index - index of the slide
     */
    Plugin.prototype.addHtml = function(index) {
        var subHtml = null;
        var subHtmlUrl;
        var $currentEle;
        if (this.s.dynamic) {
            if (this.s.dynamicEl[index].subHtmlUrl) {
                subHtmlUrl = this.s.dynamicEl[index].subHtmlUrl;
            } else {
                subHtml = this.s.dynamicEl[index].subHtml;
            }
        } else {
            $currentEle = this.$items.eq(index);
            if ($currentEle.attr('data-sub-html-url')) {
                subHtmlUrl = $currentEle.attr('data-sub-html-url');
            } else {
                subHtml = $currentEle.attr('data-sub-html');
                if (this.s.getCaptionFromTitleOrAlt && !subHtml) {
                    subHtml = $currentEle.attr('title') || $currentEle.find('img').first().attr('alt');
                }
            }
        }

        if (!subHtmlUrl) {
            if (typeof subHtml !== 'undefined' && subHtml !== null) {

                // get first letter of subhtml
                // if first letter starts with . or # get the html form the jQuery object
                var fL = subHtml.substring(0, 1);
                if (fL === '.' || fL === '#') {
                    if (this.s.subHtmlSelectorRelative && !this.s.dynamic) {
                        subHtml = $currentEle.find(subHtml).html();
                    } else {
                        subHtml = $(subHtml).html();
                    }
                }
            } else {
                subHtml = '';
            }
        }

        if (this.s.appendSubHtmlTo === '.lg-sub-html') {

            if (subHtmlUrl) {
                this.$outer.find(this.s.appendSubHtmlTo).load(subHtmlUrl);
            } else {
                this.$outer.find(this.s.appendSubHtmlTo).html(subHtml);
            }

        } else {

            if (subHtmlUrl) {
                this.$slide.eq(index).load(subHtmlUrl);
            } else {
                this.$slide.eq(index).append(subHtml);
            }
        }

        // Add lg-empty-html class if title doesn't exist
        if (typeof subHtml !== 'undefined' && subHtml !== null) {
            if (subHtml === '') {
                this.$outer.find(this.s.appendSubHtmlTo).addClass('lg-empty-html');
            } else {
                this.$outer.find(this.s.appendSubHtmlTo).removeClass('lg-empty-html');
            }
        }

        this.$el.trigger('onAfterAppendSubHtml.lg', [index]);
    };

    /**
     *  @desc Preload slides
     *  @param {Number} index - index of the slide
     */
    Plugin.prototype.preload = function(index) {
        var i = 1;
        var j = 1;
        for (i = 1; i <= this.s.preload; i++) {
            if (i >= this.$items.length - index) {
                break;
            }

            this.loadContent(index + i, false, 0);
        }

        for (j = 1; j <= this.s.preload; j++) {
            if (index - j < 0) {
                break;
            }

            this.loadContent(index - j, false, 0);
        }
    };

    /**
     *  @desc Load slide content into slide.
     *  @param {Number} index - index of the slide.
     *  @param {Boolean} rec - if true call loadcontent() function again.
     *  @param {Boolean} delay - delay for adding complete class. it is 0 except first time.
     */
    Plugin.prototype.loadContent = function(index, rec, delay) {

        var _this = this;
        var _hasPoster = false;
        var _$img;
        var _src;
        var _poster;
        var _srcset;
        var _sizes;
        var _html;
        var getResponsiveSrc = function(srcItms) {
            var rsWidth = [];
            var rsSrc = [];
            for (var i = 0; i < srcItms.length; i++) {
                var __src = srcItms[i].split(' ');

                // Manage empty space
                if (__src[0] === '') {
                    __src.splice(0, 1);
                }

                rsSrc.push(__src[0]);
                rsWidth.push(__src[1]);
            }

            var wWidth = $(window).width();
            for (var j = 0; j < rsWidth.length; j++) {
                if (parseInt(rsWidth[j], 10) > wWidth) {
                    _src = rsSrc[j];
                    break;
                }
            }
        };

        if (_this.s.dynamic) {

            if (_this.s.dynamicEl[index].poster) {
                _hasPoster = true;
                _poster = _this.s.dynamicEl[index].poster;
            }

            _html = _this.s.dynamicEl[index].html;
            _src = _this.s.dynamicEl[index].src;

            if (_this.s.dynamicEl[index].responsive) {
                var srcDyItms = _this.s.dynamicEl[index].responsive.split(',');
                getResponsiveSrc(srcDyItms);
            }

            _srcset = _this.s.dynamicEl[index].srcset;
            _sizes = _this.s.dynamicEl[index].sizes;

        } else {

            if (_this.$items.eq(index).attr('data-poster')) {
                _hasPoster = true;
                _poster = _this.$items.eq(index).attr('data-poster');
            }

            _html = _this.$items.eq(index).attr('data-html');
            _src = _this.$items.eq(index).attr('href') || _this.$items.eq(index).attr('data-src');

            if (_this.$items.eq(index).attr('data-responsive')) {
                var srcItms = _this.$items.eq(index).attr('data-responsive').split(',');
                getResponsiveSrc(srcItms);
            }

            _srcset = _this.$items.eq(index).attr('data-srcset');
            _sizes = _this.$items.eq(index).attr('data-sizes');

        }

        //if (_src || _srcset || _sizes || _poster) {

        var iframe = false;
        if (_this.s.dynamic) {
            if (_this.s.dynamicEl[index].iframe) {
                iframe = true;
            }
        } else {
            if (_this.$items.eq(index).attr('data-iframe') === 'true') {
                iframe = true;
            }
        }

        var _isVideo = _this.isVideo(_src, index);
        if (!_this.$slide.eq(index).hasClass('lg-loaded')) {
            if (iframe) {
                _this.$slide.eq(index).prepend('<div class="lg-video-cont lg-has-iframe" style="max-width:' + _this.s.iframeMaxWidth + '"><div class="lg-video"><iframe class="lg-object" frameborder="0" src="' + _src + '"  allowfullscreen="true"></iframe></div></div>');
            } else if (_hasPoster) {
                var videoClass = '';
                if (_isVideo && _isVideo.youtube) {
                    videoClass = 'lg-has-youtube';
                } else if (_isVideo && _isVideo.vimeo) {
                    videoClass = 'lg-has-vimeo';
                } else {
                    videoClass = 'lg-has-html5';
                }

                _this.$slide.eq(index).prepend('<div class="lg-video-cont ' + videoClass + ' "><div class="lg-video"><span class="lg-video-play"></span><img class="lg-object lg-has-poster" src="' + _poster + '" /></div></div>');

            } else if (_isVideo) {
                _this.$slide.eq(index).prepend('<div class="lg-video-cont "><div class="lg-video"></div></div>');
                _this.$el.trigger('hasVideo.lg', [index, _src, _html]);
            } else {
                _this.$slide.eq(index).prepend('<div class="lg-img-wrap"><img class="lg-object lg-image" src="' + _src + '" /></div>');
            }

            _this.$el.trigger('onAferAppendSlide.lg', [index]);

            _$img = _this.$slide.eq(index).find('.lg-object');
            if (_sizes) {
                _$img.attr('sizes', _sizes);
            }

            if (_srcset) {
                _$img.attr('srcset', _srcset);
                try {
                    picturefill({
                        elements: [_$img[0]]
                    });
                } catch (e) {
                    console.warn('lightGallery :- If you want srcset to be supported for older browser please include picturefil version 2 javascript library in your document.');
                }
            }

            if (this.s.appendSubHtmlTo !== '.lg-sub-html') {
                _this.addHtml(index);
            }

            _this.$slide.eq(index).addClass('lg-loaded');
        }

        _this.$slide.eq(index).find('.lg-object').on('load.lg error.lg', function() {

            // For first time add some delay for displaying the start animation.
            var _speed = 0;

            // Do not change the delay value because it is required for zoom plugin.
            // If gallery opened from direct url (hash) speed value should be 0
            if (delay && !$('body').hasClass('lg-from-hash')) {
                _speed = delay;
            }

            setTimeout(function() {
                _this.$slide.eq(index).addClass('lg-complete');
                _this.$el.trigger('onSlideItemLoad.lg', [index, delay || 0]);
            }, _speed);

        });

        // @todo check load state for html5 videos
        if (_isVideo && _isVideo.html5 && !_hasPoster) {
            _this.$slide.eq(index).addClass('lg-complete');
        }

        if (rec === true) {
            if (!_this.$slide.eq(index).hasClass('lg-complete')) {
                _this.$slide.eq(index).find('.lg-object').on('load.lg error.lg', function() {
                    _this.preload(index);
                });
            } else {
                _this.preload(index);
            }
        }

        //}
    };

    /**
    *   @desc slide function for lightgallery
        ** Slide() gets call on start
        ** ** Set lg.on true once slide() function gets called.
        ** Call loadContent() on slide() function inside setTimeout
        ** ** On first slide we do not want any animation like slide of fade
        ** ** So on first slide( if lg.on if false that is first slide) loadContent() should start loading immediately
        ** ** Else loadContent() should wait for the transition to complete.
        ** ** So set timeout s.speed + 50
    <=> ** loadContent() will load slide content in to the particular slide
        ** ** It has recursion (rec) parameter. if rec === true loadContent() will call preload() function.
        ** ** preload will execute only when the previous slide is fully loaded (images iframe)
        ** ** avoid simultaneous image load
    <=> ** Preload() will check for s.preload value and call loadContent() again accoring to preload value
        ** loadContent()  <====> Preload();

    *   @param {Number} index - index of the slide
    *   @param {Boolean} fromTouch - true if slide function called via touch event or mouse drag
    *   @param {Boolean} fromThumb - true if slide function called via thumbnail click
    *   @param {String} direction - Direction of the slide(next/prev)
    */
    Plugin.prototype.slide = function(index, fromTouch, fromThumb, direction) {

        var _prevIndex = this.$outer.find('.lg-current').index();
        var _this = this;

        // Prevent if multiple call
        // Required for hsh plugin
        if (_this.lGalleryOn && (_prevIndex === index)) {
            return;
        }

        var _length = this.$slide.length;
        var _time = _this.lGalleryOn ? this.s.speed : 0;

        if (!_this.lgBusy) {

            if (this.s.download) {
                var _src;
                if (_this.s.dynamic) {
                    _src = _this.s.dynamicEl[index].downloadUrl !== false && (_this.s.dynamicEl[index].downloadUrl || _this.s.dynamicEl[index].src);
                } else {
                    _src = _this.$items.eq(index).attr('data-download-url') !== 'false' && (_this.$items.eq(index).attr('data-download-url') || _this.$items.eq(index).attr('href') || _this.$items.eq(index).attr('data-src'));

                }

                if (_src) {
                    $('#lg-download').attr('href', _src);
                    _this.$outer.removeClass('lg-hide-download');
                } else {
                    _this.$outer.addClass('lg-hide-download');
                }
            }

            this.$el.trigger('onBeforeSlide.lg', [_prevIndex, index, fromTouch, fromThumb]);

            _this.lgBusy = true;

            clearTimeout(_this.hideBartimeout);

            // Add title if this.s.appendSubHtmlTo === lg-sub-html
            if (this.s.appendSubHtmlTo === '.lg-sub-html') {

                // wait for slide animation to complete
                setTimeout(function() {
                    _this.addHtml(index);
                }, _time);
            }

            this.arrowDisable(index);

            if (!direction) {
                if (index < _prevIndex) {
                    direction = 'prev';
                } else if (index > _prevIndex) {
                    direction = 'next';
                }
            }

            if (!fromTouch) {

                // remove all transitions
                _this.$outer.addClass('lg-no-trans');

                this.$slide.removeClass('lg-prev-slide lg-next-slide');

                if (direction === 'prev') {

                    //prevslide
                    this.$slide.eq(index).addClass('lg-prev-slide');
                    this.$slide.eq(_prevIndex).addClass('lg-next-slide');
                } else {

                    // next slide
                    this.$slide.eq(index).addClass('lg-next-slide');
                    this.$slide.eq(_prevIndex).addClass('lg-prev-slide');
                }

                // give 50 ms for browser to add/remove class
                setTimeout(function() {
                    _this.$slide.removeClass('lg-current');

                    //_this.$slide.eq(_prevIndex).removeClass('lg-current');
                    _this.$slide.eq(index).addClass('lg-current');

                    // reset all transitions
                    _this.$outer.removeClass('lg-no-trans');
                }, 50);
            } else {

                this.$slide.removeClass('lg-prev-slide lg-current lg-next-slide');
                var touchPrev;
                var touchNext;
                if (_length > 2) {
                    touchPrev = index - 1;
                    touchNext = index + 1;

                    if ((index === 0) && (_prevIndex === _length - 1)) {

                        // next slide
                        touchNext = 0;
                        touchPrev = _length - 1;
                    } else if ((index === _length - 1) && (_prevIndex === 0)) {

                        // prev slide
                        touchNext = 0;
                        touchPrev = _length - 1;
                    }

                } else {
                    touchPrev = 0;
                    touchNext = 1;
                }

                if (direction === 'prev') {
                    _this.$slide.eq(touchNext).addClass('lg-next-slide');
                } else {
                    _this.$slide.eq(touchPrev).addClass('lg-prev-slide');
                }

                _this.$slide.eq(index).addClass('lg-current');
            }

            if (_this.lGalleryOn) {
                setTimeout(function() {
                    _this.loadContent(index, true, 0);
                }, this.s.speed + 50);

                setTimeout(function() {
                    _this.lgBusy = false;
                    _this.$el.trigger('onAfterSlide.lg', [_prevIndex, index, fromTouch, fromThumb]);
                }, this.s.speed);

            } else {
                _this.loadContent(index, true, _this.s.backdropDuration);

                _this.lgBusy = false;
                _this.$el.trigger('onAfterSlide.lg', [_prevIndex, index, fromTouch, fromThumb]);
            }

            _this.lGalleryOn = true;

            if (this.s.counter) {
                $('#lg-counter-current').text(index + 1);
            }

        }
        _this.index = index;

    };

    /**
     *  @desc Go to next slide
     *  @param {Boolean} fromTouch - true if slide function called via touch event
     */
    Plugin.prototype.goToNextSlide = function(fromTouch) {
        var _this = this;
        var _loop = _this.s.loop;
        if (fromTouch && _this.$slide.length < 3) {
            _loop = false;
        }

        if (!_this.lgBusy) {
            if ((_this.index + 1) < _this.$slide.length) {
                _this.index++;
                _this.$el.trigger('onBeforeNextSlide.lg', [_this.index]);
                _this.slide(_this.index, fromTouch, false, 'next');
            } else {
                if (_loop) {
                    _this.index = 0;
                    _this.$el.trigger('onBeforeNextSlide.lg', [_this.index]);
                    _this.slide(_this.index, fromTouch, false, 'next');
                } else if (_this.s.slideEndAnimatoin && !fromTouch) {
                    _this.$outer.addClass('lg-right-end');
                    setTimeout(function() {
                        _this.$outer.removeClass('lg-right-end');
                    }, 400);
                }
            }
        }
    };

    /**
     *  @desc Go to previous slide
     *  @param {Boolean} fromTouch - true if slide function called via touch event
     */
    Plugin.prototype.goToPrevSlide = function(fromTouch) {
        var _this = this;
        var _loop = _this.s.loop;
        if (fromTouch && _this.$slide.length < 3) {
            _loop = false;
        }

        if (!_this.lgBusy) {
            if (_this.index > 0) {
                _this.index--;
                _this.$el.trigger('onBeforePrevSlide.lg', [_this.index, fromTouch]);
                _this.slide(_this.index, fromTouch, false, 'prev');
            } else {
                if (_loop) {
                    _this.index = _this.$items.length - 1;
                    _this.$el.trigger('onBeforePrevSlide.lg', [_this.index, fromTouch]);
                    _this.slide(_this.index, fromTouch, false, 'prev');
                } else if (_this.s.slideEndAnimatoin && !fromTouch) {
                    _this.$outer.addClass('lg-left-end');
                    setTimeout(function() {
                        _this.$outer.removeClass('lg-left-end');
                    }, 400);
                }
            }
        }
    };

    Plugin.prototype.keyPress = function() {
        var _this = this;
        if (this.$items.length > 1) {
            $(window).on('keyup.lg', function(e) {
                if (_this.$items.length > 1) {
                    if (e.keyCode === 37) {
                        e.preventDefault();
                        _this.goToPrevSlide();
                    }

                    if (e.keyCode === 39) {
                        e.preventDefault();
                        _this.goToNextSlide();
                    }
                }
            });
        }

        $(window).on('keydown.lg', function(e) {
            if (_this.s.escKey === true && e.keyCode === 27) {
                e.preventDefault();
                if (!_this.$outer.hasClass('lg-thumb-open')) {
                    _this.destroy();
                } else {
                    _this.$outer.removeClass('lg-thumb-open');
                }
            }
        });
    };

    Plugin.prototype.arrow = function() {
        var _this = this;
        this.$outer.find('.lg-prev').on('click.lg', function() {
            _this.goToPrevSlide();
        });

        this.$outer.find('.lg-next').on('click.lg', function() {
            _this.goToNextSlide();
        });
    };

    Plugin.prototype.arrowDisable = function(index) {

        // Disable arrows if s.hideControlOnEnd is true
        if (!this.s.loop && this.s.hideControlOnEnd) {
            if ((index + 1) < this.$slide.length) {
                this.$outer.find('.lg-next').removeAttr('disabled').removeClass('disabled');
            } else {
                this.$outer.find('.lg-next').attr('disabled', 'disabled').addClass('disabled');
            }

            if (index > 0) {
                this.$outer.find('.lg-prev').removeAttr('disabled').removeClass('disabled');
            } else {
                this.$outer.find('.lg-prev').attr('disabled', 'disabled').addClass('disabled');
            }
        }
    };

    Plugin.prototype.setTranslate = function($el, xValue, yValue) {
        // jQuery supports Automatic CSS prefixing since jQuery 1.8.0
        if (this.s.useLeft) {
            $el.css('left', xValue);
        } else {
            $el.css({
                transform: 'translate3d(' + (xValue) + 'px, ' + yValue + 'px, 0px)'
            });
        }
    };

    Plugin.prototype.touchMove = function(startCoords, endCoords) {

        var distance = endCoords - startCoords;

        if (Math.abs(distance) > 15) {
            // reset opacity and transition duration
            this.$outer.addClass('lg-dragging');

            // move current slide
            this.setTranslate(this.$slide.eq(this.index), distance, 0);

            // move next and prev slide with current slide
            this.setTranslate($('.lg-prev-slide'), -this.$slide.eq(this.index).width() + distance, 0);
            this.setTranslate($('.lg-next-slide'), this.$slide.eq(this.index).width() + distance, 0);
        }
    };

    Plugin.prototype.touchEnd = function(distance) {
        var _this = this;

        // keep slide animation for any mode while dragg/swipe
        if (_this.s.mode !== 'lg-slide') {
            _this.$outer.addClass('lg-slide');
        }

        this.$slide.not('.lg-current, .lg-prev-slide, .lg-next-slide').css('opacity', '0');

        // set transition duration
        setTimeout(function() {
            _this.$outer.removeClass('lg-dragging');
            if ((distance < 0) && (Math.abs(distance) > _this.s.swipeThreshold)) {
                _this.goToNextSlide(true);
            } else if ((distance > 0) && (Math.abs(distance) > _this.s.swipeThreshold)) {
                _this.goToPrevSlide(true);
            } else if (Math.abs(distance) < 5) {

                // Trigger click if distance is less than 5 pix
                _this.$el.trigger('onSlideClick.lg');
            }

            _this.$slide.removeAttr('style');
        });

        // remove slide class once drag/swipe is completed if mode is not slide
        setTimeout(function() {
            if (!_this.$outer.hasClass('lg-dragging') && _this.s.mode !== 'lg-slide') {
                _this.$outer.removeClass('lg-slide');
            }
        }, _this.s.speed + 100);

    };

    Plugin.prototype.enableSwipe = function() {
        var _this = this;
        var startCoords = 0;
        var endCoords = 0;
        var isMoved = false;

        if (_this.s.enableSwipe && _this.doCss()) {

            _this.$slide.on('touchstart.lg', function(e) {
                if (!_this.$outer.hasClass('lg-zoomed') && !_this.lgBusy) {
                    e.preventDefault();
                    _this.manageSwipeClass();
                    startCoords = e.originalEvent.targetTouches[0].pageX;
                }
            });

            _this.$slide.on('touchmove.lg', function(e) {
                if (!_this.$outer.hasClass('lg-zoomed')) {
                    e.preventDefault();
                    endCoords = e.originalEvent.targetTouches[0].pageX;
                    _this.touchMove(startCoords, endCoords);
                    isMoved = true;
                }
            });

            _this.$slide.on('touchend.lg', function() {
                if (!_this.$outer.hasClass('lg-zoomed')) {
                    if (isMoved) {
                        isMoved = false;
                        _this.touchEnd(endCoords - startCoords);
                    } else {
                        _this.$el.trigger('onSlideClick.lg');
                    }
                }
            });
        }

    };

    Plugin.prototype.enableDrag = function() {
        var _this = this;
        var startCoords = 0;
        var endCoords = 0;
        var isDraging = false;
        var isMoved = false;
        if (_this.s.enableDrag && _this.doCss()) {
            _this.$slide.on('mousedown.lg', function(e) {
                if (!_this.$outer.hasClass('lg-zoomed') && !_this.lgBusy && !$(e.target).text().trim()) {
                    e.preventDefault();
                    _this.manageSwipeClass();
                    startCoords = e.pageX;
                    isDraging = true;

                    // ** Fix for webkit cursor issue https://code.google.com/p/chromium/issues/detail?id=26723
                    _this.$outer.scrollLeft += 1;
                    _this.$outer.scrollLeft -= 1;

                    // *

                    _this.$outer.removeClass('lg-grab').addClass('lg-grabbing');

                    _this.$el.trigger('onDragstart.lg');
                }
            });

            $(window).on('mousemove.lg', function(e) {
                if (isDraging) {
                    isMoved = true;
                    endCoords = e.pageX;
                    _this.touchMove(startCoords, endCoords);
                    _this.$el.trigger('onDragmove.lg');
                }
            });

            $(window).on('mouseup.lg', function(e) {
                if (isMoved) {
                    isMoved = false;
                    _this.touchEnd(endCoords - startCoords);
                    _this.$el.trigger('onDragend.lg');
                } else if ($(e.target).hasClass('lg-object') || $(e.target).hasClass('lg-video-play')) {
                    _this.$el.trigger('onSlideClick.lg');
                }

                // Prevent execution on click
                if (isDraging) {
                    isDraging = false;
                    _this.$outer.removeClass('lg-grabbing').addClass('lg-grab');
                }
            });

        }
    };

    Plugin.prototype.manageSwipeClass = function() {
        var _touchNext = this.index + 1;
        var _touchPrev = this.index - 1;
        if (this.s.loop && this.$slide.length > 2) {
            if (this.index === 0) {
                _touchPrev = this.$slide.length - 1;
            } else if (this.index === this.$slide.length - 1) {
                _touchNext = 0;
            }
        }

        this.$slide.removeClass('lg-next-slide lg-prev-slide');
        if (_touchPrev > -1) {
            this.$slide.eq(_touchPrev).addClass('lg-prev-slide');
        }

        this.$slide.eq(_touchNext).addClass('lg-next-slide');
    };

    Plugin.prototype.mousewheel = function() {
        var _this = this;
        _this.$outer.on('mousewheel.lg', function(e) {

            if (!e.deltaY) {
                return;
            }

            if (e.deltaY > 0) {
                _this.goToPrevSlide();
            } else {
                _this.goToNextSlide();
            }

            e.preventDefault();
        });

    };

    Plugin.prototype.closeGallery = function() {

        var _this = this;
        var mousedown = false;
        this.$outer.find('.lg-close').on('click.lg', function() {
            _this.destroy();
        });

        if (_this.s.closable) {

            // If you drag the slide and release outside gallery gets close on chrome
            // for preventing this check mousedown and mouseup happened on .lg-item or lg-outer
            _this.$outer.on('mousedown.lg', function(e) {

                if ($(e.target).is('.lg-outer') || $(e.target).is('.lg-item ') || $(e.target).is('.lg-img-wrap')) {
                    mousedown = true;
                } else {
                    mousedown = false;
                }

            });
            
            _this.$outer.on('mousemove.lg', function() {
                mousedown = false;
            });

            _this.$outer.on('mouseup.lg', function(e) {

                if ($(e.target).is('.lg-outer') || $(e.target).is('.lg-item ') || $(e.target).is('.lg-img-wrap') && mousedown) {
                    if (!_this.$outer.hasClass('lg-dragging')) {
                        _this.destroy();
                    }
                }

            });

        }

    };

    Plugin.prototype.destroy = function(d) {

        var _this = this;

        if (!d) {
            _this.$el.trigger('onBeforeClose.lg');
            $(window).scrollTop(_this.prevScrollTop);
        }


        /**
         * if d is false or undefined destroy will only close the gallery
         * plugins instance remains with the element
         *
         * if d is true destroy will completely remove the plugin
         */

        if (d) {
            if (!_this.s.dynamic) {
                // only when not using dynamic mode is $items a jquery collection
                this.$items.off('click.lg click.lgcustom');
            }

            $.removeData(_this.el, 'lightGallery');
        }

        // Unbind all events added by lightGallery
        this.$el.off('.lg.tm');

        // Distroy all lightGallery modules
        $.each($.fn.lightGallery.modules, function(key) {
            if (_this.modules[key]) {
                _this.modules[key].destroy();
            }
        });

        this.lGalleryOn = false;

        clearTimeout(_this.hideBartimeout);
        this.hideBartimeout = false;
        $(window).off('.lg');
        $('body').removeClass('lg-on lg-from-hash');

        if (_this.$outer) {
            _this.$outer.removeClass('lg-visible');
        }

        $('.lg-backdrop').removeClass('in');

        setTimeout(function() {
            if (_this.$outer) {
                _this.$outer.remove();
            }

            $('.lg-backdrop').remove();

            if (!d) {
                _this.$el.trigger('onCloseAfter.lg');
            }

        }, _this.s.backdropDuration + 50);
    };

    $.fn.lightGallery = function(options) {
        return this.each(function() {
            if (!$.data(this, 'lightGallery')) {
                $.data(this, 'lightGallery', new Plugin(this, options));
            } else {
                try {
                    $(this).data('lightGallery').init();
                } catch (err) {
                    console.error('lightGallery has not initiated properly');
                }
            }
        });
    };

    $.fn.lightGallery.modules = {};

})();

/*! lg-autoplay - v1.0.4 - 2017-03-28
* http://sachinchoolur.github.io/lightGallery
* Copyright (c) 2017 Sachin N; Licensed GPLv3 */

(function (root, factory) {
  if (typeof define === 'function' && define.amd) {
    // AMD. Register as an anonymous module unless amdModuleId is set
    define(['jquery'], function (a0) {
      return (factory(a0));
    });
  } else if (typeof exports === 'object') {
    // Node. Does not work with strict CommonJS, but
    // only CommonJS-like environments that support module.exports,
    // like Node.
    module.exports = factory(require('jquery'));
  } else {
    factory(jQuery);
  }
}(this, function ($) {


(function() {

    'use strict';

    var defaults = {
        autoplay: false,
        pause: 5000,
        progressBar: true,
        fourceAutoplay: false,
        autoplayControls: true,
        appendAutoplayControlsTo: '.lg-toolbar'
    };

    /**
     * Creates the autoplay plugin.
     * @param {object} element - lightGallery element
     */
    var Autoplay = function(element) {

        this.core = $(element).data('lightGallery');

        this.$el = $(element);

        // Execute only if items are above 1
        if (this.core.$items.length < 2) {
            return false;
        }

        this.core.s = $.extend({}, defaults, this.core.s);
        this.interval = false;

        // Identify if slide happened from autoplay
        this.fromAuto = true;

        // Identify if autoplay canceled from touch/drag
        this.canceledOnTouch = false;

        // save fourceautoplay value
        this.fourceAutoplayTemp = this.core.s.fourceAutoplay;

        // do not allow progress bar if browser does not support css3 transitions
        if (!this.core.doCss()) {
            this.core.s.progressBar = false;
        }

        this.init();

        return this;
    };

    Autoplay.prototype.init = function() {
        var _this = this;

        // append autoplay controls
        if (_this.core.s.autoplayControls) {
            _this.controls();
        }

        // Create progress bar
        if (_this.core.s.progressBar) {
            _this.core.$outer.find('.lg').append('<div class="lg-progress-bar"><div class="lg-progress"></div></div>');
        }

        // set progress
        _this.progress();

        // Start autoplay
        if (_this.core.s.autoplay) {
            _this.$el.one('onSlideItemLoad.lg.tm', function() {
                _this.startlAuto();
            });
        }

        // cancel interval on touchstart and dragstart
        _this.$el.on('onDragstart.lg.tm touchstart.lg.tm', function() {
            if (_this.interval) {
                _this.cancelAuto();
                _this.canceledOnTouch = true;
            }
        });

        // restore autoplay if autoplay canceled from touchstart / dragstart
        _this.$el.on('onDragend.lg.tm touchend.lg.tm onSlideClick.lg.tm', function() {
            if (!_this.interval && _this.canceledOnTouch) {
                _this.startlAuto();
                _this.canceledOnTouch = false;
            }
        });

    };

    Autoplay.prototype.progress = function() {

        var _this = this;
        var _$progressBar;
        var _$progress;

        _this.$el.on('onBeforeSlide.lg.tm', function() {

            // start progress bar animation
            if (_this.core.s.progressBar && _this.fromAuto) {
                _$progressBar = _this.core.$outer.find('.lg-progress-bar');
                _$progress = _this.core.$outer.find('.lg-progress');
                if (_this.interval) {
                    _$progress.removeAttr('style');
                    _$progressBar.removeClass('lg-start');
                    setTimeout(function() {
                        _$progress.css('transition', 'width ' + (_this.core.s.speed + _this.core.s.pause) + 'ms ease 0s');
                        _$progressBar.addClass('lg-start');
                    }, 20);
                }
            }

            // Remove setinterval if slide is triggered manually and fourceautoplay is false
            if (!_this.fromAuto && !_this.core.s.fourceAutoplay) {
                _this.cancelAuto();
            }

            _this.fromAuto = false;

        });
    };

    // Manage autoplay via play/stop buttons
    Autoplay.prototype.controls = function() {
        var _this = this;
        var _html = '<span class="lg-autoplay-button lg-icon"></span>';

        // Append autoplay controls
        $(this.core.s.appendAutoplayControlsTo).append(_html);

        _this.core.$outer.find('.lg-autoplay-button').on('click.lg', function() {
            if ($(_this.core.$outer).hasClass('lg-show-autoplay')) {
                _this.cancelAuto();
                _this.core.s.fourceAutoplay = false;
            } else {
                if (!_this.interval) {
                    _this.startlAuto();
                    _this.core.s.fourceAutoplay = _this.fourceAutoplayTemp;
                }
            }
        });
    };

    // Autostart gallery
    Autoplay.prototype.startlAuto = function() {
        var _this = this;

        _this.core.$outer.find('.lg-progress').css('transition', 'width ' + (_this.core.s.speed + _this.core.s.pause) + 'ms ease 0s');
        _this.core.$outer.addClass('lg-show-autoplay');
        _this.core.$outer.find('.lg-progress-bar').addClass('lg-start');

        _this.interval = setInterval(function() {
            if (_this.core.index + 1 < _this.core.$items.length) {
                _this.core.index++;
            } else {
                _this.core.index = 0;
            }

            _this.fromAuto = true;
            _this.core.slide(_this.core.index, false, false, 'next');
        }, _this.core.s.speed + _this.core.s.pause);
    };

    // cancel Autostart
    Autoplay.prototype.cancelAuto = function() {
        clearInterval(this.interval);
        this.interval = false;
        this.core.$outer.find('.lg-progress').removeAttr('style');
        this.core.$outer.removeClass('lg-show-autoplay');
        this.core.$outer.find('.lg-progress-bar').removeClass('lg-start');
    };

    Autoplay.prototype.destroy = function() {

        this.cancelAuto();
        this.core.$outer.find('.lg-progress-bar').remove();
    };

    $.fn.lightGallery.modules.autoplay = Autoplay;

})();


}));

/*! lg-fullscreen - v1.1.0 - 2019-02-19
* http://sachinchoolur.github.io/lightGallery
* Copyright (c) 2019 Sachin N; Licensed GPLv3 */

(function (root, factory) {
  if (typeof define === 'function' && define.amd) {
    // AMD. Register as an anonymous module unless amdModuleId is set
    define(['jquery'], function (a0) {
      return (factory(a0));
    });
  } else if (typeof module === 'object' && module.exports) {
    // Node. Does not work with strict CommonJS, but
    // only CommonJS-like environments that support module.exports,
    // like Node.
    module.exports = factory(require('jquery'));
  } else {
    factory(root["jQuery"]);
  }
}(this, function ($) {

(function() {

    'use strict';

    var defaults = {
        fullScreen: true
    };

    function isFullScreen() {
        return (
            document.fullscreenElement ||
            document.mozFullScreenElement ||
            document.webkitFullscreenElement ||
            document.msFullscreenElement
        );
    }

    var Fullscreen = function(element) {

        // get lightGallery core plugin data
        this.core = $(element).data('lightGallery');

        this.$el = $(element);

        // extend module defalut settings with lightGallery core settings
        this.core.s = $.extend({}, defaults, this.core.s);

        this.init();

        return this;
    };

    Fullscreen.prototype.init = function() {
        var fullScreen = '';
        if (this.core.s.fullScreen) {

            // check for fullscreen browser support
            if (!document.fullscreenEnabled && !document.webkitFullscreenEnabled &&
                !document.mozFullScreenEnabled && !document.msFullscreenEnabled) {
                return;
            } else {
                fullScreen = '<span class="lg-fullscreen lg-icon"></span>';
                this.core.$outer.find('.lg-toolbar').append(fullScreen);
                this.fullScreen();
            }
        }
    };

    Fullscreen.prototype.requestFullscreen = function() {
        var el = document.documentElement;
        if (el.requestFullscreen) {
            el.requestFullscreen();
        } else if (el.msRequestFullscreen) {
            el.msRequestFullscreen();
        } else if (el.mozRequestFullScreen) {
            el.mozRequestFullScreen();
        } else if (el.webkitRequestFullscreen) {
            el.webkitRequestFullscreen();
        }
    };

    Fullscreen.prototype.exitFullscreen = function() {
        if (document.exitFullscreen) {
            document.exitFullscreen();
        } else if (document.msExitFullscreen) {
            document.msExitFullscreen();
        } else if (document.mozCancelFullScreen) {
            document.mozCancelFullScreen();
        } else if (document.webkitExitFullscreen) {
            document.webkitExitFullscreen();
        }
    };

    // https://developer.mozilla.org/en-US/docs/Web/Guide/API/DOM/Using_full_screen_mode
    Fullscreen.prototype.fullScreen = function() {
        var _this = this;

        $(document).on('fullscreenchange.lg webkitfullscreenchange.lg mozfullscreenchange.lg MSFullscreenChange.lg', function() {
            _this.core.$outer.toggleClass('lg-fullscreen-on');
        });

        this.core.$outer.find('.lg-fullscreen').on('click.lg', function() {
            if (isFullScreen()) {
                _this.exitFullscreen();
            } else {
                _this.requestFullscreen();
            }
        });

    };

    Fullscreen.prototype.destroy = function() {

        // exit from fullscreen if activated
        if(isFullScreen()) {
            this.exitFullscreen();
        }

        $(document).off('fullscreenchange.lg webkitfullscreenchange.lg mozfullscreenchange.lg MSFullscreenChange.lg');
    };

    $.fn.lightGallery.modules.fullscreen = Fullscreen;

})();

}));

/*! lg-hash - v1.0.4 - 2017-12-20
* http://sachinchoolur.github.io/lightGallery
* Copyright (c) 2017 Sachin N; Licensed GPLv3 */

(function (root, factory) {
  if (typeof define === 'function' && define.amd) {
    // AMD. Register as an anonymous module unless amdModuleId is set
    define(['jquery'], function (a0) {
      return (factory(a0));
    });
  } else if (typeof exports === 'object') {
    // Node. Does not work with strict CommonJS, but
    // only CommonJS-like environments that support module.exports,
    // like Node.
    module.exports = factory(require('jquery'));
  } else {
    factory(jQuery);
  }
}(this, function ($) {

(function() {

    'use strict';

    var defaults = {
        hash: true
    };

    var Hash = function(element) {

        this.core = $(element).data('lightGallery');

        this.core.s = $.extend({}, defaults, this.core.s);

        if (this.core.s.hash) {
            this.oldHash = window.location.hash;
            this.init();
        }

        return this;
    };

    Hash.prototype.init = function() {
        var _this = this;
        var _hash;

        // Change hash value on after each slide transition
        _this.core.$el.on('onAfterSlide.lg.tm', function(event, prevIndex, index) {
            if (history.replaceState) {
                history.replaceState(null, null, window.location.pathname + window.location.search + '#lg=' + _this.core.s.galleryId + '&slide=' + index);
            } else {
                window.location.hash = 'lg=' + _this.core.s.galleryId + '&slide=' + index;
            }
        });

        // Listen hash change and change the slide according to slide value
        $(window).on('hashchange.lg.hash', function() {
            _hash = window.location.hash;
            var _idx = parseInt(_hash.split('&slide=')[1], 10);

            // it galleryId doesn't exist in the url close the gallery
            if ((_hash.indexOf('lg=' + _this.core.s.galleryId) > -1)) {
                _this.core.slide(_idx, false, false);
            } else if (_this.core.lGalleryOn) {
                _this.core.destroy();
            }

        });
    };

    Hash.prototype.destroy = function() {

        if (!this.core.s.hash) {
            return;
        }

        // Reset to old hash value
        if (this.oldHash && this.oldHash.indexOf('lg=' + this.core.s.galleryId) < 0) {
            if (history.replaceState) {
                history.replaceState(null, null, this.oldHash);
            } else {
                window.location.hash = this.oldHash;
            }
        } else {
            if (history.replaceState) {
                history.replaceState(null, document.title, window.location.pathname + window.location.search);
            } else {
                window.location.hash = '';
            }
        }

        this.core.$el.off('.lg.hash');

    };

    $.fn.lightGallery.modules.hash = Hash;

})();


}));

/*! lg-pager - v1.0.2 - 2017-01-22
* http://sachinchoolur.github.io/lightGallery
* Copyright (c) 2017 Sachin N; Licensed GPLv3 */

(function (root, factory) {
  if (typeof define === 'function' && define.amd) {
    // AMD. Register as an anonymous module unless amdModuleId is set
    define(['jquery'], function (a0) {
      return (factory(a0));
    });
  } else if (typeof exports === 'object') {
    // Node. Does not work with strict CommonJS, but
    // only CommonJS-like environments that support module.exports,
    // like Node.
    module.exports = factory(require('jquery'));
  } else {
    factory(jQuery);
  }
}(this, function ($) {

(function() {

    'use strict';

    var defaults = {
        pager: false
    };

    var Pager = function(element) {

        this.core = $(element).data('lightGallery');

        this.$el = $(element);
        this.core.s = $.extend({}, defaults, this.core.s);
        if (this.core.s.pager && this.core.$items.length > 1) {
            this.init();
        }

        return this;
    };

    Pager.prototype.init = function() {
        var _this = this;
        var pagerList = '';
        var $pagerCont;
        var $pagerOuter;
        var timeout;

        _this.core.$outer.find('.lg').append('<div class="lg-pager-outer"></div>');

        if (_this.core.s.dynamic) {
            for (var i = 0; i < _this.core.s.dynamicEl.length; i++) {
                pagerList += '<span class="lg-pager-cont"> <span class="lg-pager"></span><div class="lg-pager-thumb-cont"><span class="lg-caret"></span> <img src="' + _this.core.s.dynamicEl[i].thumb + '" /></div></span>';
            }
        } else {
            _this.core.$items.each(function() {

                if (!_this.core.s.exThumbImage) {
                    pagerList += '<span class="lg-pager-cont"> <span class="lg-pager"></span><div class="lg-pager-thumb-cont"><span class="lg-caret"></span> <img src="' + $(this).find('img').attr('src') + '" /></div></span>';
                } else {
                    pagerList += '<span class="lg-pager-cont"> <span class="lg-pager"></span><div class="lg-pager-thumb-cont"><span class="lg-caret"></span> <img src="' + $(this).attr(_this.core.s.exThumbImage) + '" /></div></span>';
                }

            });
        }

        $pagerOuter = _this.core.$outer.find('.lg-pager-outer');

        $pagerOuter.html(pagerList);

        $pagerCont = _this.core.$outer.find('.lg-pager-cont');
        $pagerCont.on('click.lg touchend.lg', function() {
            var _$this = $(this);
            _this.core.index = _$this.index();
            _this.core.slide(_this.core.index, false, true, false);
        });

        $pagerOuter.on('mouseover.lg', function() {
            clearTimeout(timeout);
            $pagerOuter.addClass('lg-pager-hover');
        });

        $pagerOuter.on('mouseout.lg', function() {
            timeout = setTimeout(function() {
                $pagerOuter.removeClass('lg-pager-hover');
            });
        });

        _this.core.$el.on('onBeforeSlide.lg.tm', function(e, prevIndex, index) {
            $pagerCont.removeClass('lg-pager-active');
            $pagerCont.eq(index).addClass('lg-pager-active');
        });

    };

    Pager.prototype.destroy = function() {

    };

    $.fn.lightGallery.modules.pager = Pager;

})();


}));

/*! lg-thumbnail - v1.1.0 - 2017-08-08
* http://sachinchoolur.github.io/lightGallery
* Copyright (c) 2017 Sachin N; Licensed GPLv3 */

(function (root, factory) {
  if (typeof define === 'function' && define.amd) {
    // AMD. Register as an anonymous module unless amdModuleId is set
    define(['jquery'], function (a0) {
      return (factory(a0));
    });
  } else if (typeof exports === 'object') {
    // Node. Does not work with strict CommonJS, but
    // only CommonJS-like environments that support module.exports,
    // like Node.
    module.exports = factory(require('jquery'));
  } else {
    factory(jQuery);
  }
}(this, function ($) {

(function() {

    'use strict';

    var defaults = {
        thumbnail: true,

        animateThumb: true,
        currentPagerPosition: 'middle',

        thumbWidth: 100,
        thumbHeight: '80px',
        thumbContHeight: 100,
        thumbMargin: 5,

        exThumbImage: false,
        showThumbByDefault: true,
        toogleThumb: true,
        pullCaptionUp: true,

        enableThumbDrag: true,
        enableThumbSwipe: true,
        swipeThreshold: 50,

        loadYoutubeThumbnail: true,
        youtubeThumbSize: 1,

        loadVimeoThumbnail: true,
        vimeoThumbSize: 'thumbnail_small',

        loadDailymotionThumbnail: true
    };

    var Thumbnail = function(element) {

        // get lightGallery core plugin data
        this.core = $(element).data('lightGallery');

        // extend module default settings with lightGallery core settings
        this.core.s = $.extend({}, defaults, this.core.s);

        this.$el = $(element);
        this.$thumbOuter = null;
        this.thumbOuterWidth = 0;
        this.thumbTotalWidth = (this.core.$items.length * (this.core.s.thumbWidth + this.core.s.thumbMargin));
        this.thumbIndex = this.core.index;

        if (this.core.s.animateThumb) {
            this.core.s.thumbHeight = '100%';
        }

        // Thumbnail animation value
        this.left = 0;

        this.init();

        return this;
    };

    Thumbnail.prototype.init = function() {
        var _this = this;
        if (this.core.s.thumbnail && this.core.$items.length > 1) {
            if (this.core.s.showThumbByDefault) {
                setTimeout(function(){
                    _this.core.$outer.addClass('lg-thumb-open');
                }, 700);
            }

            if (this.core.s.pullCaptionUp) {
                this.core.$outer.addClass('lg-pull-caption-up');
            }

            this.build();
            if (this.core.s.animateThumb && this.core.doCss()) {
                if (this.core.s.enableThumbDrag) {
                    this.enableThumbDrag();
                }

                if (this.core.s.enableThumbSwipe) {
                    this.enableThumbSwipe();
                }

                this.thumbClickable = false;
            } else {
                this.thumbClickable = true;
            }

            this.toogle();
            this.thumbkeyPress();
        }
    };

    Thumbnail.prototype.build = function() {
        var _this = this;
        var thumbList = '';
        var vimeoErrorThumbSize = '';
        var $thumb;
        var html = '<div class="lg-thumb-outer">' +
            '<div class="lg-thumb lg-group">' +
            '</div>' +
            '</div>';

        switch (this.core.s.vimeoThumbSize) {
            case 'thumbnail_large':
                vimeoErrorThumbSize = '640';
                break;
            case 'thumbnail_medium':
                vimeoErrorThumbSize = '200x150';
                break;
            case 'thumbnail_small':
                vimeoErrorThumbSize = '100x75';
        }

        _this.core.$outer.addClass('lg-has-thumb');

        _this.core.$outer.find('.lg').append(html);

        _this.$thumbOuter = _this.core.$outer.find('.lg-thumb-outer');
        _this.thumbOuterWidth = _this.$thumbOuter.width();

        if (_this.core.s.animateThumb) {
            _this.core.$outer.find('.lg-thumb').css({
                width: _this.thumbTotalWidth + 'px',
                position: 'relative'
            });
        }

        if (this.core.s.animateThumb) {
            _this.$thumbOuter.css('height', _this.core.s.thumbContHeight + 'px');
        }

        function getThumb(src, thumb, index) {
            var isVideo = _this.core.isVideo(src, index) || {};
            var thumbImg;
            var vimeoId = '';

            if (isVideo.youtube || isVideo.vimeo || isVideo.dailymotion) {
                if (isVideo.youtube) {
                    if (_this.core.s.loadYoutubeThumbnail) {
                        thumbImg = '//img.youtube.com/vi/' + isVideo.youtube[1] + '/' + _this.core.s.youtubeThumbSize + '.jpg';
                    } else {
                        thumbImg = thumb;
                    }
                } else if (isVideo.vimeo) {
                    if (_this.core.s.loadVimeoThumbnail) {
                        thumbImg = '//i.vimeocdn.com/video/error_' + vimeoErrorThumbSize + '.jpg';
                        vimeoId = isVideo.vimeo[1];
                    } else {
                        thumbImg = thumb;
                    }
                } else if (isVideo.dailymotion) {
                    if (_this.core.s.loadDailymotionThumbnail) {
                        thumbImg = '//www.dailymotion.com/thumbnail/video/' + isVideo.dailymotion[1];
                    } else {
                        thumbImg = thumb;
                    }
                }
            } else {
                thumbImg = thumb;
            }

            thumbList += '<div data-vimeo-id="' + vimeoId + '" class="lg-thumb-item" style="width:' + _this.core.s.thumbWidth + 'px; height: ' + _this.core.s.thumbHeight + '; margin-right: ' + _this.core.s.thumbMargin + 'px"><img src="' + thumbImg + '" /></div>';
            vimeoId = '';
        }

        if (_this.core.s.dynamic) {
            for (var i = 0; i < _this.core.s.dynamicEl.length; i++) {
                getThumb(_this.core.s.dynamicEl[i].src, _this.core.s.dynamicEl[i].thumb, i);
            }
        } else {
            _this.core.$items.each(function(i) {

                if (!_this.core.s.exThumbImage) {
                    getThumb($(this).attr('href') || $(this).attr('data-src'), $(this).find('img').attr('src'), i);
                } else {
                    getThumb($(this).attr('href') || $(this).attr('data-src'), $(this).attr(_this.core.s.exThumbImage), i);
                }

            });
        }

        _this.core.$outer.find('.lg-thumb').html(thumbList);

        $thumb = _this.core.$outer.find('.lg-thumb-item');

        // Load vimeo thumbnails
        $thumb.each(function() {
            var $this = $(this);
            var vimeoVideoId = $this.attr('data-vimeo-id');

            if (vimeoVideoId) {
                $.getJSON('//www.vimeo.com/api/v2/video/' + vimeoVideoId + '.json?callback=?', {
                    format: 'json'
                }, function(data) {
                    $this.find('img').attr('src', data[0][_this.core.s.vimeoThumbSize]);
                });
            }
        });

        // manage active class for thumbnail
        $thumb.eq(_this.core.index).addClass('active');
        _this.core.$el.on('onBeforeSlide.lg.tm', function() {
            $thumb.removeClass('active');
            $thumb.eq(_this.core.index).addClass('active');
        });

        $thumb.on('click.lg touchend.lg', function() {
            var _$this = $(this);
            setTimeout(function() {

                // In IE9 and bellow touch does not support
                // Go to slide if browser does not support css transitions
                if ((_this.thumbClickable && !_this.core.lgBusy) || !_this.core.doCss()) {
                    _this.core.index = _$this.index();
                    _this.core.slide(_this.core.index, false, true, false);
                }
            }, 50);
        });

        _this.core.$el.on('onBeforeSlide.lg.tm', function() {
            _this.animateThumb(_this.core.index);
        });

        $(window).on('resize.lg.thumb orientationchange.lg.thumb', function() {
            setTimeout(function() {
                _this.animateThumb(_this.core.index);
                _this.thumbOuterWidth = _this.$thumbOuter.width();
            }, 200);
        });

    };

    Thumbnail.prototype.setTranslate = function(value) {
        // jQuery supports Automatic CSS prefixing since jQuery 1.8.0
        this.core.$outer.find('.lg-thumb').css({
            transform: 'translate3d(-' + (value) + 'px, 0px, 0px)'
        });
    };

    Thumbnail.prototype.animateThumb = function(index) {
        var $thumb = this.core.$outer.find('.lg-thumb');
        if (this.core.s.animateThumb) {
            var position;
            switch (this.core.s.currentPagerPosition) {
                case 'left':
                    position = 0;
                    break;
                case 'middle':
                    position = (this.thumbOuterWidth / 2) - (this.core.s.thumbWidth / 2);
                    break;
                case 'right':
                    position = this.thumbOuterWidth - this.core.s.thumbWidth;
            }
            this.left = ((this.core.s.thumbWidth + this.core.s.thumbMargin) * index - 1) - position;
            if (this.left > (this.thumbTotalWidth - this.thumbOuterWidth)) {
                this.left = this.thumbTotalWidth - this.thumbOuterWidth;
            }

            if (this.left < 0) {
                this.left = 0;
            }

            if (this.core.lGalleryOn) {
                if (!$thumb.hasClass('on')) {
                    this.core.$outer.find('.lg-thumb').css('transition-duration', this.core.s.speed + 'ms');
                }

                if (!this.core.doCss()) {
                    $thumb.animate({
                        left: -this.left + 'px'
                    }, this.core.s.speed);
                }
            } else {
                if (!this.core.doCss()) {
                    $thumb.css('left', -this.left + 'px');
                }
            }

            this.setTranslate(this.left);

        }
    };

    // Enable thumbnail dragging and swiping
    Thumbnail.prototype.enableThumbDrag = function() {

        var _this = this;
        var startCoords = 0;
        var endCoords = 0;
        var isDraging = false;
        var isMoved = false;
        var tempLeft = 0;

        _this.$thumbOuter.addClass('lg-grab');

        _this.core.$outer.find('.lg-thumb').on('mousedown.lg.thumb', function(e) {
            if (_this.thumbTotalWidth > _this.thumbOuterWidth) {
                // execute only on .lg-object
                e.preventDefault();
                startCoords = e.pageX;
                isDraging = true;

                // ** Fix for webkit cursor issue https://code.google.com/p/chromium/issues/detail?id=26723
                _this.core.$outer.scrollLeft += 1;
                _this.core.$outer.scrollLeft -= 1;

                // *
                _this.thumbClickable = false;
                _this.$thumbOuter.removeClass('lg-grab').addClass('lg-grabbing');
            }
        });

        $(window).on('mousemove.lg.thumb', function(e) {
            if (isDraging) {
                tempLeft = _this.left;
                isMoved = true;
                endCoords = e.pageX;

                _this.$thumbOuter.addClass('lg-dragging');

                tempLeft = tempLeft - (endCoords - startCoords);

                if (tempLeft > (_this.thumbTotalWidth - _this.thumbOuterWidth)) {
                    tempLeft = _this.thumbTotalWidth - _this.thumbOuterWidth;
                }

                if (tempLeft < 0) {
                    tempLeft = 0;
                }

                // move current slide
                _this.setTranslate(tempLeft);

            }
        });

        $(window).on('mouseup.lg.thumb', function() {
            if (isMoved) {
                isMoved = false;
                _this.$thumbOuter.removeClass('lg-dragging');

                _this.left = tempLeft;

                if (Math.abs(endCoords - startCoords) < _this.core.s.swipeThreshold) {
                    _this.thumbClickable = true;
                }

            } else {
                _this.thumbClickable = true;
            }

            if (isDraging) {
                isDraging = false;
                _this.$thumbOuter.removeClass('lg-grabbing').addClass('lg-grab');
            }
        });

    };

    Thumbnail.prototype.enableThumbSwipe = function() {
        var _this = this;
        var startCoords = 0;
        var endCoords = 0;
        var isMoved = false;
        var tempLeft = 0;

        _this.core.$outer.find('.lg-thumb').on('touchstart.lg', function(e) {
            if (_this.thumbTotalWidth > _this.thumbOuterWidth) {
                e.preventDefault();
                startCoords = e.originalEvent.targetTouches[0].pageX;
                _this.thumbClickable = false;
            }
        });

        _this.core.$outer.find('.lg-thumb').on('touchmove.lg', function(e) {
            if (_this.thumbTotalWidth > _this.thumbOuterWidth) {
                e.preventDefault();
                endCoords = e.originalEvent.targetTouches[0].pageX;
                isMoved = true;

                _this.$thumbOuter.addClass('lg-dragging');

                tempLeft = _this.left;

                tempLeft = tempLeft - (endCoords - startCoords);

                if (tempLeft > (_this.thumbTotalWidth - _this.thumbOuterWidth)) {
                    tempLeft = _this.thumbTotalWidth - _this.thumbOuterWidth;
                }

                if (tempLeft < 0) {
                    tempLeft = 0;
                }

                // move current slide
                _this.setTranslate(tempLeft);

            }
        });

        _this.core.$outer.find('.lg-thumb').on('touchend.lg', function() {
            if (_this.thumbTotalWidth > _this.thumbOuterWidth) {

                if (isMoved) {
                    isMoved = false;
                    _this.$thumbOuter.removeClass('lg-dragging');
                    if (Math.abs(endCoords - startCoords) < _this.core.s.swipeThreshold) {
                        _this.thumbClickable = true;
                    }

                    _this.left = tempLeft;
                } else {
                    _this.thumbClickable = true;
                }
            } else {
                _this.thumbClickable = true;
            }
        });

    };

    Thumbnail.prototype.toogle = function() {
        var _this = this;
        if (_this.core.s.toogleThumb) {
            _this.core.$outer.addClass('lg-can-toggle');
            _this.$thumbOuter.append('<span class="lg-toogle-thumb lg-icon"></span>');
            _this.core.$outer.find('.lg-toogle-thumb').on('click.lg', function() {
                _this.core.$outer.toggleClass('lg-thumb-open');
            });
        }
    };

    Thumbnail.prototype.thumbkeyPress = function() {
        var _this = this;
        $(window).on('keydown.lg.thumb', function(e) {
            if (e.keyCode === 38) {
                e.preventDefault();
                _this.core.$outer.addClass('lg-thumb-open');
            } else if (e.keyCode === 40) {
                e.preventDefault();
                _this.core.$outer.removeClass('lg-thumb-open');
            }
        });
    };

    Thumbnail.prototype.destroy = function() {
        if (this.core.s.thumbnail && this.core.$items.length > 1) {
            $(window).off('resize.lg.thumb orientationchange.lg.thumb keydown.lg.thumb');
            this.$thumbOuter.remove();
            this.core.$outer.removeClass('lg-has-thumb');
        }
    };

    $.fn.lightGallery.modules.Thumbnail = Thumbnail;

})();

}));

/*! lg-zoom - v1.1.0 - 2017-08-08
* http://sachinchoolur.github.io/lightGallery
* Copyright (c) 2017 Sachin N; Licensed GPLv3 */

(function (root, factory) {
  if (typeof define === 'function' && define.amd) {
    // AMD. Register as an anonymous module unless amdModuleId is set
    define(['jquery'], function (a0) {
      return (factory(a0));
    });
  } else if (typeof exports === 'object') {
    // Node. Does not work with strict CommonJS, but
    // only CommonJS-like environments that support module.exports,
    // like Node.
    module.exports = factory(require('jquery'));
  } else {
    factory(jQuery);
  }
}(this, function ($) {

(function() {

    'use strict';

    var getUseLeft = function() {
        var useLeft = false;
        var isChrome = navigator.userAgent.match(/Chrom(e|ium)\/([0-9]+)\./);
        if (isChrome && parseInt(isChrome[2], 10) < 54) {
            useLeft = true;
        }

        return useLeft;
    };

    var defaults = {
        scale: 1,
        zoom: true,
        actualSize: true,
        enableZoomAfter: 300,
        useLeftForZoom: getUseLeft()
    };

    var Zoom = function(element) {

        this.core = $(element).data('lightGallery');

        this.core.s = $.extend({}, defaults, this.core.s);

        if (this.core.s.zoom && this.core.doCss()) {
            this.init();

            // Store the zoomable timeout value just to clear it while closing
            this.zoomabletimeout = false;

            // Set the initial value center
            this.pageX = $(window).width() / 2;
            this.pageY = ($(window).height() / 2) + $(window).scrollTop();
        }

        return this;
    };

    Zoom.prototype.init = function() {

        var _this = this;
        var zoomIcons = '<span id="lg-zoom-in" class="lg-icon"></span><span id="lg-zoom-out" class="lg-icon"></span>';

        if (_this.core.s.actualSize) {
            zoomIcons += '<span id="lg-actual-size" class="lg-icon"></span>';
        }

        if (_this.core.s.useLeftForZoom) {
            _this.core.$outer.addClass('lg-use-left-for-zoom');
        } else {
            _this.core.$outer.addClass('lg-use-transition-for-zoom');
        }

        this.core.$outer.find('.lg-toolbar').append(zoomIcons);

        // Add zoomable class
        _this.core.$el.on('onSlideItemLoad.lg.tm.zoom', function(event, index, delay) {

            // delay will be 0 except first time
            var _speed = _this.core.s.enableZoomAfter + delay;

            // set _speed value 0 if gallery opened from direct url and if it is first slide
            if ($('body').hasClass('lg-from-hash') && delay) {

                // will execute only once
                _speed = 0;
            } else {

                // Remove lg-from-hash to enable starting animation.
                $('body').removeClass('lg-from-hash');
            }

            _this.zoomabletimeout = setTimeout(function() {
                _this.core.$slide.eq(index).addClass('lg-zoomable');
            }, _speed + 30);
        });

        var scale = 1;
        /**
         * @desc Image zoom
         * Translate the wrap and scale the image to get better user experience
         *
         * @param {String} scaleVal - Zoom decrement/increment value
         */
        var zoom = function(scaleVal) {

            var $image = _this.core.$outer.find('.lg-current .lg-image');
            var _x;
            var _y;

            // Find offset manually to avoid issue after zoom
            var offsetX = ($(window).width() - $image.prop('offsetWidth')) / 2;
            var offsetY = (($(window).height() - $image.prop('offsetHeight')) / 2) + $(window).scrollTop();

            _x = _this.pageX - offsetX;
            _y = _this.pageY - offsetY;

            var x = (scaleVal - 1) * (_x);
            var y = (scaleVal - 1) * (_y);

            $image.css('transform', 'scale3d(' + scaleVal + ', ' + scaleVal + ', 1)').attr('data-scale', scaleVal);

            if (_this.core.s.useLeftForZoom) {
                $image.parent().css({
                    left: -x + 'px',
                    top: -y + 'px'
                }).attr('data-x', x).attr('data-y', y);
            } else {
                $image.parent().css('transform', 'translate3d(-' + x + 'px, -' + y + 'px, 0)').attr('data-x', x).attr('data-y', y);
            }
        };

        var callScale = function() {
            if (scale > 1) {
                _this.core.$outer.addClass('lg-zoomed');
            } else {
                _this.resetZoom();
            }

            if (scale < 1) {
                scale = 1;
            }

            zoom(scale);
        };

        var actualSize = function(event, $image, index, fromIcon) {
            var w = $image.prop('offsetWidth');
            var nw;
            if (_this.core.s.dynamic) {
                nw = _this.core.s.dynamicEl[index].width || $image[0].naturalWidth || w;
            } else {
                nw = _this.core.$items.eq(index).attr('data-width') || $image[0].naturalWidth || w;
            }

            var _scale;

            if (_this.core.$outer.hasClass('lg-zoomed')) {
                scale = 1;
            } else {
                if (nw > w) {
                    _scale = nw / w;
                    scale = _scale || 2;
                }
            }

            if (fromIcon) {
                _this.pageX = $(window).width() / 2;
                _this.pageY = ($(window).height() / 2) + $(window).scrollTop();
            } else {
                _this.pageX = event.pageX || event.originalEvent.targetTouches[0].pageX;
                _this.pageY = event.pageY || event.originalEvent.targetTouches[0].pageY;
            }

            callScale();
            setTimeout(function() {
                _this.core.$outer.removeClass('lg-grabbing').addClass('lg-grab');
            }, 10);
        };

        var tapped = false;

        // event triggered after appending slide content
        _this.core.$el.on('onAferAppendSlide.lg.tm.zoom', function(event, index) {

            // Get the current element
            var $image = _this.core.$slide.eq(index).find('.lg-image');

            $image.on('dblclick', function(event) {
                actualSize(event, $image, index);
            });

            $image.on('touchstart', function(event) {
                if (!tapped) {
                    tapped = setTimeout(function() {
                        tapped = null;
                    }, 300);
                } else {
                    clearTimeout(tapped);
                    tapped = null;
                    actualSize(event, $image, index);
                }

                event.preventDefault();
            });

        });

        // Update zoom on resize and orientationchange
        $(window).on('resize.lg.zoom scroll.lg.zoom orientationchange.lg.zoom', function() {
            _this.pageX = $(window).width() / 2;
            _this.pageY = ($(window).height() / 2) + $(window).scrollTop();
            zoom(scale);
        });

        $('#lg-zoom-out').on('click.lg', function() {
            if (_this.core.$outer.find('.lg-current .lg-image').length) {
                scale -= _this.core.s.scale;
                callScale();
            }
        });

        $('#lg-zoom-in').on('click.lg', function() {
            if (_this.core.$outer.find('.lg-current .lg-image').length) {
                scale += _this.core.s.scale;
                callScale();
            }
        });

        $('#lg-actual-size').on('click.lg', function(event) {
            actualSize(event, _this.core.$slide.eq(_this.core.index).find('.lg-image'), _this.core.index, true);
        });

        // Reset zoom on slide change
        _this.core.$el.on('onBeforeSlide.lg.tm', function() {
            scale = 1;
            _this.resetZoom();
        });

        // Drag option after zoom
        _this.zoomDrag();

        _this.zoomSwipe();

    };

    // Reset zoom effect
    Zoom.prototype.resetZoom = function() {
        this.core.$outer.removeClass('lg-zoomed');
        this.core.$slide.find('.lg-img-wrap').removeAttr('style data-x data-y');
        this.core.$slide.find('.lg-image').removeAttr('style data-scale');

        // Reset pagx pagy values to center
        this.pageX = $(window).width() / 2;
        this.pageY = ($(window).height() / 2) + $(window).scrollTop();
    };

    Zoom.prototype.zoomSwipe = function() {
        var _this = this;
        var startCoords = {};
        var endCoords = {};
        var isMoved = false;

        // Allow x direction drag
        var allowX = false;

        // Allow Y direction drag
        var allowY = false;

        _this.core.$slide.on('touchstart.lg', function(e) {

            if (_this.core.$outer.hasClass('lg-zoomed')) {
                var $image = _this.core.$slide.eq(_this.core.index).find('.lg-object');

                allowY = $image.prop('offsetHeight') * $image.attr('data-scale') > _this.core.$outer.find('.lg').height();
                allowX = $image.prop('offsetWidth') * $image.attr('data-scale') > _this.core.$outer.find('.lg').width();
                if ((allowX || allowY)) {
                    e.preventDefault();
                    startCoords = {
                        x: e.originalEvent.targetTouches[0].pageX,
                        y: e.originalEvent.targetTouches[0].pageY
                    };
                }
            }

        });

        _this.core.$slide.on('touchmove.lg', function(e) {

            if (_this.core.$outer.hasClass('lg-zoomed')) {

                var _$el = _this.core.$slide.eq(_this.core.index).find('.lg-img-wrap');
                var distanceX;
                var distanceY;

                e.preventDefault();
                isMoved = true;

                endCoords = {
                    x: e.originalEvent.targetTouches[0].pageX,
                    y: e.originalEvent.targetTouches[0].pageY
                };

                // reset opacity and transition duration
                _this.core.$outer.addClass('lg-zoom-dragging');

                if (allowY) {
                    distanceY = (-Math.abs(_$el.attr('data-y'))) + (endCoords.y - startCoords.y);
                } else {
                    distanceY = -Math.abs(_$el.attr('data-y'));
                }

                if (allowX) {
                    distanceX = (-Math.abs(_$el.attr('data-x'))) + (endCoords.x - startCoords.x);
                } else {
                    distanceX = -Math.abs(_$el.attr('data-x'));
                }

                if ((Math.abs(endCoords.x - startCoords.x) > 15) || (Math.abs(endCoords.y - startCoords.y) > 15)) {

                    if (_this.core.s.useLeftForZoom) {
                        _$el.css({
                            left: distanceX + 'px',
                            top: distanceY + 'px'
                        });
                    } else {
                        _$el.css('transform', 'translate3d(' + distanceX + 'px, ' + distanceY + 'px, 0)');
                    }
                }

            }

        });

        _this.core.$slide.on('touchend.lg', function() {
            if (_this.core.$outer.hasClass('lg-zoomed')) {
                if (isMoved) {
                    isMoved = false;
                    _this.core.$outer.removeClass('lg-zoom-dragging');
                    _this.touchendZoom(startCoords, endCoords, allowX, allowY);

                }
            }
        });

    };

    Zoom.prototype.zoomDrag = function() {

        var _this = this;
        var startCoords = {};
        var endCoords = {};
        var isDraging = false;
        var isMoved = false;

        // Allow x direction drag
        var allowX = false;

        // Allow Y direction drag
        var allowY = false;

        _this.core.$slide.on('mousedown.lg.zoom', function(e) {

            // execute only on .lg-object
            var $image = _this.core.$slide.eq(_this.core.index).find('.lg-object');

            allowY = $image.prop('offsetHeight') * $image.attr('data-scale') > _this.core.$outer.find('.lg').height();
            allowX = $image.prop('offsetWidth') * $image.attr('data-scale') > _this.core.$outer.find('.lg').width();

            if (_this.core.$outer.hasClass('lg-zoomed')) {
                if ($(e.target).hasClass('lg-object') && (allowX || allowY)) {
                    e.preventDefault();
                    startCoords = {
                        x: e.pageX,
                        y: e.pageY
                    };

                    isDraging = true;

                    // ** Fix for webkit cursor issue https://code.google.com/p/chromium/issues/detail?id=26723
                    _this.core.$outer.scrollLeft += 1;
                    _this.core.$outer.scrollLeft -= 1;

                    _this.core.$outer.removeClass('lg-grab').addClass('lg-grabbing');
                }
            }
        });

        $(window).on('mousemove.lg.zoom', function(e) {
            if (isDraging) {
                var _$el = _this.core.$slide.eq(_this.core.index).find('.lg-img-wrap');
                var distanceX;
                var distanceY;

                isMoved = true;
                endCoords = {
                    x: e.pageX,
                    y: e.pageY
                };

                // reset opacity and transition duration
                _this.core.$outer.addClass('lg-zoom-dragging');

                if (allowY) {
                    distanceY = (-Math.abs(_$el.attr('data-y'))) + (endCoords.y - startCoords.y);
                } else {
                    distanceY = -Math.abs(_$el.attr('data-y'));
                }

                if (allowX) {
                    distanceX = (-Math.abs(_$el.attr('data-x'))) + (endCoords.x - startCoords.x);
                } else {
                    distanceX = -Math.abs(_$el.attr('data-x'));
                }

                if (_this.core.s.useLeftForZoom) {
                    _$el.css({
                        left: distanceX + 'px',
                        top: distanceY + 'px'
                    });
                } else {
                    _$el.css('transform', 'translate3d(' + distanceX + 'px, ' + distanceY + 'px, 0)');
                }
            }
        });

        $(window).on('mouseup.lg.zoom', function(e) {

            if (isDraging) {
                isDraging = false;
                _this.core.$outer.removeClass('lg-zoom-dragging');

                // Fix for chrome mouse move on click
                if (isMoved && ((startCoords.x !== endCoords.x) || (startCoords.y !== endCoords.y))) {
                    endCoords = {
                        x: e.pageX,
                        y: e.pageY
                    };
                    _this.touchendZoom(startCoords, endCoords, allowX, allowY);

                }

                isMoved = false;
            }

            _this.core.$outer.removeClass('lg-grabbing').addClass('lg-grab');

        });
    };

    Zoom.prototype.touchendZoom = function(startCoords, endCoords, allowX, allowY) {

        var _this = this;
        var _$el = _this.core.$slide.eq(_this.core.index).find('.lg-img-wrap');
        var $image = _this.core.$slide.eq(_this.core.index).find('.lg-object');
        var distanceX = (-Math.abs(_$el.attr('data-x'))) + (endCoords.x - startCoords.x);
        var distanceY = (-Math.abs(_$el.attr('data-y'))) + (endCoords.y - startCoords.y);
        var minY = (_this.core.$outer.find('.lg').height() - $image.prop('offsetHeight')) / 2;
        var maxY = Math.abs(($image.prop('offsetHeight') * Math.abs($image.attr('data-scale'))) - _this.core.$outer.find('.lg').height() + minY);
        var minX = (_this.core.$outer.find('.lg').width() - $image.prop('offsetWidth')) / 2;
        var maxX = Math.abs(($image.prop('offsetWidth') * Math.abs($image.attr('data-scale'))) - _this.core.$outer.find('.lg').width() + minX);

        if ((Math.abs(endCoords.x - startCoords.x) > 15) || (Math.abs(endCoords.y - startCoords.y) > 15)) {
            if (allowY) {
                if (distanceY <= -maxY) {
                    distanceY = -maxY;
                } else if (distanceY >= -minY) {
                    distanceY = -minY;
                }
            }

            if (allowX) {
                if (distanceX <= -maxX) {
                    distanceX = -maxX;
                } else if (distanceX >= -minX) {
                    distanceX = -minX;
                }
            }

            if (allowY) {
                _$el.attr('data-y', Math.abs(distanceY));
            } else {
                distanceY = -Math.abs(_$el.attr('data-y'));
            }

            if (allowX) {
                _$el.attr('data-x', Math.abs(distanceX));
            } else {
                distanceX = -Math.abs(_$el.attr('data-x'));
            }

            if (_this.core.s.useLeftForZoom) {
                _$el.css({
                    left: distanceX + 'px',
                    top: distanceY + 'px'
                });
            } else {
                _$el.css('transform', 'translate3d(' + distanceX + 'px, ' + distanceY + 'px, 0)');
            }

        }
    };

    Zoom.prototype.destroy = function() {

        var _this = this;

        // Unbind all events added by lightGallery zoom plugin
        _this.core.$el.off('.lg.zoom');
        $(window).off('.lg.zoom');
        _this.core.$slide.off('.lg.zoom');
        _this.core.$el.off('.lg.tm.zoom');
        _this.resetZoom();
        clearTimeout(_this.zoomabletimeout);
        _this.zoomabletimeout = false;
    };

    $.fn.lightGallery.modules.zoom = Zoom;

})();


}));

/**
 * bootstrap-imageupload v1.1.2
 * https://github.com/egonolieux/bootstrap-imageupload
 * Copyright 2016 Egon Olieux
 * Released under the MIT license
 */

if (typeof jQuery === 'undefined') {
    throw new Error('bootstrap-imageupload\'s JavaScript requires jQuery.');
}

(function($) {
    'use strict';

    var options = {};

    var methods = {
        init: init,
        disable: disable,
        enable: enable,
        reset: reset
    };

    // -----------------------------------------------------------------------------
    // Plugin Definition
    // -----------------------------------------------------------------------------

    $.fn.imageupload = function(methodOrOptions) {
        var givenArguments = arguments;

        return this.filter('div').each(function() {
            if (methods[methodOrOptions]) {
                methods[methodOrOptions].apply($(this), Array.prototype.slice.call(givenArguments, 1));
            }
            else if (typeof methodOrOptions === 'object' || !methodOrOptions) {
                methods.init.apply($(this), givenArguments);
            }
            else {
                throw new Error('Method "' + methodOrOptions + '" is not defined for imageupload.');
            }
        });
    };

    $.fn.imageupload.defaultOptions = {
        allowedFormats: [ 'jpg', 'jpeg', 'png', 'gif' ],
        maxWidth: 250,
        maxHeight: 250,
        maxFileSizeKb: 2048
    };

    // -----------------------------------------------------------------------------
    // Public Methods
    // -----------------------------------------------------------------------------

    function init(givenOptions) {
        options = $.extend({}, $.fn.imageupload.defaultOptions, givenOptions);

        var $imageupload = this;
        var $fileTab = $imageupload.find('.file-tab');
        var $fileTabButton = $imageupload.find('.panel-heading .btn:eq(0)');
        var $browseFileButton = $fileTab.find('input[type="file"]');
        var $removeFileButton = $fileTab.find('.btn:eq(1)');
        var $urlTab = $imageupload.find('.url-tab');
        var $urlTabButton = $imageupload.find('.panel-heading .btn:eq(1)');
        var $submitUrlButton = $urlTab.find('.btn:eq(0)');
        var $removeUrlButton = $urlTab.find('.btn:eq(1)');

        // Do a complete reset.
        resetFileTab($fileTab);
        resetUrlTab($urlTab);
        showFileTab($fileTab);
        enable.call($imageupload);
        
        // Unbind all previous bound event handlers.
        $fileTabButton.off();
        $browseFileButton.off();
        $removeFileButton.off();
        $urlTabButton.off();
        $submitUrlButton.off();
        $removeUrlButton.off();

        $fileTabButton.on('click', function() {
            $(this).blur();
            showFileTab($fileTab);
        });

        $browseFileButton.on('change', function() {
            $(this).blur();
            submitImageFile($fileTab);
        });

        $removeFileButton.on('click', function() {
            $(this).blur();
            resetFileTab($fileTab);
        });

        $urlTabButton.on('click', function() {
            $(this).blur();
            showUrlTab($urlTab);
        });

        $submitUrlButton.on('click', function() {
            $(this).blur();
            submitImageUrl($urlTab);
        });

        $removeUrlButton.on('click', function() {
            $(this).blur();
            resetUrlTab($urlTab);
        });
    }

    function disable() {
        var $imageupload = this;
        $imageupload.addClass('imageupload-disabled');
    }

    function enable() {
        var $imageupload = this;
        $imageupload.removeClass('imageupload-disabled');
    }

    function reset() {
        var $imageupload = this;
        init.call($imageupload, options);
    }

    // -----------------------------------------------------------------------------
    // Private Methods
    // -----------------------------------------------------------------------------

    function getAlertHtml(message) {
        var html = [];
        html.push('<div class="alert alert-danger alert-dismissible">');
        html.push('<button type="button" class="close" data-dismiss="alert">');
        html.push('<span>&times;</span>');
        html.push('</button>' + message);
        html.push('</div>');
        return html.join('');
    }

    function getImageThumbnailHtml(src) {
        return '<img src="' + src + '" alt="Image preview" class="thumbnail" style="max-width: ' + options.maxWidth + 'px; max-height: ' + options.maxHeight + 'px">';
    }

    function getFileExtension(path) {
        return path.substr(path.lastIndexOf('.') + 1).toLowerCase();
    }

    function isValidImageFile(file, callback) {
        // Check file size.
        if (file.size / 1024 > options.maxFileSizeKb)
        {
            callback(false, 'File is too large (max ' + options.maxFileSizeKb + 'kB).');
            return;
        }

        // Check image format by file extension.
        var fileExtension = getFileExtension(file.name);
        if ($.inArray(fileExtension, options.allowedFormats) > -1) {
            callback(true, 'Image file is valid.');
        }
        else {
            callback(false, 'File type is not allowed.');
        }
    }

    function isValidImageUrl(url, callback) {
        var timer = null;
        var timeoutMs = 3000;
        var timeout = false;
        var image = new Image();

        image.onload = function() {
            if (!timeout) {
                window.clearTimeout(timer);

                // Strip querystring (and fragment) from URL.
                var tempUrl = url;
                if (tempUrl.indexOf('?') !== -1) {
                    tempUrl = tempUrl.split('?')[0].split('#')[0];
                }

                // Check image format by file extension.
                var fileExtension = getFileExtension(tempUrl);
                if ($.inArray(fileExtension, options.allowedFormats) > -1) {
                    callback(true, 'Image URL is valid.');
                }
                else {
                    callback(false, 'File type is not allowed.');
                }
            }
        };

        image.onerror = function() {
            if (!timeout) {
                window.clearTimeout(timer);
                callback(false, 'Image could not be found.');
            }
        };

        image.src = url;

        // Abort if image takes longer than 3000ms to load.
        timer = window.setTimeout(function() {
            timeout = true;
            image.src = '???'; // Trigger error to stop loading.
            callback(false, 'Loading image timed out.');
        }, timeoutMs);
    }

    function showFileTab($fileTab) {
        var $imageupload = $fileTab.closest('.imageupload');
        var $fileTabButton = $imageupload.find('.panel-heading .btn:eq(0)');

        if (!$fileTabButton.hasClass('active')) {
            var $urlTab = $imageupload.find('.url-tab');

            // Change active tab buttton.
            $imageupload.find('.panel-heading .btn:eq(1)').removeClass('active');
            $fileTabButton.addClass('active');

            // Hide URL tab and show file tab.
            $urlTab.hide();
            $fileTab.show();
            resetUrlTab($urlTab);
        }
    }

    function resetFileTab($fileTab) {
        $fileTab.find('.alert').remove();
        $fileTab.find('img').remove();
        $fileTab.find('.btn span').text('Browse');
        $fileTab.find('.btn:eq(1)').hide();
        $fileTab.find('input').val('');
    }

    function submitImageFile($fileTab) {
        var $browseFileButton = $fileTab.find('.btn:eq(0)');
        var $removeFileButton = $fileTab.find('.btn:eq(1)');
        var $fileInput = $browseFileButton.find('input');
        
        $fileTab.find('.alert').remove();
        $fileTab.find('img').remove();
        $browseFileButton.find('span').text('Browse');
        $removeFileButton.hide();

        // Check if file was uploaded.
        if (!($fileInput[0].files && $fileInput[0].files[0])) {
            return;
        }

        $browseFileButton.prop('disabled', true);
        
        var file = $fileInput[0].files[0];

        isValidImageFile(file, function(isValid, message) {
            if (isValid) {
                var fileReader = new FileReader();

                fileReader.onload = function(e) {
                    // Show thumbnail and remove button.
                    $fileTab.prepend(getImageThumbnailHtml(e.target.result));
                    $browseFileButton.find('span').text('Change');
                    $removeFileButton.css('display', 'inline-block');
                };

                fileReader.onerror = function() {
                    $fileTab.prepend(getAlertHtml('Error loading image file.'));
                    $fileInput.val('');
                };

                fileReader.readAsDataURL(file);
            }
            else {
                $fileTab.prepend(getAlertHtml(message));
                $browseFileButton.find('span').text('Browse');
                $fileInput.val('');
            }

            $browseFileButton.prop('disabled', false);
        });
    }

    function showUrlTab($urlTab) {
        var $imageupload = $urlTab.closest('.imageupload');
        var $urlTabButton = $imageupload.find('.panel-heading .btn:eq(1)');

        if (!$urlTabButton.hasClass('active')) {
            var $fileTab = $imageupload.find('.file-tab');

            // Change active tab button.
            $imageupload.find('.panel-heading .btn:eq(0)').removeClass('active');
            $urlTabButton.addClass('active');

            // Hide file tab and show URL tab.
            $fileTab.hide();
            $urlTab.show();
            resetFileTab($fileTab);
        }
    }

    function resetUrlTab($urlTab) {
        $urlTab.find('.alert').remove();
        $urlTab.find('img').remove();
        $urlTab.find('.btn:eq(1)').hide();
        $urlTab.find('input').val('');
    }

    function submitImageUrl($urlTab) {
        var $urlInput = $urlTab.find('input[type="text"]');
        var $submitUrlButton = $urlTab.find('.btn:eq(0)');
        var $removeUrlButton = $urlTab.find('.btn:eq(1)');

        $urlTab.find('.alert').remove();
        $urlTab.find('img').remove();
        $removeUrlButton.hide();

        var url = $urlInput.val();
        if (!url) {
            $urlTab.prepend(getAlertHtml('Please enter an image URL.'));
            return;
        }

        $urlInput.prop('disabled', true);
        $submitUrlButton.prop('disabled', true);
        
        isValidImageUrl(url, function(isValid, message) {
            if (isValid) {
                // Submit URL value.
                $urlTab.find('input[type="hidden"]').val(url);

                // Show thumbnail and remove button.
                $(getImageThumbnailHtml(url)).insertAfter($submitUrlButton.closest('.input-group'));
                $removeUrlButton.css('display', 'inline-block');
            }
            else {
                $urlTab.prepend(getAlertHtml(message));
            }

            $urlInput.prop('disabled', false);
            $submitUrlButton.prop('disabled', false);
        });
    }
}(jQuery));

$.fn.easyPieChart = function(options) {
	return this.each(function() {
		var instanceOptions;

		if (!$.data(this, 'easyPieChart')) {
			instanceOptions = $.extend({}, options, $(this).data());
			$.data(this, 'easyPieChart', new EasyPieChart(this, instanceOptions));
		}
	});
};

var EasyPieChart = function(el, opts) {
	var defaultOptions = {
		barColor: '#ef1e25',
		trackColor: '#f9f9f9',
		scaleColor: '#dfe0e0',
		scaleLength: 5,
		lineCap: 'round',
		lineWidth: 3,
		trackWidth: undefined,
		size: 110,
		rotate: 0,
		animate: {
			duration: 1000,
			enabled: true
		},
		easing: function (x, t, b, c, d) { // more can be found here: http://gsgd.co.uk/sandbox/jquery/easing/
			t = t / (d/2);
			if (t < 1) {
				return c / 2 * t * t + b;
			}
			return -c/2 * ((--t)*(t-2) - 1) + b;
		},
		onStart: function(from, to) {
			return;
		},
		onStep: function(from, to, currentValue) {
			return;
		},
		onStop: function(from, to) {
			return;
		}
	};

	// detect present renderer
	if (typeof(CanvasRenderer) !== 'undefined') {
		defaultOptions.renderer = CanvasRenderer;
	} else if (typeof(SVGRenderer) !== 'undefined') {
		defaultOptions.renderer = SVGRenderer;
	} else {
		throw new Error('Please load either the SVG- or the CanvasRenderer');
	}

	var options = {};
	var currentValue = 0;

	/**
	 * Initialize the plugin by creating the options object and initialize rendering
	 */
	var init = function() {
		this.el = el;
		this.options = options;

		// merge user options into default options
		for (var i in defaultOptions) {
			if (defaultOptions.hasOwnProperty(i)) {
				options[i] = opts && typeof(opts[i]) !== 'undefined' ? opts[i] : defaultOptions[i];
				if (typeof(options[i]) === 'function') {
					options[i] = options[i].bind(this);
				}
			}
		}

		// check for jQuery easing
		if (typeof(options.easing) === 'string' && typeof(jQuery) !== 'undefined' && jQuery.isFunction(jQuery.easing[options.easing])) {
			options.easing = jQuery.easing[options.easing];
		} else {
			options.easing = defaultOptions.easing;
		}

		// process earlier animate option to avoid bc breaks
		if (typeof(options.animate) === 'number') {
			options.animate = {
				duration: options.animate,
				enabled: true
			};
		}

		if (typeof(options.animate) === 'boolean' && !options.animate) {
			options.animate = {
				duration: 1000,
				enabled: options.animate
			};
		}

		// create renderer
		this.renderer = new options.renderer(el, options);

		// initial draw
		this.renderer.draw(currentValue);

		// initial update
		if (el.dataset && el.dataset.percent) {
			this.update(parseFloat(el.dataset.percent));
		} else if (el.getAttribute && el.getAttribute('data-percent')) {
			this.update(parseFloat(el.getAttribute('data-percent')));
		}
	}.bind(this);

	/**
	 * Update the value of the chart
	 * @param  {number} newValue Number between 0 and 100
	 * @return {object}          Instance of the plugin for method chaining
	 */
	this.update = function(newValue) {
		newValue = parseFloat(newValue);
		if (options.animate.enabled) {
			this.renderer.animate(currentValue, newValue);
		} else {
			this.renderer.draw(newValue);
		}
		currentValue = newValue;
		return this;
	}.bind(this);

	/**
	 * Disable animation
	 * @return {object} Instance of the plugin for method chaining
	 */
	this.disableAnimation = function() {
		options.animate.enabled = false;
		return this;
	};

	/**
	 * Enable animation
	 * @return {object} Instance of the plugin for method chaining
	 */
	this.enableAnimation = function() {
		options.animate.enabled = true;
		return this;
	};

	init();
};


/**!
 * easy-pie-chart
 * Lightweight plugin to render simple, animated and retina optimized pie charts
 *
 * @license 
 * @author Robert Fleischmann <rendro87@gmail.com> (http://robert-fleischmann.de)
 * @version 2.1.7
 **/

(function (root, factory) {
  if (typeof define === 'function' && define.amd) {
    // AMD. Register as an anonymous module unless amdModuleId is set
    define(["jquery"], function (a0) {
      return (factory(a0));
    });
  } else if (typeof exports === 'object') {
    // Node. Does not work with strict CommonJS, but
    // only CommonJS-like environments that support module.exports,
    // like Node.
    module.exports = factory(require("jquery"));
  } else {
    factory(jQuery);
  }
}(this, function ($) {

/**
 * Renderer to render the chart on a canvas object
 * @param {DOMElement} el      DOM element to host the canvas (root of the plugin)
 * @param {object}     options options object of the plugin
 */
var CanvasRenderer = function(el, options) {
	var cachedBackground;
	var canvas = document.createElement('canvas');

	el.appendChild(canvas);

	if (typeof(G_vmlCanvasManager) === 'object') {
		G_vmlCanvasManager.initElement(canvas);
	}

	var ctx = canvas.getContext('2d');

	canvas.width = canvas.height = options.size;

	// canvas on retina devices
	var scaleBy = 1;
	if (window.devicePixelRatio > 1) {
		scaleBy = window.devicePixelRatio;
		canvas.style.width = canvas.style.height = [options.size, 'px'].join('');
		canvas.width = canvas.height = options.size * scaleBy;
		ctx.scale(scaleBy, scaleBy);
	}

	// move 0,0 coordinates to the center
	ctx.translate(options.size / 2, options.size / 2);

	// rotate canvas -90deg
	ctx.rotate((-1 / 2 + options.rotate / 180) * Math.PI);

	var radius = (options.size - options.lineWidth) / 2;
	if (options.scaleColor && options.scaleLength) {
		radius -= options.scaleLength + 2; // 2 is the distance between scale and bar
	}

	// IE polyfill for Date
	Date.now = Date.now || function() {
		return +(new Date());
	};

	/**
	 * Draw a circle around the center of the canvas
	 * @param {strong} color     Valid CSS color string
	 * @param {number} lineWidth Width of the line in px
	 * @param {number} percent   Percentage to draw (float between -1 and 1)
	 */
	var drawCircle = function(color, lineWidth, percent) {
		percent = Math.min(Math.max(-1, percent || 0), 1);
		var isNegative = percent <= 0 ? true : false;

		ctx.beginPath();
		ctx.arc(0, 0, radius, 0, Math.PI * 2 * percent, isNegative);

		ctx.strokeStyle = color;
		ctx.lineWidth = lineWidth;

		ctx.stroke();
	};

	/**
	 * Draw the scale of the chart
	 */
	var drawScale = function() {
		var offset;
		var length;

		ctx.lineWidth = 1;
		ctx.fillStyle = options.scaleColor;

		ctx.save();
		for (var i = 24; i > 0; --i) {
			if (i % 6 === 0) {
				length = options.scaleLength;
				offset = 0;
			} else {
				length = options.scaleLength * 0.6;
				offset = options.scaleLength - length;
			}
			ctx.fillRect(-options.size/2 + offset, 0, length, 1);
			ctx.rotate(Math.PI / 12);
		}
		ctx.restore();
	};

	/**
	 * Request animation frame wrapper with polyfill
	 * @return {function} Request animation frame method or timeout fallback
	 */
	var reqAnimationFrame = (function() {
		return  window.requestAnimationFrame ||
				window.webkitRequestAnimationFrame ||
				window.mozRequestAnimationFrame ||
				function(callback) {
					window.setTimeout(callback, 1000 / 60);
				};
	}());

	/**
	 * Draw the background of the plugin including the scale and the track
	 */
	var drawBackground = function() {
		if(options.scaleColor) drawScale();
		if(options.trackColor) drawCircle(options.trackColor, options.trackWidth || options.lineWidth, 1);
	};

  /**
    * Canvas accessor
   */
  this.getCanvas = function() {
    return canvas;
  };

  /**
    * Canvas 2D context 'ctx' accessor
   */
  this.getCtx = function() {
    return ctx;
  };

	/**
	 * Clear the complete canvas
	 */
	this.clear = function() {
		ctx.clearRect(options.size / -2, options.size / -2, options.size, options.size);
	};

	/**
	 * Draw the complete chart
	 * @param {number} percent Percent shown by the chart between -100 and 100
	 */
	this.draw = function(percent) {
		// do we need to render a background
		if (!!options.scaleColor || !!options.trackColor) {
			// getImageData and putImageData are supported
			if (ctx.getImageData && ctx.putImageData) {
				if (!cachedBackground) {
					drawBackground();
					cachedBackground = ctx.getImageData(0, 0, options.size * scaleBy, options.size * scaleBy);
				} else {
					ctx.putImageData(cachedBackground, 0, 0);
				}
			} else {
				this.clear();
				drawBackground();
			}
		} else {
			this.clear();
		}

		ctx.lineCap = options.lineCap;

		// if barcolor is a function execute it and pass the percent as a value
		var color;
		if (typeof(options.barColor) === 'function') {
			color = options.barColor(percent);
		} else {
			color = options.barColor;
		}

		// draw bar
		drawCircle(color, options.lineWidth, percent / 100);
	}.bind(this);

	/**
	 * Animate from some percent to some other percentage
	 * @param {number} from Starting percentage
	 * @param {number} to   Final percentage
	 */
	this.animate = function(from, to) {
		var startTime = Date.now();
		options.onStart(from, to);
		var animation = function() {
			var process = Math.min(Date.now() - startTime, options.animate.duration);
			var currentValue = options.easing(this, process, from, to - from, options.animate.duration);
			this.draw(currentValue);
			options.onStep(from, to, currentValue);
			if (process >= options.animate.duration) {
				options.onStop(from, to);
			} else {
				reqAnimationFrame(animation);
			}
		}.bind(this);

		reqAnimationFrame(animation);
	}.bind(this);
};

var EasyPieChart = function(el, opts) {
	var defaultOptions = {
		barColor: '#ef1e25',
		trackColor: '#f9f9f9',
		scaleColor: '#dfe0e0',
		scaleLength: 5,
		lineCap: 'round',
		lineWidth: 3,
		trackWidth: undefined,
		size: 110,
		rotate: 0,
		animate: {
			duration: 1000,
			enabled: true
		},
		easing: function (x, t, b, c, d) { // more can be found here: http://gsgd.co.uk/sandbox/jquery/easing/
			t = t / (d/2);
			if (t < 1) {
				return c / 2 * t * t + b;
			}
			return -c/2 * ((--t)*(t-2) - 1) + b;
		},
		onStart: function(from, to) {
			return;
		},
		onStep: function(from, to, currentValue) {
			return;
		},
		onStop: function(from, to) {
			return;
		}
	};

	// detect present renderer
	if (typeof(CanvasRenderer) !== 'undefined') {
		defaultOptions.renderer = CanvasRenderer;
	} else if (typeof(SVGRenderer) !== 'undefined') {
		defaultOptions.renderer = SVGRenderer;
	} else {
		throw new Error('Please load either the SVG- or the CanvasRenderer');
	}

	var options = {};
	var currentValue = 0;

	/**
	 * Initialize the plugin by creating the options object and initialize rendering
	 */
	var init = function() {
		this.el = el;
		this.options = options;

		// merge user options into default options
		for (var i in defaultOptions) {
			if (defaultOptions.hasOwnProperty(i)) {
				options[i] = opts && typeof(opts[i]) !== 'undefined' ? opts[i] : defaultOptions[i];
				if (typeof(options[i]) === 'function') {
					options[i] = options[i].bind(this);
				}
			}
		}

		// check for jQuery easing
		if (typeof(options.easing) === 'string' && typeof(jQuery) !== 'undefined' && jQuery.isFunction(jQuery.easing[options.easing])) {
			options.easing = jQuery.easing[options.easing];
		} else {
			options.easing = defaultOptions.easing;
		}

		// process earlier animate option to avoid bc breaks
		if (typeof(options.animate) === 'number') {
			options.animate = {
				duration: options.animate,
				enabled: true
			};
		}

		if (typeof(options.animate) === 'boolean' && !options.animate) {
			options.animate = {
				duration: 1000,
				enabled: options.animate
			};
		}

		// create renderer
		this.renderer = new options.renderer(el, options);

		// initial draw
		this.renderer.draw(currentValue);

		// initial update
		if (el.dataset && el.dataset.percent) {
			this.update(parseFloat(el.dataset.percent));
		} else if (el.getAttribute && el.getAttribute('data-percent')) {
			this.update(parseFloat(el.getAttribute('data-percent')));
		}
	}.bind(this);

	/**
	 * Update the value of the chart
	 * @param  {number} newValue Number between 0 and 100
	 * @return {object}          Instance of the plugin for method chaining
	 */
	this.update = function(newValue) {
		newValue = parseFloat(newValue);
		if (options.animate.enabled) {
			this.renderer.animate(currentValue, newValue);
		} else {
			this.renderer.draw(newValue);
		}
		currentValue = newValue;
		return this;
	}.bind(this);

	/**
	 * Disable animation
	 * @return {object} Instance of the plugin for method chaining
	 */
	this.disableAnimation = function() {
		options.animate.enabled = false;
		return this;
	};

	/**
	 * Enable animation
	 * @return {object} Instance of the plugin for method chaining
	 */
	this.enableAnimation = function() {
		options.animate.enabled = true;
		return this;
	};

	init();
};

$.fn.easyPieChart = function(options) {
	return this.each(function() {
		var instanceOptions;

		if (!$.data(this, 'easyPieChart')) {
			instanceOptions = $.extend({}, options, $(this).data());
			$.data(this, 'easyPieChart', new EasyPieChart(this, instanceOptions));
		}
	});
};


}));

document.addEventListener('DOMContentLoaded', function () {
	/* 	Easy pie chart Snippet
		DOC: make sure to include this snippet in your project to be able to use the easy 
		configurations without any jquery implementations
	 */
	$('.js-easy-pie-chart').each(function() {

		var $this = $(this),
			barcolor = $this.css('color') || color.primary._700,
			trackcolor = $this.data('trackcolor') || 'rgba(0,0,0,0.04)',
			size = parseInt($this.data('piesize')) || 50,
			scalecolor =   $this.data('scalecolor') || $this.css('color'),
			scalelength = parseInt($this.data('scalelength')) || 0,
			linewidth = parseInt($this.data('linewidth')) ||  parseInt(size / 8.5),
			linecap = $this.data('linecap') || 'butt'; //butt, round and square.
			
		$this.easyPieChart({
			size : size,
			barColor : barcolor,
			trackColor : trackcolor,
			scaleColor: scalecolor,
			scaleLength: scalelength, //Length of the scale lines (reduces the radius of the chart).
			lineCap : linecap, //Defines how the ending of the bar line looks like. Possible values are: butt, round and square.
			lineWidth : linewidth,
			animate: {
				duration: 1500,
				enabled: true
			},
			onStep: function(from, to, percent) {
				$(this.el).find('.js-percent').text(Math.round(percent));
			}
		});

		$this = null;
	});
});
// Peity jQuery plugin version 3.3.0
// (c) 2018 Ben Pickles
//
// http://benpickles.github.io/peity
//
// Released under MIT license.
(function($, document, Math, undefined) {
  var peity = $.fn.peity = function(type, options) {
    if (svgSupported) {
      this.each(function() {
        var $this = $(this)
        var chart = $this.data('_peity')

        if (chart) {
          if (type) chart.type = type
          $.extend(chart.opts, options)
        } else {
          chart = new Peity(
            $this,
            type,
            $.extend({},
              peity.defaults[type],
              $this.data('peity'),
              options)
          )

          $this
            .change(function() { chart.draw() })
            .data('_peity', chart)
        }

        chart.draw()
      });
    }

    return this;
  };

  var Peity = function($el, type, opts) {
    this.$el = $el
    this.type = type
    this.opts = opts
  }

  var PeityPrototype = Peity.prototype

  var svgElement = PeityPrototype.svgElement = function(tag, attrs) {
    return $(
      document.createElementNS('http://www.w3.org/2000/svg', tag)
    ).attr(attrs)
  }

  // https://gist.github.com/madrobby/3201472
  var svgSupported = 'createElementNS' in document && svgElement('svg', {})[0].createSVGRect

  PeityPrototype.draw = function() {
    var opts = this.opts
    peity.graphers[this.type].call(this, opts)
    if (opts.after) opts.after.call(this, opts)
  }

  PeityPrototype.fill = function() {
    var fill = this.opts.fill

    return $.isFunction(fill)
      ? fill
      : function(_, i) { return fill[i % fill.length] }
  }

  PeityPrototype.prepare = function(width, height) {
    if (!this.$svg) {
      this.$el.hide().after(
        this.$svg = svgElement('svg', {
          "class": "peity"
        })
      )
    }

    return this.$svg
      .empty()
      .data('_peity', this)
      .attr({
        height: height,
        width: width
      })
  }

  PeityPrototype.values = function() {
    return $.map(this.$el.text().split(this.opts.delimiter), function(value) {
      return parseFloat(value)
    })
  }

  peity.defaults = {}
  peity.graphers = {}

  peity.register = function(type, defaults, grapher) {
    this.defaults[type] = defaults
    this.graphers[type] = grapher
  }

  peity.register(
    'pie',
    {
      fill: ['#ff9900', '#fff4dd', '#ffc66e'],
      radius: 8
    },
    function(opts) {
      if (!opts.delimiter) {
        var delimiter = this.$el.text().match(/[^0-9\.]/)
        opts.delimiter = delimiter ? delimiter[0] : ","
      }

      var values = $.map(this.values(), function(n) {
        return n > 0 ? n : 0
      })

      if (opts.delimiter == "/") {
        var v1 = values[0]
        var v2 = values[1]
        values = [v1, Math.max(0, v2 - v1)]
      }

      var i = 0
      var length = values.length
      var sum = 0

      for (; i < length; i++) {
        sum += values[i]
      }

      if (!sum) {
        length = 2
        sum = 1
        values = [0, 1]
      }

      var diameter = opts.radius * 2

      var $svg = this.prepare(
        opts.width || diameter,
        opts.height || diameter
      )

      var width = $svg.width()
        , height = $svg.height()
        , cx = width / 2
        , cy = height / 2

      var radius = Math.min(cx, cy)
        , innerRadius = opts.innerRadius

      if (this.type == 'donut' && !innerRadius) {
        innerRadius = radius * 0.5
      }

      var pi = Math.PI
      var fill = this.fill()

      var scale = this.scale = function(value, radius) {
        var radians = value / sum * pi * 2 - pi / 2

        return [
          radius * Math.cos(radians) + cx,
          radius * Math.sin(radians) + cy
        ]
      }

      var cumulative = 0

      for (i = 0; i < length; i++) {
        var value = values[i]
          , portion = value / sum
          , $node

        if (portion == 0) continue

        if (portion == 1) {
          if (innerRadius) {
            var x2 = cx - 0.01
              , y1 = cy - radius
              , y2 = cy - innerRadius

            $node = svgElement('path', {
              d: [
                'M', cx, y1,
                'A', radius, radius, 0, 1, 1, x2, y1,
                'L', x2, y2,
                'A', innerRadius, innerRadius, 0, 1, 0, cx, y2
              ].join(' '),
              'data-value': value,
            })
          } else {
            $node = svgElement('circle', {
              cx: cx,
              cy: cy,
              'data-value': value,
              r: radius
            })
          }
        } else {
          var cumulativePlusValue = cumulative + value

          var d = ['M'].concat(
            scale(cumulative, radius),
            'A', radius, radius, 0, portion > 0.5 ? 1 : 0, 1,
            scale(cumulativePlusValue, radius),
            'L'
          )

          if (innerRadius) {
            d = d.concat(
              scale(cumulativePlusValue, innerRadius),
              'A', innerRadius, innerRadius, 0, portion > 0.5 ? 1 : 0, 0,
              scale(cumulative, innerRadius)
            )
          } else {
            d.push(cx, cy)
          }

          cumulative += value

          $node = svgElement('path', {
            d: d.join(" "),
            'data-value': value,
          })
        }

        $node.attr('fill', fill.call(this, value, i, values))

        $svg.append($node)
      }
    }
  )

  peity.register(
    'donut',
    $.extend(true, {}, peity.defaults.pie),
    function(opts) {
      peity.graphers.pie.call(this, opts)
    }
  )

  peity.register(
    "line",
    {
      delimiter: ",",
      fill: "#c6d9fd",
      height: 16,
      min: 0,
      stroke: "#4d89f9",
      strokeWidth: 1,
      width: 32
    },
    function(opts) {
      var values = this.values()
      if (values.length == 1) values.push(values[0])
      var max = Math.max.apply(Math, opts.max == undefined ? values : values.concat(opts.max))
        , min = Math.min.apply(Math, opts.min == undefined ? values : values.concat(opts.min))

      var $svg = this.prepare(opts.width, opts.height)
        , strokeWidth = opts.strokeWidth
        , width = $svg.width()
        , height = $svg.height() - strokeWidth
        , diff = max - min

      var xScale = this.x = function(input) {
        return input * (width / (values.length - 1))
      }

      var yScale = this.y = function(input) {
        var y = height

        if (diff) {
          y -= ((input - min) / diff) * height
        }

        return y + strokeWidth / 2
      }

      var zero = yScale(Math.max(min, 0))
        , coords = [0, zero]

      for (var i = 0; i < values.length; i++) {
        coords.push(
          xScale(i),
          yScale(values[i])
        )
      }

      coords.push(width, zero)

      if (opts.fill) {
        $svg.append(
          svgElement('polygon', {
            fill: opts.fill,
            points: coords.join(' ')
          })
        )
      }

      if (strokeWidth) {
        $svg.append(
          svgElement('polyline', {
            fill: 'none',
            points: coords.slice(2, coords.length - 2).join(' '),
            stroke: opts.stroke,
            'stroke-width': strokeWidth,
            'stroke-linecap': 'square'
          })
        )
      }
    }
  );

  peity.register(
    'bar',
    {
      delimiter: ",",
      fill: ["#4D89F9"],
      height: 16,
      min: 0,
      padding: 0.1,
      width: 32
    },
    function(opts) {
      var values = this.values()
        , max = Math.max.apply(Math, opts.max == undefined ? values : values.concat(opts.max))
        , min = Math.min.apply(Math, opts.min == undefined ? values : values.concat(opts.min))

      var $svg = this.prepare(opts.width, opts.height)
        , width = $svg.width()
        , height = $svg.height()
        , diff = max - min
        , padding = opts.padding
        , fill = this.fill()

      var xScale = this.x = function(input) {
        return input * width / values.length
      }

      var yScale = this.y = function(input) {
        return height - (
          diff
            ? ((input - min) / diff) * height
            : 1
        )
      }

      for (var i = 0; i < values.length; i++) {
        var x = xScale(i + padding)
          , w = xScale(i + 1 - padding) - x
          , value = values[i]
          , valueY = yScale(value)
          , y1 = valueY
          , y2 = valueY
          , h

        if (!diff) {
          h = 1
        } else if (value < 0) {
          y1 = yScale(Math.min(max, 0))
        } else {
          y2 = yScale(Math.max(min, 0))
        }

        h = y2 - y1

        if (h == 0) {
          h = 1
          if (max > 0 && diff) y1--
        }

        $svg.append(
          svgElement('rect', {
            'data-value': value,
            fill: fill.call(this, value, i, values),
            x: x,
            y: y1,
            width: w,
            height: h
          })
        )
      }
    }
  );
})(jQuery, document, Math);

document.addEventListener('DOMContentLoaded', function () {
	/* 	Starts peity
		DOC: searches for the class and init. peity based on class
	 */
	$(".peity-pie").peity("pie");
	$('.peity-donut').peity('donut');
	$(".peity-line").peity("line");
	$(".peity-bar").peity("bar");
});
/* Javascript plotting library for jQuery, version 0.8.3.

Copyright (c) 2007-2014 IOLA and Ole Laursen.
Licensed under the MIT license.

*/

// first an inline dependency, jquery.colorhelpers.js, we inline it here
// for convenience

/* Plugin for jQuery for working with colors.
 *
 * Version 1.1.
 *
 * Inspiration from jQuery color animation plugin by John Resig.
 *
 * Released under the MIT license by Ole Laursen, October 2009.
 *
 * Examples:
 *
 *   $.color.parse("#fff").scale('rgb', 0.25).add('a', -0.5).toString()
 *   var c = $.color.extract($("#mydiv"), 'background-color');
 *   console.log(c.r, c.g, c.b, c.a);
 *   $.color.make(100, 50, 25, 0.4).toString() // returns "rgba(100,50,25,0.4)"
 *
 * Note that .scale() and .add() return the same modified object
 * instead of making a new one.
 *
 * V. 1.1: Fix error handling so e.g. parsing an empty string does
 * produce a color rather than just crashing.
 */
(function($){$.color={};$.color.make=function(r,g,b,a){var o={};o.r=r||0;o.g=g||0;o.b=b||0;o.a=a!=null?a:1;o.add=function(c,d){for(var i=0;i<c.length;++i)o[c.charAt(i)]+=d;return o.normalize()};o.scale=function(c,f){for(var i=0;i<c.length;++i)o[c.charAt(i)]*=f;return o.normalize()};o.toString=function(){if(o.a>=1){return"rgb("+[o.r,o.g,o.b].join(",")+")"}else{return"rgba("+[o.r,o.g,o.b,o.a].join(",")+")"}};o.normalize=function(){function clamp(min,value,max){return value<min?min:value>max?max:value}o.r=clamp(0,parseInt(o.r),255);o.g=clamp(0,parseInt(o.g),255);o.b=clamp(0,parseInt(o.b),255);o.a=clamp(0,o.a,1);return o};o.clone=function(){return $.color.make(o.r,o.b,o.g,o.a)};return o.normalize()};$.color.extract=function(elem,css){var c;do{c=elem.css(css).toLowerCase();if(c!=""&&c!="transparent")break;elem=elem.parent()}while(elem.length&&!$.nodeName(elem.get(0),"body"));if(c=="rgba(0, 0, 0, 0)")c="transparent";return $.color.parse(c)};$.color.parse=function(str){var res,m=$.color.make;if(res=/rgb\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*\)/.exec(str))return m(parseInt(res[1],10),parseInt(res[2],10),parseInt(res[3],10));if(res=/rgba\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]+(?:\.[0-9]+)?)\s*\)/.exec(str))return m(parseInt(res[1],10),parseInt(res[2],10),parseInt(res[3],10),parseFloat(res[4]));if(res=/rgb\(\s*([0-9]+(?:\.[0-9]+)?)\%\s*,\s*([0-9]+(?:\.[0-9]+)?)\%\s*,\s*([0-9]+(?:\.[0-9]+)?)\%\s*\)/.exec(str))return m(parseFloat(res[1])*2.55,parseFloat(res[2])*2.55,parseFloat(res[3])*2.55);if(res=/rgba\(\s*([0-9]+(?:\.[0-9]+)?)\%\s*,\s*([0-9]+(?:\.[0-9]+)?)\%\s*,\s*([0-9]+(?:\.[0-9]+)?)\%\s*,\s*([0-9]+(?:\.[0-9]+)?)\s*\)/.exec(str))return m(parseFloat(res[1])*2.55,parseFloat(res[2])*2.55,parseFloat(res[3])*2.55,parseFloat(res[4]));if(res=/#([a-fA-F0-9]{2})([a-fA-F0-9]{2})([a-fA-F0-9]{2})/.exec(str))return m(parseInt(res[1],16),parseInt(res[2],16),parseInt(res[3],16));if(res=/#([a-fA-F0-9])([a-fA-F0-9])([a-fA-F0-9])/.exec(str))return m(parseInt(res[1]+res[1],16),parseInt(res[2]+res[2],16),parseInt(res[3]+res[3],16));var name=$.trim(str).toLowerCase();if(name=="transparent")return m(255,255,255,0);else{res=lookupColors[name]||[0,0,0];return m(res[0],res[1],res[2])}};var lookupColors={aqua:[0,255,255],azure:[240,255,255],beige:[245,245,220],black:[0,0,0],blue:[0,0,255],brown:[165,42,42],cyan:[0,255,255],darkblue:[0,0,139],darkcyan:[0,139,139],darkgrey:[169,169,169],darkgreen:[0,100,0],darkkhaki:[189,183,107],darkmagenta:[139,0,139],darkolivegreen:[85,107,47],darkorange:[255,140,0],darkorchid:[153,50,204],darkred:[139,0,0],darksalmon:[233,150,122],darkviolet:[148,0,211],fuchsia:[255,0,255],gold:[255,215,0],green:[0,128,0],indigo:[75,0,130],khaki:[240,230,140],lightblue:[173,216,230],lightcyan:[224,255,255],lightgreen:[144,238,144],lightgrey:[211,211,211],lightpink:[255,182,193],lightyellow:[255,255,224],lime:[0,255,0],magenta:[255,0,255],maroon:[128,0,0],navy:[0,0,128],olive:[128,128,0],orange:[255,165,0],pink:[255,192,203],purple:[128,0,128],violet:[128,0,128],red:[255,0,0],silver:[192,192,192],white:[255,255,255],yellow:[255,255,0]}})(jQuery);

// the actual Flot code
(function($) {

	// Cache the prototype hasOwnProperty for faster access

	var hasOwnProperty = Object.prototype.hasOwnProperty;

    // A shim to provide 'detach' to jQuery versions prior to 1.4.  Using a DOM
    // operation produces the same effect as detach, i.e. removing the element
    // without touching its jQuery data.

    // Do not merge this into Flot 0.9, since it requires jQuery 1.4.4+.

    if (!$.fn.detach) {
        $.fn.detach = function() {
            return this.each(function() {
                if (this.parentNode) {
                    this.parentNode.removeChild( this );
                }
            });
        };
    }

	///////////////////////////////////////////////////////////////////////////
	// The Canvas object is a wrapper around an HTML5 <canvas> tag.
	//
	// @constructor
	// @param {string} cls List of classes to apply to the canvas.
	// @param {element} container Element onto which to append the canvas.
	//
	// Requiring a container is a little iffy, but unfortunately canvas
	// operations don't work unless the canvas is attached to the DOM.

	function Canvas(cls, container) {

		var element = container.children("." + cls)[0];

		if (element == null) {

			element = document.createElement("canvas");
			element.className = cls;

			$(element).css({ direction: "ltr", position: "absolute", left: 0, top: 0 })
				.appendTo(container);

			// If HTML5 Canvas isn't available, fall back to [Ex|Flash]canvas

			if (!element.getContext) {
				if (window.G_vmlCanvasManager) {
					element = window.G_vmlCanvasManager.initElement(element);
				} else {
					throw new Error("Canvas is not available. If you're using IE with a fall-back such as Excanvas, then there's either a mistake in your conditional include, or the page has no DOCTYPE and is rendering in Quirks Mode.");
				}
			}
		}

		this.element = element;

		var context = this.context = element.getContext("2d");

		// Determine the screen's ratio of physical to device-independent
		// pixels.  This is the ratio between the canvas width that the browser
		// advertises and the number of pixels actually present in that space.

		// The iPhone 4, for example, has a device-independent width of 320px,
		// but its screen is actually 640px wide.  It therefore has a pixel
		// ratio of 2, while most normal devices have a ratio of 1.

		var devicePixelRatio = window.devicePixelRatio || 1,
			backingStoreRatio =
				context.webkitBackingStorePixelRatio ||
				context.mozBackingStorePixelRatio ||
				context.msBackingStorePixelRatio ||
				context.oBackingStorePixelRatio ||
				context.backingStorePixelRatio || 1;

		this.pixelRatio = devicePixelRatio / backingStoreRatio;

		// Size the canvas to match the internal dimensions of its container

		this.resize(container.width(), container.height());

		// Collection of HTML div layers for text overlaid onto the canvas

		this.textContainer = null;
		this.text = {};

		// Cache of text fragments and metrics, so we can avoid expensively
		// re-calculating them when the plot is re-rendered in a loop.

		this._textCache = {};
	}

	// Resizes the canvas to the given dimensions.
	//
	// @param {number} width New width of the canvas, in pixels.
	// @param {number} width New height of the canvas, in pixels.

	Canvas.prototype.resize = function(width, height) {

		if (width <= 0 || height <= 0) {
			throw new Error("Invalid dimensions for plot, width = " + width + ", height = " + height);
		}

		var element = this.element,
			context = this.context,
			pixelRatio = this.pixelRatio;

		// Resize the canvas, increasing its density based on the display's
		// pixel ratio; basically giving it more pixels without increasing the
		// size of its element, to take advantage of the fact that retina
		// displays have that many more pixels in the same advertised space.

		// Resizing should reset the state (excanvas seems to be buggy though)

		if (this.width != width) {
			element.width = width * pixelRatio;
			element.style.width = width + "px";
			this.width = width;
		}

		if (this.height != height) {
			element.height = height * pixelRatio;
			element.style.height = height + "px";
			this.height = height;
		}

		// Save the context, so we can reset in case we get replotted.  The
		// restore ensure that we're really back at the initial state, and
		// should be safe even if we haven't saved the initial state yet.

		context.restore();
		context.save();

		// Scale the coordinate space to match the display density; so even though we
		// may have twice as many pixels, we still want lines and other drawing to
		// appear at the same size; the extra pixels will just make them crisper.

		context.scale(pixelRatio, pixelRatio);
	};

	// Clears the entire canvas area, not including any overlaid HTML text

	Canvas.prototype.clear = function() {
		this.context.clearRect(0, 0, this.width, this.height);
	};

	// Finishes rendering the canvas, including managing the text overlay.

	Canvas.prototype.render = function() {

		var cache = this._textCache;

		// For each text layer, add elements marked as active that haven't
		// already been rendered, and remove those that are no longer active.

		for (var layerKey in cache) {
			if (hasOwnProperty.call(cache, layerKey)) {

				var layer = this.getTextLayer(layerKey),
					layerCache = cache[layerKey];

				layer.hide();

				for (var styleKey in layerCache) {
					if (hasOwnProperty.call(layerCache, styleKey)) {
						var styleCache = layerCache[styleKey];
						for (var key in styleCache) {
							if (hasOwnProperty.call(styleCache, key)) {

								var positions = styleCache[key].positions;

								for (var i = 0, position; position = positions[i]; i++) {
									if (position.active) {
										if (!position.rendered) {
											layer.append(position.element);
											position.rendered = true;
										}
									} else {
										positions.splice(i--, 1);
										if (position.rendered) {
											position.element.detach();
										}
									}
								}

								if (positions.length == 0) {
									delete styleCache[key];
								}
							}
						}
					}
				}

				layer.show();
			}
		}
	};

	// Creates (if necessary) and returns the text overlay container.
	//
	// @param {string} classes String of space-separated CSS classes used to
	//     uniquely identify the text layer.
	// @return {object} The jQuery-wrapped text-layer div.

	Canvas.prototype.getTextLayer = function(classes) {

		var layer = this.text[classes];

		// Create the text layer if it doesn't exist

		if (layer == null) {

			// Create the text layer container, if it doesn't exist

			if (this.textContainer == null) {
				this.textContainer = $("<div class='flot-text'></div>")
					.css({
						position: "absolute",
						top: 0,
						left: 0,
						bottom: 0,
						right: 0,
						'font-size': "smaller",
						color: "#545454"
					})
					.insertAfter(this.element);
			}

			layer = this.text[classes] = $("<div></div>")
				.addClass(classes)
				.css({
					position: "absolute",
					top: 0,
					left: 0,
					bottom: 0,
					right: 0
				})
				.appendTo(this.textContainer);
		}

		return layer;
	};

	// Creates (if necessary) and returns a text info object.
	//
	// The object looks like this:
	//
	// {
	//     width: Width of the text's wrapper div.
	//     height: Height of the text's wrapper div.
	//     element: The jQuery-wrapped HTML div containing the text.
	//     positions: Array of positions at which this text is drawn.
	// }
	//
	// The positions array contains objects that look like this:
	//
	// {
	//     active: Flag indicating whether the text should be visible.
	//     rendered: Flag indicating whether the text is currently visible.
	//     element: The jQuery-wrapped HTML div containing the text.
	//     x: X coordinate at which to draw the text.
	//     y: Y coordinate at which to draw the text.
	// }
	//
	// Each position after the first receives a clone of the original element.
	//
	// The idea is that that the width, height, and general 'identity' of the
	// text is constant no matter where it is placed; the placements are a
	// secondary property.
	//
	// Canvas maintains a cache of recently-used text info objects; getTextInfo
	// either returns the cached element or creates a new entry.
	//
	// @param {string} layer A string of space-separated CSS classes uniquely
	//     identifying the layer containing this text.
	// @param {string} text Text string to retrieve info for.
	// @param {(string|object)=} font Either a string of space-separated CSS
	//     classes or a font-spec object, defining the text's font and style.
	// @param {number=} angle Angle at which to rotate the text, in degrees.
	//     Angle is currently unused, it will be implemented in the future.
	// @param {number=} width Maximum width of the text before it wraps.
	// @return {object} a text info object.

	Canvas.prototype.getTextInfo = function(layer, text, font, angle, width) {

		var textStyle, layerCache, styleCache, info;

		// Cast the value to a string, in case we were given a number or such

		text = "" + text;

		// If the font is a font-spec object, generate a CSS font definition

		if (typeof font === "object") {
			textStyle = font.style + " " + font.variant + " " + font.weight + " " + font.size + "px/" + font.lineHeight + "px " + font.family;
		} else {
			textStyle = font;
		}

		// Retrieve (or create) the cache for the text's layer and styles

		layerCache = this._textCache[layer];

		if (layerCache == null) {
			layerCache = this._textCache[layer] = {};
		}

		styleCache = layerCache[textStyle];

		if (styleCache == null) {
			styleCache = layerCache[textStyle] = {};
		}

		info = styleCache[text];

		// If we can't find a matching element in our cache, create a new one

		if (info == null) {

			var element = $("<div></div>").html(text)
				.css({
					position: "absolute",
					'max-width': width,
					top: -9999
				})
				.appendTo(this.getTextLayer(layer));

			if (typeof font === "object") {
				element.css({
					font: textStyle,
					color: font.color
				});
			} else if (typeof font === "string") {
				element.addClass(font);
			}

			info = styleCache[text] = {
				width: element.outerWidth(true),
				height: element.outerHeight(true),
				element: element,
				positions: []
			};

			element.detach();
		}

		return info;
	};

	// Adds a text string to the canvas text overlay.
	//
	// The text isn't drawn immediately; it is marked as rendering, which will
	// result in its addition to the canvas on the next render pass.
	//
	// @param {string} layer A string of space-separated CSS classes uniquely
	//     identifying the layer containing this text.
	// @param {number} x X coordinate at which to draw the text.
	// @param {number} y Y coordinate at which to draw the text.
	// @param {string} text Text string to draw.
	// @param {(string|object)=} font Either a string of space-separated CSS
	//     classes or a font-spec object, defining the text's font and style.
	// @param {number=} angle Angle at which to rotate the text, in degrees.
	//     Angle is currently unused, it will be implemented in the future.
	// @param {number=} width Maximum width of the text before it wraps.
	// @param {string=} halign Horizontal alignment of the text; either "left",
	//     "center" or "right".
	// @param {string=} valign Vertical alignment of the text; either "top",
	//     "middle" or "bottom".

	Canvas.prototype.addText = function(layer, x, y, text, font, angle, width, halign, valign) {

		var info = this.getTextInfo(layer, text, font, angle, width),
			positions = info.positions;

		// Tweak the div's position to match the text's alignment

		if (halign == "center") {
			x -= info.width / 2;
		} else if (halign == "right") {
			x -= info.width;
		}

		if (valign == "middle") {
			y -= info.height / 2;
		} else if (valign == "bottom") {
			y -= info.height;
		}

		// Determine whether this text already exists at this position.
		// If so, mark it for inclusion in the next render pass.

		for (var i = 0, position; position = positions[i]; i++) {
			if (position.x == x && position.y == y) {
				position.active = true;
				return;
			}
		}

		// If the text doesn't exist at this position, create a new entry

		// For the very first position we'll re-use the original element,
		// while for subsequent ones we'll clone it.

		position = {
			active: true,
			rendered: false,
			element: positions.length ? info.element.clone() : info.element,
			x: x,
			y: y
		};

		positions.push(position);

		// Move the element to its final position within the container

		position.element.css({
			top: Math.round(y),
			left: Math.round(x),
			'text-align': halign	// In case the text wraps
		});
	};

	// Removes one or more text strings from the canvas text overlay.
	//
	// If no parameters are given, all text within the layer is removed.
	//
	// Note that the text is not immediately removed; it is simply marked as
	// inactive, which will result in its removal on the next render pass.
	// This avoids the performance penalty for 'clear and redraw' behavior,
	// where we potentially get rid of all text on a layer, but will likely
	// add back most or all of it later, as when redrawing axes, for example.
	//
	// @param {string} layer A string of space-separated CSS classes uniquely
	//     identifying the layer containing this text.
	// @param {number=} x X coordinate of the text.
	// @param {number=} y Y coordinate of the text.
	// @param {string=} text Text string to remove.
	// @param {(string|object)=} font Either a string of space-separated CSS
	//     classes or a font-spec object, defining the text's font and style.
	// @param {number=} angle Angle at which the text is rotated, in degrees.
	//     Angle is currently unused, it will be implemented in the future.

	Canvas.prototype.removeText = function(layer, x, y, text, font, angle) {
		if (text == null) {
			var layerCache = this._textCache[layer];
			if (layerCache != null) {
				for (var styleKey in layerCache) {
					if (hasOwnProperty.call(layerCache, styleKey)) {
						var styleCache = layerCache[styleKey];
						for (var key in styleCache) {
							if (hasOwnProperty.call(styleCache, key)) {
								var positions = styleCache[key].positions;
								for (var i = 0, position; position = positions[i]; i++) {
									position.active = false;
								}
							}
						}
					}
				}
			}
		} else {
			var positions = this.getTextInfo(layer, text, font, angle).positions;
			for (var i = 0, position; position = positions[i]; i++) {
				if (position.x == x && position.y == y) {
					position.active = false;
				}
			}
		}
	};

	///////////////////////////////////////////////////////////////////////////
	// The top-level container for the entire plot.

    function Plot(placeholder, data_, options_, plugins) {
        // data is on the form:
        //   [ series1, series2 ... ]
        // where series is either just the data as [ [x1, y1], [x2, y2], ... ]
        // or { data: [ [x1, y1], [x2, y2], ... ], label: "some label", ... }

        var series = [],
            options = {
                // the color theme used for graphs
                colors: ["#edc240", "#afd8f8", "#cb4b4b", "#4da74d", "#9440ed"],
                legend: {
                    show: true,
                    noColumns: 1, // number of colums in legend table
                    labelFormatter: null, // fn: string -> string
                    labelBoxBorderColor: "#ccc", // border color for the little label boxes
                    container: null, // container (as jQuery object) to put legend in, null means default on top of graph
                    position: "ne", // position of default legend container within plot
                    margin: 5, // distance from grid edge to default legend container within plot
                    backgroundColor: null, // null means auto-detect
                    backgroundOpacity: 0.85, // set to 0 to avoid background
                    sorted: null    // default to no legend sorting
                },
                xaxis: {
                    show: null, // null = auto-detect, true = always, false = never
                    position: "bottom", // or "top"
                    mode: null, // null or "time"
                    font: null, // null (derived from CSS in placeholder) or object like { size: 11, lineHeight: 13, style: "italic", weight: "bold", family: "sans-serif", variant: "small-caps" }
                    color: null, // base color, labels, ticks
                    tickColor: null, // possibly different color of ticks, e.g. "rgba(0,0,0,0.15)"
                    transform: null, // null or f: number -> number to transform axis
                    inverseTransform: null, // if transform is set, this should be the inverse function
                    min: null, // min. value to show, null means set automatically
                    max: null, // max. value to show, null means set automatically
                    autoscaleMargin: null, // margin in % to add if auto-setting min/max
                    ticks: null, // either [1, 3] or [[1, "a"], 3] or (fn: axis info -> ticks) or app. number of ticks for auto-ticks
                    tickFormatter: null, // fn: number -> string
                    labelWidth: null, // size of tick labels in pixels
                    labelHeight: null,
                    reserveSpace: null, // whether to reserve space even if axis isn't shown
                    tickLength: null, // size in pixels of ticks, or "full" for whole line
                    alignTicksWithAxis: null, // axis number or null for no sync
                    tickDecimals: null, // no. of decimals, null means auto
                    tickSize: null, // number or [number, "unit"]
                    minTickSize: null // number or [number, "unit"]
                },
                yaxis: {
                    autoscaleMargin: 0.02,
                    position: "left" // or "right"
                },
                xaxes: [],
                yaxes: [],
                series: {
                    points: {
                        show: false,
                        radius: 3,
                        lineWidth: 2, // in pixels
                        fill: true,
                        fillColor: "#ffffff",
                        symbol: "circle" // or callback
                    },
                    lines: {
                        // we don't put in show: false so we can see
                        // whether lines were actively disabled
                        lineWidth: 2, // in pixels
                        fill: false,
                        fillColor: null,
                        steps: false
                        // Omit 'zero', so we can later default its value to
                        // match that of the 'fill' option.
                    },
                    bars: {
                        show: false,
                        lineWidth: 2, // in pixels
                        barWidth: 1, // in units of the x axis
                        fill: true,
                        fillColor: null,
                        align: "left", // "left", "right", or "center"
                        horizontal: false,
                        zero: true
                    },
                    shadowSize: 3,
                    highlightColor: null
                },
                grid: {
                    show: true,
                    aboveData: false,
                    color: "#545454", // primary color used for outline and labels
                    backgroundColor: null, // null for transparent, else color
                    borderColor: null, // set if different from the grid color
                    tickColor: null, // color for the ticks, e.g. "rgba(0,0,0,0.15)"
                    margin: 0, // distance from the canvas edge to the grid
                    labelMargin: 5, // in pixels
                    axisMargin: 8, // in pixels
                    borderWidth: 2, // in pixels
                    minBorderMargin: null, // in pixels, null means taken from points radius
                    markings: null, // array of ranges or fn: axes -> array of ranges
                    markingsColor: "#f4f4f4",
                    markingsLineWidth: 2,
                    // interactive stuff
                    clickable: false,
                    hoverable: false,
                    autoHighlight: true, // highlight in case mouse is near
                    mouseActiveRadius: 10 // how far the mouse can be away to activate an item
                },
                interaction: {
                    redrawOverlayInterval: 1000/60 // time between updates, -1 means in same flow
                },
                hooks: {}
            },
        surface = null,     // the canvas for the plot itself
        overlay = null,     // canvas for interactive stuff on top of plot
        eventHolder = null, // jQuery object that events should be bound to
        ctx = null, octx = null,
        xaxes = [], yaxes = [],
        plotOffset = { left: 0, right: 0, top: 0, bottom: 0},
        plotWidth = 0, plotHeight = 0,
        hooks = {
            processOptions: [],
            processRawData: [],
            processDatapoints: [],
            processOffset: [],
            drawBackground: [],
            drawSeries: [],
            draw: [],
            bindEvents: [],
            drawOverlay: [],
            shutdown: []
        },
        plot = this;

        // public functions
        plot.setData = setData;
        plot.setupGrid = setupGrid;
        plot.draw = draw;
        plot.getPlaceholder = function() { return placeholder; };
        plot.getCanvas = function() { return surface.element; };
        plot.getPlotOffset = function() { return plotOffset; };
        plot.width = function () { return plotWidth; };
        plot.height = function () { return plotHeight; };
        plot.offset = function () {
            var o = eventHolder.offset();
            o.left += plotOffset.left;
            o.top += plotOffset.top;
            return o;
        };
        plot.getData = function () { return series; };
        plot.getAxes = function () {
            var res = {}, i;
            $.each(xaxes.concat(yaxes), function (_, axis) {
                if (axis)
                    res[axis.direction + (axis.n != 1 ? axis.n : "") + "axis"] = axis;
            });
            return res;
        };
        plot.getXAxes = function () { return xaxes; };
        plot.getYAxes = function () { return yaxes; };
        plot.c2p = canvasToAxisCoords;
        plot.p2c = axisToCanvasCoords;
        plot.getOptions = function () { return options; };
        plot.highlight = highlight;
        plot.unhighlight = unhighlight;
        plot.triggerRedrawOverlay = triggerRedrawOverlay;
        plot.pointOffset = function(point) {
            return {
                left: parseInt(xaxes[axisNumber(point, "x") - 1].p2c(+point.x) + plotOffset.left, 10),
                top: parseInt(yaxes[axisNumber(point, "y") - 1].p2c(+point.y) + plotOffset.top, 10)
            };
        };
        plot.shutdown = shutdown;
        plot.destroy = function () {
            shutdown();
            placeholder.removeData("plot").empty();

            series = [];
            options = null;
            surface = null;
            overlay = null;
            eventHolder = null;
            ctx = null;
            octx = null;
            xaxes = [];
            yaxes = [];
            hooks = null;
            highlights = [];
            plot = null;
        };
        plot.resize = function () {
        	var width = placeholder.width(),
        		height = placeholder.height();
            surface.resize(width, height);
            overlay.resize(width, height);
        };

        // public attributes
        plot.hooks = hooks;

        // initialize
        initPlugins(plot);
        parseOptions(options_);
        setupCanvases();
        setData(data_);
        setupGrid();
        draw();
        bindEvents();


        function executeHooks(hook, args) {
            args = [plot].concat(args);
            for (var i = 0; i < hook.length; ++i)
                hook[i].apply(this, args);
        }

        function initPlugins() {

            // References to key classes, allowing plugins to modify them

            var classes = {
                Canvas: Canvas
            };

            for (var i = 0; i < plugins.length; ++i) {
                var p = plugins[i];
                p.init(plot, classes);
                if (p.options)
                    $.extend(true, options, p.options);
            }
        }

        function parseOptions(opts) {

            $.extend(true, options, opts);

            // $.extend merges arrays, rather than replacing them.  When less
            // colors are provided than the size of the default palette, we
            // end up with those colors plus the remaining defaults, which is
            // not expected behavior; avoid it by replacing them here.

            if (opts && opts.colors) {
            	options.colors = opts.colors;
            }

            if (options.xaxis.color == null)
                options.xaxis.color = $.color.parse(options.grid.color).scale('a', 0.22).toString();
            if (options.yaxis.color == null)
                options.yaxis.color = $.color.parse(options.grid.color).scale('a', 0.22).toString();

            if (options.xaxis.tickColor == null) // grid.tickColor for back-compatibility
                options.xaxis.tickColor = options.grid.tickColor || options.xaxis.color;
            if (options.yaxis.tickColor == null) // grid.tickColor for back-compatibility
                options.yaxis.tickColor = options.grid.tickColor || options.yaxis.color;

            if (options.grid.borderColor == null)
                options.grid.borderColor = options.grid.color;
            if (options.grid.tickColor == null)
                options.grid.tickColor = $.color.parse(options.grid.color).scale('a', 0.22).toString();

            // Fill in defaults for axis options, including any unspecified
            // font-spec fields, if a font-spec was provided.

            // If no x/y axis options were provided, create one of each anyway,
            // since the rest of the code assumes that they exist.

            var i, axisOptions, axisCount,
                fontSize = placeholder.css("font-size"),
                fontSizeDefault = fontSize ? +fontSize.replace("px", "") : 13,
                fontDefaults = {
                    style: placeholder.css("font-style"),
                    size: Math.round(0.8 * fontSizeDefault),
                    variant: placeholder.css("font-variant"),
                    weight: placeholder.css("font-weight"),
                    family: placeholder.css("font-family")
                };

            axisCount = options.xaxes.length || 1;
            for (i = 0; i < axisCount; ++i) {

                axisOptions = options.xaxes[i];
                if (axisOptions && !axisOptions.tickColor) {
                    axisOptions.tickColor = axisOptions.color;
                }

                axisOptions = $.extend(true, {}, options.xaxis, axisOptions);
                options.xaxes[i] = axisOptions;

                if (axisOptions.font) {
                    axisOptions.font = $.extend({}, fontDefaults, axisOptions.font);
                    if (!axisOptions.font.color) {
                        axisOptions.font.color = axisOptions.color;
                    }
                    if (!axisOptions.font.lineHeight) {
                        axisOptions.font.lineHeight = Math.round(axisOptions.font.size * 1.15);
                    }
                }
            }

            axisCount = options.yaxes.length || 1;
            for (i = 0; i < axisCount; ++i) {

                axisOptions = options.yaxes[i];
                if (axisOptions && !axisOptions.tickColor) {
                    axisOptions.tickColor = axisOptions.color;
                }

                axisOptions = $.extend(true, {}, options.yaxis, axisOptions);
                options.yaxes[i] = axisOptions;

                if (axisOptions.font) {
                    axisOptions.font = $.extend({}, fontDefaults, axisOptions.font);
                    if (!axisOptions.font.color) {
                        axisOptions.font.color = axisOptions.color;
                    }
                    if (!axisOptions.font.lineHeight) {
                        axisOptions.font.lineHeight = Math.round(axisOptions.font.size * 1.15);
                    }
                }
            }

            // backwards compatibility, to be removed in future
            if (options.xaxis.noTicks && options.xaxis.ticks == null)
                options.xaxis.ticks = options.xaxis.noTicks;
            if (options.yaxis.noTicks && options.yaxis.ticks == null)
                options.yaxis.ticks = options.yaxis.noTicks;
            if (options.x2axis) {
                options.xaxes[1] = $.extend(true, {}, options.xaxis, options.x2axis);
                options.xaxes[1].position = "top";
                // Override the inherit to allow the axis to auto-scale
                if (options.x2axis.min == null) {
                    options.xaxes[1].min = null;
                }
                if (options.x2axis.max == null) {
                    options.xaxes[1].max = null;
                }
            }
            if (options.y2axis) {
                options.yaxes[1] = $.extend(true, {}, options.yaxis, options.y2axis);
                options.yaxes[1].position = "right";
                // Override the inherit to allow the axis to auto-scale
                if (options.y2axis.min == null) {
                    options.yaxes[1].min = null;
                }
                if (options.y2axis.max == null) {
                    options.yaxes[1].max = null;
                }
            }
            if (options.grid.coloredAreas)
                options.grid.markings = options.grid.coloredAreas;
            if (options.grid.coloredAreasColor)
                options.grid.markingsColor = options.grid.coloredAreasColor;
            if (options.lines)
                $.extend(true, options.series.lines, options.lines);
            if (options.points)
                $.extend(true, options.series.points, options.points);
            if (options.bars)
                $.extend(true, options.series.bars, options.bars);
            if (options.shadowSize != null)
                options.series.shadowSize = options.shadowSize;
            if (options.highlightColor != null)
                options.series.highlightColor = options.highlightColor;

            // save options on axes for future reference
            for (i = 0; i < options.xaxes.length; ++i)
                getOrCreateAxis(xaxes, i + 1).options = options.xaxes[i];
            for (i = 0; i < options.yaxes.length; ++i)
                getOrCreateAxis(yaxes, i + 1).options = options.yaxes[i];

            // add hooks from options
            for (var n in hooks)
                if (options.hooks[n] && options.hooks[n].length)
                    hooks[n] = hooks[n].concat(options.hooks[n]);

            executeHooks(hooks.processOptions, [options]);
        }

        function setData(d) {
            series = parseData(d);
            fillInSeriesOptions();
            processData();
        }

        function parseData(d) {
            var res = [];
            for (var i = 0; i < d.length; ++i) {
                var s = $.extend(true, {}, options.series);

                if (d[i].data != null) {
                    s.data = d[i].data; // move the data instead of deep-copy
                    delete d[i].data;

                    $.extend(true, s, d[i]);

                    d[i].data = s.data;
                }
                else
                    s.data = d[i];
                res.push(s);
            }

            return res;
        }

        function axisNumber(obj, coord) {
            var a = obj[coord + "axis"];
            if (typeof a == "object") // if we got a real axis, extract number
                a = a.n;
            if (typeof a != "number")
                a = 1; // default to first axis
            return a;
        }

        function allAxes() {
            // return flat array without annoying null entries
            return $.grep(xaxes.concat(yaxes), function (a) { return a; });
        }

        function canvasToAxisCoords(pos) {
            // return an object with x/y corresponding to all used axes
            var res = {}, i, axis;
            for (i = 0; i < xaxes.length; ++i) {
                axis = xaxes[i];
                if (axis && axis.used)
                    res["x" + axis.n] = axis.c2p(pos.left);
            }

            for (i = 0; i < yaxes.length; ++i) {
                axis = yaxes[i];
                if (axis && axis.used)
                    res["y" + axis.n] = axis.c2p(pos.top);
            }

            if (res.x1 !== undefined)
                res.x = res.x1;
            if (res.y1 !== undefined)
                res.y = res.y1;

            return res;
        }

        function axisToCanvasCoords(pos) {
            // get canvas coords from the first pair of x/y found in pos
            var res = {}, i, axis, key;

            for (i = 0; i < xaxes.length; ++i) {
                axis = xaxes[i];
                if (axis && axis.used) {
                    key = "x" + axis.n;
                    if (pos[key] == null && axis.n == 1)
                        key = "x";

                    if (pos[key] != null) {
                        res.left = axis.p2c(pos[key]);
                        break;
                    }
                }
            }

            for (i = 0; i < yaxes.length; ++i) {
                axis = yaxes[i];
                if (axis && axis.used) {
                    key = "y" + axis.n;
                    if (pos[key] == null && axis.n == 1)
                        key = "y";

                    if (pos[key] != null) {
                        res.top = axis.p2c(pos[key]);
                        break;
                    }
                }
            }

            return res;
        }

        function getOrCreateAxis(axes, number) {
            if (!axes[number - 1])
                axes[number - 1] = {
                    n: number, // save the number for future reference
                    direction: axes == xaxes ? "x" : "y",
                    options: $.extend(true, {}, axes == xaxes ? options.xaxis : options.yaxis)
                };

            return axes[number - 1];
        }

        function fillInSeriesOptions() {

            var neededColors = series.length, maxIndex = -1, i;

            // Subtract the number of series that already have fixed colors or
            // color indexes from the number that we still need to generate.

            for (i = 0; i < series.length; ++i) {
                var sc = series[i].color;
                if (sc != null) {
                    neededColors--;
                    if (typeof sc == "number" && sc > maxIndex) {
                        maxIndex = sc;
                    }
                }
            }

            // If any of the series have fixed color indexes, then we need to
            // generate at least as many colors as the highest index.

            if (neededColors <= maxIndex) {
                neededColors = maxIndex + 1;
            }

            // Generate all the colors, using first the option colors and then
            // variations on those colors once they're exhausted.

            var c, colors = [], colorPool = options.colors,
                colorPoolSize = colorPool.length, variation = 0;

            for (i = 0; i < neededColors; i++) {

                c = $.color.parse(colorPool[i % colorPoolSize] || "#666");

                // Each time we exhaust the colors in the pool we adjust
                // a scaling factor used to produce more variations on
                // those colors. The factor alternates negative/positive
                // to produce lighter/darker colors.

                // Reset the variation after every few cycles, or else
                // it will end up producing only white or black colors.

                if (i % colorPoolSize == 0 && i) {
                    if (variation >= 0) {
                        if (variation < 0.5) {
                            variation = -variation - 0.2;
                        } else variation = 0;
                    } else variation = -variation;
                }

                colors[i] = c.scale('rgb', 1 + variation);
            }

            // Finalize the series options, filling in their colors

            var colori = 0, s;
            for (i = 0; i < series.length; ++i) {
                s = series[i];

                // assign colors
                if (s.color == null) {
                    s.color = colors[colori].toString();
                    ++colori;
                }
                else if (typeof s.color == "number")
                    s.color = colors[s.color].toString();

                // turn on lines automatically in case nothing is set
                if (s.lines.show == null) {
                    var v, show = true;
                    for (v in s)
                        if (s[v] && s[v].show) {
                            show = false;
                            break;
                        }
                    if (show)
                        s.lines.show = true;
                }

                // If nothing was provided for lines.zero, default it to match
                // lines.fill, since areas by default should extend to zero.

                if (s.lines.zero == null) {
                    s.lines.zero = !!s.lines.fill;
                }

                // setup axes
                s.xaxis = getOrCreateAxis(xaxes, axisNumber(s, "x"));
                s.yaxis = getOrCreateAxis(yaxes, axisNumber(s, "y"));
            }
        }

        function processData() {
            var topSentry = Number.POSITIVE_INFINITY,
                bottomSentry = Number.NEGATIVE_INFINITY,
                fakeInfinity = Number.MAX_VALUE,
                i, j, k, m, length,
                s, points, ps, x, y, axis, val, f, p,
                data, format;

            function updateAxis(axis, min, max) {
                if (min < axis.datamin && min != -fakeInfinity)
                    axis.datamin = min;
                if (max > axis.datamax && max != fakeInfinity)
                    axis.datamax = max;
            }

            $.each(allAxes(), function (_, axis) {
                // init axis
                axis.datamin = topSentry;
                axis.datamax = bottomSentry;
                axis.used = false;
            });

            for (i = 0; i < series.length; ++i) {
                s = series[i];
                s.datapoints = { points: [] };

                executeHooks(hooks.processRawData, [ s, s.data, s.datapoints ]);
            }

            // first pass: clean and copy data
            for (i = 0; i < series.length; ++i) {
                s = series[i];

                data = s.data;
                format = s.datapoints.format;

                if (!format) {
                    format = [];
                    // find out how to copy
                    format.push({ x: true, number: true, required: true });
                    format.push({ y: true, number: true, required: true });

                    if (s.bars.show || (s.lines.show && s.lines.fill)) {
                        var autoscale = !!((s.bars.show && s.bars.zero) || (s.lines.show && s.lines.zero));
                        format.push({ y: true, number: true, required: false, defaultValue: 0, autoscale: autoscale });
                        if (s.bars.horizontal) {
                            delete format[format.length - 1].y;
                            format[format.length - 1].x = true;
                        }
                    }

                    s.datapoints.format = format;
                }

                if (s.datapoints.pointsize != null)
                    continue; // already filled in

                s.datapoints.pointsize = format.length;

                ps = s.datapoints.pointsize;
                points = s.datapoints.points;

                var insertSteps = s.lines.show && s.lines.steps;
                s.xaxis.used = s.yaxis.used = true;

                for (j = k = 0; j < data.length; ++j, k += ps) {
                    p = data[j];

                    var nullify = p == null;
                    if (!nullify) {
                        for (m = 0; m < ps; ++m) {
                            val = p[m];
                            f = format[m];

                            if (f) {
                                if (f.number && val != null) {
                                    val = +val; // convert to number
                                    if (isNaN(val))
                                        val = null;
                                    else if (val == Infinity)
                                        val = fakeInfinity;
                                    else if (val == -Infinity)
                                        val = -fakeInfinity;
                                }

                                if (val == null) {
                                    if (f.required)
                                        nullify = true;

                                    if (f.defaultValue != null)
                                        val = f.defaultValue;
                                }
                            }

                            points[k + m] = val;
                        }
                    }

                    if (nullify) {
                        for (m = 0; m < ps; ++m) {
                            val = points[k + m];
                            if (val != null) {
                                f = format[m];
                                // extract min/max info
                                if (f.autoscale !== false) {
                                    if (f.x) {
                                        updateAxis(s.xaxis, val, val);
                                    }
                                    if (f.y) {
                                        updateAxis(s.yaxis, val, val);
                                    }
                                }
                            }
                            points[k + m] = null;
                        }
                    }
                    else {
                        // a little bit of line specific stuff that
                        // perhaps shouldn't be here, but lacking
                        // better means...
                        if (insertSteps && k > 0
                            && points[k - ps] != null
                            && points[k - ps] != points[k]
                            && points[k - ps + 1] != points[k + 1]) {
                            // copy the point to make room for a middle point
                            for (m = 0; m < ps; ++m)
                                points[k + ps + m] = points[k + m];

                            // middle point has same y
                            points[k + 1] = points[k - ps + 1];

                            // we've added a point, better reflect that
                            k += ps;
                        }
                    }
                }
            }

            // give the hooks a chance to run
            for (i = 0; i < series.length; ++i) {
                s = series[i];

                executeHooks(hooks.processDatapoints, [ s, s.datapoints]);
            }

            // second pass: find datamax/datamin for auto-scaling
            for (i = 0; i < series.length; ++i) {
                s = series[i];
                points = s.datapoints.points;
                ps = s.datapoints.pointsize;
                format = s.datapoints.format;

                var xmin = topSentry, ymin = topSentry,
                    xmax = bottomSentry, ymax = bottomSentry;

                for (j = 0; j < points.length; j += ps) {
                    if (points[j] == null)
                        continue;

                    for (m = 0; m < ps; ++m) {
                        val = points[j + m];
                        f = format[m];
                        if (!f || f.autoscale === false || val == fakeInfinity || val == -fakeInfinity)
                            continue;

                        if (f.x) {
                            if (val < xmin)
                                xmin = val;
                            if (val > xmax)
                                xmax = val;
                        }
                        if (f.y) {
                            if (val < ymin)
                                ymin = val;
                            if (val > ymax)
                                ymax = val;
                        }
                    }
                }

                if (s.bars.show) {
                    // make sure we got room for the bar on the dancing floor
                    var delta;

                    switch (s.bars.align) {
                        case "left":
                            delta = 0;
                            break;
                        case "right":
                            delta = -s.bars.barWidth;
                            break;
                        default:
                            delta = -s.bars.barWidth / 2;
                    }

                    if (s.bars.horizontal) {
                        ymin += delta;
                        ymax += delta + s.bars.barWidth;
                    }
                    else {
                        xmin += delta;
                        xmax += delta + s.bars.barWidth;
                    }
                }

                updateAxis(s.xaxis, xmin, xmax);
                updateAxis(s.yaxis, ymin, ymax);
            }

            $.each(allAxes(), function (_, axis) {
                if (axis.datamin == topSentry)
                    axis.datamin = null;
                if (axis.datamax == bottomSentry)
                    axis.datamax = null;
            });
        }

        function setupCanvases() {

            // Make sure the placeholder is clear of everything except canvases
            // from a previous plot in this container that we'll try to re-use.

            placeholder.css("padding", 0) // padding messes up the positioning
                .children().filter(function(){
                    return !$(this).hasClass("flot-overlay") && !$(this).hasClass('flot-base');
                }).remove();

            if (placeholder.css("position") == 'static')
                placeholder.css("position", "relative"); // for positioning labels and overlay

            surface = new Canvas("flot-base", placeholder);
            overlay = new Canvas("flot-overlay", placeholder); // overlay canvas for interactive features

            ctx = surface.context;
            octx = overlay.context;

            // define which element we're listening for events on
            eventHolder = $(overlay.element).unbind();

            // If we're re-using a plot object, shut down the old one

            var existing = placeholder.data("plot");

            if (existing) {
                existing.shutdown();
                overlay.clear();
            }

            // save in case we get replotted
            placeholder.data("plot", plot);
        }

        function bindEvents() {
            // bind events
            if (options.grid.hoverable) {
                eventHolder.mousemove(onMouseMove);

                // Use bind, rather than .mouseleave, because we officially
                // still support jQuery 1.2.6, which doesn't define a shortcut
                // for mouseenter or mouseleave.  This was a bug/oversight that
                // was fixed somewhere around 1.3.x.  We can return to using
                // .mouseleave when we drop support for 1.2.6.

                eventHolder.bind("mouseleave", onMouseLeave);
            }

            if (options.grid.clickable)
                eventHolder.click(onClick);

            executeHooks(hooks.bindEvents, [eventHolder]);
        }

        function shutdown() {
            if (redrawTimeout)
                clearTimeout(redrawTimeout);

            eventHolder.unbind("mousemove", onMouseMove);
            eventHolder.unbind("mouseleave", onMouseLeave);
            eventHolder.unbind("click", onClick);

            executeHooks(hooks.shutdown, [eventHolder]);
        }

        function setTransformationHelpers(axis) {
            // set helper functions on the axis, assumes plot area
            // has been computed already

            function identity(x) { return x; }

            var s, m, t = axis.options.transform || identity,
                it = axis.options.inverseTransform;

            // precompute how much the axis is scaling a point
            // in canvas space
            if (axis.direction == "x") {
                s = axis.scale = plotWidth / Math.abs(t(axis.max) - t(axis.min));
                m = Math.min(t(axis.max), t(axis.min));
            }
            else {
                s = axis.scale = plotHeight / Math.abs(t(axis.max) - t(axis.min));
                s = -s;
                m = Math.max(t(axis.max), t(axis.min));
            }

            // data point to canvas coordinate
            if (t == identity) // slight optimization
                axis.p2c = function (p) { return (p - m) * s; };
            else
                axis.p2c = function (p) { return (t(p) - m) * s; };
            // canvas coordinate to data point
            if (!it)
                axis.c2p = function (c) { return m + c / s; };
            else
                axis.c2p = function (c) { return it(m + c / s); };
        }

        function measureTickLabels(axis) {

            var opts = axis.options,
                ticks = axis.ticks || [],
                labelWidth = opts.labelWidth || 0,
                labelHeight = opts.labelHeight || 0,
                maxWidth = labelWidth || (axis.direction == "x" ? Math.floor(surface.width / (ticks.length || 1)) : null),
                legacyStyles = axis.direction + "Axis " + axis.direction + axis.n + "Axis",
                layer = "flot-" + axis.direction + "-axis flot-" + axis.direction + axis.n + "-axis " + legacyStyles,
                font = opts.font || "flot-tick-label tickLabel";

            for (var i = 0; i < ticks.length; ++i) {

                var t = ticks[i];

                if (!t.label)
                    continue;

                var info = surface.getTextInfo(layer, t.label, font, null, maxWidth);

                labelWidth = Math.max(labelWidth, info.width);
                labelHeight = Math.max(labelHeight, info.height);
            }

            axis.labelWidth = opts.labelWidth || labelWidth;
            axis.labelHeight = opts.labelHeight || labelHeight;
        }

        function allocateAxisBoxFirstPhase(axis) {
            // find the bounding box of the axis by looking at label
            // widths/heights and ticks, make room by diminishing the
            // plotOffset; this first phase only looks at one
            // dimension per axis, the other dimension depends on the
            // other axes so will have to wait

            var lw = axis.labelWidth,
                lh = axis.labelHeight,
                pos = axis.options.position,
                isXAxis = axis.direction === "x",
                tickLength = axis.options.tickLength,
                axisMargin = options.grid.axisMargin,
                padding = options.grid.labelMargin,
                innermost = true,
                outermost = true,
                first = true,
                found = false;

            // Determine the axis's position in its direction and on its side

            $.each(isXAxis ? xaxes : yaxes, function(i, a) {
                if (a && (a.show || a.reserveSpace)) {
                    if (a === axis) {
                        found = true;
                    } else if (a.options.position === pos) {
                        if (found) {
                            outermost = false;
                        } else {
                            innermost = false;
                        }
                    }
                    if (!found) {
                        first = false;
                    }
                }
            });

            // The outermost axis on each side has no margin

            if (outermost) {
                axisMargin = 0;
            }

            // The ticks for the first axis in each direction stretch across

            if (tickLength == null) {
                tickLength = first ? "full" : 5;
            }

            if (!isNaN(+tickLength))
                padding += +tickLength;

            if (isXAxis) {
                lh += padding;

                if (pos == "bottom") {
                    plotOffset.bottom += lh + axisMargin;
                    axis.box = { top: surface.height - plotOffset.bottom, height: lh };
                }
                else {
                    axis.box = { top: plotOffset.top + axisMargin, height: lh };
                    plotOffset.top += lh + axisMargin;
                }
            }
            else {
                lw += padding;

                if (pos == "left") {
                    axis.box = { left: plotOffset.left + axisMargin, width: lw };
                    plotOffset.left += lw + axisMargin;
                }
                else {
                    plotOffset.right += lw + axisMargin;
                    axis.box = { left: surface.width - plotOffset.right, width: lw };
                }
            }

             // save for future reference
            axis.position = pos;
            axis.tickLength = tickLength;
            axis.box.padding = padding;
            axis.innermost = innermost;
        }

        function allocateAxisBoxSecondPhase(axis) {
            // now that all axis boxes have been placed in one
            // dimension, we can set the remaining dimension coordinates
            if (axis.direction == "x") {
                axis.box.left = plotOffset.left - axis.labelWidth / 2;
                axis.box.width = surface.width - plotOffset.left - plotOffset.right + axis.labelWidth;
            }
            else {
                axis.box.top = plotOffset.top - axis.labelHeight / 2;
                axis.box.height = surface.height - plotOffset.bottom - plotOffset.top + axis.labelHeight;
            }
        }

        function adjustLayoutForThingsStickingOut() {
            // possibly adjust plot offset to ensure everything stays
            // inside the canvas and isn't clipped off

            var minMargin = options.grid.minBorderMargin,
                axis, i;

            // check stuff from the plot (FIXME: this should just read
            // a value from the series, otherwise it's impossible to
            // customize)
            if (minMargin == null) {
                minMargin = 0;
                for (i = 0; i < series.length; ++i)
                    minMargin = Math.max(minMargin, 2 * (series[i].points.radius + series[i].points.lineWidth/2));
            }

            var margins = {
                left: minMargin,
                right: minMargin,
                top: minMargin,
                bottom: minMargin
            };

            // check axis labels, note we don't check the actual
            // labels but instead use the overall width/height to not
            // jump as much around with replots
            $.each(allAxes(), function (_, axis) {
                if (axis.reserveSpace && axis.ticks && axis.ticks.length) {
                    if (axis.direction === "x") {
                        margins.left = Math.max(margins.left, axis.labelWidth / 2);
                        margins.right = Math.max(margins.right, axis.labelWidth / 2);
                    } else {
                        margins.bottom = Math.max(margins.bottom, axis.labelHeight / 2);
                        margins.top = Math.max(margins.top, axis.labelHeight / 2);
                    }
                }
            });

            plotOffset.left = Math.ceil(Math.max(margins.left, plotOffset.left));
            plotOffset.right = Math.ceil(Math.max(margins.right, plotOffset.right));
            plotOffset.top = Math.ceil(Math.max(margins.top, plotOffset.top));
            plotOffset.bottom = Math.ceil(Math.max(margins.bottom, plotOffset.bottom));
        }

        function setupGrid() {
            var i, axes = allAxes(), showGrid = options.grid.show;

            // Initialize the plot's offset from the edge of the canvas

            for (var a in plotOffset) {
                var margin = options.grid.margin || 0;
                plotOffset[a] = typeof margin == "number" ? margin : margin[a] || 0;
            }

            executeHooks(hooks.processOffset, [plotOffset]);

            // If the grid is visible, add its border width to the offset

            for (var a in plotOffset) {
                if(typeof(options.grid.borderWidth) == "object") {
                    plotOffset[a] += showGrid ? options.grid.borderWidth[a] : 0;
                }
                else {
                    plotOffset[a] += showGrid ? options.grid.borderWidth : 0;
                }
            }

            $.each(axes, function (_, axis) {
                var axisOpts = axis.options;
                axis.show = axisOpts.show == null ? axis.used : axisOpts.show;
                axis.reserveSpace = axisOpts.reserveSpace == null ? axis.show : axisOpts.reserveSpace;
                setRange(axis);
            });

            if (showGrid) {

                var allocatedAxes = $.grep(axes, function (axis) {
                    return axis.show || axis.reserveSpace;
                });

                $.each(allocatedAxes, function (_, axis) {
                    // make the ticks
                    setupTickGeneration(axis);
                    setTicks(axis);
                    snapRangeToTicks(axis, axis.ticks);
                    // find labelWidth/Height for axis
                    measureTickLabels(axis);
                });

                // with all dimensions calculated, we can compute the
                // axis bounding boxes, start from the outside
                // (reverse order)
                for (i = allocatedAxes.length - 1; i >= 0; --i)
                    allocateAxisBoxFirstPhase(allocatedAxes[i]);

                // make sure we've got enough space for things that
                // might stick out
                adjustLayoutForThingsStickingOut();

                $.each(allocatedAxes, function (_, axis) {
                    allocateAxisBoxSecondPhase(axis);
                });
            }

            plotWidth = surface.width - plotOffset.left - plotOffset.right;
            plotHeight = surface.height - plotOffset.bottom - plotOffset.top;

            // now we got the proper plot dimensions, we can compute the scaling
            $.each(axes, function (_, axis) {
                setTransformationHelpers(axis);
            });

            if (showGrid) {
                drawAxisLabels();
            }

            insertLegend();
        }

        function setRange(axis) {
            var opts = axis.options,
                min = +(opts.min != null ? opts.min : axis.datamin),
                max = +(opts.max != null ? opts.max : axis.datamax),
                delta = max - min;

            if (delta == 0.0) {
                // degenerate case
                var widen = max == 0 ? 1 : 0.01;

                if (opts.min == null)
                    min -= widen;
                // always widen max if we couldn't widen min to ensure we
                // don't fall into min == max which doesn't work
                if (opts.max == null || opts.min != null)
                    max += widen;
            }
            else {
                // consider autoscaling
                var margin = opts.autoscaleMargin;
                if (margin != null) {
                    if (opts.min == null) {
                        min -= delta * margin;
                        // make sure we don't go below zero if all values
                        // are positive
                        if (min < 0 && axis.datamin != null && axis.datamin >= 0)
                            min = 0;
                    }
                    if (opts.max == null) {
                        max += delta * margin;
                        if (max > 0 && axis.datamax != null && axis.datamax <= 0)
                            max = 0;
                    }
                }
            }
            axis.min = min;
            axis.max = max;
        }

        function setupTickGeneration(axis) {
            var opts = axis.options;

            // estimate number of ticks
            var noTicks;
            if (typeof opts.ticks == "number" && opts.ticks > 0)
                noTicks = opts.ticks;
            else
                // heuristic based on the model a*sqrt(x) fitted to
                // some data points that seemed reasonable
                noTicks = 0.3 * Math.sqrt(axis.direction == "x" ? surface.width : surface.height);

            var delta = (axis.max - axis.min) / noTicks,
                dec = -Math.floor(Math.log(delta) / Math.LN10),
                maxDec = opts.tickDecimals;

            if (maxDec != null && dec > maxDec) {
                dec = maxDec;
            }

            var magn = Math.pow(10, -dec),
                norm = delta / magn, // norm is between 1.0 and 10.0
                size;

            if (norm < 1.5) {
                size = 1;
            } else if (norm < 3) {
                size = 2;
                // special case for 2.5, requires an extra decimal
                if (norm > 2.25 && (maxDec == null || dec + 1 <= maxDec)) {
                    size = 2.5;
                    ++dec;
                }
            } else if (norm < 7.5) {
                size = 5;
            } else {
                size = 10;
            }

            size *= magn;

            if (opts.minTickSize != null && size < opts.minTickSize) {
                size = opts.minTickSize;
            }

            axis.delta = delta;
            axis.tickDecimals = Math.max(0, maxDec != null ? maxDec : dec);
            axis.tickSize = opts.tickSize || size;

            // Time mode was moved to a plug-in in 0.8, and since so many people use it
            // we'll add an especially friendly reminder to make sure they included it.

            if (opts.mode == "time" && !axis.tickGenerator) {
                throw new Error("Time mode requires the flot.time plugin.");
            }

            // Flot supports base-10 axes; any other mode else is handled by a plug-in,
            // like flot.time.js.

            if (!axis.tickGenerator) {

                axis.tickGenerator = function (axis) {

                    var ticks = [],
                        start = floorInBase(axis.min, axis.tickSize),
                        i = 0,
                        v = Number.NaN,
                        prev;

                    do {
                        prev = v;
                        v = start + i * axis.tickSize;
                        ticks.push(v);
                        ++i;
                    } while (v < axis.max && v != prev);
                    return ticks;
                };

				axis.tickFormatter = function (value, axis) {

					var factor = axis.tickDecimals ? Math.pow(10, axis.tickDecimals) : 1;
					var formatted = "" + Math.round(value * factor) / factor;

					// If tickDecimals was specified, ensure that we have exactly that
					// much precision; otherwise default to the value's own precision.

					if (axis.tickDecimals != null) {
						var decimal = formatted.indexOf(".");
						var precision = decimal == -1 ? 0 : formatted.length - decimal - 1;
						if (precision < axis.tickDecimals) {
							return (precision ? formatted : formatted + ".") + ("" + factor).substr(1, axis.tickDecimals - precision);
						}
					}

                    return formatted;
                };
            }

            if ($.isFunction(opts.tickFormatter))
                axis.tickFormatter = function (v, axis) { return "" + opts.tickFormatter(v, axis); };

            if (opts.alignTicksWithAxis != null) {
                var otherAxis = (axis.direction == "x" ? xaxes : yaxes)[opts.alignTicksWithAxis - 1];
                if (otherAxis && otherAxis.used && otherAxis != axis) {
                    // consider snapping min/max to outermost nice ticks
                    var niceTicks = axis.tickGenerator(axis);
                    if (niceTicks.length > 0) {
                        if (opts.min == null)
                            axis.min = Math.min(axis.min, niceTicks[0]);
                        if (opts.max == null && niceTicks.length > 1)
                            axis.max = Math.max(axis.max, niceTicks[niceTicks.length - 1]);
                    }

                    axis.tickGenerator = function (axis) {
                        // copy ticks, scaled to this axis
                        var ticks = [], v, i;
                        for (i = 0; i < otherAxis.ticks.length; ++i) {
                            v = (otherAxis.ticks[i].v - otherAxis.min) / (otherAxis.max - otherAxis.min);
                            v = axis.min + v * (axis.max - axis.min);
                            ticks.push(v);
                        }
                        return ticks;
                    };

                    // we might need an extra decimal since forced
                    // ticks don't necessarily fit naturally
                    if (!axis.mode && opts.tickDecimals == null) {
                        var extraDec = Math.max(0, -Math.floor(Math.log(axis.delta) / Math.LN10) + 1),
                            ts = axis.tickGenerator(axis);

                        // only proceed if the tick interval rounded
                        // with an extra decimal doesn't give us a
                        // zero at end
                        if (!(ts.length > 1 && /\..*0$/.test((ts[1] - ts[0]).toFixed(extraDec))))
                            axis.tickDecimals = extraDec;
                    }
                }
            }
        }

        function setTicks(axis) {
            var oticks = axis.options.ticks, ticks = [];
            if (oticks == null || (typeof oticks == "number" && oticks > 0))
                ticks = axis.tickGenerator(axis);
            else if (oticks) {
                if ($.isFunction(oticks))
                    // generate the ticks
                    ticks = oticks(axis);
                else
                    ticks = oticks;
            }

            // clean up/labelify the supplied ticks, copy them over
            var i, v;
            axis.ticks = [];
            for (i = 0; i < ticks.length; ++i) {
                var label = null;
                var t = ticks[i];
                if (typeof t == "object") {
                    v = +t[0];
                    if (t.length > 1)
                        label = t[1];
                }
                else
                    v = +t;
                if (label == null)
                    label = axis.tickFormatter(v, axis);
                if (!isNaN(v))
                    axis.ticks.push({ v: v, label: label });
            }
        }

        function snapRangeToTicks(axis, ticks) {
            if (axis.options.autoscaleMargin && ticks.length > 0) {
                // snap to ticks
                if (axis.options.min == null)
                    axis.min = Math.min(axis.min, ticks[0].v);
                if (axis.options.max == null && ticks.length > 1)
                    axis.max = Math.max(axis.max, ticks[ticks.length - 1].v);
            }
        }

        function draw() {

            surface.clear();

            executeHooks(hooks.drawBackground, [ctx]);

            var grid = options.grid;

            // draw background, if any
            if (grid.show && grid.backgroundColor)
                drawBackground();

            if (grid.show && !grid.aboveData) {
                drawGrid();
            }

            for (var i = 0; i < series.length; ++i) {
                executeHooks(hooks.drawSeries, [ctx, series[i]]);
                drawSeries(series[i]);
            }

            executeHooks(hooks.draw, [ctx]);

            if (grid.show && grid.aboveData) {
                drawGrid();
            }

            surface.render();

            // A draw implies that either the axes or data have changed, so we
            // should probably update the overlay highlights as well.

            triggerRedrawOverlay();
        }

        function extractRange(ranges, coord) {
            var axis, from, to, key, axes = allAxes();

            for (var i = 0; i < axes.length; ++i) {
                axis = axes[i];
                if (axis.direction == coord) {
                    key = coord + axis.n + "axis";
                    if (!ranges[key] && axis.n == 1)
                        key = coord + "axis"; // support x1axis as xaxis
                    if (ranges[key]) {
                        from = ranges[key].from;
                        to = ranges[key].to;
                        break;
                    }
                }
            }

            // backwards-compat stuff - to be removed in future
            if (!ranges[key]) {
                axis = coord == "x" ? xaxes[0] : yaxes[0];
                from = ranges[coord + "1"];
                to = ranges[coord + "2"];
            }

            // auto-reverse as an added bonus
            if (from != null && to != null && from > to) {
                var tmp = from;
                from = to;
                to = tmp;
            }

            return { from: from, to: to, axis: axis };
        }

        function drawBackground() {
            ctx.save();
            ctx.translate(plotOffset.left, plotOffset.top);

            ctx.fillStyle = getColorOrGradient(options.grid.backgroundColor, plotHeight, 0, "rgba(255, 255, 255, 0)");
            ctx.fillRect(0, 0, plotWidth, plotHeight);
            ctx.restore();
        }

        function drawGrid() {
            var i, axes, bw, bc;

            ctx.save();
            ctx.translate(plotOffset.left, plotOffset.top);

            // draw markings
            var markings = options.grid.markings;
            if (markings) {
                if ($.isFunction(markings)) {
                    axes = plot.getAxes();
                    // xmin etc. is backwards compatibility, to be
                    // removed in the future
                    axes.xmin = axes.xaxis.min;
                    axes.xmax = axes.xaxis.max;
                    axes.ymin = axes.yaxis.min;
                    axes.ymax = axes.yaxis.max;

                    markings = markings(axes);
                }

                for (i = 0; i < markings.length; ++i) {
                    var m = markings[i],
                        xrange = extractRange(m, "x"),
                        yrange = extractRange(m, "y");

                    // fill in missing
                    if (xrange.from == null)
                        xrange.from = xrange.axis.min;
                    if (xrange.to == null)
                        xrange.to = xrange.axis.max;
                    if (yrange.from == null)
                        yrange.from = yrange.axis.min;
                    if (yrange.to == null)
                        yrange.to = yrange.axis.max;

                    // clip
                    if (xrange.to < xrange.axis.min || xrange.from > xrange.axis.max ||
                        yrange.to < yrange.axis.min || yrange.from > yrange.axis.max)
                        continue;

                    xrange.from = Math.max(xrange.from, xrange.axis.min);
                    xrange.to = Math.min(xrange.to, xrange.axis.max);
                    yrange.from = Math.max(yrange.from, yrange.axis.min);
                    yrange.to = Math.min(yrange.to, yrange.axis.max);

                    var xequal = xrange.from === xrange.to,
                        yequal = yrange.from === yrange.to;

                    if (xequal && yequal) {
                        continue;
                    }

                    // then draw
                    xrange.from = Math.floor(xrange.axis.p2c(xrange.from));
                    xrange.to = Math.floor(xrange.axis.p2c(xrange.to));
                    yrange.from = Math.floor(yrange.axis.p2c(yrange.from));
                    yrange.to = Math.floor(yrange.axis.p2c(yrange.to));

                    if (xequal || yequal) {
                        var lineWidth = m.lineWidth || options.grid.markingsLineWidth,
                            subPixel = lineWidth % 2 ? 0.5 : 0;
                        ctx.beginPath();
                        ctx.strokeStyle = m.color || options.grid.markingsColor;
                        ctx.lineWidth = lineWidth;
                        if (xequal) {
                            ctx.moveTo(xrange.to + subPixel, yrange.from);
                            ctx.lineTo(xrange.to + subPixel, yrange.to);
                        } else {
                            ctx.moveTo(xrange.from, yrange.to + subPixel);
                            ctx.lineTo(xrange.to, yrange.to + subPixel);                            
                        }
                        ctx.stroke();
                    } else {
                        ctx.fillStyle = m.color || options.grid.markingsColor;
                        ctx.fillRect(xrange.from, yrange.to,
                                     xrange.to - xrange.from,
                                     yrange.from - yrange.to);
                    }
                }
            }

            // draw the ticks
            axes = allAxes();
            bw = options.grid.borderWidth;

            for (var j = 0; j < axes.length; ++j) {
                var axis = axes[j], box = axis.box,
                    t = axis.tickLength, x, y, xoff, yoff;
                if (!axis.show || axis.ticks.length == 0)
                    continue;

                ctx.lineWidth = 1;

                // find the edges
                if (axis.direction == "x") {
                    x = 0;
                    if (t == "full")
                        y = (axis.position == "top" ? 0 : plotHeight);
                    else
                        y = box.top - plotOffset.top + (axis.position == "top" ? box.height : 0);
                }
                else {
                    y = 0;
                    if (t == "full")
                        x = (axis.position == "left" ? 0 : plotWidth);
                    else
                        x = box.left - plotOffset.left + (axis.position == "left" ? box.width : 0);
                }

                // draw tick bar
                if (!axis.innermost) {
                    ctx.strokeStyle = axis.options.color;
                    ctx.beginPath();
                    xoff = yoff = 0;
                    if (axis.direction == "x")
                        xoff = plotWidth + 1;
                    else
                        yoff = plotHeight + 1;

                    if (ctx.lineWidth == 1) {
                        if (axis.direction == "x") {
                            y = Math.floor(y) + 0.5;
                        } else {
                            x = Math.floor(x) + 0.5;
                        }
                    }

                    ctx.moveTo(x, y);
                    ctx.lineTo(x + xoff, y + yoff);
                    ctx.stroke();
                }

                // draw ticks

                ctx.strokeStyle = axis.options.tickColor;

                ctx.beginPath();
                for (i = 0; i < axis.ticks.length; ++i) {
                    var v = axis.ticks[i].v;

                    xoff = yoff = 0;

                    if (isNaN(v) || v < axis.min || v > axis.max
                        // skip those lying on the axes if we got a border
                        || (t == "full"
                            && ((typeof bw == "object" && bw[axis.position] > 0) || bw > 0)
                            && (v == axis.min || v == axis.max)))
                        continue;

                    if (axis.direction == "x") {
                        x = axis.p2c(v);
                        yoff = t == "full" ? -plotHeight : t;

                        if (axis.position == "top")
                            yoff = -yoff;
                    }
                    else {
                        y = axis.p2c(v);
                        xoff = t == "full" ? -plotWidth : t;

                        if (axis.position == "left")
                            xoff = -xoff;
                    }

                    if (ctx.lineWidth == 1) {
                        if (axis.direction == "x")
                            x = Math.floor(x) + 0.5;
                        else
                            y = Math.floor(y) + 0.5;
                    }

                    ctx.moveTo(x, y);
                    ctx.lineTo(x + xoff, y + yoff);
                }

                ctx.stroke();
            }


            // draw border
            if (bw) {
                // If either borderWidth or borderColor is an object, then draw the border
                // line by line instead of as one rectangle
                bc = options.grid.borderColor;
                if(typeof bw == "object" || typeof bc == "object") {
                    if (typeof bw !== "object") {
                        bw = {top: bw, right: bw, bottom: bw, left: bw};
                    }
                    if (typeof bc !== "object") {
                        bc = {top: bc, right: bc, bottom: bc, left: bc};
                    }

                    if (bw.top > 0) {
                        ctx.strokeStyle = bc.top;
                        ctx.lineWidth = bw.top;
                        ctx.beginPath();
                        ctx.moveTo(0 - bw.left, 0 - bw.top/2);
                        ctx.lineTo(plotWidth, 0 - bw.top/2);
                        ctx.stroke();
                    }

                    if (bw.right > 0) {
                        ctx.strokeStyle = bc.right;
                        ctx.lineWidth = bw.right;
                        ctx.beginPath();
                        ctx.moveTo(plotWidth + bw.right / 2, 0 - bw.top);
                        ctx.lineTo(plotWidth + bw.right / 2, plotHeight);
                        ctx.stroke();
                    }

                    if (bw.bottom > 0) {
                        ctx.strokeStyle = bc.bottom;
                        ctx.lineWidth = bw.bottom;
                        ctx.beginPath();
                        ctx.moveTo(plotWidth + bw.right, plotHeight + bw.bottom / 2);
                        ctx.lineTo(0, plotHeight + bw.bottom / 2);
                        ctx.stroke();
                    }

                    if (bw.left > 0) {
                        ctx.strokeStyle = bc.left;
                        ctx.lineWidth = bw.left;
                        ctx.beginPath();
                        ctx.moveTo(0 - bw.left/2, plotHeight + bw.bottom);
                        ctx.lineTo(0- bw.left/2, 0);
                        ctx.stroke();
                    }
                }
                else {
                    ctx.lineWidth = bw;
                    ctx.strokeStyle = options.grid.borderColor;
                    ctx.strokeRect(-bw/2, -bw/2, plotWidth + bw, plotHeight + bw);
                }
            }

            ctx.restore();
        }

        function drawAxisLabels() {

            $.each(allAxes(), function (_, axis) {
                var box = axis.box,
                    legacyStyles = axis.direction + "Axis " + axis.direction + axis.n + "Axis",
                    layer = "flot-" + axis.direction + "-axis flot-" + axis.direction + axis.n + "-axis " + legacyStyles,
                    font = axis.options.font || "flot-tick-label tickLabel",
                    tick, x, y, halign, valign;

                // Remove text before checking for axis.show and ticks.length;
                // otherwise plugins, like flot-tickrotor, that draw their own
                // tick labels will end up with both theirs and the defaults.

                surface.removeText(layer);

                if (!axis.show || axis.ticks.length == 0)
                    return;

                for (var i = 0; i < axis.ticks.length; ++i) {

                    tick = axis.ticks[i];
                    if (!tick.label || tick.v < axis.min || tick.v > axis.max)
                        continue;

                    if (axis.direction == "x") {
                        halign = "center";
                        x = plotOffset.left + axis.p2c(tick.v);
                        if (axis.position == "bottom") {
                            y = box.top + box.padding;
                        } else {
                            y = box.top + box.height - box.padding;
                            valign = "bottom";
                        }
                    } else {
                        valign = "middle";
                        y = plotOffset.top + axis.p2c(tick.v);
                        if (axis.position == "left") {
                            x = box.left + box.width - box.padding;
                            halign = "right";
                        } else {
                            x = box.left + box.padding;
                        }
                    }

                    surface.addText(layer, x, y, tick.label, font, null, null, halign, valign);
                }
            });
        }

        function drawSeries(series) {
            if (series.lines.show)
                drawSeriesLines(series);
            if (series.bars.show)
                drawSeriesBars(series);
            if (series.points.show)
                drawSeriesPoints(series);
        }

        function drawSeriesLines(series) {
            function plotLine(datapoints, xoffset, yoffset, axisx, axisy) {
                var points = datapoints.points,
                    ps = datapoints.pointsize,
                    prevx = null, prevy = null;

                ctx.beginPath();
                for (var i = ps; i < points.length; i += ps) {
                    var x1 = points[i - ps], y1 = points[i - ps + 1],
                        x2 = points[i], y2 = points[i + 1];

                    if (x1 == null || x2 == null)
                        continue;

                    // clip with ymin
                    if (y1 <= y2 && y1 < axisy.min) {
                        if (y2 < axisy.min)
                            continue;   // line segment is outside
                        // compute new intersection point
                        x1 = (axisy.min - y1) / (y2 - y1) * (x2 - x1) + x1;
                        y1 = axisy.min;
                    }
                    else if (y2 <= y1 && y2 < axisy.min) {
                        if (y1 < axisy.min)
                            continue;
                        x2 = (axisy.min - y1) / (y2 - y1) * (x2 - x1) + x1;
                        y2 = axisy.min;
                    }

                    // clip with ymax
                    if (y1 >= y2 && y1 > axisy.max) {
                        if (y2 > axisy.max)
                            continue;
                        x1 = (axisy.max - y1) / (y2 - y1) * (x2 - x1) + x1;
                        y1 = axisy.max;
                    }
                    else if (y2 >= y1 && y2 > axisy.max) {
                        if (y1 > axisy.max)
                            continue;
                        x2 = (axisy.max - y1) / (y2 - y1) * (x2 - x1) + x1;
                        y2 = axisy.max;
                    }

                    // clip with xmin
                    if (x1 <= x2 && x1 < axisx.min) {
                        if (x2 < axisx.min)
                            continue;
                        y1 = (axisx.min - x1) / (x2 - x1) * (y2 - y1) + y1;
                        x1 = axisx.min;
                    }
                    else if (x2 <= x1 && x2 < axisx.min) {
                        if (x1 < axisx.min)
                            continue;
                        y2 = (axisx.min - x1) / (x2 - x1) * (y2 - y1) + y1;
                        x2 = axisx.min;
                    }

                    // clip with xmax
                    if (x1 >= x2 && x1 > axisx.max) {
                        if (x2 > axisx.max)
                            continue;
                        y1 = (axisx.max - x1) / (x2 - x1) * (y2 - y1) + y1;
                        x1 = axisx.max;
                    }
                    else if (x2 >= x1 && x2 > axisx.max) {
                        if (x1 > axisx.max)
                            continue;
                        y2 = (axisx.max - x1) / (x2 - x1) * (y2 - y1) + y1;
                        x2 = axisx.max;
                    }

                    if (x1 != prevx || y1 != prevy)
                        ctx.moveTo(axisx.p2c(x1) + xoffset, axisy.p2c(y1) + yoffset);

                    prevx = x2;
                    prevy = y2;
                    ctx.lineTo(axisx.p2c(x2) + xoffset, axisy.p2c(y2) + yoffset);
                }
                ctx.stroke();
            }

            function plotLineArea(datapoints, axisx, axisy) {
                var points = datapoints.points,
                    ps = datapoints.pointsize,
                    bottom = Math.min(Math.max(0, axisy.min), axisy.max),
                    i = 0, top, areaOpen = false,
                    ypos = 1, segmentStart = 0, segmentEnd = 0;

                // we process each segment in two turns, first forward
                // direction to sketch out top, then once we hit the
                // end we go backwards to sketch the bottom
                while (true) {
                    if (ps > 0 && i > points.length + ps)
                        break;

                    i += ps; // ps is negative if going backwards

                    var x1 = points[i - ps],
                        y1 = points[i - ps + ypos],
                        x2 = points[i], y2 = points[i + ypos];

                    if (areaOpen) {
                        if (ps > 0 && x1 != null && x2 == null) {
                            // at turning point
                            segmentEnd = i;
                            ps = -ps;
                            ypos = 2;
                            continue;
                        }

                        if (ps < 0 && i == segmentStart + ps) {
                            // done with the reverse sweep
                            ctx.fill();
                            areaOpen = false;
                            ps = -ps;
                            ypos = 1;
                            i = segmentStart = segmentEnd + ps;
                            continue;
                        }
                    }

                    if (x1 == null || x2 == null)
                        continue;

                    // clip x values

                    // clip with xmin
                    if (x1 <= x2 && x1 < axisx.min) {
                        if (x2 < axisx.min)
                            continue;
                        y1 = (axisx.min - x1) / (x2 - x1) * (y2 - y1) + y1;
                        x1 = axisx.min;
                    }
                    else if (x2 <= x1 && x2 < axisx.min) {
                        if (x1 < axisx.min)
                            continue;
                        y2 = (axisx.min - x1) / (x2 - x1) * (y2 - y1) + y1;
                        x2 = axisx.min;
                    }

                    // clip with xmax
                    if (x1 >= x2 && x1 > axisx.max) {
                        if (x2 > axisx.max)
                            continue;
                        y1 = (axisx.max - x1) / (x2 - x1) * (y2 - y1) + y1;
                        x1 = axisx.max;
                    }
                    else if (x2 >= x1 && x2 > axisx.max) {
                        if (x1 > axisx.max)
                            continue;
                        y2 = (axisx.max - x1) / (x2 - x1) * (y2 - y1) + y1;
                        x2 = axisx.max;
                    }

                    if (!areaOpen) {
                        // open area
                        ctx.beginPath();
                        ctx.moveTo(axisx.p2c(x1), axisy.p2c(bottom));
                        areaOpen = true;
                    }

                    // now first check the case where both is outside
                    if (y1 >= axisy.max && y2 >= axisy.max) {
                        ctx.lineTo(axisx.p2c(x1), axisy.p2c(axisy.max));
                        ctx.lineTo(axisx.p2c(x2), axisy.p2c(axisy.max));
                        continue;
                    }
                    else if (y1 <= axisy.min && y2 <= axisy.min) {
                        ctx.lineTo(axisx.p2c(x1), axisy.p2c(axisy.min));
                        ctx.lineTo(axisx.p2c(x2), axisy.p2c(axisy.min));
                        continue;
                    }

                    // else it's a bit more complicated, there might
                    // be a flat maxed out rectangle first, then a
                    // triangular cutout or reverse; to find these
                    // keep track of the current x values
                    var x1old = x1, x2old = x2;

                    // clip the y values, without shortcutting, we
                    // go through all cases in turn

                    // clip with ymin
                    if (y1 <= y2 && y1 < axisy.min && y2 >= axisy.min) {
                        x1 = (axisy.min - y1) / (y2 - y1) * (x2 - x1) + x1;
                        y1 = axisy.min;
                    }
                    else if (y2 <= y1 && y2 < axisy.min && y1 >= axisy.min) {
                        x2 = (axisy.min - y1) / (y2 - y1) * (x2 - x1) + x1;
                        y2 = axisy.min;
                    }

                    // clip with ymax
                    if (y1 >= y2 && y1 > axisy.max && y2 <= axisy.max) {
                        x1 = (axisy.max - y1) / (y2 - y1) * (x2 - x1) + x1;
                        y1 = axisy.max;
                    }
                    else if (y2 >= y1 && y2 > axisy.max && y1 <= axisy.max) {
                        x2 = (axisy.max - y1) / (y2 - y1) * (x2 - x1) + x1;
                        y2 = axisy.max;
                    }

                    // if the x value was changed we got a rectangle
                    // to fill
                    if (x1 != x1old) {
                        ctx.lineTo(axisx.p2c(x1old), axisy.p2c(y1));
                        // it goes to (x1, y1), but we fill that below
                    }

                    // fill triangular section, this sometimes result
                    // in redundant points if (x1, y1) hasn't changed
                    // from previous line to, but we just ignore that
                    ctx.lineTo(axisx.p2c(x1), axisy.p2c(y1));
                    ctx.lineTo(axisx.p2c(x2), axisy.p2c(y2));

                    // fill the other rectangle if it's there
                    if (x2 != x2old) {
                        ctx.lineTo(axisx.p2c(x2), axisy.p2c(y2));
                        ctx.lineTo(axisx.p2c(x2old), axisy.p2c(y2));
                    }
                }
            }

            ctx.save();
            ctx.translate(plotOffset.left, plotOffset.top);
            ctx.lineJoin = "round";

            var lw = series.lines.lineWidth,
                sw = series.shadowSize;
            // FIXME: consider another form of shadow when filling is turned on
            if (lw > 0 && sw > 0) {
                // draw shadow as a thick and thin line with transparency
                ctx.lineWidth = sw;
                ctx.strokeStyle = "rgba(0,0,0,0.1)";
                // position shadow at angle from the mid of line
                var angle = Math.PI/18;
                plotLine(series.datapoints, Math.sin(angle) * (lw/2 + sw/2), Math.cos(angle) * (lw/2 + sw/2), series.xaxis, series.yaxis);
                ctx.lineWidth = sw/2;
                plotLine(series.datapoints, Math.sin(angle) * (lw/2 + sw/4), Math.cos(angle) * (lw/2 + sw/4), series.xaxis, series.yaxis);
            }

            ctx.lineWidth = lw;
            ctx.strokeStyle = series.color;
            var fillStyle = getFillStyle(series.lines, series.color, 0, plotHeight);
            if (fillStyle) {
                ctx.fillStyle = fillStyle;
                plotLineArea(series.datapoints, series.xaxis, series.yaxis);
            }

            if (lw > 0)
                plotLine(series.datapoints, 0, 0, series.xaxis, series.yaxis);
            ctx.restore();
        }

        function drawSeriesPoints(series) {
            function plotPoints(datapoints, radius, fillStyle, offset, shadow, axisx, axisy, symbol) {
                var points = datapoints.points, ps = datapoints.pointsize;

                for (var i = 0; i < points.length; i += ps) {
                    var x = points[i], y = points[i + 1];
                    if (x == null || x < axisx.min || x > axisx.max || y < axisy.min || y > axisy.max)
                        continue;

                    ctx.beginPath();
                    x = axisx.p2c(x);
                    y = axisy.p2c(y) + offset;
                    if (symbol == "circle")
                        ctx.arc(x, y, radius, 0, shadow ? Math.PI : Math.PI * 2, false);
                    else
                        symbol(ctx, x, y, radius, shadow);
                    ctx.closePath();

                    if (fillStyle) {
                        ctx.fillStyle = fillStyle;
                        ctx.fill();
                    }
                    ctx.stroke();
                }
            }

            ctx.save();
            ctx.translate(plotOffset.left, plotOffset.top);

            var lw = series.points.lineWidth,
                sw = series.shadowSize,
                radius = series.points.radius,
                symbol = series.points.symbol;

            // If the user sets the line width to 0, we change it to a very 
            // small value. A line width of 0 seems to force the default of 1.
            // Doing the conditional here allows the shadow setting to still be 
            // optional even with a lineWidth of 0.

            if( lw == 0 )
                lw = 0.0001;

            if (lw > 0 && sw > 0) {
                // draw shadow in two steps
                var w = sw / 2;
                ctx.lineWidth = w;
                ctx.strokeStyle = "rgba(0,0,0,0.1)";
                plotPoints(series.datapoints, radius, null, w + w/2, true,
                           series.xaxis, series.yaxis, symbol);

                ctx.strokeStyle = "rgba(0,0,0,0.2)";
                plotPoints(series.datapoints, radius, null, w/2, true,
                           series.xaxis, series.yaxis, symbol);
            }

            ctx.lineWidth = lw;
            ctx.strokeStyle = series.color;
            plotPoints(series.datapoints, radius,
                       getFillStyle(series.points, series.color), 0, false,
                       series.xaxis, series.yaxis, symbol);
            ctx.restore();
        }

        function drawBar(x, y, b, barLeft, barRight, fillStyleCallback, axisx, axisy, c, horizontal, lineWidth) {
            var left, right, bottom, top,
                drawLeft, drawRight, drawTop, drawBottom,
                tmp;

            // in horizontal mode, we start the bar from the left
            // instead of from the bottom so it appears to be
            // horizontal rather than vertical
            if (horizontal) {
                drawBottom = drawRight = drawTop = true;
                drawLeft = false;
                left = b;
                right = x;
                top = y + barLeft;
                bottom = y + barRight;

                // account for negative bars
                if (right < left) {
                    tmp = right;
                    right = left;
                    left = tmp;
                    drawLeft = true;
                    drawRight = false;
                }
            }
            else {
                drawLeft = drawRight = drawTop = true;
                drawBottom = false;
                left = x + barLeft;
                right = x + barRight;
                bottom = b;
                top = y;

                // account for negative bars
                if (top < bottom) {
                    tmp = top;
                    top = bottom;
                    bottom = tmp;
                    drawBottom = true;
                    drawTop = false;
                }
            }

            // clip
            if (right < axisx.min || left > axisx.max ||
                top < axisy.min || bottom > axisy.max)
                return;

            if (left < axisx.min) {
                left = axisx.min;
                drawLeft = false;
            }

            if (right > axisx.max) {
                right = axisx.max;
                drawRight = false;
            }

            if (bottom < axisy.min) {
                bottom = axisy.min;
                drawBottom = false;
            }

            if (top > axisy.max) {
                top = axisy.max;
                drawTop = false;
            }

            left = axisx.p2c(left);
            bottom = axisy.p2c(bottom);
            right = axisx.p2c(right);
            top = axisy.p2c(top);

            // fill the bar
            if (fillStyleCallback) {
                c.fillStyle = fillStyleCallback(bottom, top);
                c.fillRect(left, top, right - left, bottom - top)
            }

            // draw outline
            if (lineWidth > 0 && (drawLeft || drawRight || drawTop || drawBottom)) {
                c.beginPath();

                // FIXME: inline moveTo is buggy with excanvas
                c.moveTo(left, bottom);
                if (drawLeft)
                    c.lineTo(left, top);
                else
                    c.moveTo(left, top);
                if (drawTop)
                    c.lineTo(right, top);
                else
                    c.moveTo(right, top);
                if (drawRight)
                    c.lineTo(right, bottom);
                else
                    c.moveTo(right, bottom);
                if (drawBottom)
                    c.lineTo(left, bottom);
                else
                    c.moveTo(left, bottom);
                c.stroke();
            }
        }

        function drawSeriesBars(series) {
            function plotBars(datapoints, barLeft, barRight, fillStyleCallback, axisx, axisy) {
                var points = datapoints.points, ps = datapoints.pointsize;

                for (var i = 0; i < points.length; i += ps) {
                    if (points[i] == null)
                        continue;
                    drawBar(points[i], points[i + 1], points[i + 2], barLeft, barRight, fillStyleCallback, axisx, axisy, ctx, series.bars.horizontal, series.bars.lineWidth);
                }
            }

            ctx.save();
            ctx.translate(plotOffset.left, plotOffset.top);

            // FIXME: figure out a way to add shadows (for instance along the right edge)
            ctx.lineWidth = series.bars.lineWidth;
            ctx.strokeStyle = series.color;

            var barLeft;

            switch (series.bars.align) {
                case "left":
                    barLeft = 0;
                    break;
                case "right":
                    barLeft = -series.bars.barWidth;
                    break;
                default:
                    barLeft = -series.bars.barWidth / 2;
            }

            var fillStyleCallback = series.bars.fill ? function (bottom, top) { return getFillStyle(series.bars, series.color, bottom, top); } : null;
            plotBars(series.datapoints, barLeft, barLeft + series.bars.barWidth, fillStyleCallback, series.xaxis, series.yaxis);
            ctx.restore();
        }

        function getFillStyle(filloptions, seriesColor, bottom, top) {
            var fill = filloptions.fill;
            if (!fill)
                return null;

            if (filloptions.fillColor)
                return getColorOrGradient(filloptions.fillColor, bottom, top, seriesColor);

            var c = $.color.parse(seriesColor);
            c.a = typeof fill == "number" ? fill : 0.4;
            c.normalize();
            return c.toString();
        }

        function insertLegend() {

            if (options.legend.container != null) {
                $(options.legend.container).html("");
            } else {
                placeholder.find(".legend").remove();
            }

            if (!options.legend.show) {
                return;
            }

            var fragments = [], entries = [], rowStarted = false,
                lf = options.legend.labelFormatter, s, label;

            // Build a list of legend entries, with each having a label and a color

            for (var i = 0; i < series.length; ++i) {
                s = series[i];
                if (s.label) {
                    label = lf ? lf(s.label, s) : s.label;
                    if (label) {
                        entries.push({
                            label: label,
                            color: s.color
                        });
                    }
                }
            }

            // Sort the legend using either the default or a custom comparator

            if (options.legend.sorted) {
                if ($.isFunction(options.legend.sorted)) {
                    entries.sort(options.legend.sorted);
                } else if (options.legend.sorted == "reverse") {
                	entries.reverse();
                } else {
                    var ascending = options.legend.sorted != "descending";
                    entries.sort(function(a, b) {
                        return a.label == b.label ? 0 : (
                            (a.label < b.label) != ascending ? 1 : -1   // Logical XOR
                        );
                    });
                }
            }

            // Generate markup for the list of entries, in their final order

            for (var i = 0; i < entries.length; ++i) {

                var entry = entries[i];

                if (i % options.legend.noColumns == 0) {
                    if (rowStarted)
                        fragments.push('</tr>');
                    fragments.push('<tr>');
                    rowStarted = true;
                }

                fragments.push(
                    '<td class="legendColorBox"><div style="border:1px solid ' + options.legend.labelBoxBorderColor + ';padding:1px"><div style="width:4px;height:0;border:5px solid ' + entry.color + ';overflow:hidden"></div></div></td>' +
                    '<td class="legendLabel">' + entry.label + '</td>'
                );
            }

            if (rowStarted)
                fragments.push('</tr>');

            if (fragments.length == 0)
                return;

            var table = '<table style="font-size:smaller;color:' + options.grid.color + '">' + fragments.join("") + '</table>';
            if (options.legend.container != null)
                $(options.legend.container).html(table);
            else {
                var pos = "",
                    p = options.legend.position,
                    m = options.legend.margin;
                if (m[0] == null)
                    m = [m, m];
                if (p.charAt(0) == "n")
                    pos += 'top:' + (m[1] + plotOffset.top) + 'px;';
                else if (p.charAt(0) == "s")
                    pos += 'bottom:' + (m[1] + plotOffset.bottom) + 'px;';
                if (p.charAt(1) == "e")
                    pos += 'right:' + (m[0] + plotOffset.right) + 'px;';
                else if (p.charAt(1) == "w")
                    pos += 'left:' + (m[0] + plotOffset.left) + 'px;';
                var legend = $('<div class="legend">' + table.replace('style="', 'style="position:absolute;' + pos +';') + '</div>').appendTo(placeholder);
                if (options.legend.backgroundOpacity != 0.0) {
                    // put in the transparent background
                    // separately to avoid blended labels and
                    // label boxes
                    var c = options.legend.backgroundColor;
                    if (c == null) {
                        c = options.grid.backgroundColor;
                        if (c && typeof c == "string")
                            c = $.color.parse(c);
                        else
                            c = $.color.extract(legend, 'background-color');
                        c.a = 1;
                        c = c.toString();
                    }
                    var div = legend.children();
                    $('<div style="position:absolute;width:' + div.width() + 'px;height:' + div.height() + 'px;' + pos +'background-color:' + c + ';"> </div>').prependTo(legend).css('opacity', options.legend.backgroundOpacity);
                }
            }
        }


        // interactive features

        var highlights = [],
            redrawTimeout = null;

        // returns the data item the mouse is over, or null if none is found
        function findNearbyItem(mouseX, mouseY, seriesFilter) {
            var maxDistance = options.grid.mouseActiveRadius,
                smallestDistance = maxDistance * maxDistance + 1,
                item = null, foundPoint = false, i, j, ps;

            for (i = series.length - 1; i >= 0; --i) {
                if (!seriesFilter(series[i]))
                    continue;

                var s = series[i],
                    axisx = s.xaxis,
                    axisy = s.yaxis,
                    points = s.datapoints.points,
                    mx = axisx.c2p(mouseX), // precompute some stuff to make the loop faster
                    my = axisy.c2p(mouseY),
                    maxx = maxDistance / axisx.scale,
                    maxy = maxDistance / axisy.scale;

                ps = s.datapoints.pointsize;
                // with inverse transforms, we can't use the maxx/maxy
                // optimization, sadly
                if (axisx.options.inverseTransform)
                    maxx = Number.MAX_VALUE;
                if (axisy.options.inverseTransform)
                    maxy = Number.MAX_VALUE;

                if (s.lines.show || s.points.show) {
                    for (j = 0; j < points.length; j += ps) {
                        var x = points[j], y = points[j + 1];
                        if (x == null)
                            continue;

                        // For points and lines, the cursor must be within a
                        // certain distance to the data point
                        if (x - mx > maxx || x - mx < -maxx ||
                            y - my > maxy || y - my < -maxy)
                            continue;

                        // We have to calculate distances in pixels, not in
                        // data units, because the scales of the axes may be different
                        var dx = Math.abs(axisx.p2c(x) - mouseX),
                            dy = Math.abs(axisy.p2c(y) - mouseY),
                            dist = dx * dx + dy * dy; // we save the sqrt

                        // use <= to ensure last point takes precedence
                        // (last generally means on top of)
                        if (dist < smallestDistance) {
                            smallestDistance = dist;
                            item = [i, j / ps];
                        }
                    }
                }

                if (s.bars.show && !item) { // no other point can be nearby

                    var barLeft, barRight;

                    switch (s.bars.align) {
                        case "left":
                            barLeft = 0;
                            break;
                        case "right":
                            barLeft = -s.bars.barWidth;
                            break;
                        default:
                            barLeft = -s.bars.barWidth / 2;
                    }

                    barRight = barLeft + s.bars.barWidth;

                    for (j = 0; j < points.length; j += ps) {
                        var x = points[j], y = points[j + 1], b = points[j + 2];
                        if (x == null)
                            continue;

                        // for a bar graph, the cursor must be inside the bar
                        if (series[i].bars.horizontal ?
                            (mx <= Math.max(b, x) && mx >= Math.min(b, x) &&
                             my >= y + barLeft && my <= y + barRight) :
                            (mx >= x + barLeft && mx <= x + barRight &&
                             my >= Math.min(b, y) && my <= Math.max(b, y)))
                                item = [i, j / ps];
                    }
                }
            }

            if (item) {
                i = item[0];
                j = item[1];
                ps = series[i].datapoints.pointsize;

                return { datapoint: series[i].datapoints.points.slice(j * ps, (j + 1) * ps),
                         dataIndex: j,
                         series: series[i],
                         seriesIndex: i };
            }

            return null;
        }

        function onMouseMove(e) {
            if (options.grid.hoverable)
                triggerClickHoverEvent("plothover", e,
                                       function (s) { return s["hoverable"] != false; });
        }

        function onMouseLeave(e) {
            if (options.grid.hoverable)
                triggerClickHoverEvent("plothover", e,
                                       function (s) { return false; });
        }

        function onClick(e) {
            triggerClickHoverEvent("plotclick", e,
                                   function (s) { return s["clickable"] != false; });
        }

        // trigger click or hover event (they send the same parameters
        // so we share their code)
        function triggerClickHoverEvent(eventname, event, seriesFilter) {
            var offset = eventHolder.offset(),
                canvasX = event.pageX - offset.left - plotOffset.left,
                canvasY = event.pageY - offset.top - plotOffset.top,
            pos = canvasToAxisCoords({ left: canvasX, top: canvasY });

            pos.pageX = event.pageX;
            pos.pageY = event.pageY;

            var item = findNearbyItem(canvasX, canvasY, seriesFilter);

            if (item) {
                // fill in mouse pos for any listeners out there
                item.pageX = parseInt(item.series.xaxis.p2c(item.datapoint[0]) + offset.left + plotOffset.left, 10);
                item.pageY = parseInt(item.series.yaxis.p2c(item.datapoint[1]) + offset.top + plotOffset.top, 10);
            }

            if (options.grid.autoHighlight) {
                // clear auto-highlights
                for (var i = 0; i < highlights.length; ++i) {
                    var h = highlights[i];
                    if (h.auto == eventname &&
                        !(item && h.series == item.series &&
                          h.point[0] == item.datapoint[0] &&
                          h.point[1] == item.datapoint[1]))
                        unhighlight(h.series, h.point);
                }

                if (item)
                    highlight(item.series, item.datapoint, eventname);
            }

            placeholder.trigger(eventname, [ pos, item ]);
        }

        function triggerRedrawOverlay() {
            var t = options.interaction.redrawOverlayInterval;
            if (t == -1) {      // skip event queue
                drawOverlay();
                return;
            }

            if (!redrawTimeout)
                redrawTimeout = setTimeout(drawOverlay, t);
        }

        function drawOverlay() {
            redrawTimeout = null;

            // draw highlights
            octx.save();
            overlay.clear();
            octx.translate(plotOffset.left, plotOffset.top);

            var i, hi;
            for (i = 0; i < highlights.length; ++i) {
                hi = highlights[i];

                if (hi.series.bars.show)
                    drawBarHighlight(hi.series, hi.point);
                else
                    drawPointHighlight(hi.series, hi.point);
            }
            octx.restore();

            executeHooks(hooks.drawOverlay, [octx]);
        }

        function highlight(s, point, auto) {
            if (typeof s == "number")
                s = series[s];

            if (typeof point == "number") {
                var ps = s.datapoints.pointsize;
                point = s.datapoints.points.slice(ps * point, ps * (point + 1));
            }

            var i = indexOfHighlight(s, point);
            if (i == -1) {
                highlights.push({ series: s, point: point, auto: auto });

                triggerRedrawOverlay();
            }
            else if (!auto)
                highlights[i].auto = false;
        }

        function unhighlight(s, point) {
            if (s == null && point == null) {
                highlights = [];
                triggerRedrawOverlay();
                return;
            }

            if (typeof s == "number")
                s = series[s];

            if (typeof point == "number") {
                var ps = s.datapoints.pointsize;
                point = s.datapoints.points.slice(ps * point, ps * (point + 1));
            }

            var i = indexOfHighlight(s, point);
            if (i != -1) {
                highlights.splice(i, 1);

                triggerRedrawOverlay();
            }
        }

        function indexOfHighlight(s, p) {
            for (var i = 0; i < highlights.length; ++i) {
                var h = highlights[i];
                if (h.series == s && h.point[0] == p[0]
                    && h.point[1] == p[1])
                    return i;
            }
            return -1;
        }

        function drawPointHighlight(series, point) {
            var x = point[0], y = point[1],
                axisx = series.xaxis, axisy = series.yaxis,
                highlightColor = (typeof series.highlightColor === "string") ? series.highlightColor : $.color.parse(series.color).scale('a', 0.5).toString();

            if (x < axisx.min || x > axisx.max || y < axisy.min || y > axisy.max)
                return;

            var pointRadius = series.points.radius + series.points.lineWidth / 2;
            octx.lineWidth = pointRadius;
            octx.strokeStyle = highlightColor;
            var radius = 1.5 * pointRadius;
            x = axisx.p2c(x);
            y = axisy.p2c(y);

            octx.beginPath();
            if (series.points.symbol == "circle")
                octx.arc(x, y, radius, 0, 2 * Math.PI, false);
            else
                series.points.symbol(octx, x, y, radius, false);
            octx.closePath();
            octx.stroke();
        }

        function drawBarHighlight(series, point) {
            var highlightColor = (typeof series.highlightColor === "string") ? series.highlightColor : $.color.parse(series.color).scale('a', 0.5).toString(),
                fillStyle = highlightColor,
                barLeft;

            switch (series.bars.align) {
                case "left":
                    barLeft = 0;
                    break;
                case "right":
                    barLeft = -series.bars.barWidth;
                    break;
                default:
                    barLeft = -series.bars.barWidth / 2;
            }

            octx.lineWidth = series.bars.lineWidth;
            octx.strokeStyle = highlightColor;

            drawBar(point[0], point[1], point[2] || 0, barLeft, barLeft + series.bars.barWidth,
                    function () { return fillStyle; }, series.xaxis, series.yaxis, octx, series.bars.horizontal, series.bars.lineWidth);
        }

        function getColorOrGradient(spec, bottom, top, defaultColor) {
            if (typeof spec == "string")
                return spec;
            else {
                // assume this is a gradient spec; IE currently only
                // supports a simple vertical gradient properly, so that's
                // what we support too
                var gradient = ctx.createLinearGradient(0, top, 0, bottom);

                for (var i = 0, l = spec.colors.length; i < l; ++i) {
                    var c = spec.colors[i];
                    if (typeof c != "string") {
                        var co = $.color.parse(defaultColor);
                        if (c.brightness != null)
                            co = co.scale('rgb', c.brightness);
                        if (c.opacity != null)
                            co.a *= c.opacity;
                        c = co.toString();
                    }
                    gradient.addColorStop(i / (l - 1), c);
                }

                return gradient;
            }
        }
    }

    // Add the plot function to the top level of the jQuery object

    $.plot = function(placeholder, data, options) {
        //var t0 = new Date();
        var plot = new Plot($(placeholder), data, options, $.plot.plugins);
        //(window.console ? console.log : alert)("time used (msecs): " + ((new Date()).getTime() - t0.getTime()));
        return plot;
    };

    $.plot.version = "0.8.3";

    $.plot.plugins = [];

    // Also add the plot function as a chainable property

    $.fn.plot = function(data, options) {
        return this.each(function() {
            $.plot(this, data, options);
        });
    };

    // round to nearby lower multiple of base
    function floorInBase(n, base) {
        return base * Math.floor(n / base);
    }

})(jQuery);

/* Plugin for jQuery for working with colors.
 * 
 * Version 1.1.
 * 
 * Inspiration from jQuery color animation plugin by John Resig.
 *
 * Released under the MIT license by Ole Laursen, October 2009.
 *
 * Examples:
 *
 *   $.color.parse("#fff").scale('rgb', 0.25).add('a', -0.5).toString()
 *   var c = $.color.extract($("#mydiv"), 'background-color');
 *   console.log(c.r, c.g, c.b, c.a);
 *   $.color.make(100, 50, 25, 0.4).toString() // returns "rgba(100,50,25,0.4)"
 *
 * Note that .scale() and .add() return the same modified object
 * instead of making a new one.
 *
 * V. 1.1: Fix error handling so e.g. parsing an empty string does
 * produce a color rather than just crashing.
 */ 

(function($) {
    $.color = {};

    // construct color object with some convenient chainable helpers
    $.color.make = function (r, g, b, a) {
        var o = {};
        o.r = r || 0;
        o.g = g || 0;
        o.b = b || 0;
        o.a = a != null ? a : 1;

        o.add = function (c, d) {
            for (var i = 0; i < c.length; ++i)
                o[c.charAt(i)] += d;
            return o.normalize();
        };
        
        o.scale = function (c, f) {
            for (var i = 0; i < c.length; ++i)
                o[c.charAt(i)] *= f;
            return o.normalize();
        };
        
        o.toString = function () {
            if (o.a >= 1.0) {
                return "rgb("+[o.r, o.g, o.b].join(",")+")";
            } else {
                return "rgba("+[o.r, o.g, o.b, o.a].join(",")+")";
            }
        };

        o.normalize = function () {
            function clamp(min, value, max) {
                return value < min ? min: (value > max ? max: value);
            }
            
            o.r = clamp(0, parseInt(o.r), 255);
            o.g = clamp(0, parseInt(o.g), 255);
            o.b = clamp(0, parseInt(o.b), 255);
            o.a = clamp(0, o.a, 1);
            return o;
        };

        o.clone = function () {
            return $.color.make(o.r, o.b, o.g, o.a);
        };

        return o.normalize();
    }

    // extract CSS color property from element, going up in the DOM
    // if it's "transparent"
    $.color.extract = function (elem, css) {
        var c;

        do {
            c = elem.css(css).toLowerCase();
            // keep going until we find an element that has color, or
            // we hit the body or root (have no parent)
            if (c != '' && c != 'transparent')
                break;
            elem = elem.parent();
        } while (elem.length && !$.nodeName(elem.get(0), "body"));

        // catch Safari's way of signalling transparent
        if (c == "rgba(0, 0, 0, 0)")
            c = "transparent";
        
        return $.color.parse(c);
    }
    
    // parse CSS color string (like "rgb(10, 32, 43)" or "#fff"),
    // returns color object, if parsing failed, you get black (0, 0,
    // 0) out
    $.color.parse = function (str) {
        var res, m = $.color.make;

        // Look for rgb(num,num,num)
        if (res = /rgb\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*\)/.exec(str))
            return m(parseInt(res[1], 10), parseInt(res[2], 10), parseInt(res[3], 10));
        
        // Look for rgba(num,num,num,num)
        if (res = /rgba\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]+(?:\.[0-9]+)?)\s*\)/.exec(str))
            return m(parseInt(res[1], 10), parseInt(res[2], 10), parseInt(res[3], 10), parseFloat(res[4]));
            
        // Look for rgb(num%,num%,num%)
        if (res = /rgb\(\s*([0-9]+(?:\.[0-9]+)?)\%\s*,\s*([0-9]+(?:\.[0-9]+)?)\%\s*,\s*([0-9]+(?:\.[0-9]+)?)\%\s*\)/.exec(str))
            return m(parseFloat(res[1])*2.55, parseFloat(res[2])*2.55, parseFloat(res[3])*2.55);

        // Look for rgba(num%,num%,num%,num)
        if (res = /rgba\(\s*([0-9]+(?:\.[0-9]+)?)\%\s*,\s*([0-9]+(?:\.[0-9]+)?)\%\s*,\s*([0-9]+(?:\.[0-9]+)?)\%\s*,\s*([0-9]+(?:\.[0-9]+)?)\s*\)/.exec(str))
            return m(parseFloat(res[1])*2.55, parseFloat(res[2])*2.55, parseFloat(res[3])*2.55, parseFloat(res[4]));
        
        // Look for #a0b1c2
        if (res = /#([a-fA-F0-9]{2})([a-fA-F0-9]{2})([a-fA-F0-9]{2})/.exec(str))
            return m(parseInt(res[1], 16), parseInt(res[2], 16), parseInt(res[3], 16));

        // Look for #fff
        if (res = /#([a-fA-F0-9])([a-fA-F0-9])([a-fA-F0-9])/.exec(str))
            return m(parseInt(res[1]+res[1], 16), parseInt(res[2]+res[2], 16), parseInt(res[3]+res[3], 16));

        // Otherwise, we're most likely dealing with a named color
        var name = $.trim(str).toLowerCase();
        if (name == "transparent")
            return m(255, 255, 255, 0);
        else {
            // default to black
            res = lookupColors[name] || [0, 0, 0];
            return m(res[0], res[1], res[2]);
        }
    }
    
    var lookupColors = {
        aqua:[0,255,255],
        azure:[240,255,255],
        beige:[245,245,220],
        black:[0,0,0],
        blue:[0,0,255],
        brown:[165,42,42],
        cyan:[0,255,255],
        darkblue:[0,0,139],
        darkcyan:[0,139,139],
        darkgrey:[169,169,169],
        darkgreen:[0,100,0],
        darkkhaki:[189,183,107],
        darkmagenta:[139,0,139],
        darkolivegreen:[85,107,47],
        darkorange:[255,140,0],
        darkorchid:[153,50,204],
        darkred:[139,0,0],
        darksalmon:[233,150,122],
        darkviolet:[148,0,211],
        fuchsia:[255,0,255],
        gold:[255,215,0],
        green:[0,128,0],
        indigo:[75,0,130],
        khaki:[240,230,140],
        lightblue:[173,216,230],
        lightcyan:[224,255,255],
        lightgreen:[144,238,144],
        lightgrey:[211,211,211],
        lightpink:[255,182,193],
        lightyellow:[255,255,224],
        lime:[0,255,0],
        magenta:[255,0,255],
        maroon:[128,0,0],
        navy:[0,0,128],
        olive:[128,128,0],
        orange:[255,165,0],
        pink:[255,192,203],
        purple:[128,0,128],
        violet:[128,0,128],
        red:[255,0,0],
        silver:[192,192,192],
        white:[255,255,255],
        yellow:[255,255,0]
    };
})(jQuery);

/* Flot plugin for drawing all elements of a plot on the canvas.

Copyright (c) 2007-2014 IOLA and Ole Laursen.
Licensed under the MIT license.

Flot normally produces certain elements, like axis labels and the legend, using
HTML elements. This permits greater interactivity and customization, and often
looks better, due to cross-browser canvas text inconsistencies and limitations.

It can also be desirable to render the plot entirely in canvas, particularly
if the goal is to save it as an image, or if Flot is being used in a context
where the HTML DOM does not exist, as is the case within Node.js. This plugin
switches out Flot's standard drawing operations for canvas-only replacements.

Currently the plugin supports only axis labels, but it will eventually allow
every element of the plot to be rendered directly to canvas.

The plugin supports these options:

{
    canvas: boolean
}

The "canvas" option controls whether full canvas drawing is enabled, making it
possible to toggle on and off. This is useful when a plot uses HTML text in the
browser, but needs to redraw with canvas text when exporting as an image.

*/

(function($) {

	var options = {
		canvas: true
	};

	var render, getTextInfo, addText;

	// Cache the prototype hasOwnProperty for faster access

	var hasOwnProperty = Object.prototype.hasOwnProperty;

	function init(plot, classes) {

		var Canvas = classes.Canvas;

		// We only want to replace the functions once; the second time around
		// we would just get our new function back.  This whole replacing of
		// prototype functions is a disaster, and needs to be changed ASAP.

		if (render == null) {
			getTextInfo = Canvas.prototype.getTextInfo,
			addText = Canvas.prototype.addText,
			render = Canvas.prototype.render;
		}

		// Finishes rendering the canvas, including overlaid text

		Canvas.prototype.render = function() {

			if (!plot.getOptions().canvas) {
				return render.call(this);
			}

			var context = this.context,
				cache = this._textCache;

			// For each text layer, render elements marked as active

			context.save();
			context.textBaseline = "middle";

			for (var layerKey in cache) {
				if (hasOwnProperty.call(cache, layerKey)) {
					var layerCache = cache[layerKey];
					for (var styleKey in layerCache) {
						if (hasOwnProperty.call(layerCache, styleKey)) {
							var styleCache = layerCache[styleKey],
								updateStyles = true;
							for (var key in styleCache) {
								if (hasOwnProperty.call(styleCache, key)) {

									var info = styleCache[key],
										positions = info.positions,
										lines = info.lines;

									// Since every element at this level of the cache have the
									// same font and fill styles, we can just change them once
									// using the values from the first element.

									if (updateStyles) {
										context.fillStyle = info.font.color;
										context.font = info.font.definition;
										updateStyles = false;
									}

									for (var i = 0, position; position = positions[i]; i++) {
										if (position.active) {
											for (var j = 0, line; line = position.lines[j]; j++) {
												context.fillText(lines[j].text, line[0], line[1]);
											}
										} else {
											positions.splice(i--, 1);
										}
									}

									if (positions.length == 0) {
										delete styleCache[key];
									}
								}
							}
						}
					}
				}
			}

			context.restore();
		};

		// Creates (if necessary) and returns a text info object.
		//
		// When the canvas option is set, the object looks like this:
		//
		// {
		//     width: Width of the text's bounding box.
		//     height: Height of the text's bounding box.
		//     positions: Array of positions at which this text is drawn.
		//     lines: [{
		//         height: Height of this line.
		//         widths: Width of this line.
		//         text: Text on this line.
		//     }],
		//     font: {
		//         definition: Canvas font property string.
		//         color: Color of the text.
		//     },
		// }
		//
		// The positions array contains objects that look like this:
		//
		// {
		//     active: Flag indicating whether the text should be visible.
		//     lines: Array of [x, y] coordinates at which to draw the line.
		//     x: X coordinate at which to draw the text.
		//     y: Y coordinate at which to draw the text.
		// }

		Canvas.prototype.getTextInfo = function(layer, text, font, angle, width) {

			if (!plot.getOptions().canvas) {
				return getTextInfo.call(this, layer, text, font, angle, width);
			}

			var textStyle, layerCache, styleCache, info;

			// Cast the value to a string, in case we were given a number

			text = "" + text;

			// If the font is a font-spec object, generate a CSS definition

			if (typeof font === "object") {
				textStyle = font.style + " " + font.variant + " " + font.weight + " " + font.size + "px " + font.family;
			} else {
				textStyle = font;
			}

			// Retrieve (or create) the cache for the text's layer and styles

			layerCache = this._textCache[layer];

			if (layerCache == null) {
				layerCache = this._textCache[layer] = {};
			}

			styleCache = layerCache[textStyle];

			if (styleCache == null) {
				styleCache = layerCache[textStyle] = {};
			}

			info = styleCache[text];

			if (info == null) {

				var context = this.context;

				// If the font was provided as CSS, create a div with those
				// classes and examine it to generate a canvas font spec.

				if (typeof font !== "object") {

					var element = $("<div>&nbsp;</div>")
						.css("position", "absolute")
						.addClass(typeof font === "string" ? font : null)
						.appendTo(this.getTextLayer(layer));

					font = {
						lineHeight: element.height(),
						style: element.css("font-style"),
						variant: element.css("font-variant"),
						weight: element.css("font-weight"),
						family: element.css("font-family"),
						color: element.css("color")
					};

					// Setting line-height to 1, without units, sets it equal
					// to the font-size, even if the font-size is abstract,
					// like 'smaller'.  This enables us to read the real size
					// via the element's height, working around browsers that
					// return the literal 'smaller' value.

					font.size = element.css("line-height", 1).height();

					element.remove();
				}

				textStyle = font.style + " " + font.variant + " " + font.weight + " " + font.size + "px " + font.family;

				// Create a new info object, initializing the dimensions to
				// zero so we can count them up line-by-line.

				info = styleCache[text] = {
					width: 0,
					height: 0,
					positions: [],
					lines: [],
					font: {
						definition: textStyle,
						color: font.color
					}
				};

				context.save();
				context.font = textStyle;

				// Canvas can't handle multi-line strings; break on various
				// newlines, including HTML brs, to build a list of lines.
				// Note that we could split directly on regexps, but IE < 9 is
				// broken; revisit when we drop IE 7/8 support.

				var lines = (text + "").replace(/<br ?\/?>|\r\n|\r/g, "\n").split("\n");

				for (var i = 0; i < lines.length; ++i) {

					var lineText = lines[i],
						measured = context.measureText(lineText);

					info.width = Math.max(measured.width, info.width);
					info.height += font.lineHeight;

					info.lines.push({
						text: lineText,
						width: measured.width,
						height: font.lineHeight
					});
				}

				context.restore();
			}

			return info;
		};

		// Adds a text string to the canvas text overlay.

		Canvas.prototype.addText = function(layer, x, y, text, font, angle, width, halign, valign) {

			if (!plot.getOptions().canvas) {
				return addText.call(this, layer, x, y, text, font, angle, width, halign, valign);
			}

			var info = this.getTextInfo(layer, text, font, angle, width),
				positions = info.positions,
				lines = info.lines;

			// Text is drawn with baseline 'middle', which we need to account
			// for by adding half a line's height to the y position.

			y += info.height / lines.length / 2;

			// Tweak the initial y-position to match vertical alignment

			if (valign == "middle") {
				y = Math.round(y - info.height / 2);
			} else if (valign == "bottom") {
				y = Math.round(y - info.height);
			} else {
				y = Math.round(y);
			}

			// FIXME: LEGACY BROWSER FIX
			// AFFECTS: Opera < 12.00

			// Offset the y coordinate, since Opera is off pretty
			// consistently compared to the other browsers.

			if (!!(window.opera && window.opera.version().split(".")[0] < 12)) {
				y -= 2;
			}

			// Determine whether this text already exists at this position.
			// If so, mark it for inclusion in the next render pass.

			for (var i = 0, position; position = positions[i]; i++) {
				if (position.x == x && position.y == y) {
					position.active = true;
					return;
				}
			}

			// If the text doesn't exist at this position, create a new entry

			position = {
				active: true,
				lines: [],
				x: x,
				y: y
			};

			positions.push(position);

			// Fill in the x & y positions of each line, adjusting them
			// individually for horizontal alignment.

			for (var i = 0, line; line = lines[i]; i++) {
				if (halign == "center") {
					position.lines.push([Math.round(x - line.width / 2), y]);
				} else if (halign == "right") {
					position.lines.push([Math.round(x - line.width), y]);
				} else {
					position.lines.push([Math.round(x), y]);
				}
				y += line.height;
			}
		};
	}

	$.plot.plugins.push({
		init: init,
		options: options,
		name: "canvas",
		version: "1.0"
	});

})(jQuery);

/* Flot plugin for plotting textual data or categories.

Copyright (c) 2007-2014 IOLA and Ole Laursen.
Licensed under the MIT license.

Consider a dataset like [["February", 34], ["March", 20], ...]. This plugin
allows you to plot such a dataset directly.

To enable it, you must specify mode: "categories" on the axis with the textual
labels, e.g.

	$.plot("#placeholder", data, { xaxis: { mode: "categories" } });

By default, the labels are ordered as they are met in the data series. If you
need a different ordering, you can specify "categories" on the axis options
and list the categories there:

	xaxis: {
		mode: "categories",
		categories: ["February", "March", "April"]
	}

If you need to customize the distances between the categories, you can specify
"categories" as an object mapping labels to values

	xaxis: {
		mode: "categories",
		categories: { "February": 1, "March": 3, "April": 4 }
	}

If you don't specify all categories, the remaining categories will be numbered
from the max value plus 1 (with a spacing of 1 between each).

Internally, the plugin works by transforming the input data through an auto-
generated mapping where the first category becomes 0, the second 1, etc.
Hence, a point like ["February", 34] becomes [0, 34] internally in Flot (this
is visible in hover and click events that return numbers rather than the
category labels). The plugin also overrides the tick generator to spit out the
categories as ticks instead of the values.

If you need to map a value back to its label, the mapping is always accessible
as "categories" on the axis object, e.g. plot.getAxes().xaxis.categories.

*/

(function ($) {
    var options = {
        xaxis: {
            categories: null
        },
        yaxis: {
            categories: null
        }
    };
    
    function processRawData(plot, series, data, datapoints) {
        // if categories are enabled, we need to disable
        // auto-transformation to numbers so the strings are intact
        // for later processing

        var xCategories = series.xaxis.options.mode == "categories",
            yCategories = series.yaxis.options.mode == "categories";
        
        if (!(xCategories || yCategories))
            return;

        var format = datapoints.format;

        if (!format) {
            // FIXME: auto-detection should really not be defined here
            var s = series;
            format = [];
            format.push({ x: true, number: true, required: true });
            format.push({ y: true, number: true, required: true });

            if (s.bars.show || (s.lines.show && s.lines.fill)) {
                var autoscale = !!((s.bars.show && s.bars.zero) || (s.lines.show && s.lines.zero));
                format.push({ y: true, number: true, required: false, defaultValue: 0, autoscale: autoscale });
                if (s.bars.horizontal) {
                    delete format[format.length - 1].y;
                    format[format.length - 1].x = true;
                }
            }
            
            datapoints.format = format;
        }

        for (var m = 0; m < format.length; ++m) {
            if (format[m].x && xCategories)
                format[m].number = false;
            
            if (format[m].y && yCategories)
                format[m].number = false;
        }
    }

    function getNextIndex(categories) {
        var index = -1;
        
        for (var v in categories)
            if (categories[v] > index)
                index = categories[v];

        return index + 1;
    }

    function categoriesTickGenerator(axis) {
        var res = [];
        for (var label in axis.categories) {
            var v = axis.categories[label];
            if (v >= axis.min && v <= axis.max)
                res.push([v, label]);
        }

        res.sort(function (a, b) { return a[0] - b[0]; });

        return res;
    }
    
    function setupCategoriesForAxis(series, axis, datapoints) {
        if (series[axis].options.mode != "categories")
            return;
        
        if (!series[axis].categories) {
            // parse options
            var c = {}, o = series[axis].options.categories || {};
            if ($.isArray(o)) {
                for (var i = 0; i < o.length; ++i)
                    c[o[i]] = i;
            }
            else {
                for (var v in o)
                    c[v] = o[v];
            }
            
            series[axis].categories = c;
        }

        // fix ticks
        if (!series[axis].options.ticks)
            series[axis].options.ticks = categoriesTickGenerator;

        transformPointsOnAxis(datapoints, axis, series[axis].categories);
    }
    
    function transformPointsOnAxis(datapoints, axis, categories) {
        // go through the points, transforming them
        var points = datapoints.points,
            ps = datapoints.pointsize,
            format = datapoints.format,
            formatColumn = axis.charAt(0),
            index = getNextIndex(categories);

        for (var i = 0; i < points.length; i += ps) {
            if (points[i] == null)
                continue;
            
            for (var m = 0; m < ps; ++m) {
                var val = points[i + m];

                if (val == null || !format[m][formatColumn])
                    continue;

                if (!(val in categories)) {
                    categories[val] = index;
                    ++index;
                }
                
                points[i + m] = categories[val];
            }
        }
    }

    function processDatapoints(plot, series, datapoints) {
        setupCategoriesForAxis(series, "xaxis", datapoints);
        setupCategoriesForAxis(series, "yaxis", datapoints);
    }

    function init(plot) {
        plot.hooks.processRawData.push(processRawData);
        plot.hooks.processDatapoints.push(processDatapoints);
    }
    
    $.plot.plugins.push({
        init: init,
        options: options,
        name: 'categories',
        version: '1.0'
    });
})(jQuery);

/* Flot plugin for showing crosshairs when the mouse hovers over the plot.

Copyright (c) 2007-2014 IOLA and Ole Laursen.
Licensed under the MIT license.

The plugin supports these options:

	crosshair: {
		mode: null or "x" or "y" or "xy"
		color: color
		lineWidth: number
	}

Set the mode to one of "x", "y" or "xy". The "x" mode enables a vertical
crosshair that lets you trace the values on the x axis, "y" enables a
horizontal crosshair and "xy" enables them both. "color" is the color of the
crosshair (default is "rgba(170, 0, 0, 0.80)"), "lineWidth" is the width of
the drawn lines (default is 1).

The plugin also adds four public methods:

  - setCrosshair( pos )

    Set the position of the crosshair. Note that this is cleared if the user
    moves the mouse. "pos" is in coordinates of the plot and should be on the
    form { x: xpos, y: ypos } (you can use x2/x3/... if you're using multiple
    axes), which is coincidentally the same format as what you get from a
    "plothover" event. If "pos" is null, the crosshair is cleared.

  - clearCrosshair()

    Clear the crosshair.

  - lockCrosshair(pos)

    Cause the crosshair to lock to the current location, no longer updating if
    the user moves the mouse. Optionally supply a position (passed on to
    setCrosshair()) to move it to.

    Example usage:

	var myFlot = $.plot( $("#graph"), ..., { crosshair: { mode: "x" } } };
	$("#graph").bind( "plothover", function ( evt, position, item ) {
		if ( item ) {
			// Lock the crosshair to the data point being hovered
			myFlot.lockCrosshair({
				x: item.datapoint[ 0 ],
				y: item.datapoint[ 1 ]
			});
		} else {
			// Return normal crosshair operation
			myFlot.unlockCrosshair();
		}
	});

  - unlockCrosshair()

    Free the crosshair to move again after locking it.
*/

(function ($) {
    var options = {
        crosshair: {
            mode: null, // one of null, "x", "y" or "xy",
            color: "rgba(170, 0, 0, 0.80)",
            lineWidth: 1
        }
    };
    
    function init(plot) {
        // position of crosshair in pixels
        var crosshair = { x: -1, y: -1, locked: false };

        plot.setCrosshair = function setCrosshair(pos) {
            if (!pos)
                crosshair.x = -1;
            else {
                var o = plot.p2c(pos);
                crosshair.x = Math.max(0, Math.min(o.left, plot.width()));
                crosshair.y = Math.max(0, Math.min(o.top, plot.height()));
            }
            
            plot.triggerRedrawOverlay();
        };
        
        plot.clearCrosshair = plot.setCrosshair; // passes null for pos
        
        plot.lockCrosshair = function lockCrosshair(pos) {
            if (pos)
                plot.setCrosshair(pos);
            crosshair.locked = true;
        };

        plot.unlockCrosshair = function unlockCrosshair() {
            crosshair.locked = false;
        };

        function onMouseOut(e) {
            if (crosshair.locked)
                return;

            if (crosshair.x != -1) {
                crosshair.x = -1;
                plot.triggerRedrawOverlay();
            }
        }

        function onMouseMove(e) {
            if (crosshair.locked)
                return;
                
            if (plot.getSelection && plot.getSelection()) {
                crosshair.x = -1; // hide the crosshair while selecting
                return;
            }
                
            var offset = plot.offset();
            crosshair.x = Math.max(0, Math.min(e.pageX - offset.left, plot.width()));
            crosshair.y = Math.max(0, Math.min(e.pageY - offset.top, plot.height()));
            plot.triggerRedrawOverlay();
        }
        
        plot.hooks.bindEvents.push(function (plot, eventHolder) {
            if (!plot.getOptions().crosshair.mode)
                return;

            eventHolder.mouseout(onMouseOut);
            eventHolder.mousemove(onMouseMove);
        });

        plot.hooks.drawOverlay.push(function (plot, ctx) {
            var c = plot.getOptions().crosshair;
            if (!c.mode)
                return;

            var plotOffset = plot.getPlotOffset();
            
            ctx.save();
            ctx.translate(plotOffset.left, plotOffset.top);

            if (crosshair.x != -1) {
                var adj = plot.getOptions().crosshair.lineWidth % 2 ? 0.5 : 0;

                ctx.strokeStyle = c.color;
                ctx.lineWidth = c.lineWidth;
                ctx.lineJoin = "round";

                ctx.beginPath();
                if (c.mode.indexOf("x") != -1) {
                    var drawX = Math.floor(crosshair.x) + adj;
                    ctx.moveTo(drawX, 0);
                    ctx.lineTo(drawX, plot.height());
                }
                if (c.mode.indexOf("y") != -1) {
                    var drawY = Math.floor(crosshair.y) + adj;
                    ctx.moveTo(0, drawY);
                    ctx.lineTo(plot.width(), drawY);
                }
                ctx.stroke();
            }
            ctx.restore();
        });

        plot.hooks.shutdown.push(function (plot, eventHolder) {
            eventHolder.unbind("mouseout", onMouseOut);
            eventHolder.unbind("mousemove", onMouseMove);
        });
    }
    
    $.plot.plugins.push({
        init: init,
        options: options,
        name: 'crosshair',
        version: '1.0'
    });
})(jQuery);

/* Flot plugin for plotting error bars.

Copyright (c) 2007-2014 IOLA and Ole Laursen.
Licensed under the MIT license.

Error bars are used to show standard deviation and other statistical
properties in a plot.

* Created by Rui Pereira  -  rui (dot) pereira (at) gmail (dot) com

This plugin allows you to plot error-bars over points. Set "errorbars" inside
the points series to the axis name over which there will be error values in
your data array (*even* if you do not intend to plot them later, by setting
"show: null" on xerr/yerr).

The plugin supports these options:

	series: {
		points: {
			errorbars: "x" or "y" or "xy",
			xerr: {
				show: null/false or true,
				asymmetric: null/false or true,
				upperCap: null or "-" or function,
				lowerCap: null or "-" or function,
				color: null or color,
				radius: null or number
			},
			yerr: { same options as xerr }
		}
	}

Each data point array is expected to be of the type:

	"x"  [ x, y, xerr ]
	"y"  [ x, y, yerr ]
	"xy" [ x, y, xerr, yerr ]

Where xerr becomes xerr_lower,xerr_upper for the asymmetric error case, and
equivalently for yerr. Eg., a datapoint for the "xy" case with symmetric
error-bars on X and asymmetric on Y would be:

	[ x, y, xerr, yerr_lower, yerr_upper ]

By default no end caps are drawn. Setting upperCap and/or lowerCap to "-" will
draw a small cap perpendicular to the error bar. They can also be set to a
user-defined drawing function, with (ctx, x, y, radius) as parameters, as eg.

	function drawSemiCircle( ctx, x, y, radius ) {
		ctx.beginPath();
		ctx.arc( x, y, radius, 0, Math.PI, false );
		ctx.moveTo( x - radius, y );
		ctx.lineTo( x + radius, y );
		ctx.stroke();
	}

Color and radius both default to the same ones of the points series if not
set. The independent radius parameter on xerr/yerr is useful for the case when
we may want to add error-bars to a line, without showing the interconnecting
points (with radius: 0), and still showing end caps on the error-bars.
shadowSize and lineWidth are derived as well from the points series.

*/

(function ($) {
    var options = {
        series: {
            points: {
                errorbars: null, //should be 'x', 'y' or 'xy'
                xerr: { err: 'x', show: null, asymmetric: null, upperCap: null, lowerCap: null, color: null, radius: null},
                yerr: { err: 'y', show: null, asymmetric: null, upperCap: null, lowerCap: null, color: null, radius: null}
            }
        }
    };

    function processRawData(plot, series, data, datapoints){
        if (!series.points.errorbars)
            return;

        // x,y values
        var format = [
            { x: true, number: true, required: true },
            { y: true, number: true, required: true }
        ];

        var errors = series.points.errorbars;
        // error bars - first X then Y
        if (errors == 'x' || errors == 'xy') {
            // lower / upper error
            if (series.points.xerr.asymmetric) {
                format.push({ x: true, number: true, required: true });
                format.push({ x: true, number: true, required: true });
            } else
                format.push({ x: true, number: true, required: true });
        }
        if (errors == 'y' || errors == 'xy') {
            // lower / upper error
            if (series.points.yerr.asymmetric) {
                format.push({ y: true, number: true, required: true });
                format.push({ y: true, number: true, required: true });
            } else
                format.push({ y: true, number: true, required: true });
        }
        datapoints.format = format;
    }

    function parseErrors(series, i){

        var points = series.datapoints.points;

        // read errors from points array
        var exl = null,
                exu = null,
                eyl = null,
                eyu = null;
        var xerr = series.points.xerr,
                yerr = series.points.yerr;

        var eb = series.points.errorbars;
        // error bars - first X
        if (eb == 'x' || eb == 'xy') {
            if (xerr.asymmetric) {
                exl = points[i + 2];
                exu = points[i + 3];
                if (eb == 'xy')
                    if (yerr.asymmetric){
                        eyl = points[i + 4];
                        eyu = points[i + 5];
                    } else eyl = points[i + 4];
            } else {
                exl = points[i + 2];
                if (eb == 'xy')
                    if (yerr.asymmetric) {
                        eyl = points[i + 3];
                        eyu = points[i + 4];
                    } else eyl = points[i + 3];
            }
        // only Y
        } else if (eb == 'y')
            if (yerr.asymmetric) {
                eyl = points[i + 2];
                eyu = points[i + 3];
            } else eyl = points[i + 2];

        // symmetric errors?
        if (exu == null) exu = exl;
        if (eyu == null) eyu = eyl;

        var errRanges = [exl, exu, eyl, eyu];
        // nullify if not showing
        if (!xerr.show){
            errRanges[0] = null;
            errRanges[1] = null;
        }
        if (!yerr.show){
            errRanges[2] = null;
            errRanges[3] = null;
        }
        return errRanges;
    }

    function drawSeriesErrors(plot, ctx, s){

        var points = s.datapoints.points,
                ps = s.datapoints.pointsize,
                ax = [s.xaxis, s.yaxis],
                radius = s.points.radius,
                err = [s.points.xerr, s.points.yerr];

        //sanity check, in case some inverted axis hack is applied to flot
        var invertX = false;
        if (ax[0].p2c(ax[0].max) < ax[0].p2c(ax[0].min)) {
            invertX = true;
            var tmp = err[0].lowerCap;
            err[0].lowerCap = err[0].upperCap;
            err[0].upperCap = tmp;
        }

        var invertY = false;
        if (ax[1].p2c(ax[1].min) < ax[1].p2c(ax[1].max)) {
            invertY = true;
            var tmp = err[1].lowerCap;
            err[1].lowerCap = err[1].upperCap;
            err[1].upperCap = tmp;
        }

        for (var i = 0; i < s.datapoints.points.length; i += ps) {

            //parse
            var errRanges = parseErrors(s, i);

            //cycle xerr & yerr
            for (var e = 0; e < err.length; e++){

                var minmax = [ax[e].min, ax[e].max];

                //draw this error?
                if (errRanges[e * err.length]){

                    //data coordinates
                    var x = points[i],
                        y = points[i + 1];

                    //errorbar ranges
                    var upper = [x, y][e] + errRanges[e * err.length + 1],
                        lower = [x, y][e] - errRanges[e * err.length];

                    //points outside of the canvas
                    if (err[e].err == 'x')
                        if (y > ax[1].max || y < ax[1].min || upper < ax[0].min || lower > ax[0].max)
                            continue;
                    if (err[e].err == 'y')
                        if (x > ax[0].max || x < ax[0].min || upper < ax[1].min || lower > ax[1].max)
                            continue;

                    // prevent errorbars getting out of the canvas
                    var drawUpper = true,
                        drawLower = true;

                    if (upper > minmax[1]) {
                        drawUpper = false;
                        upper = minmax[1];
                    }
                    if (lower < minmax[0]) {
                        drawLower = false;
                        lower = minmax[0];
                    }

                    //sanity check, in case some inverted axis hack is applied to flot
                    if ((err[e].err == 'x' && invertX) || (err[e].err == 'y' && invertY)) {
                        //swap coordinates
                        var tmp = lower;
                        lower = upper;
                        upper = tmp;
                        tmp = drawLower;
                        drawLower = drawUpper;
                        drawUpper = tmp;
                        tmp = minmax[0];
                        minmax[0] = minmax[1];
                        minmax[1] = tmp;
                    }

                    // convert to pixels
                    x = ax[0].p2c(x),
                        y = ax[1].p2c(y),
                        upper = ax[e].p2c(upper);
                    lower = ax[e].p2c(lower);
                    minmax[0] = ax[e].p2c(minmax[0]);
                    minmax[1] = ax[e].p2c(minmax[1]);

                    //same style as points by default
                    var lw = err[e].lineWidth ? err[e].lineWidth : s.points.lineWidth,
                        sw = s.points.shadowSize != null ? s.points.shadowSize : s.shadowSize;

                    //shadow as for points
                    if (lw > 0 && sw > 0) {
                        var w = sw / 2;
                        ctx.lineWidth = w;
                        ctx.strokeStyle = "rgba(0,0,0,0.1)";
                        drawError(ctx, err[e], x, y, upper, lower, drawUpper, drawLower, radius, w + w/2, minmax);

                        ctx.strokeStyle = "rgba(0,0,0,0.2)";
                        drawError(ctx, err[e], x, y, upper, lower, drawUpper, drawLower, radius, w/2, minmax);
                    }

                    ctx.strokeStyle = err[e].color? err[e].color: s.color;
                    ctx.lineWidth = lw;
                    //draw it
                    drawError(ctx, err[e], x, y, upper, lower, drawUpper, drawLower, radius, 0, minmax);
                }
            }
        }
    }

    function drawError(ctx,err,x,y,upper,lower,drawUpper,drawLower,radius,offset,minmax){

        //shadow offset
        y += offset;
        upper += offset;
        lower += offset;

        // error bar - avoid plotting over circles
        if (err.err == 'x'){
            if (upper > x + radius) drawPath(ctx, [[upper,y],[Math.max(x + radius,minmax[0]),y]]);
            else drawUpper = false;
            if (lower < x - radius) drawPath(ctx, [[Math.min(x - radius,minmax[1]),y],[lower,y]] );
            else drawLower = false;
        }
        else {
            if (upper < y - radius) drawPath(ctx, [[x,upper],[x,Math.min(y - radius,minmax[0])]] );
            else drawUpper = false;
            if (lower > y + radius) drawPath(ctx, [[x,Math.max(y + radius,minmax[1])],[x,lower]] );
            else drawLower = false;
        }

        //internal radius value in errorbar, allows to plot radius 0 points and still keep proper sized caps
        //this is a way to get errorbars on lines without visible connecting dots
        radius = err.radius != null? err.radius: radius;

        // upper cap
        if (drawUpper) {
            if (err.upperCap == '-'){
                if (err.err=='x') drawPath(ctx, [[upper,y - radius],[upper,y + radius]] );
                else drawPath(ctx, [[x - radius,upper],[x + radius,upper]] );
            } else if ($.isFunction(err.upperCap)){
                if (err.err=='x') err.upperCap(ctx, upper, y, radius);
                else err.upperCap(ctx, x, upper, radius);
            }
        }
        // lower cap
        if (drawLower) {
            if (err.lowerCap == '-'){
                if (err.err=='x') drawPath(ctx, [[lower,y - radius],[lower,y + radius]] );
                else drawPath(ctx, [[x - radius,lower],[x + radius,lower]] );
            } else if ($.isFunction(err.lowerCap)){
                if (err.err=='x') err.lowerCap(ctx, lower, y, radius);
                else err.lowerCap(ctx, x, lower, radius);
            }
        }
    }

    function drawPath(ctx, pts){
        ctx.beginPath();
        ctx.moveTo(pts[0][0], pts[0][1]);
        for (var p=1; p < pts.length; p++)
            ctx.lineTo(pts[p][0], pts[p][1]);
        ctx.stroke();
    }

    function draw(plot, ctx){
        var plotOffset = plot.getPlotOffset();

        ctx.save();
        ctx.translate(plotOffset.left, plotOffset.top);
        $.each(plot.getData(), function (i, s) {
            if (s.points.errorbars && (s.points.xerr.show || s.points.yerr.show))
                drawSeriesErrors(plot, ctx, s);
        });
        ctx.restore();
    }

    function init(plot) {
        plot.hooks.processRawData.push(processRawData);
        plot.hooks.draw.push(draw);
    }

    $.plot.plugins.push({
                init: init,
                options: options,
                name: 'errorbars',
                version: '1.0'
            });
})(jQuery);

/* Flot plugin for computing bottoms for filled line and bar charts.

Copyright (c) 2007-2014 IOLA and Ole Laursen.
Licensed under the MIT license.

The case: you've got two series that you want to fill the area between. In Flot
terms, you need to use one as the fill bottom of the other. You can specify the
bottom of each data point as the third coordinate manually, or you can use this
plugin to compute it for you.

In order to name the other series, you need to give it an id, like this:

	var dataset = [
		{ data: [ ... ], id: "foo" } ,         // use default bottom
		{ data: [ ... ], fillBetween: "foo" }, // use first dataset as bottom
	];

	$.plot($("#placeholder"), dataset, { lines: { show: true, fill: true }});

As a convenience, if the id given is a number that doesn't appear as an id in
the series, it is interpreted as the index in the array instead (so fillBetween:
0 can also mean the first series).

Internally, the plugin modifies the datapoints in each series. For line series,
extra data points might be inserted through interpolation. Note that at points
where the bottom line is not defined (due to a null point or start/end of line),
the current line will show a gap too. The algorithm comes from the
jquery.flot.stack.js plugin, possibly some code could be shared.

*/

(function ( $ ) {

	var options = {
		series: {
			fillBetween: null	// or number
		}
	};

	function init( plot ) {

		function findBottomSeries( s, allseries ) {

			var i;

			for ( i = 0; i < allseries.length; ++i ) {
				if ( allseries[ i ].id === s.fillBetween ) {
					return allseries[ i ];
				}
			}

			if ( typeof s.fillBetween === "number" ) {
				if ( s.fillBetween < 0 || s.fillBetween >= allseries.length ) {
					return null;
				}
				return allseries[ s.fillBetween ];
			}

			return null;
		}

		function computeFillBottoms( plot, s, datapoints ) {

			if ( s.fillBetween == null ) {
				return;
			}

			var other = findBottomSeries( s, plot.getData() );

			if ( !other ) {
				return;
			}

			var ps = datapoints.pointsize,
				points = datapoints.points,
				otherps = other.datapoints.pointsize,
				otherpoints = other.datapoints.points,
				newpoints = [],
				px, py, intery, qx, qy, bottom,
				withlines = s.lines.show,
				withbottom = ps > 2 && datapoints.format[2].y,
				withsteps = withlines && s.lines.steps,
				fromgap = true,
				i = 0,
				j = 0,
				l, m;

			while ( true ) {

				if ( i >= points.length ) {
					break;
				}

				l = newpoints.length;

				if ( points[ i ] == null ) {

					// copy gaps

					for ( m = 0; m < ps; ++m ) {
						newpoints.push( points[ i + m ] );
					}

					i += ps;

				} else if ( j >= otherpoints.length ) {

					// for lines, we can't use the rest of the points

					if ( !withlines ) {
						for ( m = 0; m < ps; ++m ) {
							newpoints.push( points[ i + m ] );
						}
					}

					i += ps;

				} else if ( otherpoints[ j ] == null ) {

					// oops, got a gap

					for ( m = 0; m < ps; ++m ) {
						newpoints.push( null );
					}

					fromgap = true;
					j += otherps;

				} else {

					// cases where we actually got two points

					px = points[ i ];
					py = points[ i + 1 ];
					qx = otherpoints[ j ];
					qy = otherpoints[ j + 1 ];
					bottom = 0;

					if ( px === qx ) {

						for ( m = 0; m < ps; ++m ) {
							newpoints.push( points[ i + m ] );
						}

						//newpoints[ l + 1 ] += qy;
						bottom = qy;

						i += ps;
						j += otherps;

					} else if ( px > qx ) {

						// we got past point below, might need to
						// insert interpolated extra point

						if ( withlines && i > 0 && points[ i - ps ] != null ) {
							intery = py + ( points[ i - ps + 1 ] - py ) * ( qx - px ) / ( points[ i - ps ] - px );
							newpoints.push( qx );
							newpoints.push( intery );
							for ( m = 2; m < ps; ++m ) {
								newpoints.push( points[ i + m ] );
							}
							bottom = qy;
						}

						j += otherps;

					} else { // px < qx

						// if we come from a gap, we just skip this point

						if ( fromgap && withlines ) {
							i += ps;
							continue;
						}

						for ( m = 0; m < ps; ++m ) {
							newpoints.push( points[ i + m ] );
						}

						// we might be able to interpolate a point below,
						// this can give us a better y

						if ( withlines && j > 0 && otherpoints[ j - otherps ] != null ) {
							bottom = qy + ( otherpoints[ j - otherps + 1 ] - qy ) * ( px - qx ) / ( otherpoints[ j - otherps ] - qx );
						}

						//newpoints[l + 1] += bottom;

						i += ps;
					}

					fromgap = false;

					if ( l !== newpoints.length && withbottom ) {
						newpoints[ l + 2 ] = bottom;
					}
				}

				// maintain the line steps invariant

				if ( withsteps && l !== newpoints.length && l > 0 &&
					newpoints[ l ] !== null &&
					newpoints[ l ] !== newpoints[ l - ps ] &&
					newpoints[ l + 1 ] !== newpoints[ l - ps + 1 ] ) {
					for (m = 0; m < ps; ++m) {
						newpoints[ l + ps + m ] = newpoints[ l + m ];
					}
					newpoints[ l + 1 ] = newpoints[ l - ps + 1 ];
				}
			}

			datapoints.points = newpoints;
		}

		plot.hooks.processDatapoints.push( computeFillBottoms );
	}

	$.plot.plugins.push({
		init: init,
		options: options,
		name: "fillbetween",
		version: "1.0"
	});

})(jQuery);

/* Flot plugin for plotting images.

Copyright (c) 2007-2014 IOLA and Ole Laursen.
Licensed under the MIT license.

The data syntax is [ [ image, x1, y1, x2, y2 ], ... ] where (x1, y1) and
(x2, y2) are where you intend the two opposite corners of the image to end up
in the plot. Image must be a fully loaded Javascript image (you can make one
with new Image()). If the image is not complete, it's skipped when plotting.

There are two helpers included for retrieving images. The easiest work the way
that you put in URLs instead of images in the data, like this:

	[ "myimage.png", 0, 0, 10, 10 ]

Then call $.plot.image.loadData( data, options, callback ) where data and
options are the same as you pass in to $.plot. This loads the images, replaces
the URLs in the data with the corresponding images and calls "callback" when
all images are loaded (or failed loading). In the callback, you can then call
$.plot with the data set. See the included example.

A more low-level helper, $.plot.image.load(urls, callback) is also included.
Given a list of URLs, it calls callback with an object mapping from URL to
Image object when all images are loaded or have failed loading.

The plugin supports these options:

	series: {
		images: {
			show: boolean
			anchor: "corner" or "center"
			alpha: [ 0, 1 ]
		}
	}

They can be specified for a specific series:

	$.plot( $("#placeholder"), [{
		data: [ ... ],
		images: { ... }
	])

Note that because the data format is different from usual data points, you
can't use images with anything else in a specific data series.

Setting "anchor" to "center" causes the pixels in the image to be anchored at
the corner pixel centers inside of at the pixel corners, effectively letting
half a pixel stick out to each side in the plot.

A possible future direction could be support for tiling for large images (like
Google Maps).

*/

(function ($) {
    var options = {
        series: {
            images: {
                show: false,
                alpha: 1,
                anchor: "corner" // or "center"
            }
        }
    };

    $.plot.image = {};

    $.plot.image.loadDataImages = function (series, options, callback) {
        var urls = [], points = [];

        var defaultShow = options.series.images.show;
        
        $.each(series, function (i, s) {
            if (!(defaultShow || s.images.show))
                return;
            
            if (s.data)
                s = s.data;

            $.each(s, function (i, p) {
                if (typeof p[0] == "string") {
                    urls.push(p[0]);
                    points.push(p);
                }
            });
        });

        $.plot.image.load(urls, function (loadedImages) {
            $.each(points, function (i, p) {
                var url = p[0];
                if (loadedImages[url])
                    p[0] = loadedImages[url];
            });

            callback();
        });
    }
    
    $.plot.image.load = function (urls, callback) {
        var missing = urls.length, loaded = {};
        if (missing == 0)
            callback({});

        $.each(urls, function (i, url) {
            var handler = function () {
                --missing;
                
                loaded[url] = this;
                
                if (missing == 0)
                    callback(loaded);
            };

            $('<img />').load(handler).error(handler).attr('src', url);
        });
    };
    
    function drawSeries(plot, ctx, series) {
        var plotOffset = plot.getPlotOffset();
        
        if (!series.images || !series.images.show)
            return;
        
        var points = series.datapoints.points,
            ps = series.datapoints.pointsize;
        
        for (var i = 0; i < points.length; i += ps) {
            var img = points[i],
                x1 = points[i + 1], y1 = points[i + 2],
                x2 = points[i + 3], y2 = points[i + 4],
                xaxis = series.xaxis, yaxis = series.yaxis,
                tmp;

            // actually we should check img.complete, but it
            // appears to be a somewhat unreliable indicator in
            // IE6 (false even after load event)
            if (!img || img.width <= 0 || img.height <= 0)
                continue;

            if (x1 > x2) {
                tmp = x2;
                x2 = x1;
                x1 = tmp;
            }
            if (y1 > y2) {
                tmp = y2;
                y2 = y1;
                y1 = tmp;
            }
            
            // if the anchor is at the center of the pixel, expand the 
            // image by 1/2 pixel in each direction
            if (series.images.anchor == "center") {
                tmp = 0.5 * (x2-x1) / (img.width - 1);
                x1 -= tmp;
                x2 += tmp;
                tmp = 0.5 * (y2-y1) / (img.height - 1);
                y1 -= tmp;
                y2 += tmp;
            }
            
            // clip
            if (x1 == x2 || y1 == y2 ||
                x1 >= xaxis.max || x2 <= xaxis.min ||
                y1 >= yaxis.max || y2 <= yaxis.min)
                continue;

            var sx1 = 0, sy1 = 0, sx2 = img.width, sy2 = img.height;
            if (x1 < xaxis.min) {
                sx1 += (sx2 - sx1) * (xaxis.min - x1) / (x2 - x1);
                x1 = xaxis.min;
            }

            if (x2 > xaxis.max) {
                sx2 += (sx2 - sx1) * (xaxis.max - x2) / (x2 - x1);
                x2 = xaxis.max;
            }

            if (y1 < yaxis.min) {
                sy2 += (sy1 - sy2) * (yaxis.min - y1) / (y2 - y1);
                y1 = yaxis.min;
            }

            if (y2 > yaxis.max) {
                sy1 += (sy1 - sy2) * (yaxis.max - y2) / (y2 - y1);
                y2 = yaxis.max;
            }
            
            x1 = xaxis.p2c(x1);
            x2 = xaxis.p2c(x2);
            y1 = yaxis.p2c(y1);
            y2 = yaxis.p2c(y2);
            
            // the transformation may have swapped us
            if (x1 > x2) {
                tmp = x2;
                x2 = x1;
                x1 = tmp;
            }
            if (y1 > y2) {
                tmp = y2;
                y2 = y1;
                y1 = tmp;
            }

            tmp = ctx.globalAlpha;
            ctx.globalAlpha *= series.images.alpha;
            ctx.drawImage(img,
                          sx1, sy1, sx2 - sx1, sy2 - sy1,
                          x1 + plotOffset.left, y1 + plotOffset.top,
                          x2 - x1, y2 - y1);
            ctx.globalAlpha = tmp;
        }
    }

    function processRawData(plot, series, data, datapoints) {
        if (!series.images.show)
            return;

        // format is Image, x1, y1, x2, y2 (opposite corners)
        datapoints.format = [
            { required: true },
            { x: true, number: true, required: true },
            { y: true, number: true, required: true },
            { x: true, number: true, required: true },
            { y: true, number: true, required: true }
        ];
    }
    
    function init(plot) {
        plot.hooks.processRawData.push(processRawData);
        plot.hooks.drawSeries.push(drawSeries);
    }
    
    $.plot.plugins.push({
        init: init,
        options: options,
        name: 'image',
        version: '1.1'
    });
})(jQuery);

/* Flot plugin for adding the ability to pan and zoom the plot.

Copyright (c) 2007-2014 IOLA and Ole Laursen.
Licensed under the MIT license.

The default behaviour is double click and scrollwheel up/down to zoom in, drag
to pan. The plugin defines plot.zoom({ center }), plot.zoomOut() and
plot.pan( offset ) so you easily can add custom controls. It also fires
"plotpan" and "plotzoom" events, useful for synchronizing plots.

The plugin supports these options:

	zoom: {
		interactive: false
		trigger: "dblclick" // or "click" for single click
		amount: 1.5         // 2 = 200% (zoom in), 0.5 = 50% (zoom out)
	}

	pan: {
		interactive: false
		cursor: "move"      // CSS mouse cursor value used when dragging, e.g. "pointer"
		frameRate: 20
	}

	xaxis, yaxis, x2axis, y2axis: {
		zoomRange: null  // or [ number, number ] (min range, max range) or false
		panRange: null   // or [ number, number ] (min, max) or false
	}

"interactive" enables the built-in drag/click behaviour. If you enable
interactive for pan, then you'll have a basic plot that supports moving
around; the same for zoom.

"amount" specifies the default amount to zoom in (so 1.5 = 150%) relative to
the current viewport.

"cursor" is a standard CSS mouse cursor string used for visual feedback to the
user when dragging.

"frameRate" specifies the maximum number of times per second the plot will
update itself while the user is panning around on it (set to null to disable
intermediate pans, the plot will then not update until the mouse button is
released).

"zoomRange" is the interval in which zooming can happen, e.g. with zoomRange:
[1, 100] the zoom will never scale the axis so that the difference between min
and max is smaller than 1 or larger than 100. You can set either end to null
to ignore, e.g. [1, null]. If you set zoomRange to false, zooming on that axis
will be disabled.

"panRange" confines the panning to stay within a range, e.g. with panRange:
[-10, 20] panning stops at -10 in one end and at 20 in the other. Either can
be null, e.g. [-10, null]. If you set panRange to false, panning on that axis
will be disabled.

Example API usage:

	plot = $.plot(...);

	// zoom default amount in on the pixel ( 10, 20 )
	plot.zoom({ center: { left: 10, top: 20 } });

	// zoom out again
	plot.zoomOut({ center: { left: 10, top: 20 } });

	// zoom 200% in on the pixel (10, 20)
	plot.zoom({ amount: 2, center: { left: 10, top: 20 } });

	// pan 100 pixels to the left and 20 down
	plot.pan({ left: -100, top: 20 })

Here, "center" specifies where the center of the zooming should happen. Note
that this is defined in pixel space, not the space of the data points (you can
use the p2c helpers on the axes in Flot to help you convert between these).

"amount" is the amount to zoom the viewport relative to the current range, so
1 is 100% (i.e. no change), 1.5 is 150% (zoom in), 0.7 is 70% (zoom out). You
can set the default in the options.

*/

// First two dependencies, jquery.event.drag.js and
// jquery.mousewheel.js, we put them inline here to save people the
// effort of downloading them.

/*
jquery.event.drag.js ~ v1.5 ~ Copyright (c) 2008, Three Dub Media (http://threedubmedia.com)
Licensed under the MIT License ~ http://threedubmedia.googlecode.com/files/MIT-LICENSE.txt
*/
(function(a){function e(h){var k,j=this,l=h.data||{};if(l.elem)j=h.dragTarget=l.elem,h.dragProxy=d.proxy||j,h.cursorOffsetX=l.pageX-l.left,h.cursorOffsetY=l.pageY-l.top,h.offsetX=h.pageX-h.cursorOffsetX,h.offsetY=h.pageY-h.cursorOffsetY;else if(d.dragging||l.which>0&&h.which!=l.which||a(h.target).is(l.not))return;switch(h.type){case"mousedown":return a.extend(l,a(j).offset(),{elem:j,target:h.target,pageX:h.pageX,pageY:h.pageY}),b.add(document,"mousemove mouseup",e,l),i(j,!1),d.dragging=null,!1;case!d.dragging&&"mousemove":if(g(h.pageX-l.pageX)+g(h.pageY-l.pageY)<l.distance)break;h.target=l.target,k=f(h,"dragstart",j),k!==!1&&(d.dragging=j,d.proxy=h.dragProxy=a(k||j)[0]);case"mousemove":if(d.dragging){if(k=f(h,"drag",j),c.drop&&(c.drop.allowed=k!==!1,c.drop.handler(h)),k!==!1)break;h.type="mouseup"}case"mouseup":b.remove(document,"mousemove mouseup",e),d.dragging&&(c.drop&&c.drop.handler(h),f(h,"dragend",j)),i(j,!0),d.dragging=d.proxy=l.elem=!1}return!0}function f(b,c,d){b.type=c;var e=a.event.dispatch.call(d,b);return e===!1?!1:e||b.result}function g(a){return Math.pow(a,2)}function h(){return d.dragging===!1}function i(a,b){a&&(a.unselectable=b?"off":"on",a.onselectstart=function(){return b},a.style&&(a.style.MozUserSelect=b?"":"none"))}a.fn.drag=function(a,b,c){return b&&this.bind("dragstart",a),c&&this.bind("dragend",c),a?this.bind("drag",b?b:a):this.trigger("drag")};var b=a.event,c=b.special,d=c.drag={not:":input",distance:0,which:1,dragging:!1,setup:function(c){c=a.extend({distance:d.distance,which:d.which,not:d.not},c||{}),c.distance=g(c.distance),b.add(this,"mousedown",e,c),this.attachEvent&&this.attachEvent("ondragstart",h)},teardown:function(){b.remove(this,"mousedown",e),this===d.dragging&&(d.dragging=d.proxy=!1),i(this,!0),this.detachEvent&&this.detachEvent("ondragstart",h)}};c.dragstart=c.dragend={setup:function(){},teardown:function(){}}})(jQuery);

/* jquery.mousewheel.min.js
 * Copyright (c) 2011 Brandon Aaron (http://brandonaaron.net)
 * Licensed under the MIT License (LICENSE.txt).
 * Thanks to: http://adomas.org/javascript-mouse-wheel/ for some pointers.
 * Thanks to: Mathias Bank(http://www.mathias-bank.de) for a scope bug fix.
 * Thanks to: Seamus Leahy for adding deltaX and deltaY
 *
 * Version: 3.0.6
 *
 * Requires: 1.2.2+
 */
(function(d){function e(a){var b=a||window.event,c=[].slice.call(arguments,1),f=0,e=0,g=0,a=d.event.fix(b);a.type="mousewheel";b.wheelDelta&&(f=b.wheelDelta/120);b.detail&&(f=-b.detail/3);g=f;void 0!==b.axis&&b.axis===b.HORIZONTAL_AXIS&&(g=0,e=-1*f);void 0!==b.wheelDeltaY&&(g=b.wheelDeltaY/120);void 0!==b.wheelDeltaX&&(e=-1*b.wheelDeltaX/120);c.unshift(a,f,e,g);return(d.event.dispatch||d.event.handle).apply(this,c)}var c=["DOMMouseScroll","mousewheel"];if(d.event.fixHooks)for(var h=c.length;h;)d.event.fixHooks[c[--h]]=d.event.mouseHooks;d.event.special.mousewheel={setup:function(){if(this.addEventListener)for(var a=c.length;a;)this.addEventListener(c[--a],e,!1);else this.onmousewheel=e},teardown:function(){if(this.removeEventListener)for(var a=c.length;a;)this.removeEventListener(c[--a],e,!1);else this.onmousewheel=null}};d.fn.extend({mousewheel:function(a){return a?this.bind("mousewheel",a):this.trigger("mousewheel")},unmousewheel:function(a){return this.unbind("mousewheel",a)}})})(jQuery);




(function ($) {
    var options = {
        xaxis: {
            zoomRange: null, // or [number, number] (min range, max range)
            panRange: null // or [number, number] (min, max)
        },
        zoom: {
            interactive: false,
            trigger: "dblclick", // or "click" for single click
            amount: 1.5 // how much to zoom relative to current position, 2 = 200% (zoom in), 0.5 = 50% (zoom out)
        },
        pan: {
            interactive: false,
            cursor: "move",
            frameRate: 20
        }
    };

    function init(plot) {
        function onZoomClick(e, zoomOut) {
            var c = plot.offset();
            c.left = e.pageX - c.left;
            c.top = e.pageY - c.top;
            if (zoomOut)
                plot.zoomOut({ center: c });
            else
                plot.zoom({ center: c });
        }

        function onMouseWheel(e, delta) {
            e.preventDefault();
            onZoomClick(e, delta < 0);
            return false;
        }
        
        var prevCursor = 'default', prevPageX = 0, prevPageY = 0,
            panTimeout = null;

        function onDragStart(e) {
            if (e.which != 1)  // only accept left-click
                return false;
            var c = plot.getPlaceholder().css('cursor');
            if (c)
                prevCursor = c;
            plot.getPlaceholder().css('cursor', plot.getOptions().pan.cursor);
            prevPageX = e.pageX;
            prevPageY = e.pageY;
        }
        
        function onDrag(e) {
            var frameRate = plot.getOptions().pan.frameRate;
            if (panTimeout || !frameRate)
                return;

            panTimeout = setTimeout(function () {
                plot.pan({ left: prevPageX - e.pageX,
                           top: prevPageY - e.pageY });
                prevPageX = e.pageX;
                prevPageY = e.pageY;
                                                    
                panTimeout = null;
            }, 1 / frameRate * 1000);
        }

        function onDragEnd(e) {
            if (panTimeout) {
                clearTimeout(panTimeout);
                panTimeout = null;
            }
                    
            plot.getPlaceholder().css('cursor', prevCursor);
            plot.pan({ left: prevPageX - e.pageX,
                       top: prevPageY - e.pageY });
        }
        
        function bindEvents(plot, eventHolder) {
            var o = plot.getOptions();
            if (o.zoom.interactive) {
                eventHolder[o.zoom.trigger](onZoomClick);
                eventHolder.mousewheel(onMouseWheel);
            }

            if (o.pan.interactive) {
                eventHolder.bind("dragstart", { distance: 10 }, onDragStart);
                eventHolder.bind("drag", onDrag);
                eventHolder.bind("dragend", onDragEnd);
            }
        }

        plot.zoomOut = function (args) {
            if (!args)
                args = {};
            
            if (!args.amount)
                args.amount = plot.getOptions().zoom.amount;

            args.amount = 1 / args.amount;
            plot.zoom(args);
        };
        
        plot.zoom = function (args) {
            if (!args)
                args = {};
            
            var c = args.center,
                amount = args.amount || plot.getOptions().zoom.amount,
                w = plot.width(), h = plot.height();

            if (!c)
                c = { left: w / 2, top: h / 2 };
                
            var xf = c.left / w,
                yf = c.top / h,
                minmax = {
                    x: {
                        min: c.left - xf * w / amount,
                        max: c.left + (1 - xf) * w / amount
                    },
                    y: {
                        min: c.top - yf * h / amount,
                        max: c.top + (1 - yf) * h / amount
                    }
                };

            $.each(plot.getAxes(), function(_, axis) {
                var opts = axis.options,
                    min = minmax[axis.direction].min,
                    max = minmax[axis.direction].max,
                    zr = opts.zoomRange,
                    pr = opts.panRange;

                if (zr === false) // no zooming on this axis
                    return;
                    
                min = axis.c2p(min);
                max = axis.c2p(max);
                if (min > max) {
                    // make sure min < max
                    var tmp = min;
                    min = max;
                    max = tmp;
                }

                //Check that we are in panRange
                if (pr) {
                    if (pr[0] != null && min < pr[0]) {
                        min = pr[0];
                    }
                    if (pr[1] != null && max > pr[1]) {
                        max = pr[1];
                    }
                }

                var range = max - min;
                if (zr &&
                    ((zr[0] != null && range < zr[0] && amount >1) ||
                     (zr[1] != null && range > zr[1] && amount <1)))
                    return;
            
                opts.min = min;
                opts.max = max;
            });
            
            plot.setupGrid();
            plot.draw();
            
            if (!args.preventEvent)
                plot.getPlaceholder().trigger("plotzoom", [ plot, args ]);
        };

        plot.pan = function (args) {
            var delta = {
                x: +args.left,
                y: +args.top
            };

            if (isNaN(delta.x))
                delta.x = 0;
            if (isNaN(delta.y))
                delta.y = 0;

            $.each(plot.getAxes(), function (_, axis) {
                var opts = axis.options,
                    min, max, d = delta[axis.direction];

                min = axis.c2p(axis.p2c(axis.min) + d),
                max = axis.c2p(axis.p2c(axis.max) + d);

                var pr = opts.panRange;
                if (pr === false) // no panning on this axis
                    return;
                
                if (pr) {
                    // check whether we hit the wall
                    if (pr[0] != null && pr[0] > min) {
                        d = pr[0] - min;
                        min += d;
                        max += d;
                    }
                    
                    if (pr[1] != null && pr[1] < max) {
                        d = pr[1] - max;
                        min += d;
                        max += d;
                    }
                }
                
                opts.min = min;
                opts.max = max;
            });
            
            plot.setupGrid();
            plot.draw();
            
            if (!args.preventEvent)
                plot.getPlaceholder().trigger("plotpan", [ plot, args ]);
        };

        function shutdown(plot, eventHolder) {
            eventHolder.unbind(plot.getOptions().zoom.trigger, onZoomClick);
            eventHolder.unbind("mousewheel", onMouseWheel);
            eventHolder.unbind("dragstart", onDragStart);
            eventHolder.unbind("drag", onDrag);
            eventHolder.unbind("dragend", onDragEnd);
            if (panTimeout)
                clearTimeout(panTimeout);
        }
        
        plot.hooks.bindEvents.push(bindEvents);
        plot.hooks.shutdown.push(shutdown);
    }
    
    $.plot.plugins.push({
        init: init,
        options: options,
        name: 'navigate',
        version: '1.3'
    });
})(jQuery);

/* Flot plugin for rendering pie charts.

Copyright (c) 2007-2014 IOLA and Ole Laursen.
Licensed under the MIT license.

The plugin assumes that each series has a single data value, and that each
value is a positive integer or zero.  Negative numbers don't make sense for a
pie chart, and have unpredictable results.  The values do NOT need to be
passed in as percentages; the plugin will calculate the total and per-slice
percentages internally.

* Created by Brian Medendorp

* Updated with contributions from btburnett3, Anthony Aragues and Xavi Ivars

The plugin supports these options:

	series: {
		pie: {
			show: true/false
			radius: 0-1 for percentage of fullsize, or a specified pixel length, or 'auto'
			innerRadius: 0-1 for percentage of fullsize or a specified pixel length, for creating a donut effect
			startAngle: 0-2 factor of PI used for starting angle (in radians) i.e 3/2 starts at the top, 0 and 2 have the same result
			tilt: 0-1 for percentage to tilt the pie, where 1 is no tilt, and 0 is completely flat (nothing will show)
			offset: {
				top: integer value to move the pie up or down
				left: integer value to move the pie left or right, or 'auto'
			},
			stroke: {
				color: any hexidecimal color value (other formats may or may not work, so best to stick with something like '#FFF')
				width: integer pixel width of the stroke
			},
			label: {
				show: true/false, or 'auto'
				formatter:  a user-defined function that modifies the text/style of the label text
				radius: 0-1 for percentage of fullsize, or a specified pixel length
				background: {
					color: any hexidecimal color value (other formats may or may not work, so best to stick with something like '#000')
					opacity: 0-1
				},
				threshold: 0-1 for the percentage value at which to hide labels (if they're too small)
			},
			combine: {
				threshold: 0-1 for the percentage value at which to combine slices (if they're too small)
				color: any hexidecimal color value (other formats may or may not work, so best to stick with something like '#CCC'), if null, the plugin will automatically use the color of the first slice to be combined
				label: any text value of what the combined slice should be labeled
			}
			highlight: {
				opacity: 0-1
			}
		}
	}

More detail and specific examples can be found in the included HTML file.

*/

(function($) {

	// Maximum redraw attempts when fitting labels within the plot

	var REDRAW_ATTEMPTS = 10;

	// Factor by which to shrink the pie when fitting labels within the plot

	var REDRAW_SHRINK = 0.95;

	function init(plot) {

		var canvas = null,
			target = null,
			options = null,
			maxRadius = null,
			centerLeft = null,
			centerTop = null,
			processed = false,
			ctx = null;

		// interactive variables

		var highlights = [];

		// add hook to determine if pie plugin in enabled, and then perform necessary operations

		plot.hooks.processOptions.push(function(plot, options) {
			if (options.series.pie.show) {

				options.grid.show = false;

				// set labels.show

				if (options.series.pie.label.show == "auto") {
					if (options.legend.show) {
						options.series.pie.label.show = false;
					} else {
						options.series.pie.label.show = true;
					}
				}

				// set radius

				if (options.series.pie.radius == "auto") {
					if (options.series.pie.label.show) {
						options.series.pie.radius = 3/4;
					} else {
						options.series.pie.radius = 1;
					}
				}

				// ensure sane tilt

				if (options.series.pie.tilt > 1) {
					options.series.pie.tilt = 1;
				} else if (options.series.pie.tilt < 0) {
					options.series.pie.tilt = 0;
				}
			}
		});

		plot.hooks.bindEvents.push(function(plot, eventHolder) {
			var options = plot.getOptions();
			if (options.series.pie.show) {
				if (options.grid.hoverable) {
					eventHolder.unbind("mousemove").mousemove(onMouseMove);
				}
				if (options.grid.clickable) {
					eventHolder.unbind("click").click(onClick);
				}
			}
		});

		plot.hooks.processDatapoints.push(function(plot, series, data, datapoints) {
			var options = plot.getOptions();
			if (options.series.pie.show) {
				processDatapoints(plot, series, data, datapoints);
			}
		});

		plot.hooks.drawOverlay.push(function(plot, octx) {
			var options = plot.getOptions();
			if (options.series.pie.show) {
				drawOverlay(plot, octx);
			}
		});

		plot.hooks.draw.push(function(plot, newCtx) {
			var options = plot.getOptions();
			if (options.series.pie.show) {
				draw(plot, newCtx);
			}
		});

		function processDatapoints(plot, series, datapoints) {
			if (!processed)	{
				processed = true;
				canvas = plot.getCanvas();
				target = $(canvas).parent();
				options = plot.getOptions();
				plot.setData(combine(plot.getData()));
			}
		}

		function combine(data) {

			var total = 0,
				combined = 0,
				numCombined = 0,
				color = options.series.pie.combine.color,
				newdata = [];

			// Fix up the raw data from Flot, ensuring the data is numeric

			for (var i = 0; i < data.length; ++i) {

				var value = data[i].data;

				// If the data is an array, we'll assume that it's a standard
				// Flot x-y pair, and are concerned only with the second value.

				// Note how we use the original array, rather than creating a
				// new one; this is more efficient and preserves any extra data
				// that the user may have stored in higher indexes.

				if ($.isArray(value) && value.length == 1) {
    				value = value[0];
				}

				if ($.isArray(value)) {
					// Equivalent to $.isNumeric() but compatible with jQuery < 1.7
					if (!isNaN(parseFloat(value[1])) && isFinite(value[1])) {
						value[1] = +value[1];
					} else {
						value[1] = 0;
					}
				} else if (!isNaN(parseFloat(value)) && isFinite(value)) {
					value = [1, +value];
				} else {
					value = [1, 0];
				}

				data[i].data = [value];
			}

			// Sum up all the slices, so we can calculate percentages for each

			for (var i = 0; i < data.length; ++i) {
				total += data[i].data[0][1];
			}

			// Count the number of slices with percentages below the combine
			// threshold; if it turns out to be just one, we won't combine.

			for (var i = 0; i < data.length; ++i) {
				var value = data[i].data[0][1];
				if (value / total <= options.series.pie.combine.threshold) {
					combined += value;
					numCombined++;
					if (!color) {
						color = data[i].color;
					}
				}
			}

			for (var i = 0; i < data.length; ++i) {
				var value = data[i].data[0][1];
				if (numCombined < 2 || value / total > options.series.pie.combine.threshold) {
					newdata.push(
						$.extend(data[i], {     /* extend to allow keeping all other original data values
						                           and using them e.g. in labelFormatter. */
							data: [[1, value]],
							color: data[i].color,
							label: data[i].label,
							angle: value * Math.PI * 2 / total,
							percent: value / (total / 100)
						})
					);
				}
			}

			if (numCombined > 1) {
				newdata.push({
					data: [[1, combined]],
					color: color,
					label: options.series.pie.combine.label,
					angle: combined * Math.PI * 2 / total,
					percent: combined / (total / 100)
				});
			}

			return newdata;
		}

		function draw(plot, newCtx) {

			if (!target) {
				return; // if no series were passed
			}

			var canvasWidth = plot.getPlaceholder().width(),
				canvasHeight = plot.getPlaceholder().height(),
				legendWidth = target.children().filter(".legend").children().width() || 0;

			ctx = newCtx;

			// WARNING: HACK! REWRITE THIS CODE AS SOON AS POSSIBLE!

			// When combining smaller slices into an 'other' slice, we need to
			// add a new series.  Since Flot gives plugins no way to modify the
			// list of series, the pie plugin uses a hack where the first call
			// to processDatapoints results in a call to setData with the new
			// list of series, then subsequent processDatapoints do nothing.

			// The plugin-global 'processed' flag is used to control this hack;
			// it starts out false, and is set to true after the first call to
			// processDatapoints.

			// Unfortunately this turns future setData calls into no-ops; they
			// call processDatapoints, the flag is true, and nothing happens.

			// To fix this we'll set the flag back to false here in draw, when
			// all series have been processed, so the next sequence of calls to
			// processDatapoints once again starts out with a slice-combine.
			// This is really a hack; in 0.9 we need to give plugins a proper
			// way to modify series before any processing begins.

			processed = false;

			// calculate maximum radius and center point

			maxRadius =  Math.min(canvasWidth, canvasHeight / options.series.pie.tilt) / 2;
			centerTop = canvasHeight / 2 + options.series.pie.offset.top;
			centerLeft = canvasWidth / 2;

			if (options.series.pie.offset.left == "auto") {
				if (options.legend.position.match("w")) {
					centerLeft += legendWidth / 2;
				} else {
					centerLeft -= legendWidth / 2;
				}
				if (centerLeft < maxRadius) {
					centerLeft = maxRadius;
				} else if (centerLeft > canvasWidth - maxRadius) {
					centerLeft = canvasWidth - maxRadius;
				}
			} else {
				centerLeft += options.series.pie.offset.left;
			}

			var slices = plot.getData(),
				attempts = 0;

			// Keep shrinking the pie's radius until drawPie returns true,
			// indicating that all the labels fit, or we try too many times.

			do {
				if (attempts > 0) {
					maxRadius *= REDRAW_SHRINK;
				}
				attempts += 1;
				clear();
				if (options.series.pie.tilt <= 0.8) {
					drawShadow();
				}
			} while (!drawPie() && attempts < REDRAW_ATTEMPTS)

			if (attempts >= REDRAW_ATTEMPTS) {
				clear();
				target.prepend("<div class='error'>Could not draw pie with labels contained inside canvas</div>");
			}

			if (plot.setSeries && plot.insertLegend) {
				plot.setSeries(slices);
				plot.insertLegend();
			}

			// we're actually done at this point, just defining internal functions at this point

			function clear() {
				ctx.clearRect(0, 0, canvasWidth, canvasHeight);
				target.children().filter(".pieLabel, .pieLabelBackground").remove();
			}

			function drawShadow() {

				var shadowLeft = options.series.pie.shadow.left;
				var shadowTop = options.series.pie.shadow.top;
				var edge = 10;
				var alpha = options.series.pie.shadow.alpha;
				var radius = options.series.pie.radius > 1 ? options.series.pie.radius : maxRadius * options.series.pie.radius;

				if (radius >= canvasWidth / 2 - shadowLeft || radius * options.series.pie.tilt >= canvasHeight / 2 - shadowTop || radius <= edge) {
					return;	// shadow would be outside canvas, so don't draw it
				}

				ctx.save();
				ctx.translate(shadowLeft,shadowTop);
				ctx.globalAlpha = alpha;
				ctx.fillStyle = "#000";

				// center and rotate to starting position

				ctx.translate(centerLeft,centerTop);
				ctx.scale(1, options.series.pie.tilt);

				//radius -= edge;

				for (var i = 1; i <= edge; i++) {
					ctx.beginPath();
					ctx.arc(0, 0, radius, 0, Math.PI * 2, false);
					ctx.fill();
					radius -= i;
				}

				ctx.restore();
			}

			function drawPie() {

				var startAngle = Math.PI * options.series.pie.startAngle;
				var radius = options.series.pie.radius > 1 ? options.series.pie.radius : maxRadius * options.series.pie.radius;

				// center and rotate to starting position

				ctx.save();
				ctx.translate(centerLeft,centerTop);
				ctx.scale(1, options.series.pie.tilt);
				//ctx.rotate(startAngle); // start at top; -- This doesn't work properly in Opera

				// draw slices

				ctx.save();
				var currentAngle = startAngle;
				for (var i = 0; i < slices.length; ++i) {
					slices[i].startAngle = currentAngle;
					drawSlice(slices[i].angle, slices[i].color, true);
				}
				ctx.restore();

				// draw slice outlines

				if (options.series.pie.stroke.width > 0) {
					ctx.save();
					ctx.lineWidth = options.series.pie.stroke.width;
					currentAngle = startAngle;
					for (var i = 0; i < slices.length; ++i) {
						drawSlice(slices[i].angle, options.series.pie.stroke.color, false);
					}
					ctx.restore();
				}

				// draw donut hole

				drawDonutHole(ctx);

				ctx.restore();

				// Draw the labels, returning true if they fit within the plot

				if (options.series.pie.label.show) {
					return drawLabels();
				} else return true;

				function drawSlice(angle, color, fill) {

					if (angle <= 0 || isNaN(angle)) {
						return;
					}

					if (fill) {
						ctx.fillStyle = color;
					} else {
						ctx.strokeStyle = color;
						ctx.lineJoin = "round";
					}

					ctx.beginPath();
					if (Math.abs(angle - Math.PI * 2) > 0.000000001) {
						ctx.moveTo(0, 0); // Center of the pie
					}

					//ctx.arc(0, 0, radius, 0, angle, false); // This doesn't work properly in Opera
					ctx.arc(0, 0, radius,currentAngle, currentAngle + angle / 2, false);
					ctx.arc(0, 0, radius,currentAngle + angle / 2, currentAngle + angle, false);
					ctx.closePath();
					//ctx.rotate(angle); // This doesn't work properly in Opera
					currentAngle += angle;

					if (fill) {
						ctx.fill();
					} else {
						ctx.stroke();
					}
				}

				function drawLabels() {

					var currentAngle = startAngle;
					var radius = options.series.pie.label.radius > 1 ? options.series.pie.label.radius : maxRadius * options.series.pie.label.radius;

					for (var i = 0; i < slices.length; ++i) {
						if (slices[i].percent >= options.series.pie.label.threshold * 100) {
							if (!drawLabel(slices[i], currentAngle, i)) {
								return false;
							}
						}
						currentAngle += slices[i].angle;
					}

					return true;

					function drawLabel(slice, startAngle, index) {

						if (slice.data[0][1] == 0) {
							return true;
						}

						// format label text

						var lf = options.legend.labelFormatter, text, plf = options.series.pie.label.formatter;

						if (lf) {
							text = lf(slice.label, slice);
						} else {
							text = slice.label;
						}

						if (plf) {
							text = plf(text, slice);
						}

						var halfAngle = ((startAngle + slice.angle) + startAngle) / 2;
						var x = centerLeft + Math.round(Math.cos(halfAngle) * radius);
						var y = centerTop + Math.round(Math.sin(halfAngle) * radius) * options.series.pie.tilt;

						var html = "<span class='pieLabel' id='pieLabel" + index + "' style='position:absolute;top:" + y + "px;left:" + x + "px;'>" + text + "</span>";
						target.append(html);

						var label = target.children("#pieLabel" + index);
						var labelTop = (y - label.height() / 2);
						var labelLeft = (x - label.width() / 2);

						label.css("top", labelTop);
						label.css("left", labelLeft);

						// check to make sure that the label is not outside the canvas

						if (0 - labelTop > 0 || 0 - labelLeft > 0 || canvasHeight - (labelTop + label.height()) < 0 || canvasWidth - (labelLeft + label.width()) < 0) {
							return false;
						}

						if (options.series.pie.label.background.opacity != 0) {

							// put in the transparent background separately to avoid blended labels and label boxes

							var c = options.series.pie.label.background.color;

							if (c == null) {
								c = slice.color;
							}

							var pos = "top:" + labelTop + "px;left:" + labelLeft + "px;";
							$("<div class='pieLabelBackground' style='position:absolute;width:" + label.width() + "px;height:" + label.height() + "px;" + pos + "background-color:" + c + ";'></div>")
								.css("opacity", options.series.pie.label.background.opacity)
								.insertBefore(label);
						}

						return true;
					} // end individual label function
				} // end drawLabels function
			} // end drawPie function
		} // end draw function

		// Placed here because it needs to be accessed from multiple locations

		function drawDonutHole(layer) {
			if (options.series.pie.innerRadius > 0) {

				// subtract the center

				layer.save();
				var innerRadius = options.series.pie.innerRadius > 1 ? options.series.pie.innerRadius : maxRadius * options.series.pie.innerRadius;
				layer.globalCompositeOperation = "destination-out"; // this does not work with excanvas, but it will fall back to using the stroke color
				layer.beginPath();
				layer.fillStyle = options.series.pie.stroke.color;
				layer.arc(0, 0, innerRadius, 0, Math.PI * 2, false);
				layer.fill();
				layer.closePath();
				layer.restore();

				// add inner stroke

				layer.save();
				layer.beginPath();
				layer.strokeStyle = options.series.pie.stroke.color;
				layer.arc(0, 0, innerRadius, 0, Math.PI * 2, false);
				layer.stroke();
				layer.closePath();
				layer.restore();

				// TODO: add extra shadow inside hole (with a mask) if the pie is tilted.
			}
		}

		//-- Additional Interactive related functions --

		function isPointInPoly(poly, pt) {
			for(var c = false, i = -1, l = poly.length, j = l - 1; ++i < l; j = i)
				((poly[i][1] <= pt[1] && pt[1] < poly[j][1]) || (poly[j][1] <= pt[1] && pt[1]< poly[i][1]))
				&& (pt[0] < (poly[j][0] - poly[i][0]) * (pt[1] - poly[i][1]) / (poly[j][1] - poly[i][1]) + poly[i][0])
				&& (c = !c);
			return c;
		}

		function findNearbySlice(mouseX, mouseY) {

			var slices = plot.getData(),
				options = plot.getOptions(),
				radius = options.series.pie.radius > 1 ? options.series.pie.radius : maxRadius * options.series.pie.radius,
				x, y;

			for (var i = 0; i < slices.length; ++i) {

				var s = slices[i];

				if (s.pie.show) {

					ctx.save();
					ctx.beginPath();
					ctx.moveTo(0, 0); // Center of the pie
					//ctx.scale(1, options.series.pie.tilt);	// this actually seems to break everything when here.
					ctx.arc(0, 0, radius, s.startAngle, s.startAngle + s.angle / 2, false);
					ctx.arc(0, 0, radius, s.startAngle + s.angle / 2, s.startAngle + s.angle, false);
					ctx.closePath();
					x = mouseX - centerLeft;
					y = mouseY - centerTop;

					if (ctx.isPointInPath) {
						if (ctx.isPointInPath(mouseX - centerLeft, mouseY - centerTop)) {
							ctx.restore();
							return {
								datapoint: [s.percent, s.data],
								dataIndex: 0,
								series: s,
								seriesIndex: i
							};
						}
					} else {

						// excanvas for IE doesn;t support isPointInPath, this is a workaround.

						var p1X = radius * Math.cos(s.startAngle),
							p1Y = radius * Math.sin(s.startAngle),
							p2X = radius * Math.cos(s.startAngle + s.angle / 4),
							p2Y = radius * Math.sin(s.startAngle + s.angle / 4),
							p3X = radius * Math.cos(s.startAngle + s.angle / 2),
							p3Y = radius * Math.sin(s.startAngle + s.angle / 2),
							p4X = radius * Math.cos(s.startAngle + s.angle / 1.5),
							p4Y = radius * Math.sin(s.startAngle + s.angle / 1.5),
							p5X = radius * Math.cos(s.startAngle + s.angle),
							p5Y = radius * Math.sin(s.startAngle + s.angle),
							arrPoly = [[0, 0], [p1X, p1Y], [p2X, p2Y], [p3X, p3Y], [p4X, p4Y], [p5X, p5Y]],
							arrPoint = [x, y];

						// TODO: perhaps do some mathmatical trickery here with the Y-coordinate to compensate for pie tilt?

						if (isPointInPoly(arrPoly, arrPoint)) {
							ctx.restore();
							return {
								datapoint: [s.percent, s.data],
								dataIndex: 0,
								series: s,
								seriesIndex: i
							};
						}
					}

					ctx.restore();
				}
			}

			return null;
		}

		function onMouseMove(e) {
			triggerClickHoverEvent("plothover", e);
		}

		function onClick(e) {
			triggerClickHoverEvent("plotclick", e);
		}

		// trigger click or hover event (they send the same parameters so we share their code)

		function triggerClickHoverEvent(eventname, e) {

			var offset = plot.offset();
			var canvasX = parseInt(e.pageX - offset.left);
			var canvasY =  parseInt(e.pageY - offset.top);
			var item = findNearbySlice(canvasX, canvasY);

			if (options.grid.autoHighlight) {

				// clear auto-highlights

				for (var i = 0; i < highlights.length; ++i) {
					var h = highlights[i];
					if (h.auto == eventname && !(item && h.series == item.series)) {
						unhighlight(h.series);
					}
				}
			}

			// highlight the slice

			if (item) {
				highlight(item.series, eventname);
			}

			// trigger any hover bind events

			var pos = { pageX: e.pageX, pageY: e.pageY };
			target.trigger(eventname, [pos, item]);
		}

		function highlight(s, auto) {
			//if (typeof s == "number") {
			//	s = series[s];
			//}

			var i = indexOfHighlight(s);

			if (i == -1) {
				highlights.push({ series: s, auto: auto });
				plot.triggerRedrawOverlay();
			} else if (!auto) {
				highlights[i].auto = false;
			}
		}

		function unhighlight(s) {
			if (s == null) {
				highlights = [];
				plot.triggerRedrawOverlay();
			}

			//if (typeof s == "number") {
			//	s = series[s];
			//}

			var i = indexOfHighlight(s);

			if (i != -1) {
				highlights.splice(i, 1);
				plot.triggerRedrawOverlay();
			}
		}

		function indexOfHighlight(s) {
			for (var i = 0; i < highlights.length; ++i) {
				var h = highlights[i];
				if (h.series == s)
					return i;
			}
			return -1;
		}

		function drawOverlay(plot, octx) {

			var options = plot.getOptions();

			var radius = options.series.pie.radius > 1 ? options.series.pie.radius : maxRadius * options.series.pie.radius;

			octx.save();
			octx.translate(centerLeft, centerTop);
			octx.scale(1, options.series.pie.tilt);

			for (var i = 0; i < highlights.length; ++i) {
				drawHighlight(highlights[i].series);
			}

			drawDonutHole(octx);

			octx.restore();

			function drawHighlight(series) {

				if (series.angle <= 0 || isNaN(series.angle)) {
					return;
				}

				//octx.fillStyle = parseColor(options.series.pie.highlight.color).scale(null, null, null, options.series.pie.highlight.opacity).toString();
				octx.fillStyle = "rgba(255, 255, 255, " + options.series.pie.highlight.opacity + ")"; // this is temporary until we have access to parseColor
				octx.beginPath();
				if (Math.abs(series.angle - Math.PI * 2) > 0.000000001) {
					octx.moveTo(0, 0); // Center of the pie
				}
				octx.arc(0, 0, radius, series.startAngle, series.startAngle + series.angle / 2, false);
				octx.arc(0, 0, radius, series.startAngle + series.angle / 2, series.startAngle + series.angle, false);
				octx.closePath();
				octx.fill();
			}
		}
	} // end init (plugin body)

	// define pie specific options and their default values

	var options = {
		series: {
			pie: {
				show: false,
				radius: "auto",	// actual radius of the visible pie (based on full calculated radius if <=1, or hard pixel value)
				innerRadius: 0, /* for donut */
				startAngle: 3/2,
				tilt: 1,
				shadow: {
					left: 5,	// shadow left offset
					top: 15,	// shadow top offset
					alpha: 0.02	// shadow alpha
				},
				offset: {
					top: 0,
					left: "auto"
				},
				stroke: {
					color: "#fff",
					width: 1
				},
				label: {
					show: "auto",
					formatter: function(label, slice) {
						return "<div style='font-size:x-small;text-align:center;padding:2px;color:" + slice.color + ";'>" + label + "<br/>" + Math.round(slice.percent) + "%</div>";
					},	// formatter function
					radius: 1,	// radius at which to place the labels (based on full calculated radius if <=1, or hard pixel value)
					background: {
						color: null,
						opacity: 0
					},
					threshold: 0	// percentage at which to hide the label (i.e. the slice is too narrow)
				},
				combine: {
					threshold: -1,	// percentage at which to combine little slices into one larger slice
					color: null,	// color to give the new slice (auto-generated if null)
					label: "Other"	// label to give the new slice
				},
				highlight: {
					//color: "#fff",		// will add this functionality once parseColor is available
					opacity: 0.5
				}
			}
		}
	};

	$.plot.plugins.push({
		init: init,
		options: options,
		name: "pie",
		version: "1.1"
	});

})(jQuery);

/* Flot plugin for automatically redrawing plots as the placeholder resizes.

Copyright (c) 2007-2014 IOLA and Ole Laursen.
Licensed under the MIT license.

It works by listening for changes on the placeholder div (through the jQuery
resize event plugin) - if the size changes, it will redraw the plot.

There are no options. If you need to disable the plugin for some plots, you
can just fix the size of their placeholders.

*/

/* Inline dependency:
 * jQuery resize event - v1.1 - 3/14/2010
 * http://benalman.com/projects/jquery-resize-plugin/
 *
 * Copyright (c) 2010 "Cowboy" Ben Alman
 * Dual licensed under the MIT and GPL licenses.
 * http://benalman.com/about/license/
 */
(function($,e,t){"$:nomunge";var i=[],n=$.resize=$.extend($.resize,{}),a,r=false,s="setTimeout",u="resize",m=u+"-special-event",o="pendingDelay",l="activeDelay",f="throttleWindow";n[o]=200;n[l]=20;n[f]=true;$.event.special[u]={setup:function(){if(!n[f]&&this[s]){return false}var e=$(this);i.push(this);e.data(m,{w:e.width(),h:e.height()});if(i.length===1){a=t;h()}},teardown:function(){if(!n[f]&&this[s]){return false}var e=$(this);for(var t=i.length-1;t>=0;t--){if(i[t]==this){i.splice(t,1);break}}e.removeData(m);if(!i.length){if(r){cancelAnimationFrame(a)}else{clearTimeout(a)}a=null}},add:function(e){if(!n[f]&&this[s]){return false}var i;function a(e,n,a){var r=$(this),s=r.data(m)||{};s.w=n!==t?n:r.width();s.h=a!==t?a:r.height();i.apply(this,arguments)}if($.isFunction(e)){i=e;return a}else{i=e.handler;e.handler=a}}};function h(t){if(r===true){r=t||1}for(var s=i.length-1;s>=0;s--){var l=$(i[s]);if(l[0]==e||l.is(":visible")){var f=l.width(),c=l.height(),d=l.data(m);if(d&&(f!==d.w||c!==d.h)){l.trigger(u,[d.w=f,d.h=c]);r=t||true}}else{d=l.data(m);d.w=0;d.h=0}}if(a!==null){if(r&&(t==null||t-r<1e3)){a=e.requestAnimationFrame(h)}else{a=setTimeout(h,n[o]);r=false}}}if(!e.requestAnimationFrame){e.requestAnimationFrame=function(){return e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(t,i){return e.setTimeout(function(){t((new Date).getTime())},n[l])}}()}if(!e.cancelAnimationFrame){e.cancelAnimationFrame=function(){return e.webkitCancelRequestAnimationFrame||e.mozCancelRequestAnimationFrame||e.oCancelRequestAnimationFrame||e.msCancelRequestAnimationFrame||clearTimeout}()}})(jQuery,this);

(function ($) {
    var options = { }; // no options

    function init(plot) {
        function onResize() {
            var placeholder = plot.getPlaceholder();

            // somebody might have hidden us and we can't plot
            // when we don't have the dimensions
            if (placeholder.width() == 0 || placeholder.height() == 0)
                return;

            plot.resize();
            plot.setupGrid();
            plot.draw();
        }
        
        function bindEvents(plot, eventHolder) {
            plot.getPlaceholder().resize(onResize);
        }

        function shutdown(plot, eventHolder) {
            plot.getPlaceholder().unbind("resize", onResize);
        }
        
        plot.hooks.bindEvents.push(bindEvents);
        plot.hooks.shutdown.push(shutdown);
    }
    
    $.plot.plugins.push({
        init: init,
        options: options,
        name: 'resize',
        version: '1.0'
    });
})(jQuery);

/* Flot plugin for selecting regions of a plot.

Copyright (c) 2007-2014 IOLA and Ole Laursen.
Licensed under the MIT license.

The plugin supports these options:

selection: {
	mode: null or "x" or "y" or "xy",
	color: color,
	shape: "round" or "miter" or "bevel",
	minSize: number of pixels
}

Selection support is enabled by setting the mode to one of "x", "y" or "xy".
In "x" mode, the user will only be able to specify the x range, similarly for
"y" mode. For "xy", the selection becomes a rectangle where both ranges can be
specified. "color" is color of the selection (if you need to change the color
later on, you can get to it with plot.getOptions().selection.color). "shape"
is the shape of the corners of the selection.

"minSize" is the minimum size a selection can be in pixels. This value can
be customized to determine the smallest size a selection can be and still
have the selection rectangle be displayed. When customizing this value, the
fact that it refers to pixels, not axis units must be taken into account.
Thus, for example, if there is a bar graph in time mode with BarWidth set to 1
minute, setting "minSize" to 1 will not make the minimum selection size 1
minute, but rather 1 pixel. Note also that setting "minSize" to 0 will prevent
"plotunselected" events from being fired when the user clicks the mouse without
dragging.

When selection support is enabled, a "plotselected" event will be emitted on
the DOM element you passed into the plot function. The event handler gets a
parameter with the ranges selected on the axes, like this:

	placeholder.bind( "plotselected", function( event, ranges ) {
		alert("You selected " + ranges.xaxis.from + " to " + ranges.xaxis.to)
		// similar for yaxis - with multiple axes, the extra ones are in
		// x2axis, x3axis, ...
	});

The "plotselected" event is only fired when the user has finished making the
selection. A "plotselecting" event is fired during the process with the same
parameters as the "plotselected" event, in case you want to know what's
happening while it's happening,

A "plotunselected" event with no arguments is emitted when the user clicks the
mouse to remove the selection. As stated above, setting "minSize" to 0 will
destroy this behavior.

The plugin allso adds the following methods to the plot object:

- setSelection( ranges, preventEvent )

  Set the selection rectangle. The passed in ranges is on the same form as
  returned in the "plotselected" event. If the selection mode is "x", you
  should put in either an xaxis range, if the mode is "y" you need to put in
  an yaxis range and both xaxis and yaxis if the selection mode is "xy", like
  this:

	setSelection({ xaxis: { from: 0, to: 10 }, yaxis: { from: 40, to: 60 } });

  setSelection will trigger the "plotselected" event when called. If you don't
  want that to happen, e.g. if you're inside a "plotselected" handler, pass
  true as the second parameter. If you are using multiple axes, you can
  specify the ranges on any of those, e.g. as x2axis/x3axis/... instead of
  xaxis, the plugin picks the first one it sees.

- clearSelection( preventEvent )

  Clear the selection rectangle. Pass in true to avoid getting a
  "plotunselected" event.

- getSelection()

  Returns the current selection in the same format as the "plotselected"
  event. If there's currently no selection, the function returns null.

*/

(function ($) {
    function init(plot) {
        var selection = {
                first: { x: -1, y: -1}, second: { x: -1, y: -1},
                show: false,
                active: false
            };

        // FIXME: The drag handling implemented here should be
        // abstracted out, there's some similar code from a library in
        // the navigation plugin, this should be massaged a bit to fit
        // the Flot cases here better and reused. Doing this would
        // make this plugin much slimmer.
        var savedhandlers = {};

        var mouseUpHandler = null;
        
        function onMouseMove(e) {
            if (selection.active) {
                updateSelection(e);
                
                plot.getPlaceholder().trigger("plotselecting", [ getSelection() ]);
            }
        }

        function onMouseDown(e) {
            if (e.which != 1)  // only accept left-click
                return;
            
            // cancel out any text selections
            document.body.focus();

            // prevent text selection and drag in old-school browsers
            if (document.onselectstart !== undefined && savedhandlers.onselectstart == null) {
                savedhandlers.onselectstart = document.onselectstart;
                document.onselectstart = function () { return false; };
            }
            if (document.ondrag !== undefined && savedhandlers.ondrag == null) {
                savedhandlers.ondrag = document.ondrag;
                document.ondrag = function () { return false; };
            }

            setSelectionPos(selection.first, e);

            selection.active = true;

            // this is a bit silly, but we have to use a closure to be
            // able to whack the same handler again
            mouseUpHandler = function (e) { onMouseUp(e); };
            
            $(document).one("mouseup", mouseUpHandler);
        }

        function onMouseUp(e) {
            mouseUpHandler = null;
            
            // revert drag stuff for old-school browsers
            if (document.onselectstart !== undefined)
                document.onselectstart = savedhandlers.onselectstart;
            if (document.ondrag !== undefined)
                document.ondrag = savedhandlers.ondrag;

            // no more dragging
            selection.active = false;
            updateSelection(e);

            if (selectionIsSane())
                triggerSelectedEvent();
            else {
                // this counts as a clear
                plot.getPlaceholder().trigger("plotunselected", [ ]);
                plot.getPlaceholder().trigger("plotselecting", [ null ]);
            }

            return false;
        }

        function getSelection() {
            if (!selectionIsSane())
                return null;
            
            if (!selection.show) return null;

            var r = {}, c1 = selection.first, c2 = selection.second;
            $.each(plot.getAxes(), function (name, axis) {
                if (axis.used) {
                    var p1 = axis.c2p(c1[axis.direction]), p2 = axis.c2p(c2[axis.direction]); 
                    r[name] = { from: Math.min(p1, p2), to: Math.max(p1, p2) };
                }
            });
            return r;
        }

        function triggerSelectedEvent() {
            var r = getSelection();

            plot.getPlaceholder().trigger("plotselected", [ r ]);

            // backwards-compat stuff, to be removed in future
            if (r.xaxis && r.yaxis)
                plot.getPlaceholder().trigger("selected", [ { x1: r.xaxis.from, y1: r.yaxis.from, x2: r.xaxis.to, y2: r.yaxis.to } ]);
        }

        function clamp(min, value, max) {
            return value < min ? min: (value > max ? max: value);
        }

        function setSelectionPos(pos, e) {
            var o = plot.getOptions();
            var offset = plot.getPlaceholder().offset();
            var plotOffset = plot.getPlotOffset();
            pos.x = clamp(0, e.pageX - offset.left - plotOffset.left, plot.width());
            pos.y = clamp(0, e.pageY - offset.top - plotOffset.top, plot.height());

            if (o.selection.mode == "y")
                pos.x = pos == selection.first ? 0 : plot.width();

            if (o.selection.mode == "x")
                pos.y = pos == selection.first ? 0 : plot.height();
        }

        function updateSelection(pos) {
            if (pos.pageX == null)
                return;

            setSelectionPos(selection.second, pos);
            if (selectionIsSane()) {
                selection.show = true;
                plot.triggerRedrawOverlay();
            }
            else
                clearSelection(true);
        }

        function clearSelection(preventEvent) {
            if (selection.show) {
                selection.show = false;
                plot.triggerRedrawOverlay();
                if (!preventEvent)
                    plot.getPlaceholder().trigger("plotunselected", [ ]);
            }
        }

        // function taken from markings support in Flot
        function extractRange(ranges, coord) {
            var axis, from, to, key, axes = plot.getAxes();

            for (var k in axes) {
                axis = axes[k];
                if (axis.direction == coord) {
                    key = coord + axis.n + "axis";
                    if (!ranges[key] && axis.n == 1)
                        key = coord + "axis"; // support x1axis as xaxis
                    if (ranges[key]) {
                        from = ranges[key].from;
                        to = ranges[key].to;
                        break;
                    }
                }
            }

            // backwards-compat stuff - to be removed in future
            if (!ranges[key]) {
                axis = coord == "x" ? plot.getXAxes()[0] : plot.getYAxes()[0];
                from = ranges[coord + "1"];
                to = ranges[coord + "2"];
            }

            // auto-reverse as an added bonus
            if (from != null && to != null && from > to) {
                var tmp = from;
                from = to;
                to = tmp;
            }
            
            return { from: from, to: to, axis: axis };
        }
        
        function setSelection(ranges, preventEvent) {
            var axis, range, o = plot.getOptions();

            if (o.selection.mode == "y") {
                selection.first.x = 0;
                selection.second.x = plot.width();
            }
            else {
                range = extractRange(ranges, "x");

                selection.first.x = range.axis.p2c(range.from);
                selection.second.x = range.axis.p2c(range.to);
            }

            if (o.selection.mode == "x") {
                selection.first.y = 0;
                selection.second.y = plot.height();
            }
            else {
                range = extractRange(ranges, "y");

                selection.first.y = range.axis.p2c(range.from);
                selection.second.y = range.axis.p2c(range.to);
            }

            selection.show = true;
            plot.triggerRedrawOverlay();
            if (!preventEvent && selectionIsSane())
                triggerSelectedEvent();
        }

        function selectionIsSane() {
            var minSize = plot.getOptions().selection.minSize;
            return Math.abs(selection.second.x - selection.first.x) >= minSize &&
                Math.abs(selection.second.y - selection.first.y) >= minSize;
        }

        plot.clearSelection = clearSelection;
        plot.setSelection = setSelection;
        plot.getSelection = getSelection;

        plot.hooks.bindEvents.push(function(plot, eventHolder) {
            var o = plot.getOptions();
            if (o.selection.mode != null) {
                eventHolder.mousemove(onMouseMove);
                eventHolder.mousedown(onMouseDown);
            }
        });


        plot.hooks.drawOverlay.push(function (plot, ctx) {
            // draw selection
            if (selection.show && selectionIsSane()) {
                var plotOffset = plot.getPlotOffset();
                var o = plot.getOptions();

                ctx.save();
                ctx.translate(plotOffset.left, plotOffset.top);

                var c = $.color.parse(o.selection.color);

                ctx.strokeStyle = c.scale('a', 0.8).toString();
                ctx.lineWidth = 1;
                ctx.lineJoin = o.selection.shape;
                ctx.fillStyle = c.scale('a', 0.4).toString();

                var x = Math.min(selection.first.x, selection.second.x) + 0.5,
                    y = Math.min(selection.first.y, selection.second.y) + 0.5,
                    w = Math.abs(selection.second.x - selection.first.x) - 1,
                    h = Math.abs(selection.second.y - selection.first.y) - 1;

                ctx.fillRect(x, y, w, h);
                ctx.strokeRect(x, y, w, h);

                ctx.restore();
            }
        });
        
        plot.hooks.shutdown.push(function (plot, eventHolder) {
            eventHolder.unbind("mousemove", onMouseMove);
            eventHolder.unbind("mousedown", onMouseDown);
            
            if (mouseUpHandler)
                $(document).unbind("mouseup", mouseUpHandler);
        });

    }

    $.plot.plugins.push({
        init: init,
        options: {
            selection: {
                mode: null, // one of null, "x", "y" or "xy"
                color: "#e8cfac",
                shape: "round", // one of "round", "miter", or "bevel"
                minSize: 5 // minimum number of pixels
            }
        },
        name: 'selection',
        version: '1.1'
    });
})(jQuery);

/* Flot plugin for stacking data sets rather than overlyaing them.

Copyright (c) 2007-2014 IOLA and Ole Laursen.
Licensed under the MIT license.

The plugin assumes the data is sorted on x (or y if stacking horizontally).
For line charts, it is assumed that if a line has an undefined gap (from a
null point), then the line above it should have the same gap - insert zeros
instead of "null" if you want another behaviour. This also holds for the start
and end of the chart. Note that stacking a mix of positive and negative values
in most instances doesn't make sense (so it looks weird).

Two or more series are stacked when their "stack" attribute is set to the same
key (which can be any number or string or just "true"). To specify the default
stack, you can set the stack option like this:

	series: {
		stack: null/false, true, or a key (number/string)
	}

You can also specify it for a single series, like this:

	$.plot( $("#placeholder"), [{
		data: [ ... ],
		stack: true
	}])

The stacking order is determined by the order of the data series in the array
(later series end up on top of the previous).

Internally, the plugin modifies the datapoints in each series, adding an
offset to the y value. For line series, extra data points are inserted through
interpolation. If there's a second y value, it's also adjusted (e.g for bar
charts or filled areas).

*/

(function ($) {
    var options = {
        series: { stack: null } // or number/string
    };
    
    function init(plot) {
        function findMatchingSeries(s, allseries) {
            var res = null;
            for (var i = 0; i < allseries.length; ++i) {
                if (s == allseries[i])
                    break;
                
                if (allseries[i].stack == s.stack)
                    res = allseries[i];
            }
            
            return res;
        }
        
        function stackData(plot, s, datapoints) {
            if (s.stack == null || s.stack === false)
                return;

            var other = findMatchingSeries(s, plot.getData());
            if (!other)
                return;

            var ps = datapoints.pointsize,
                points = datapoints.points,
                otherps = other.datapoints.pointsize,
                otherpoints = other.datapoints.points,
                newpoints = [],
                px, py, intery, qx, qy, bottom,
                withlines = s.lines.show,
                horizontal = s.bars.horizontal,
                withbottom = ps > 2 && (horizontal ? datapoints.format[2].x : datapoints.format[2].y),
                withsteps = withlines && s.lines.steps,
                fromgap = true,
                keyOffset = horizontal ? 1 : 0,
                accumulateOffset = horizontal ? 0 : 1,
                i = 0, j = 0, l, m;

            while (true) {
                if (i >= points.length)
                    break;

                l = newpoints.length;

                if (points[i] == null) {
                    // copy gaps
                    for (m = 0; m < ps; ++m)
                        newpoints.push(points[i + m]);
                    i += ps;
                }
                else if (j >= otherpoints.length) {
                    // for lines, we can't use the rest of the points
                    if (!withlines) {
                        for (m = 0; m < ps; ++m)
                            newpoints.push(points[i + m]);
                    }
                    i += ps;
                }
                else if (otherpoints[j] == null) {
                    // oops, got a gap
                    for (m = 0; m < ps; ++m)
                        newpoints.push(null);
                    fromgap = true;
                    j += otherps;
                }
                else {
                    // cases where we actually got two points
                    px = points[i + keyOffset];
                    py = points[i + accumulateOffset];
                    qx = otherpoints[j + keyOffset];
                    qy = otherpoints[j + accumulateOffset];
                    bottom = 0;

                    if (px == qx) {
                        for (m = 0; m < ps; ++m)
                            newpoints.push(points[i + m]);

                        newpoints[l + accumulateOffset] += qy;
                        bottom = qy;
                        
                        i += ps;
                        j += otherps;
                    }
                    else if (px > qx) {
                        // we got past point below, might need to
                        // insert interpolated extra point
                        if (withlines && i > 0 && points[i - ps] != null) {
                            intery = py + (points[i - ps + accumulateOffset] - py) * (qx - px) / (points[i - ps + keyOffset] - px);
                            newpoints.push(qx);
                            newpoints.push(intery + qy);
                            for (m = 2; m < ps; ++m)
                                newpoints.push(points[i + m]);
                            bottom = qy; 
                        }

                        j += otherps;
                    }
                    else { // px < qx
                        if (fromgap && withlines) {
                            // if we come from a gap, we just skip this point
                            i += ps;
                            continue;
                        }
                            
                        for (m = 0; m < ps; ++m)
                            newpoints.push(points[i + m]);
                        
                        // we might be able to interpolate a point below,
                        // this can give us a better y
                        if (withlines && j > 0 && otherpoints[j - otherps] != null)
                            bottom = qy + (otherpoints[j - otherps + accumulateOffset] - qy) * (px - qx) / (otherpoints[j - otherps + keyOffset] - qx);

                        newpoints[l + accumulateOffset] += bottom;
                        
                        i += ps;
                    }

                    fromgap = false;
                    
                    if (l != newpoints.length && withbottom)
                        newpoints[l + 2] += bottom;
                }

                // maintain the line steps invariant
                if (withsteps && l != newpoints.length && l > 0
                    && newpoints[l] != null
                    && newpoints[l] != newpoints[l - ps]
                    && newpoints[l + 1] != newpoints[l - ps + 1]) {
                    for (m = 0; m < ps; ++m)
                        newpoints[l + ps + m] = newpoints[l + m];
                    newpoints[l + 1] = newpoints[l - ps + 1];
                }
            }

            datapoints.points = newpoints;
        }
        
        plot.hooks.processDatapoints.push(stackData);
    }
    
    $.plot.plugins.push({
        init: init,
        options: options,
        name: 'stack',
        version: '1.2'
    });
})(jQuery);

/**
 * Flot plugin that provides spline interpolation for line graphs
 * author: Alex Bardas < alex.bardas@gmail.com >
 * modified by: Avi Kohn https://github.com/AMKohn
 * based on the spline interpolation described at:
 *     http://scaledinnovation.com/analytics/splines/aboutSplines.html
 *
 * Example usage: (add in plot options series object)
 *    for linespline:
 *      series: {
 *        ...
 *        lines: {
 *          show: false
 *        },
 *        splines: {
 *          show: true,
 *          tension: x, (float between 0 and 1, defaults to 0.5),
 *          lineWidth: y (number, defaults to 2),
 *          fill: z (float between 0 .. 1 or false, as in flot documentation)
 *        },
 *        ...
 *      }
 *    areaspline:
 *      series: {
 *        ...
 *        lines: {
 *          show: true,
 *          lineWidth: 0, (line drawing will not execute)
 *          fill: x, (float between 0 .. 1, as in flot documentation)
 *          ...
 *        },
 *        splines: {
 *          show: true,
 *          tension: 0.5 (float between 0 and 1)
 *        },
 *        ...
 *      }
 *
 */

(function($) {
  'use strict'

  /**
   * @param {Number} x0, y0, x1, y1: coordinates of the end (knot) points of the segment
   * @param {Number} x2, y2: the next knot (not connected, but needed to calculate p2)
   * @param {Number} tension: control how far the control points spread
   * @return {Array}: p1 -> control point, from x1 back toward x0
   *          p2 -> the next control point, returned to become the next segment's p1
   *
   * @api private
   */
  function getControlPoints(x0, y0, x1, y1, x2, y2, tension) {

    var pow = Math.pow,
      sqrt = Math.sqrt,
      d01, d12, fa, fb, p1x, p1y, p2x, p2y;

    //  Scaling factors: distances from this knot to the previous and following knots.
    d01 = sqrt(pow(x1 - x0, 2) + pow(y1 - y0, 2));
    d12 = sqrt(pow(x2 - x1, 2) + pow(y2 - y1, 2));

    fa = tension * d01 / (d01 + d12);
    fb = tension - fa;

    p1x = x1 + fa * (x0 - x2);
    p1y = y1 + fa * (y0 - y2);

    p2x = x1 - fb * (x0 - x2);
    p2y = y1 - fb * (y0 - y2);

    return [p1x, p1y, p2x, p2y];
  }

  var line = [];

  function drawLine(points, ctx, height, fill, seriesColor) {
    var c = $.color.parse(seriesColor);

    c.a = typeof fill == "number" ? fill : .3;
    c.normalize();
    c = c.toString();

    ctx.beginPath();
    ctx.moveTo(points[0][0], points[0][1]);

    var plength = points.length;

    for (var i = 0; i < plength; i++) {
      ctx[points[i][3]].apply(ctx, points[i][2]);
    }

    ctx.stroke();

    ctx.lineWidth = 0;
    ctx.lineTo(points[plength - 1][0], height);
    ctx.lineTo(points[0][0], height);

    ctx.closePath();
    
    if (fill !== false) {
      ctx.fillStyle = c;
      ctx.fill();
    }
  }

  /**
   * @param {Object} ctx: canvas context
   * @param {String} type: accepted strings: 'bezier' or 'quadratic' (defaults to quadratic)
   * @param {Array} points: 2 points for which to draw the interpolation
   * @param {Array} cpoints: control points for those segment points
   *
   * @api private
   */
  function queue(ctx, type, points, cpoints) {
    if (type === void 0 || (type !== 'bezier' && type !== 'quadratic')) {
      type = 'quadratic';
    }
    type = type + 'CurveTo';

    if (line.length == 0) line.push([points[0], points[1], cpoints.concat(points.slice(2)), type]);
    else if (type == "quadraticCurveTo" && points.length == 2) {
      cpoints = cpoints.slice(0, 2).concat(points);

      line.push([points[0], points[1], cpoints, type]);
    }
    else line.push([points[2], points[3], cpoints.concat(points.slice(2)), type]);
  }

  /**
   * @param {Object} plot
   * @param {Object} ctx: canvas context
   * @param {Object} series
   *
   * @api private
   */

  function drawSpline(plot, ctx, series) {
    // Not interested if spline is not requested
    if (series.splines.show !== true) {
      return;
    }

    var cp = [],
      // array of control points
      tension = series.splines.tension || 0.5,
      idx, x, y, points = series.datapoints.points,
      ps = series.datapoints.pointsize,
      plotOffset = plot.getPlotOffset(),
      len = points.length,
      pts = [];

    line = [];

    // Cannot display a linespline/areaspline if there are less than 3 points
    if (len / ps < 4) {
      $.extend(series.lines, series.splines);
      return;
    }

    for (idx = 0; idx < len; idx += ps) {
      x = points[idx];
      y = points[idx + 1];
      if (x == null || x < series.xaxis.min || x > series.xaxis.max || y < series.yaxis.min || y > series.yaxis.max) {
        continue;
      }

      pts.push(series.xaxis.p2c(x) + plotOffset.left, series.yaxis.p2c(y) + plotOffset.top);
    }

    len = pts.length;

    // Draw an open curve, not connected at the ends
    for (idx = 0; idx < len - 2; idx += 2) {
      cp = cp.concat(getControlPoints.apply(this, pts.slice(idx, idx + 6).concat([tension])));
    }

    ctx.save();
    ctx.strokeStyle = series.color;
    ctx.lineWidth = series.splines.lineWidth;

    queue(ctx, 'quadratic', pts.slice(0, 4), cp.slice(0, 2));

    for (idx = 2; idx < len - 3; idx += 2) {
      queue(ctx, 'bezier', pts.slice(idx, idx + 4), cp.slice(2 * idx - 2, 2 * idx + 2));
    }

    queue(ctx, 'quadratic', pts.slice(len - 2, len), [cp[2 * len - 10], cp[2 * len - 9], pts[len - 4], pts[len - 3]]);

    drawLine(line, ctx, plot.height() + 10, series.splines.fill, series.color);

    ctx.restore();
  }

  $.plot.plugins.push({
    init: function(plot) {
      plot.hooks.drawSeries.push(drawSpline);
    },
    options: {
      series: {
        splines: {
          show: false,
          lineWidth: 2,
          tension: 0.5,
          fill: false
        }
      }
    },
    name: 'spline',
    version: '0.8.2'
  });
})(jQuery);

/* Flot plugin that adds some extra symbols for plotting points.

Copyright (c) 2007-2014 IOLA and Ole Laursen.
Licensed under the MIT license.

The symbols are accessed as strings through the standard symbol options:

	series: {
		points: {
			symbol: "square" // or "diamond", "triangle", "cross"
		}
	}

*/

(function ($) {
    function processRawData(plot, series, datapoints) {
        // we normalize the area of each symbol so it is approximately the
        // same as a circle of the given radius

        var handlers = {
            square: function (ctx, x, y, radius, shadow) {
                // pi * r^2 = (2s)^2  =>  s = r * sqrt(pi)/2
                var size = radius * Math.sqrt(Math.PI) / 2;
                ctx.rect(x - size, y - size, size + size, size + size);
            },
            diamond: function (ctx, x, y, radius, shadow) {
                // pi * r^2 = 2s^2  =>  s = r * sqrt(pi/2)
                var size = radius * Math.sqrt(Math.PI / 2);
                ctx.moveTo(x - size, y);
                ctx.lineTo(x, y - size);
                ctx.lineTo(x + size, y);
                ctx.lineTo(x, y + size);
                ctx.lineTo(x - size, y);
            },
            triangle: function (ctx, x, y, radius, shadow) {
                // pi * r^2 = 1/2 * s^2 * sin (pi / 3)  =>  s = r * sqrt(2 * pi / sin(pi / 3))
                var size = radius * Math.sqrt(2 * Math.PI / Math.sin(Math.PI / 3));
                var height = size * Math.sin(Math.PI / 3);
                ctx.moveTo(x - size/2, y + height/2);
                ctx.lineTo(x + size/2, y + height/2);
                if (!shadow) {
                    ctx.lineTo(x, y - height/2);
                    ctx.lineTo(x - size/2, y + height/2);
                }
            },
            cross: function (ctx, x, y, radius, shadow) {
                // pi * r^2 = (2s)^2  =>  s = r * sqrt(pi)/2
                var size = radius * Math.sqrt(Math.PI) / 2;
                ctx.moveTo(x - size, y - size);
                ctx.lineTo(x + size, y + size);
                ctx.moveTo(x - size, y + size);
                ctx.lineTo(x + size, y - size);
            }
        };

        var s = series.points.symbol;
        if (handlers[s])
            series.points.symbol = handlers[s];
    }
    
    function init(plot) {
        plot.hooks.processDatapoints.push(processRawData);
    }
    
    $.plot.plugins.push({
        init: init,
        name: 'symbols',
        version: '1.0'
    });
})(jQuery);

/* Flot plugin for thresholding data.

Copyright (c) 2007-2014 IOLA and Ole Laursen.
Licensed under the MIT license.

The plugin supports these options:

	series: {
		threshold: {
			below: number
			color: colorspec
		}
	}

It can also be applied to a single series, like this:

	$.plot( $("#placeholder"), [{
		data: [ ... ],
		threshold: { ... }
	}])

An array can be passed for multiple thresholding, like this:

	threshold: [{
		below: number1
		color: color1
	},{
		below: number2
		color: color2
	}]

These multiple threshold objects can be passed in any order since they are
sorted by the processing function.

The data points below "below" are drawn with the specified color. This makes
it easy to mark points below 0, e.g. for budget data.

Internally, the plugin works by splitting the data into two series, above and
below the threshold. The extra series below the threshold will have its label
cleared and the special "originSeries" attribute set to the original series.
You may need to check for this in hover events.

*/

(function ($) {
    var options = {
        series: { threshold: null } // or { below: number, color: color spec}
    };
    
    function init(plot) {
        function thresholdData(plot, s, datapoints, below, color) {
            var ps = datapoints.pointsize, i, x, y, p, prevp,
                thresholded = $.extend({}, s); // note: shallow copy

            thresholded.datapoints = { points: [], pointsize: ps, format: datapoints.format };
            thresholded.label = null;
            thresholded.color = color;
            thresholded.threshold = null;
            thresholded.originSeries = s;
            thresholded.data = [];
 
            var origpoints = datapoints.points,
                addCrossingPoints = s.lines.show;

            var threspoints = [];
            var newpoints = [];
            var m;

            for (i = 0; i < origpoints.length; i += ps) {
                x = origpoints[i];
                y = origpoints[i + 1];

                prevp = p;
                if (y < below)
                    p = threspoints;
                else
                    p = newpoints;

                if (addCrossingPoints && prevp != p && x != null
                    && i > 0 && origpoints[i - ps] != null) {
                    var interx = x + (below - y) * (x - origpoints[i - ps]) / (y - origpoints[i - ps + 1]);
                    prevp.push(interx);
                    prevp.push(below);
                    for (m = 2; m < ps; ++m)
                        prevp.push(origpoints[i + m]);
                    
                    p.push(null); // start new segment
                    p.push(null);
                    for (m = 2; m < ps; ++m)
                        p.push(origpoints[i + m]);
                    p.push(interx);
                    p.push(below);
                    for (m = 2; m < ps; ++m)
                        p.push(origpoints[i + m]);
                }

                p.push(x);
                p.push(y);
                for (m = 2; m < ps; ++m)
                    p.push(origpoints[i + m]);
            }

            datapoints.points = newpoints;
            thresholded.datapoints.points = threspoints;
            
            if (thresholded.datapoints.points.length > 0) {
                var origIndex = $.inArray(s, plot.getData());
                // Insert newly-generated series right after original one (to prevent it from becoming top-most)
                plot.getData().splice(origIndex + 1, 0, thresholded);
            }
                
            // FIXME: there are probably some edge cases left in bars
        }
        
        function processThresholds(plot, s, datapoints) {
            if (!s.threshold)
                return;
            
            if (s.threshold instanceof Array) {
                s.threshold.sort(function(a, b) {
                    return a.below - b.below;
                });
                
                $(s.threshold).each(function(i, th) {
                    thresholdData(plot, s, datapoints, th.below, th.color);
                });
            }
            else {
                thresholdData(plot, s, datapoints, s.threshold.below, s.threshold.color);
            }
        }
        
        plot.hooks.processDatapoints.push(processThresholds);
    }
    
    $.plot.plugins.push({
        init: init,
        options: options,
        name: 'threshold',
        version: '1.2'
    });
})(jQuery);

/*
 * jquery.flot.tooltip
 * 
 * description: easy-to-use tooltips for Flot charts
 * version: 0.9.0
 * authors: Krzysztof Urbas @krzysu [myviews.pl],Evan Steinkerchner @Roundaround
 * website: https://github.com/krzysu/flot.tooltip
 * 
 * build on 2016-07-26
 * released under MIT License, 2012
*/ 
(function ($) {
    // plugin options, default values
    var defaultOptions = {
        tooltip: {
            show: false,
            cssClass: "flotTip",
            content: "%s | X: %x | Y: %y",
            // allowed templates are:
            // %s -> series label,
            // %c -> series color,
            // %lx -> x axis label (requires flot-axislabels plugin https://github.com/markrcote/flot-axislabels),
            // %ly -> y axis label (requires flot-axislabels plugin https://github.com/markrcote/flot-axislabels),
            // %x -> X value,
            // %y -> Y value,
            // %x.2 -> precision of X value,
            // %p -> percent
            // %n -> value (not percent) of pie chart
            xDateFormat: null,
            yDateFormat: null,
            monthNames: null,
            dayNames: null,
            shifts: {
                x: 10,
                y: 20
            },
            defaultTheme: true,
            snap: true,
            lines: false,
            clickTips: false,

            // callbacks
            onHover: function (flotItem, $tooltipEl) {},

            $compat: false
        }
    };

    // dummy default options object for legacy code (<0.8.5) - is deleted later
    defaultOptions.tooltipOpts = defaultOptions.tooltip;

    // object
    var FlotTooltip = function (plot) {
        // variables
        this.tipPosition = {x: 0, y: 0};

        this.init(plot);
    };

    // main plugin function
    FlotTooltip.prototype.init = function (plot) {
        var that = this;

        // detect other flot plugins
        var plotPluginsLength = $.plot.plugins.length;
        this.plotPlugins = [];

        if (plotPluginsLength) {
            for (var p = 0; p < plotPluginsLength; p++) {
                this.plotPlugins.push($.plot.plugins[p].name);
            }
        }

        plot.hooks.bindEvents.push(function (plot, eventHolder) {

            // get plot options
            that.plotOptions = plot.getOptions();

            // for legacy (<0.8.5) implementations
            if (typeof(that.plotOptions.tooltip) === 'boolean') {
                that.plotOptions.tooltipOpts.show = that.plotOptions.tooltip;
                that.plotOptions.tooltip = that.plotOptions.tooltipOpts;
                delete that.plotOptions.tooltipOpts;
            }

            // if not enabled return
            if (that.plotOptions.tooltip.show === false || typeof that.plotOptions.tooltip.show === 'undefined') return;

            // shortcut to access tooltip options
            that.tooltipOptions = that.plotOptions.tooltip;

            if (that.tooltipOptions.$compat) {
                that.wfunc = 'width';
                that.hfunc = 'height';
            } else {
                that.wfunc = 'innerWidth';
                that.hfunc = 'innerHeight';
            }

            // create tooltip DOM element
            var $tip = that.getDomElement();

            // bind event
            $( plot.getPlaceholder() ).bind("plothover", plothover);
            if (that.tooltipOptions.clickTips) {
                $( plot.getPlaceholder() ).bind("plotclick", plotclick);
            }
            that.clickmode = false;

            $(eventHolder).bind('mousemove', mouseMove);
        });

        plot.hooks.shutdown.push(function (plot, eventHolder){
            $(plot.getPlaceholder()).unbind("plothover", plothover);
            $(plot.getPlaceholder()).unbind("plotclick", plotclick);
            plot.removeTooltip();
            $(eventHolder).unbind("mousemove", mouseMove);
        });

        function mouseMove(e){
            var pos = {};
            pos.x = e.pageX;
            pos.y = e.pageY;
            plot.setTooltipPosition(pos);
        }

        /**
         *  open the tooltip (if not already open) and freeze it on the current position till the next click
         */
        function plotclick(event, pos, item) {
            if (! that.clickmode) {
                // it is the click activating the clicktip
                plothover(event, pos, item);
                if (that.getDomElement().is(":visible")) {
                    $(plot.getPlaceholder()).unbind("plothover", plothover);
                    that.clickmode = true;
                }
            } else {
                // it is the click deactivating the clicktip
                $( plot.getPlaceholder() ).bind("plothover", plothover);
                plot.hideTooltip();
                that.clickmode = false;
            }
        }

        function plothover(event, pos, item) {
            // Simple distance formula.
            var lineDistance = function (p1x, p1y, p2x, p2y) {
                return Math.sqrt((p2x - p1x) * (p2x - p1x) + (p2y - p1y) * (p2y - p1y));
            };

            // Here is some voodoo magic for determining the distance to a line form a given point {x, y}.
            var dotLineLength = function (x, y, x0, y0, x1, y1, o) {
                if (o && !(o =
                    function (x, y, x0, y0, x1, y1) {
                        if (typeof x0 !== 'undefined') return { x: x0, y: y };
                        else if (typeof y0 !== 'undefined') return { x: x, y: y0 };

                        var left,
                            tg = -1 / ((y1 - y0) / (x1 - x0));

                        return {
                            x: left = (x1 * (x * tg - y + y0) + x0 * (x * -tg + y - y1)) / (tg * (x1 - x0) + y0 - y1),
                            y: tg * left - tg * x + y
                        };
                    } (x, y, x0, y0, x1, y1),
                    o.x >= Math.min(x0, x1) && o.x <= Math.max(x0, x1) && o.y >= Math.min(y0, y1) && o.y <= Math.max(y0, y1))
                ) {
                    var l1 = lineDistance(x, y, x0, y0), l2 = lineDistance(x, y, x1, y1);
                    return l1 > l2 ? l2 : l1;
                } else {
                    var a = y0 - y1, b = x1 - x0, c = x0 * y1 - y0 * x1;
                    return Math.abs(a * x + b * y + c) / Math.sqrt(a * a + b * b);
                }
            };

            if (item) {
                plot.showTooltip(item, that.tooltipOptions.snap ? item : pos);
            } else if (that.plotOptions.series.lines.show && that.tooltipOptions.lines === true) {
                var maxDistance = that.plotOptions.grid.mouseActiveRadius;

                var closestTrace = {
                    distance: maxDistance + 1
                };

                var ttPos = pos;

                $.each(plot.getData(), function (i, series) {
                    var xBeforeIndex = 0,
                        xAfterIndex = -1;

                    // Our search here assumes our data is sorted via the x-axis.
                    // TODO: Improve efficiency somehow - search smaller sets of data.
                    for (var j = 1; j < series.data.length; j++) {
                        if (series.data[j - 1][0] <= pos.x && series.data[j][0] >= pos.x) {
                            xBeforeIndex = j - 1;
                            xAfterIndex = j;
                        }
                    }

                    if (xAfterIndex === -1) {
                        plot.hideTooltip();
                        return;
                    }

                    var pointPrev = { x: series.data[xBeforeIndex][0], y: series.data[xBeforeIndex][1] },
                        pointNext = { x: series.data[xAfterIndex][0], y: series.data[xAfterIndex][1] };

                    var distToLine = dotLineLength(series.xaxis.p2c(pos.x), series.yaxis.p2c(pos.y), series.xaxis.p2c(pointPrev.x),
                        series.yaxis.p2c(pointPrev.y), series.xaxis.p2c(pointNext.x), series.yaxis.p2c(pointNext.y), false);

                    if (distToLine < closestTrace.distance) {

                        var closestIndex = lineDistance(pointPrev.x, pointPrev.y, pos.x, pos.y) <
                            lineDistance(pos.x, pos.y, pointNext.x, pointNext.y) ? xBeforeIndex : xAfterIndex;

                        var pointSize = series.datapoints.pointsize;

                        // Calculate the point on the line vertically closest to our cursor.
                        var pointOnLine = [
                            pos.x,
                            pointPrev.y + ((pointNext.y - pointPrev.y) * ((pos.x - pointPrev.x) / (pointNext.x - pointPrev.x)))
                        ];

                        var item = {
                            datapoint: pointOnLine,
                            dataIndex: closestIndex,
                            series: series,
                            seriesIndex: i
                        };

                        closestTrace = {
                            distance: distToLine,
                            item: item
                        };

                        if (that.tooltipOptions.snap) {
                            ttPos = {
                                pageX: series.xaxis.p2c(pointOnLine[0]),
                                pageY: series.yaxis.p2c(pointOnLine[1])
                            };
                        }
                    }
                });

                if (closestTrace.distance < maxDistance + 1)
                    plot.showTooltip(closestTrace.item, ttPos);
                else
                    plot.hideTooltip();
            } else {
                plot.hideTooltip();
            }
        }

        // Quick little function for setting the tooltip position.
        plot.setTooltipPosition = function (pos) {
            var $tip = that.getDomElement();

            var totalTipWidth = $tip.outerWidth() + that.tooltipOptions.shifts.x;
            var totalTipHeight = $tip.outerHeight() + that.tooltipOptions.shifts.y;
            if ((pos.x - $(window).scrollLeft()) > ($(window)[that.wfunc]() - totalTipWidth)) {
                pos.x -= totalTipWidth;
                pos.x = Math.max(pos.x, 0);
            }
            if ((pos.y - $(window).scrollTop()) > ($(window)[that.hfunc]() - totalTipHeight)) {
                pos.y -= totalTipHeight;
            }

	    /*
	       The section applies the new positioning ONLY if pos.x and pos.y
	       are numbers. If they are undefined or not a number, use the last
	       known numerical position. This hack fixes a bug that kept pie
	       charts from keeping their tooltip positioning.
	     */

            if (isNaN(pos.x)) {
		that.tipPosition.x = that.tipPosition.xPrev;
	    }
	    else {
		that.tipPosition.x = pos.x;
		that.tipPosition.xPrev = pos.x;
	    }
	    if (isNaN(pos.y)) {
		that.tipPosition.y = that.tipPosition.yPrev;
	    }
	    else {
		that.tipPosition.y = pos.y;
		that.tipPosition.yPrev = pos.y;
	    }

        };

        // Quick little function for showing the tooltip.
        plot.showTooltip = function (target, position, targetPosition) {
            var $tip = that.getDomElement();

            // convert tooltip content template to real tipText
            var tipText = that.stringFormat(that.tooltipOptions.content, target);
            if (tipText === '')
                return;

            $tip.html(tipText);
            plot.setTooltipPosition({ x: that.tipPosition.x, y: that.tipPosition.y });
            $tip.css({
                left: that.tipPosition.x + that.tooltipOptions.shifts.x,
                top: that.tipPosition.y + that.tooltipOptions.shifts.y
            }).show();

            // run callback
            if (typeof that.tooltipOptions.onHover === 'function') {
                that.tooltipOptions.onHover(target, $tip);
            }
        };

        // Quick little function for hiding the tooltip.
        plot.hideTooltip = function () {
            that.getDomElement().hide().html('');
        };

        plot.removeTooltip = function() {
            that.getDomElement().remove();
        };
    };

    /**
     * get or create tooltip DOM element
     * @return jQuery object
     */
    FlotTooltip.prototype.getDomElement = function () {
        var $tip = $('<div>');
        if (this.tooltipOptions && this.tooltipOptions.cssClass) {
            $tip = $('.' + this.tooltipOptions.cssClass);

            if( $tip.length === 0 ){
                $tip = $('<div />').addClass(this.tooltipOptions.cssClass);
                $tip.appendTo('body').hide().css({position: 'absolute'});

                if(this.tooltipOptions.defaultTheme) {
                    $tip.css({
                        'background': '#fff',
                        'z-index': '1040',
                        'padding': '0.4em 0.6em',
                        'border-radius': '0.5em',
                        'font-size': '0.8em',
                        'border': '1px solid #111',
                        'display': 'none',
                        'white-space': 'nowrap'
                    });
                }
            }
        }

        return $tip;
    };

    /**
     * core function, create tooltip content
     * @param  {string} content - template with tooltip content
     * @param  {object} item - Flot item
     * @return {string} real tooltip content for current item
     */
    FlotTooltip.prototype.stringFormat = function (content, item) {
        var percentPattern = /%p\.{0,1}(\d{0,})/;
        var seriesPattern = /%s/;
        var colorPattern = /%c/;
        var xLabelPattern = /%lx/; // requires flot-axislabels plugin https://github.com/markrcote/flot-axislabels, will be ignored if plugin isn't loaded
        var yLabelPattern = /%ly/; // requires flot-axislabels plugin https://github.com/markrcote/flot-axislabels, will be ignored if plugin isn't loaded
        var xPattern = /%x\.{0,1}(\d{0,})/;
        var yPattern = /%y\.{0,1}(\d{0,})/;
        var xPatternWithoutPrecision = "%x";
        var yPatternWithoutPrecision = "%y";
        var customTextPattern = "%ct";
	var nPiePattern = "%n";

        var x, y, customText, p, n;

        // for threshold plugin we need to read data from different place
        if (typeof item.series.threshold !== "undefined") {
            x = item.datapoint[0];
            y = item.datapoint[1];
            customText = item.datapoint[2];
	}

	// for CurvedLines plugin we need to read data from different place
	    else if (typeof item.series.curvedLines !== "undefined") {
		x = item.datapoint[0];
		y = item.datapoint[1];
	    }

        else if (typeof item.series.lines !== "undefined" && item.series.lines.steps) {
            x = item.series.datapoints.points[item.dataIndex * 2];
            y = item.series.datapoints.points[item.dataIndex * 2 + 1];
            // TODO: where to find custom text in this variant?
            customText = "";
        } else {
            x = item.series.data[item.dataIndex][0];
            y = item.series.data[item.dataIndex][1];
            customText = item.series.data[item.dataIndex][2];
        }

        // I think this is only in case of threshold plugin
        if (item.series.label === null && item.series.originSeries) {
            item.series.label = item.series.originSeries.label;
        }

        // if it is a function callback get the content string
        if (typeof(content) === 'function') {
            content = content(item.series.label, x, y, item);
        }

        // the case where the passed content is equal to false
        if (typeof(content) === 'boolean' && !content) {
            return '';
        }

        /* replacement of %ct and other multi-character templates must
           precede the replacement of single-character templates
           to avoid conflict between '%c' and '%ct'  and similar substrings
        */
        if (customText) {
            content = content.replace(customTextPattern, customText);
        }

        // percent match for pie charts and stacked percent
        if (typeof (item.series.percent) !== 'undefined') {
            p = item.series.percent;
        } else if (typeof (item.series.percents) !== 'undefined') {
            p = item.series.percents[item.dataIndex];
        }
        if (typeof p === 'number') {
            content = this.adjustValPrecision(percentPattern, content, p);
        }

        // replace %n with number of items represented by slice in pie charts
        if (item.series.hasOwnProperty('pie')) {
            if (typeof item.series.data[0][1] !== 'undefined') {
                n = item.series.data[0][1];
            }
        }
        if (typeof n === 'number') {
            content = content.replace(nPiePattern, n);
        }

        // series match
        if (typeof(item.series.label) !== 'undefined') {
            content = content.replace(seriesPattern, item.series.label);
        } else {
            //remove %s if label is undefined
            content = content.replace(seriesPattern, "");
        }

        // color match
        if (typeof(item.series.color) !== 'undefined') {
            content = content.replace(colorPattern, item.series.color);
        } else {
            //remove %s if color is undefined
            content = content.replace(colorPattern, "");
        }

        // x axis label match
        if (this.hasAxisLabel('xaxis', item)) {
            content = content.replace(xLabelPattern, item.series.xaxis.options.axisLabel);
        } else {
            //remove %lx if axis label is undefined or axislabels plugin not present
            content = content.replace(xLabelPattern, "");
        }

        // y axis label match
        if (this.hasAxisLabel('yaxis', item)) {
            content = content.replace(yLabelPattern, item.series.yaxis.options.axisLabel);
        } else {
            //remove %ly if axis label is undefined or axislabels plugin not present
            content = content.replace(yLabelPattern, "");
        }

        // time mode axes with custom dateFormat
        if (this.isTimeMode('xaxis', item) && this.isXDateFormat(item)) {
            content = content.replace(xPattern, this.timestampToDate(x, this.tooltipOptions.xDateFormat, item.series.xaxis.options));
        }
        if (this.isTimeMode('yaxis', item) && this.isYDateFormat(item)) {
            content = content.replace(yPattern, this.timestampToDate(y, this.tooltipOptions.yDateFormat, item.series.yaxis.options));
        }

        // set precision if defined
        if (typeof x === 'number') {
            content = this.adjustValPrecision(xPattern, content, x);
        }
        if (typeof y === 'number') {
            content = this.adjustValPrecision(yPattern, content, y);
        }

        // change x from number to given label, if given
        if (typeof item.series.xaxis.ticks !== 'undefined') {

            var ticks;
            if (this.hasRotatedXAxisTicks(item)) {
                // xaxis.ticks will be an empty array if tickRotor is being used, but the values are available in rotatedTicks
                ticks = 'rotatedTicks';
            } else {
                ticks = 'ticks';
            }

            // see https://github.com/krzysu/flot.tooltip/issues/65
            var tickIndex = item.dataIndex + item.seriesIndex;

            for (var xIndex in item.series.xaxis[ticks]) {
                if (item.series.xaxis[ticks].hasOwnProperty(tickIndex) && !this.isTimeMode('xaxis', item)) {
                    var valueX = (this.isCategoriesMode('xaxis', item)) ? item.series.xaxis[ticks][tickIndex].label : item.series.xaxis[ticks][tickIndex].v;
                    if (valueX === x) {
                        content = content.replace(xPattern, item.series.xaxis[ticks][tickIndex].label.replace(/\$/g, '$$$$'));
                    }
                }
            }
        }

        // change y from number to given label, if given
        if (typeof item.series.yaxis.ticks !== 'undefined') {
            for (var yIndex in item.series.yaxis.ticks) {
                if (item.series.yaxis.ticks.hasOwnProperty(yIndex)) {
                    var valueY = (this.isCategoriesMode('yaxis', item)) ? item.series.yaxis.ticks[yIndex].label : item.series.yaxis.ticks[yIndex].v;
                    if (valueY === y) {
                        content = content.replace(yPattern, item.series.yaxis.ticks[yIndex].label.replace(/\$/g, '$$$$'));
                    }
                }
            }
        }

        // if no value customization, use tickFormatter by default
        if (typeof item.series.xaxis.tickFormatter !== 'undefined') {
            //escape dollar
            content = content.replace(xPatternWithoutPrecision, item.series.xaxis.tickFormatter(x, item.series.xaxis).replace(/\$/g, '$$'));
        }
        if (typeof item.series.yaxis.tickFormatter !== 'undefined') {
            //escape dollar
            content = content.replace(yPatternWithoutPrecision, item.series.yaxis.tickFormatter(y, item.series.yaxis).replace(/\$/g, '$$'));
        }

        return content;
    };

    // helpers just for readability
    FlotTooltip.prototype.isTimeMode = function (axisName, item) {
        return (typeof item.series[axisName].options.mode !== 'undefined' && item.series[axisName].options.mode === 'time');
    };

    FlotTooltip.prototype.isXDateFormat = function (item) {
        return (typeof this.tooltipOptions.xDateFormat !== 'undefined' && this.tooltipOptions.xDateFormat !== null);
    };

    FlotTooltip.prototype.isYDateFormat = function (item) {
        return (typeof this.tooltipOptions.yDateFormat !== 'undefined' && this.tooltipOptions.yDateFormat !== null);
    };

    FlotTooltip.prototype.isCategoriesMode = function (axisName, item) {
        return (typeof item.series[axisName].options.mode !== 'undefined' && item.series[axisName].options.mode === 'categories');
    };

    //
    FlotTooltip.prototype.timestampToDate = function (tmst, dateFormat, options) {
        var theDate = $.plot.dateGenerator(tmst, options);
        return $.plot.formatDate(theDate, dateFormat, this.tooltipOptions.monthNames, this.tooltipOptions.dayNames);
    };

    //
    FlotTooltip.prototype.adjustValPrecision = function (pattern, content, value) {

        var precision;
        var matchResult = content.match(pattern);
        if( matchResult !== null ) {
            if(RegExp.$1 !== '') {
                precision = RegExp.$1;
                value = value.toFixed(precision);

                // only replace content if precision exists, in other case use thickformater
                content = content.replace(pattern, value);
            }
        }
        return content;
    };

    // other plugins detection below

    // check if flot-axislabels plugin (https://github.com/markrcote/flot-axislabels) is used and that an axis label is given
    FlotTooltip.prototype.hasAxisLabel = function (axisName, item) {
        return ($.inArray('axisLabels', this.plotPlugins) !== -1 && typeof item.series[axisName].options.axisLabel !== 'undefined' && item.series[axisName].options.axisLabel.length > 0);
    };

    // check whether flot-tickRotor, a plugin which allows rotation of X-axis ticks, is being used
    FlotTooltip.prototype.hasRotatedXAxisTicks = function (item) {
        return ($.inArray('tickRotor',this.plotPlugins) !== -1 && typeof item.series.xaxis.rotatedTicks !== 'undefined');
    };

    //
    var init = function (plot) {
      new FlotTooltip(plot);
    };

    // define Flot plugin
    $.plot.plugins.push({
        init: init,
        options: defaultOptions,
        name: 'tooltip',
        version: '0.8.5'
    });

})(jQuery);

/* Pretty handling of time axes.

Copyright (c) 2007-2014 IOLA and Ole Laursen.
Licensed under the MIT license.

Set axis.mode to "time" to enable. See the section "Time series data" in
API.txt for details.

*/

(function($) {

	var options = {
		xaxis: {
			timezone: null,		// "browser" for local to the client or timezone for timezone-js
			timeformat: null,	// format string to use
			twelveHourClock: false,	// 12 or 24 time in time mode
			monthNames: null	// list of names of months
		}
	};

	// round to nearby lower multiple of base

	function floorInBase(n, base) {
		return base * Math.floor(n / base);
	}

	// Returns a string with the date d formatted according to fmt.
	// A subset of the Open Group's strftime format is supported.

	function formatDate(d, fmt, monthNames, dayNames) {

		if (typeof d.strftime == "function") {
			return d.strftime(fmt);
		}

		var leftPad = function(n, pad) {
			n = "" + n;
			pad = "" + (pad == null ? "0" : pad);
			return n.length == 1 ? pad + n : n;
		};

		var r = [];
		var escape = false;
		var hours = d.getHours();
		var isAM = hours < 12;

		if (monthNames == null) {
			monthNames = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
		}

		if (dayNames == null) {
			dayNames = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
		}

		var hours12;

		if (hours > 12) {
			hours12 = hours - 12;
		} else if (hours == 0) {
			hours12 = 12;
		} else {
			hours12 = hours;
		}

		for (var i = 0; i < fmt.length; ++i) {

			var c = fmt.charAt(i);

			if (escape) {
				switch (c) {
					case 'a': c = "" + dayNames[d.getDay()]; break;
					case 'b': c = "" + monthNames[d.getMonth()]; break;
					case 'd': c = leftPad(d.getDate()); break;
					case 'e': c = leftPad(d.getDate(), " "); break;
					case 'h':	// For back-compat with 0.7; remove in 1.0
					case 'H': c = leftPad(hours); break;
					case 'I': c = leftPad(hours12); break;
					case 'l': c = leftPad(hours12, " "); break;
					case 'm': c = leftPad(d.getMonth() + 1); break;
					case 'M': c = leftPad(d.getMinutes()); break;
					// quarters not in Open Group's strftime specification
					case 'q':
						c = "" + (Math.floor(d.getMonth() / 3) + 1); break;
					case 'S': c = leftPad(d.getSeconds()); break;
					case 'y': c = leftPad(d.getFullYear() % 100); break;
					case 'Y': c = "" + d.getFullYear(); break;
					case 'p': c = (isAM) ? ("" + "am") : ("" + "pm"); break;
					case 'P': c = (isAM) ? ("" + "AM") : ("" + "PM"); break;
					case 'w': c = "" + d.getDay(); break;
				}
				r.push(c);
				escape = false;
			} else {
				if (c == "%") {
					escape = true;
				} else {
					r.push(c);
				}
			}
		}

		return r.join("");
	}

	// To have a consistent view of time-based data independent of which time
	// zone the client happens to be in we need a date-like object independent
	// of time zones.  This is done through a wrapper that only calls the UTC
	// versions of the accessor methods.

	function makeUtcWrapper(d) {

		function addProxyMethod(sourceObj, sourceMethod, targetObj, targetMethod) {
			sourceObj[sourceMethod] = function() {
				return targetObj[targetMethod].apply(targetObj, arguments);
			};
		};

		var utc = {
			date: d
		};

		// support strftime, if found

		if (d.strftime != undefined) {
			addProxyMethod(utc, "strftime", d, "strftime");
		}

		addProxyMethod(utc, "getTime", d, "getTime");
		addProxyMethod(utc, "setTime", d, "setTime");

		var props = ["Date", "Day", "FullYear", "Hours", "Milliseconds", "Minutes", "Month", "Seconds"];

		for (var p = 0; p < props.length; p++) {
			addProxyMethod(utc, "get" + props[p], d, "getUTC" + props[p]);
			addProxyMethod(utc, "set" + props[p], d, "setUTC" + props[p]);
		}

		return utc;
	};

	// select time zone strategy.  This returns a date-like object tied to the
	// desired timezone

	function dateGenerator(ts, opts) {
		if (opts.timezone == "browser") {
			return new Date(ts);
		} else if (!opts.timezone || opts.timezone == "utc") {
			return makeUtcWrapper(new Date(ts));
		} else if (typeof timezoneJS != "undefined" && typeof timezoneJS.Date != "undefined") {
			var d = new timezoneJS.Date();
			// timezone-js is fickle, so be sure to set the time zone before
			// setting the time.
			d.setTimezone(opts.timezone);
			d.setTime(ts);
			return d;
		} else {
			return makeUtcWrapper(new Date(ts));
		}
	}
	
	// map of app. size of time units in milliseconds

	var timeUnitSize = {
		"second": 1000,
		"minute": 60 * 1000,
		"hour": 60 * 60 * 1000,
		"day": 24 * 60 * 60 * 1000,
		"month": 30 * 24 * 60 * 60 * 1000,
		"quarter": 3 * 30 * 24 * 60 * 60 * 1000,
		"year": 365.2425 * 24 * 60 * 60 * 1000
	};

	// the allowed tick sizes, after 1 year we use
	// an integer algorithm

	var baseSpec = [
		[1, "second"], [2, "second"], [5, "second"], [10, "second"],
		[30, "second"], 
		[1, "minute"], [2, "minute"], [5, "minute"], [10, "minute"],
		[30, "minute"], 
		[1, "hour"], [2, "hour"], [4, "hour"],
		[8, "hour"], [12, "hour"],
		[1, "day"], [2, "day"], [3, "day"],
		[0.25, "month"], [0.5, "month"], [1, "month"],
		[2, "month"]
	];

	// we don't know which variant(s) we'll need yet, but generating both is
	// cheap

	var specMonths = baseSpec.concat([[3, "month"], [6, "month"],
		[1, "year"]]);
	var specQuarters = baseSpec.concat([[1, "quarter"], [2, "quarter"],
		[1, "year"]]);

	function init(plot) {
		plot.hooks.processOptions.push(function (plot, options) {
			$.each(plot.getAxes(), function(axisName, axis) {

				var opts = axis.options;

				if (opts.mode == "time") {
					axis.tickGenerator = function(axis) {

						var ticks = [];
						var d = dateGenerator(axis.min, opts);
						var minSize = 0;

						// make quarter use a possibility if quarters are
						// mentioned in either of these options

						var spec = (opts.tickSize && opts.tickSize[1] ===
							"quarter") ||
							(opts.minTickSize && opts.minTickSize[1] ===
							"quarter") ? specQuarters : specMonths;

						if (opts.minTickSize != null) {
							if (typeof opts.tickSize == "number") {
								minSize = opts.tickSize;
							} else {
								minSize = opts.minTickSize[0] * timeUnitSize[opts.minTickSize[1]];
							}
						}

						for (var i = 0; i < spec.length - 1; ++i) {
							if (axis.delta < (spec[i][0] * timeUnitSize[spec[i][1]]
											  + spec[i + 1][0] * timeUnitSize[spec[i + 1][1]]) / 2
								&& spec[i][0] * timeUnitSize[spec[i][1]] >= minSize) {
								break;
							}
						}

						var size = spec[i][0];
						var unit = spec[i][1];

						// special-case the possibility of several years

						if (unit == "year") {

							// if given a minTickSize in years, just use it,
							// ensuring that it's an integer

							if (opts.minTickSize != null && opts.minTickSize[1] == "year") {
								size = Math.floor(opts.minTickSize[0]);
							} else {

								var magn = Math.pow(10, Math.floor(Math.log(axis.delta / timeUnitSize.year) / Math.LN10));
								var norm = (axis.delta / timeUnitSize.year) / magn;

								if (norm < 1.5) {
									size = 1;
								} else if (norm < 3) {
									size = 2;
								} else if (norm < 7.5) {
									size = 5;
								} else {
									size = 10;
								}

								size *= magn;
							}

							// minimum size for years is 1

							if (size < 1) {
								size = 1;
							}
						}

						axis.tickSize = opts.tickSize || [size, unit];
						var tickSize = axis.tickSize[0];
						unit = axis.tickSize[1];

						var step = tickSize * timeUnitSize[unit];

						if (unit == "second") {
							d.setSeconds(floorInBase(d.getSeconds(), tickSize));
						} else if (unit == "minute") {
							d.setMinutes(floorInBase(d.getMinutes(), tickSize));
						} else if (unit == "hour") {
							d.setHours(floorInBase(d.getHours(), tickSize));
						} else if (unit == "month") {
							d.setMonth(floorInBase(d.getMonth(), tickSize));
						} else if (unit == "quarter") {
							d.setMonth(3 * floorInBase(d.getMonth() / 3,
								tickSize));
						} else if (unit == "year") {
							d.setFullYear(floorInBase(d.getFullYear(), tickSize));
						}

						// reset smaller components

						d.setMilliseconds(0);

						if (step >= timeUnitSize.minute) {
							d.setSeconds(0);
						}
						if (step >= timeUnitSize.hour) {
							d.setMinutes(0);
						}
						if (step >= timeUnitSize.day) {
							d.setHours(0);
						}
						if (step >= timeUnitSize.day * 4) {
							d.setDate(1);
						}
						if (step >= timeUnitSize.month * 2) {
							d.setMonth(floorInBase(d.getMonth(), 3));
						}
						if (step >= timeUnitSize.quarter * 2) {
							d.setMonth(floorInBase(d.getMonth(), 6));
						}
						if (step >= timeUnitSize.year) {
							d.setMonth(0);
						}

						var carry = 0;
						var v = Number.NaN;
						var prev;

						do {

							prev = v;
							v = d.getTime();
							ticks.push(v);

							if (unit == "month" || unit == "quarter") {
								if (tickSize < 1) {

									// a bit complicated - we'll divide the
									// month/quarter up but we need to take
									// care of fractions so we don't end up in
									// the middle of a day

									d.setDate(1);
									var start = d.getTime();
									d.setMonth(d.getMonth() +
										(unit == "quarter" ? 3 : 1));
									var end = d.getTime();
									d.setTime(v + carry * timeUnitSize.hour + (end - start) * tickSize);
									carry = d.getHours();
									d.setHours(0);
								} else {
									d.setMonth(d.getMonth() +
										tickSize * (unit == "quarter" ? 3 : 1));
								}
							} else if (unit == "year") {
								d.setFullYear(d.getFullYear() + tickSize);
							} else {
								d.setTime(v + step);
							}
						} while (v < axis.max && v != prev);

						return ticks;
					};

					axis.tickFormatter = function (v, axis) {

						var d = dateGenerator(v, axis.options);

						// first check global format

						if (opts.timeformat != null) {
							return formatDate(d, opts.timeformat, opts.monthNames, opts.dayNames);
						}

						// possibly use quarters if quarters are mentioned in
						// any of these places

						var useQuarters = (axis.options.tickSize &&
								axis.options.tickSize[1] == "quarter") ||
							(axis.options.minTickSize &&
								axis.options.minTickSize[1] == "quarter");

						var t = axis.tickSize[0] * timeUnitSize[axis.tickSize[1]];
						var span = axis.max - axis.min;
						var suffix = (opts.twelveHourClock) ? " %p" : "";
						var hourCode = (opts.twelveHourClock) ? "%I" : "%H";
						var fmt;

						if (t < timeUnitSize.minute) {
							fmt = hourCode + ":%M:%S" + suffix;
						} else if (t < timeUnitSize.day) {
							if (span < 2 * timeUnitSize.day) {
								fmt = hourCode + ":%M" + suffix;
							} else {
								fmt = "%b %d " + hourCode + ":%M" + suffix;
							}
						} else if (t < timeUnitSize.month) {
							fmt = "%b %d";
						} else if ((useQuarters && t < timeUnitSize.quarter) ||
							(!useQuarters && t < timeUnitSize.year)) {
							if (span < timeUnitSize.year) {
								fmt = "%b";
							} else {
								fmt = "%b %Y";
							}
						} else if (useQuarters && t < timeUnitSize.year) {
							if (span < timeUnitSize.year) {
								fmt = "Q%q";
							} else {
								fmt = "Q%q %Y";
							}
						} else {
							fmt = "%Y";
						}

						var rt = formatDate(d, fmt, opts.monthNames, opts.dayNames);

						return rt;
					};
				}
			});
		});
	}

	$.plot.plugins.push({
		init: init,
		options: options,
		name: 'time',
		version: '1.0'
	});

	// Time-axis support used to be in Flot core, which exposed the
	// formatDate function on the plot object.  Various plugins depend
	// on the function, so we need to re-expose it here.

	$.plot.formatDate = formatDate;
	$.plot.dateGenerator = dateGenerator;

})(jQuery);

var CanvasImageGenerator = (function() {
  /*
      options = {
          width:..,
          height:..,
          icon: {
              type: "src/fontAwesome/svg",
              content: "",
              left: 5,
              top: 5,
              dimension: 0.15, // Percentage width and height of canvas height
              border: {
                  width:..,
                  color:..
              }
          },
          rtl: true/false(default),
          outputFormat: "",
          onReady:..,
      };
  */
  var defaults = {
    icon: {
      type: "src", //"src/fontAwesome/svg",
      content: "",
      top: 5,
      left: 5,
      dimension: 0.15, // Percentage width and height of canvas height
      border: null
    },
    outputFormat: "png",
    rtl: false
  };

  function CanvasImageGenerator(src, options) {
    this.src = src;
    this.options = $.extend(true, {}, defaults, options);

    init.call(this);
  }

  var init = function() {
    this._canvas = createCanvas.call(this);

    // Cache the number of loaded images
    this._loadedImages = 0;
  };

  var getTotalNumberOfImages = function() {
    var numberOfImages = 0;

    // Check if there is a canvas image
    if (this.src) numberOfImages++;

    // Check if there is an icon image
    var icon = this.options.icon;
    if (icon && icon.type == "src" && icon.content) numberOfImages++;

    return numberOfImages;
  };

  var isCanvasReady = function() {
    // Check if all images are loaded
    return this._loadedImages == getTotalNumberOfImages.call(this);
  };

  var createCanvas = function() {
    var canvas = $("<canvas>")[0];
    var ctx = canvas.getContext("2d");

    $("#canvasContainer").html(canvas);

    renderCanvasImage.call(this, canvas, ctx);

    return canvas;
  };

  /*
  var createImageTag = function (src, callback) {
      var img = $("<img>").attr("src", src)[0];

      img.addEventListener('load', e => {
          debugger;
          callback(img);
      });

      return img;
  };

  var createImageObject = function (src, callback) {
      var img = new Image();
      img.crossOrigsin = "anonymous";
      img.src = src;

      img.onload = function (img) {
          callback(img);
      };

      return img;
  };

  var createCanvasImage = function (src, onLoad) {
      var me = this;
      var onLoadImage = function (img) {
          // Call on load image callback function
          onLoad();

          // Increment loaded images
          ++me._loadedImages;

          // Check if all images are loaded
          if (isCanvasReady.call(me)) {
              if (me.options.onReady) {
                  var onReadyCallback = me.options.onReady instanceof Function ? me.options.onReady : window[me.options.onReady];
                  onReadyCallback();
              }
          }
      };

      var img;
      if (this.options.loadFromPath) {
          img = createImageTag.call(this, src, onLoadImage);
      } else {
          img = createImageObject.call(this, src, onLoadImage);
      }

      return img;
  };
  */

  var createCanvasImage = function(src, onLoad) {
    var img = new Image();
    img.crossOrigsin = "anonymous";
    img.src = src;

    var me = this;
    img.onload = function(img) {
      // Call on load image callback function
      onLoad();

      // Increment loaded images
      ++me._loadedImages;

      // Check if all images are loaded
      if (isCanvasReady.call(me)) {
        if (me.options.onReady) {
          var onReadyCallback =
            me.options.onReady instanceof Function
              ? me.options.onReady
              : window[me.options.onReady];
          onReadyCallback();
        }
      }
    };

    return img;
  };

  var renderCanvasImage = function(canvas, ctx) {
    var me = this;

    var img = createCanvasImage.call(this, this.src, function() {
      // Get width and height from options, otherwise get the real size of image
      var width = me.options.width || img.width;
      var height = me.options.height || img.height;

      // Set canvas width and height based on image width and height
      canvas.width = width;
      canvas.height = height;

      // Draw the image
      ctx.drawImage(img, 0, 0, width, height);

      if (me.options.icon && me.options.icon.content) {
        createCanvasIcon.call(me, canvas, ctx);
      }
    });
  };

  //var calculateIconWidth = function (canvas, icon) {
  //    return canvas.width * icon.dimension;
  //};

  //var calculateIconHight = function (canvas, icon) {
  //    return canvas.height * icon.dimension;
  //};

  var getIconDimensions = function(canvas, icon) {
    return canvas.height * icon.dimension;
  };

  var calculateIconLeft = function(canvas, icon) {
    return this.options.rtl ? canvas.width - icon.left - iconWidth : icon.left;
  };

  var calculateIconTop = function(canvas, icon) {
    return icon.top;
  };

  var renderIconBorder = function(
    canvas,
    ctx,
    border,
    iconLeft,
    iconTop,
    iconWidth,
    iconHeight
  ) {
    ctx.strokeStyle = border.color;
    ctx.lineWidth = border.width;
    ctx.strokeRect(iconLeft, iconTop, iconWidth, iconHeight);
  };

  var createCanvasIcon = function(canvas, ctx) {
    var icon = this.options.icon;

    var iconLeft = calculateIconLeft.call(this, canvas, icon);
    var iconTop = calculateIconTop.call(this, canvas, icon);
    //var iconWidth = calculateIconWidth.call(this, canvas, icon);
    //var iconHeight = calculateIconHight.call(this, canvas, icon);
    var iconWidth = (iconHeight = getIconDimensions.call(this, canvas, icon));

    if (icon.border) {
      renderIconBorder.call(
        this,
        canvas,
        ctx,
        icon.border,
        iconLeft,
        iconTop,
        iconWidth,
        iconHeight
      );
    }

    switch (icon.type) {
      case "src":
        renderCanvasIconFromSrc.call(
          this,
          canvas,
          ctx,
          iconLeft,
          iconTop,
          iconWidth,
          iconHeight
        );
        break;

      case "fontAwesome":
        renderFontAwesomeIcon.call(
          this,
          canvas,
          ctx,
          iconLeft,
          iconTop,
          iconWidth,
          iconHeight
        );
        break;
    }
  };

  var renderCanvasIconFromSrc = function(
    canvas,
    ctx,
    iconLeft,
    iconTop,
    iconWidth,
    iconHeight
  ) {
    var icon = this.options.icon;

    var iconImage = createCanvasImage.call(this, icon.content, function() {
      ctx.drawImage(iconImage, iconLeft, iconTop, iconWidth, iconHeight);
    });
  };

  var renderFontAwesomeIcon = function(
    canvas,
    ctx,
    iconLeft,
    iconTop,
    iconWidth,
    iconHeight
  ) {
    var icon = this.options.icon;

    ctx.font = "Font Awesome 4.7 Free";
    //ctx.fillText(icon.content, iconTop, iconTop);
    setTimeout(_ => ctx.fillText(icon.content, iconLeft, iconTop), 200);
  };

  CanvasImageGenerator.prototype.getBase64 = function() {
    return this._canvas.toDataURL(this.options.outputFormat);
  };

  return CanvasImageGenerator;
})();

/*
 * International Telephone Input v17.0.0
 * https://github.com/jackocnr/intl-tel-input.git
 * Licensed under the MIT license
 */

!function(a){"object"==typeof module&&module.exports?module.exports=a(require("jquery")):"function"==typeof define&&define.amd?define(["jquery"],function(b){a(b)}):a(jQuery)}(function(a,b){"use strict";function c(a,b){if(!(a instanceof b))throw new TypeError("Cannot call a class as a function")}function d(a,b){for(var c=0;c<b.length;c++){var d=b[c];d.enumerable=d.enumerable||!1,d.configurable=!0,"value"in d&&(d.writable=!0),Object.defineProperty(a,d.key,d)}}function e(a,b,c){return b&&d(a.prototype,b),c&&d(a,c),a}for(var f=[["Afghanistan (‫افغانستان‬‎)","af","93"],["Albania (Shqipëri)","al","355"],["Algeria (‫الجزائر‬‎)","dz","213"],["American Samoa","as","1",5,["684"]],["Andorra","ad","376"],["Angola","ao","244"],["Anguilla","ai","1",6,["264"]],["Antigua and Barbuda","ag","1",7,["268"]],["Argentina","ar","54"],["Armenia (Հայաստան)","am","374"],["Aruba","aw","297"],["Australia","au","61",0],["Austria (Österreich)","at","43"],["Azerbaijan (Azərbaycan)","az","994"],["Bahamas","bs","1",8,["242"]],["Bahrain (‫البحرين‬‎)","bh","973"],["Bangladesh (বাংলাদেশ)","bd","880"],["Barbados","bb","1",9,["246"]],["Belarus (Беларусь)","by","375"],["Belgium (België)","be","32"],["Belize","bz","501"],["Benin (Bénin)","bj","229"],["Bermuda","bm","1",10,["441"]],["Bhutan (འབྲུག)","bt","975"],["Bolivia","bo","591"],["Bosnia and Herzegovina (Босна и Херцеговина)","ba","387"],["Botswana","bw","267"],["Brazil (Brasil)","br","55"],["British Indian Ocean Territory","io","246"],["British Virgin Islands","vg","1",11,["284"]],["Brunei","bn","673"],["Bulgaria (България)","bg","359"],["Burkina Faso","bf","226"],["Burundi (Uburundi)","bi","257"],["Cambodia (កម្ពុជា)","kh","855"],["Cameroon (Cameroun)","cm","237"],["Canada","ca","1",1,["204","226","236","249","250","289","306","343","365","387","403","416","418","431","437","438","450","506","514","519","548","579","581","587","604","613","639","647","672","705","709","742","778","780","782","807","819","825","867","873","902","905"]],["Cape Verde (Kabu Verdi)","cv","238"],["Caribbean Netherlands","bq","599",1,["3","4","7"]],["Cayman Islands","ky","1",12,["345"]],["Central African Republic (République centrafricaine)","cf","236"],["Chad (Tchad)","td","235"],["Chile","cl","56"],["China (中国)","cn","86"],["Christmas Island","cx","61",2],["Cocos (Keeling) Islands","cc","61",1],["Colombia","co","57"],["Comoros (‫جزر القمر‬‎)","km","269"],["Congo (DRC) (Jamhuri ya Kidemokrasia ya Kongo)","cd","243"],["Congo (Republic) (Congo-Brazzaville)","cg","242"],["Cook Islands","ck","682"],["Costa Rica","cr","506"],["Côte d’Ivoire","ci","225"],["Croatia (Hrvatska)","hr","385"],["Cuba","cu","53"],["Curaçao","cw","599",0],["Cyprus (Κύπρος)","cy","357"],["Czech Republic (Česká republika)","cz","420"],["Denmark (Danmark)","dk","45"],["Djibouti","dj","253"],["Dominica","dm","1",13,["767"]],["Dominican Republic (República Dominicana)","do","1",2,["809","829","849"]],["Ecuador","ec","593"],["Egypt (‫مصر‬‎)","eg","20"],["El Salvador","sv","503"],["Equatorial Guinea (Guinea Ecuatorial)","gq","240"],["Eritrea","er","291"],["Estonia (Eesti)","ee","372"],["Ethiopia","et","251"],["Falkland Islands (Islas Malvinas)","fk","500"],["Faroe Islands (Føroyar)","fo","298"],["Fiji","fj","679"],["Finland (Suomi)","fi","358",0],["France","fr","33"],["French Guiana (Guyane française)","gf","594"],["French Polynesia (Polynésie française)","pf","689"],["Gabon","ga","241"],["Gambia","gm","220"],["Georgia (საქართველო)","ge","995"],["Germany (Deutschland)","de","49"],["Ghana (Gaana)","gh","233"],["Gibraltar","gi","350"],["Greece (Ελλάδα)","gr","30"],["Greenland (Kalaallit Nunaat)","gl","299"],["Grenada","gd","1",14,["473"]],["Guadeloupe","gp","590",0],["Guam","gu","1",15,["671"]],["Guatemala","gt","502"],["Guernsey","gg","44",1,["1481","7781","7839","7911"]],["Guinea (Guinée)","gn","224"],["Guinea-Bissau (Guiné Bissau)","gw","245"],["Guyana","gy","592"],["Haiti","ht","509"],["Honduras","hn","504"],["Hong Kong (香港)","hk","852"],["Hungary (Magyarország)","hu","36"],["Iceland (Ísland)","is","354"],["India (भारत)","in","91"],["Indonesia","id","62"],["Iran (‫ایران‬‎)","ir","98"],["Iraq (‫العراق‬‎)","iq","964"],["Ireland","ie","353"],["Isle of Man","im","44",2,["1624","74576","7524","7924","7624"]],["Israel (‫ישראל‬‎)","il","972"],["Italy (Italia)","it","39",0],["Jamaica","jm","1",4,["876","658"]],["Japan (日本)","jp","81"],["Jersey","je","44",3,["1534","7509","7700","7797","7829","7937"]],["Jordan (‫الأردن‬‎)","jo","962"],["Kazakhstan (Казахстан)","kz","7",1,["33","7"]],["Kenya","ke","254"],["Kiribati","ki","686"],["Kosovo","xk","383"],["Kuwait (‫الكويت‬‎)","kw","965"],["Kyrgyzstan (Кыргызстан)","kg","996"],["Laos (ລາວ)","la","856"],["Latvia (Latvija)","lv","371"],["Lebanon (‫لبنان‬‎)","lb","961"],["Lesotho","ls","266"],["Liberia","lr","231"],["Libya (‫ليبيا‬‎)","ly","218"],["Liechtenstein","li","423"],["Lithuania (Lietuva)","lt","370"],["Luxembourg","lu","352"],["Macau (澳門)","mo","853"],["Macedonia (FYROM) (Македонија)","mk","389"],["Madagascar (Madagasikara)","mg","261"],["Malawi","mw","265"],["Malaysia","my","60"],["Maldives","mv","960"],["Mali","ml","223"],["Malta","mt","356"],["Marshall Islands","mh","692"],["Martinique","mq","596"],["Mauritania (‫موريتانيا‬‎)","mr","222"],["Mauritius (Moris)","mu","230"],["Mayotte","yt","262",1,["269","639"]],["Mexico (México)","mx","52"],["Micronesia","fm","691"],["Moldova (Republica Moldova)","md","373"],["Monaco","mc","377"],["Mongolia (Монгол)","mn","976"],["Montenegro (Crna Gora)","me","382"],["Montserrat","ms","1",16,["664"]],["Morocco (‫المغرب‬‎)","ma","212",0],["Mozambique (Moçambique)","mz","258"],["Myanmar (Burma) (မြန်မာ)","mm","95"],["Namibia (Namibië)","na","264"],["Nauru","nr","674"],["Nepal (नेपाल)","np","977"],["Netherlands (Nederland)","nl","31"],["New Caledonia (Nouvelle-Calédonie)","nc","687"],["New Zealand","nz","64"],["Nicaragua","ni","505"],["Niger (Nijar)","ne","227"],["Nigeria","ng","234"],["Niue","nu","683"],["Norfolk Island","nf","672"],["North Korea (조선 민주주의 인민 공화국)","kp","850"],["Northern Mariana Islands","mp","1",17,["670"]],["Norway (Norge)","no","47",0],["Oman (‫عُمان‬‎)","om","968"],["Pakistan (‫پاکستان‬‎)","pk","92"],["Palau","pw","680"],["Palestine (‫فلسطين‬‎)","ps","970"],["Panama (Panamá)","pa","507"],["Papua New Guinea","pg","675"],["Paraguay","py","595"],["Peru (Perú)","pe","51"],["Philippines","ph","63"],["Poland (Polska)","pl","48"],["Portugal","pt","351"],["Puerto Rico","pr","1",3,["787","939"]],["Qatar (‫قطر‬‎)","qa","974"],["Réunion (La Réunion)","re","262",0],["Romania (România)","ro","40"],["Russia (Россия)","ru","7",0],["Rwanda","rw","250"],["Saint Barthélemy","bl","590",1],["Saint Helena","sh","290"],["Saint Kitts and Nevis","kn","1",18,["869"]],["Saint Lucia","lc","1",19,["758"]],["Saint Martin (Saint-Martin (partie française))","mf","590",2],["Saint Pierre and Miquelon (Saint-Pierre-et-Miquelon)","pm","508"],["Saint Vincent and the Grenadines","vc","1",20,["784"]],["Samoa","ws","685"],["San Marino","sm","378"],["São Tomé and Príncipe (São Tomé e Príncipe)","st","239"],["Saudi Arabia (‫المملكة العربية السعودية‬‎)","sa","966"],["Senegal (Sénégal)","sn","221"],["Serbia (Србија)","rs","381"],["Seychelles","sc","248"],["Sierra Leone","sl","232"],["Singapore","sg","65"],["Sint Maarten","sx","1",21,["721"]],["Slovakia (Slovensko)","sk","421"],["Slovenia (Slovenija)","si","386"],["Solomon Islands","sb","677"],["Somalia (Soomaaliya)","so","252"],["South Africa","za","27"],["South Korea (대한민국)","kr","82"],["South Sudan (‫جنوب السودان‬‎)","ss","211"],["Spain (España)","es","34"],["Sri Lanka (ශ්‍රී ලංකාව)","lk","94"],["Sudan (‫السودان‬‎)","sd","249"],["Suriname","sr","597"],["Svalbard and Jan Mayen","sj","47",1,["79"]],["Swaziland","sz","268"],["Sweden (Sverige)","se","46"],["Switzerland (Schweiz)","ch","41"],["Syria (‫سوريا‬‎)","sy","963"],["Taiwan (台灣)","tw","886"],["Tajikistan","tj","992"],["Tanzania","tz","255"],["Thailand (ไทย)","th","66"],["Timor-Leste","tl","670"],["Togo","tg","228"],["Tokelau","tk","690"],["Tonga","to","676"],["Trinidad and Tobago","tt","1",22,["868"]],["Tunisia (‫تونس‬‎)","tn","216"],["Turkey (Türkiye)","tr","90"],["Turkmenistan","tm","993"],["Turks and Caicos Islands","tc","1",23,["649"]],["Tuvalu","tv","688"],["U.S. Virgin Islands","vi","1",24,["340"]],["Uganda","ug","256"],["Ukraine (Україна)","ua","380"],["United Arab Emirates (‫الإمارات العربية المتحدة‬‎)","ae","971"],["United Kingdom","gb","44",0],["United States","us","1",0],["Uruguay","uy","598"],["Uzbekistan (Oʻzbekiston)","uz","998"],["Vanuatu","vu","678"],["Vatican City (Città del Vaticano)","va","39",1,["06698"]],["Venezuela","ve","58"],["Vietnam (Việt Nam)","vn","84"],["Wallis and Futuna (Wallis-et-Futuna)","wf","681"],["Western Sahara (‫الصحراء الغربية‬‎)","eh","212",1,["5288","5289"]],["Yemen (‫اليمن‬‎)","ye","967"],["Zambia","zm","260"],["Zimbabwe","zw","263"],["Åland Islands","ax","358",1,["18"]]],g=0;g<f.length;g++){var h=f[g];f[g]={name:h[0],iso2:h[1],dialCode:h[2],priority:h[3]||0,areaCodes:h[4]||null}}var i={getInstance:function(a){var b=a.getAttribute("data-intl-tel-input-id");return window.intlTelInputGlobals.instances[b]},instances:{}};"object"==typeof window&&(window.intlTelInputGlobals=i);var j=0,k={allowDropdown:!0,autoHideDialCode:!0,autoPlaceholder:"polite",customContainer:"",customPlaceholder:null,dropdownContainer:null,excludeCountries:[],formatOnDisplay:!0,geoIpLookup:null,hiddenInput:"",initialCountry:"",localizedCountries:null,nationalMode:!0,onlyCountries:[],placeholderNumberType:"MOBILE",preferredCountries:["us","gb"],separateDialCode:!1,utilsScript:""},l=["800","822","833","844","855","866","877","880","881","882","883","884","885","886","887","888","889"];"object"==typeof window&&window.addEventListener("load",function(){window.intlTelInputGlobals.windowLoaded=!0});var m=function(a,b){for(var c=Object.keys(a),d=0;d<c.length;d++)b(c[d],a[c[d]])},n=function(a){m(window.intlTelInputGlobals.instances,function(b){window.intlTelInputGlobals.instances[b][a]()})},o=function(){function a(b,d){var e=this;c(this,a),this.id=j++,this.a=b,this.b=null,this.c=null;var f=d||{};this.d={},m(k,function(a,b){e.d[a]=f.hasOwnProperty(a)?f[a]:b}),this.e=Boolean(b.getAttribute("placeholder"))}return e(a,[{key:"_init",value:function(){var a=this;if(this.d.nationalMode&&(this.d.autoHideDialCode=!1),this.d.separateDialCode&&(this.d.autoHideDialCode=this.d.nationalMode=!1),this.g=/Android.+Mobile|webOS|iPhone|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent),this.g&&(document.body.classList.add("iti-mobile"),this.d.dropdownContainer||(this.d.dropdownContainer=document.body)),"undefined"!=typeof Promise){var b=new Promise(function(b,c){a.h=b,a.i=c}),c=new Promise(function(b,c){a.i0=b,a.i1=c});this.promise=Promise.all([b,c])}else this.h=this.i=function(){},this.i0=this.i1=function(){};this.s={},this._b(),this._f(),this._h(),this._i(),this._i3()}},{key:"_b",value:function(){this._d(),this._d2(),this._e(),this.d.localizedCountries&&this._d0(),(this.d.onlyCountries.length||this.d.localizedCountries)&&this.p.sort(this._d1)}},{key:"_c",value:function(a,c,d){c.length>this.dialCodeMaxLen&&(this.dialCodeMaxLen=c.length),this.q.hasOwnProperty(c)||(this.q[c]=[]);for(var e=0;e<this.q[c].length;e++)if(this.q[c][e]===a)return;var f=d!==b?d:this.q[c].length;this.q[c][f]=a}},{key:"_d",value:function(){if(this.d.onlyCountries.length){var a=this.d.onlyCountries.map(function(a){return a.toLowerCase()});this.p=f.filter(function(b){return a.indexOf(b.iso2)>-1})}else if(this.d.excludeCountries.length){var b=this.d.excludeCountries.map(function(a){return a.toLowerCase()});this.p=f.filter(function(a){return-1===b.indexOf(a.iso2)})}else this.p=f}},{key:"_d0",value:function(){for(var a=0;a<this.p.length;a++){var b=this.p[a].iso2.toLowerCase();this.d.localizedCountries.hasOwnProperty(b)&&(this.p[a].name=this.d.localizedCountries[b])}}},{key:"_d1",value:function(a,b){return a.name.localeCompare(b.name)}},{key:"_d2",value:function(){this.dialCodeMaxLen=0,this.q={};for(var a=0;a<this.p.length;a++){var b=this.p[a];this._c(b.iso2,b.dialCode,b.priority)}for(var c=0;c<this.p.length;c++){var d=this.p[c];if(d.areaCodes)for(var e=this.q[d.dialCode][0],f=0;f<d.areaCodes.length;f++){for(var g=d.areaCodes[f],h=1;h<g.length;h++){var i=d.dialCode+g.substr(0,h);this._c(e,i),this._c(d.iso2,i)}this._c(d.iso2,d.dialCode+g)}}}},{key:"_e",value:function(){this.preferredCountries=[];for(var a=0;a<this.d.preferredCountries.length;a++){var b=this.d.preferredCountries[a].toLowerCase(),c=this._y(b,!1,!0);c&&this.preferredCountries.push(c)}}},{key:"_e2",value:function(a,b,c){var d=document.createElement(a);return b&&m(b,function(a,b){return d.setAttribute(a,b)}),c&&c.appendChild(d),d}},{key:"_f",value:function(){this.a.hasAttribute("autocomplete")||this.a.form&&this.a.form.hasAttribute("autocomplete")||this.a.setAttribute("autocomplete","off");var a="iti";this.d.allowDropdown&&(a+=" iti--allow-dropdown"),this.d.separateDialCode&&(a+=" iti--separate-dial-code"),this.d.customContainer&&(a+=" ",a+=this.d.customContainer);var b=this._e2("div",{"class":a});if(this.a.parentNode.insertBefore(b,this.a),this.k=this._e2("div",{"class":"iti__flag-container"},b),b.appendChild(this.a),this.selectedFlag=this._e2("div",{"class":"iti__selected-flag",role:"combobox","aria-owns":"iti-".concat(this.id,"__country-listbox"),"aria-expanded":"false"},this.k),this.l=this._e2("div",{"class":"iti__flag"},this.selectedFlag),this.d.separateDialCode&&(this.t=this._e2("div",{"class":"iti__selected-dial-code"},this.selectedFlag)),this.d.allowDropdown&&(this.selectedFlag.setAttribute("tabindex","0"),this.u=this._e2("div",{"class":"iti__arrow"},this.selectedFlag),this.m=this._e2("ul",{"class":"iti__country-list iti__hide",id:"iti-".concat(this.id,"__country-listbox"),role:"listbox"}),this.preferredCountries.length&&(this._g(this.preferredCountries,"iti__preferred",!0),this._e2("li",{"class":"iti__divider",role:"separator","aria-disabled":"true"},this.m)),this._g(this.p,"iti__standard"),this.d.dropdownContainer?(this.dropdown=this._e2("div",{"class":"iti iti--container"}),this.dropdown.appendChild(this.m)):this.k.appendChild(this.m)),this.d.hiddenInput){var c=this.d.hiddenInput,d=this.a.getAttribute("name");if(d){var e=d.lastIndexOf("[");-1!==e&&(c="".concat(d.substr(0,e),"[").concat(c,"]"))}this.hiddenInput=this._e2("input",{type:"hidden",name:c}),b.appendChild(this.hiddenInput)}}},{key:"_g",value:function(a,b,c){for(var d="",e=0;e<a.length;e++){var f=a[e],g=c?"-preferred":"";d+="<li class='iti__country ".concat(b,"' tabIndex='-1' id='iti-").concat(this.id,"__item-").concat(f.iso2).concat(g,"' role='option' data-dial-code='").concat(f.dialCode,"' data-country-code='").concat(f.iso2,"'>"),d+="<div class='iti__flag-box'><div class='iti__flag iti__".concat(f.iso2,"'></div></div>"),d+="<span class='iti__country-name'>".concat(f.name,"</span>"),d+="<span class='iti__dial-code'>+".concat(f.dialCode,"</span>"),d+="</li>"}this.m.insertAdjacentHTML("beforeend",d)}},{key:"_h",value:function(){var a=this.a.value,b=this._5(a),c=this._w(a),d=this.d,e=d.initialCountry,f=d.nationalMode,g=d.autoHideDialCode,h=d.separateDialCode;b&&!c?this._v(a):"auto"!==e&&(e?this._z(e.toLowerCase()):b&&c?this._z("us"):(this.j=this.preferredCountries.length?this.preferredCountries[0].iso2:this.p[0].iso2,a||this._z(this.j)),a||f||g||h||(this.a.value="+".concat(this.s.dialCode))),a&&this._u(a)}},{key:"_i",value:function(){this._j(),this.d.autoHideDialCode&&this._l(),this.d.allowDropdown&&this._i2(),this.hiddenInput&&this._i0()}},{key:"_i0",value:function(){var a=this;this._a14=function(){a.hiddenInput.value=a.getNumber()},this.a.form&&this.a.form.addEventListener("submit",this._a14)}},{key:"_i1",value:function(){for(var a=this.a;a&&"LABEL"!==a.tagName;)a=a.parentNode;return a}},{key:"_i2",value:function(){var a=this;this._a9=function(b){a.m.classList.contains("iti__hide")?a.a.focus():b.preventDefault()};var b=this._i1();b&&b.addEventListener("click",this._a9),this._a10=function(){!a.m.classList.contains("iti__hide")||a.a.disabled||a.a.readOnly||a._n()},this.selectedFlag.addEventListener("click",this._a10),this._a11=function(b){a.m.classList.contains("iti__hide")&&-1!==["ArrowUp","Up","ArrowDown","Down"," ","Enter"].indexOf(b.key)&&(b.preventDefault(),b.stopPropagation(),a._n()),"Tab"===b.key&&a._2()},this.k.addEventListener("keydown",this._a11)}},{key:"_i3",value:function(){var a=this;this.d.utilsScript&&!window.intlTelInputUtils?window.intlTelInputGlobals.windowLoaded?window.intlTelInputGlobals.loadUtils(this.d.utilsScript):window.addEventListener("load",function(){window.intlTelInputGlobals.loadUtils(a.d.utilsScript)}):this.i0(),"auto"===this.d.initialCountry?this._i4():this.h()}},{key:"_i4",value:function(){window.intlTelInputGlobals.autoCountry?this.handleAutoCountry():window.intlTelInputGlobals.startedLoadingAutoCountry||(window.intlTelInputGlobals.startedLoadingAutoCountry=!0,"function"==typeof this.d.geoIpLookup&&this.d.geoIpLookup(function(a){window.intlTelInputGlobals.autoCountry=a.toLowerCase(),setTimeout(function(){return n("handleAutoCountry")})},function(){return n("rejectAutoCountryPromise")}))}},{key:"_j",value:function(){var a=this;this._a12=function(){a._v(a.a.value)&&a._8()},this.a.addEventListener("keyup",this._a12),this._a13=function(){setTimeout(a._a12)},this.a.addEventListener("cut",this._a13),this.a.addEventListener("paste",this._a13)}},{key:"_j2",value:function(a){var b=this.a.getAttribute("maxlength");return b&&a.length>b?a.substr(0,b):a}},{key:"_l",value:function(){var a=this;this._a8=function(){a._l2()},this.a.form&&this.a.form.addEventListener("submit",this._a8),this.a.addEventListener("blur",this._a8)}},{key:"_l2",value:function(){if("+"===this.a.value.charAt(0)){var a=this._m(this.a.value);a&&this.s.dialCode!==a||(this.a.value="")}}},{key:"_m",value:function(a){return a.replace(/\D/g,"")}},{key:"_m2",value:function(a){var b=document.createEvent("Event");b.initEvent(a,!0,!0),this.a.dispatchEvent(b)}},{key:"_n",value:function(){this.m.classList.remove("iti__hide"),this.selectedFlag.setAttribute("aria-expanded","true"),this._o(),this.b&&(this._x(this.b,!1),this._3(this.b,!0)),this._p(),this.u.classList.add("iti__arrow--up"),this._m2("open:countrydropdown")}},{key:"_n2",value:function(a,b,c){c&&!a.classList.contains(b)?a.classList.add(b):!c&&a.classList.contains(b)&&a.classList.remove(b)}},{key:"_o",value:function(){var a=this;if(this.d.dropdownContainer&&this.d.dropdownContainer.appendChild(this.dropdown),!this.g){var b=this.a.getBoundingClientRect(),c=window.pageYOffset||document.documentElement.scrollTop,d=b.top+c,e=this.m.offsetHeight,f=d+this.a.offsetHeight+e<c+window.innerHeight,g=d-e>c;if(this._n2(this.m,"iti__country-list--dropup",!f&&g),this.d.dropdownContainer){var h=!f&&g?0:this.a.offsetHeight;this.dropdown.style.top="".concat(d+h,"px"),this.dropdown.style.left="".concat(b.left+document.body.scrollLeft,"px"),this._a4=function(){return a._2()},window.addEventListener("scroll",this._a4)}}}},{key:"_o2",value:function(a){for(var b=a;b&&b!==this.m&&!b.classList.contains("iti__country");)b=b.parentNode;return b===this.m?null:b}},{key:"_p",value:function(){var a=this;this._a0=function(b){var c=a._o2(b.target);c&&a._x(c,!1)},this.m.addEventListener("mouseover",this._a0),this._a1=function(b){var c=a._o2(b.target);c&&a._1(c)},this.m.addEventListener("click",this._a1);var b=!0;this._a2=function(){b||a._2(),b=!1},document.documentElement.addEventListener("click",this._a2);var c="",d=null;this._a3=function(b){b.preventDefault(),"ArrowUp"===b.key||"Up"===b.key||"ArrowDown"===b.key||"Down"===b.key?a._q(b.key):"Enter"===b.key?a._r():"Escape"===b.key?a._2():/^[a-zA-ZÀ-ÿа-яА-Я ]$/.test(b.key)&&(d&&clearTimeout(d),c+=b.key.toLowerCase(),a._s(c),d=setTimeout(function(){c=""},1e3))},document.addEventListener("keydown",this._a3)}},{key:"_q",value:function(a){var b="ArrowUp"===a||"Up"===a?this.c.previousElementSibling:this.c.nextElementSibling;b&&(b.classList.contains("iti__divider")&&(b="ArrowUp"===a||"Up"===a?b.previousElementSibling:b.nextElementSibling),this._x(b,!0))}},{key:"_r",value:function(){this.c&&this._1(this.c)}},{key:"_s",value:function(a){for(var b=0;b<this.p.length;b++)if(this._t(this.p[b].name,a)){var c=this.m.querySelector("#iti-".concat(this.id,"__item-").concat(this.p[b].iso2));this._x(c,!1),this._3(c,!0);break}}},{key:"_t",value:function(a,b){return a.substr(0,b.length).toLowerCase()===b}},{key:"_u",value:function(a){var b=a;if(this.d.formatOnDisplay&&window.intlTelInputUtils&&this.s){var c=!this.d.separateDialCode&&(this.d.nationalMode||"+"!==b.charAt(0)),d=intlTelInputUtils.numberFormat,e=d.NATIONAL,f=d.INTERNATIONAL,g=c?e:f;b=intlTelInputUtils.formatNumber(b,this.s.iso2,g)}b=this._7(b),this.a.value=b}},{key:"_v",value:function(a){var b=a,c=this.s.dialCode,d="1"===c;b&&this.d.nationalMode&&d&&"+"!==b.charAt(0)&&("1"!==b.charAt(0)&&(b="1".concat(b)),b="+".concat(b)),this.d.separateDialCode&&c&&"+"!==b.charAt(0)&&(b="+".concat(c).concat(b));var e=this._5(b),f=this._m(b),g=null;if(e){var h=this.q[this._m(e)],i=-1!==h.indexOf(this.s.iso2)&&f.length<=e.length-1;if(!("1"===c&&this._w(f))&&!i)for(var j=0;j<h.length;j++)if(h[j]){g=h[j];break}}else"+"===b.charAt(0)&&f.length?g="":b&&"+"!==b||(g=this.j);return null!==g&&this._z(g)}},{key:"_w",value:function(a){var b=this._m(a);if("1"===b.charAt(0)){var c=b.substr(1,3);return-1!==l.indexOf(c)}return!1}},{key:"_x",value:function(a,b){var c=this.c;c&&c.classList.remove("iti__highlight"),this.c=a,this.c.classList.add("iti__highlight"),b&&this.c.focus()}},{key:"_y",value:function(a,b,c){for(var d=b?f:this.p,e=0;e<d.length;e++)if(d[e].iso2===a)return d[e];if(c)return null;throw new Error("No country data for '".concat(a,"'"))}},{key:"_z",value:function(a){var b=this.s.iso2?this.s:{};this.s=a?this._y(a,!1,!1):{},this.s.iso2&&(this.j=this.s.iso2),this.l.setAttribute("class","iti__flag iti__".concat(a));var c=a?"".concat(this.s.name,": +").concat(this.s.dialCode):"Unknown";if(this.selectedFlag.setAttribute("title",c),this.d.separateDialCode){var d=this.s.dialCode?"+".concat(this.s.dialCode):"";this.t.innerHTML=d;var e=this.selectedFlag.offsetWidth||this._getHiddenSelectedFlagWidth();this.a.style.paddingLeft="".concat(e+6,"px")}if(this._0(),this.d.allowDropdown){var f=this.b;if(f&&(f.classList.remove("iti__active"),f.setAttribute("aria-selected","false")),a){var g=this.m.querySelector("#iti-".concat(this.id,"__item-").concat(a,"-preferred"))||this.m.querySelector("#iti-".concat(this.id,"__item-").concat(a));g.setAttribute("aria-selected","true"),g.classList.add("iti__active"),this.b=g,this.selectedFlag.setAttribute("aria-activedescendant",g.getAttribute("id"))}}return b.iso2!==a}},{key:"_getHiddenSelectedFlagWidth",value:function(){var a=this.a.parentNode.cloneNode();a.style.visibility="hidden",document.body.appendChild(a);var b=this.selectedFlag.cloneNode(!0);a.appendChild(b);var c=b.offsetWidth;return a.parentNode.removeChild(a),c}},{key:"_0",value:function(){var a="aggressive"===this.d.autoPlaceholder||!this.e&&"polite"===this.d.autoPlaceholder;if(window.intlTelInputUtils&&a){var b=intlTelInputUtils.numberType[this.d.placeholderNumberType],c=this.s.iso2?intlTelInputUtils.getExampleNumber(this.s.iso2,this.d.nationalMode,b):"";c=this._7(c),"function"==typeof this.d.customPlaceholder&&(c=this.d.customPlaceholder(c,this.s)),this.a.setAttribute("placeholder",c)}}},{key:"_1",value:function(a){var b=this._z(a.getAttribute("data-country-code"));this._2(),this._4(a.getAttribute("data-dial-code"),!0),this.a.focus();var c=this.a.value.length;this.a.setSelectionRange(c,c),b&&this._8()}},{key:"_2",value:function(){this.m.classList.add("iti__hide"),this.selectedFlag.setAttribute("aria-expanded","false"),this.u.classList.remove("iti__arrow--up"),document.removeEventListener("keydown",this._a3),document.documentElement.removeEventListener("click",this._a2),this.m.removeEventListener("mouseover",this._a0),this.m.removeEventListener("click",this._a1),this.d.dropdownContainer&&(this.g||window.removeEventListener("scroll",this._a4),this.dropdown.parentNode&&this.dropdown.parentNode.removeChild(this.dropdown)),this._m2("close:countrydropdown")}},{key:"_3",value:function(a,b){var c=this.m,d=window.pageYOffset||document.documentElement.scrollTop,e=c.offsetHeight,f=c.getBoundingClientRect().top+d,g=f+e,h=a.offsetHeight,i=a.getBoundingClientRect().top+d,j=i+h,k=i-f+c.scrollTop,l=e/2-h/2;if(i<f)b&&(k-=l),c.scrollTop=k;else if(j>g){b&&(k+=l);var m=e-h;c.scrollTop=k-m}}},{key:"_4",value:function(a,b){var c,d=this.a.value,e="+".concat(a);if("+"===d.charAt(0)){var f=this._5(d);c=f?d.replace(f,e):e}else{if(this.d.nationalMode||this.d.separateDialCode)return;if(d)c=e+d;else{if(!b&&this.d.autoHideDialCode)return;c=e}}this.a.value=c}},{key:"_5",value:function(a){var b="";if("+"===a.charAt(0))for(var c="",d=0;d<a.length;d++){var e=a.charAt(d);if(!isNaN(parseInt(e,10))&&(c+=e,this.q[c]&&(b=a.substr(0,d+1)),c.length===this.dialCodeMaxLen))break}return b}},{key:"_6",value:function(){var a=this.a.value.trim(),b=this.s.dialCode,c=this._m(a);return(this.d.separateDialCode&&"+"!==a.charAt(0)&&b&&c?"+".concat(b):"")+a}},{key:"_7",value:function(a){var b=a;if(this.d.separateDialCode){var c=this._5(b);if(c){c="+".concat(this.s.dialCode);var d=" "===b[c.length]||"-"===b[c.length]?c.length+1:c.length;b=b.substr(d)}}return this._j2(b)}},{key:"_8",value:function(){this._m2("countrychange")}},{key:"handleAutoCountry",value:function(){"auto"===this.d.initialCountry&&(this.j=window.intlTelInputGlobals.autoCountry,this.a.value||this.setCountry(this.j),this.h())}},{key:"handleUtils",value:function(){window.intlTelInputUtils&&(this.a.value&&this._u(this.a.value),this._0()),this.i0()}},{key:"destroy",value:function(){var a=this.a.form;if(this.d.allowDropdown){this._2(),this.selectedFlag.removeEventListener("click",this._a10),this.k.removeEventListener("keydown",this._a11);var b=this._i1();b&&b.removeEventListener("click",this._a9)}this.hiddenInput&&a&&a.removeEventListener("submit",this._a14),this.d.autoHideDialCode&&(a&&a.removeEventListener("submit",this._a8),this.a.removeEventListener("blur",this._a8)),this.a.removeEventListener("keyup",this._a12),this.a.removeEventListener("cut",this._a13),this.a.removeEventListener("paste",this._a13),this.a.removeAttribute("data-intl-tel-input-id");var c=this.a.parentNode;c.parentNode.insertBefore(this.a,c),c.parentNode.removeChild(c),delete window.intlTelInputGlobals.instances[this.id]}},{key:"getExtension",value:function(){return window.intlTelInputUtils?intlTelInputUtils.getExtension(this._6(),this.s.iso2):""}},{key:"getNumber",value:function(a){if(window.intlTelInputUtils){var b=this.s.iso2;return intlTelInputUtils.formatNumber(this._6(),b,a)}return""}},{key:"getNumberType",value:function(){return window.intlTelInputUtils?intlTelInputUtils.getNumberType(this._6(),this.s.iso2):-99}},{key:"getSelectedCountryData",value:function(){return this.s}},{key:"getValidationError",
value:function(){if(window.intlTelInputUtils){var a=this.s.iso2;return intlTelInputUtils.getValidationError(this._6(),a)}return-99}},{key:"isValidNumber",value:function(){var a=this._6().trim(),b=this.d.nationalMode?this.s.iso2:"";return window.intlTelInputUtils?intlTelInputUtils.isValidNumber(a,b):null}},{key:"setCountry",value:function(a){var b=a.toLowerCase();this.l.classList.contains("iti__".concat(b))||(this._z(b),this._4(this.s.dialCode,!1),this._8())}},{key:"setNumber",value:function(a){var b=this._v(a);this._u(a),b&&this._8()}},{key:"setPlaceholderNumberType",value:function(a){this.d.placeholderNumberType=a,this._0()}}]),a}();i.getCountryData=function(){return f};var p=function(a,b,c){var d=document.createElement("script");d.onload=function(){n("handleUtils"),b&&b()},d.onerror=function(){n("rejectUtilsScriptPromise"),c&&c()},d.className="iti-load-utils",d.async=!0,d.src=a,document.body.appendChild(d)};i.loadUtils=function(a){if(!window.intlTelInputUtils&&!window.intlTelInputGlobals.startedLoadingUtilsScript){if(window.intlTelInputGlobals.startedLoadingUtilsScript=!0,"undefined"!=typeof Promise)return new Promise(function(b,c){return p(a,b,c)});p(a)}return null},i.defaults=k,i.version="17.0.0";a.fn.intlTelInput=function(c){var d=arguments;if(c===b||"object"==typeof c)return this.each(function(){if(!a.data(this,"plugin_intlTelInput")){var b=new o(this,c);b._init(),window.intlTelInputGlobals.instances[b.id]=b,a.data(this,"plugin_intlTelInput",b)}});if("string"==typeof c&&"_"!==c[0]){var e;return this.each(function(){var b=a.data(this,"plugin_intlTelInput");b instanceof o&&"function"==typeof b[c]&&(e=b[c].apply(b,Array.prototype.slice.call(d,1))),"destroy"===c&&a.data(this,"plugin_intlTelInput",null)}),e!==b?e:this}}});
(function(){var aa=this;function k(a){return"string"==typeof a}function m(a,b){a=a.split(".");var c=aa;a[0]in c||!c.execScript||c.execScript("var "+a[0]);for(var d;a.length&&(d=a.shift());)a.length||void 0===b?c[d]&&c[d]!==Object.prototype[d]?c=c[d]:c=c[d]={}:c[d]=b}
function n(a,b){function c(){}c.prototype=b.prototype;a.o=b.prototype;a.prototype=new c;a.prototype.constructor=a;a.aa=function(a,c,f){for(var d=Array(arguments.length-2),e=2;e<arguments.length;e++)d[e-2]=arguments[e];return b.prototype[c].apply(a,d)}};var p=Array.prototype.indexOf?function(a,b,c){return Array.prototype.indexOf.call(a,b,c)}:function(a,b,c){c=null==c?0:0>c?Math.max(0,a.length+c):c;if(k(a))return k(b)&&1==b.length?a.indexOf(b,c):-1;for(;c<a.length;c++)if(c in a&&a[c]===b)return c;return-1};function q(a,b){a.sort(b||ba)}function ba(a,b){return a>b?1:a<b?-1:0};function ca(a){var b=[],c=0,d;for(d in a)b[c++]=a[d];return b};function da(a,b){this.a=a;this.h=!!b.i;this.c=b.b;this.m=b.type;this.l=!1;switch(this.c){case ea:case fa:case ha:case ia:case ja:case ka:case la:this.l=!0}this.g=b.defaultValue}var la=1,ka=2,ea=3,fa=4,ha=6,ia=16,ja=18;function ma(a,b){this.c=a;this.a={};for(a=0;a<b.length;a++){var c=b[a];this.a[c.a]=c}}function na(a){a=ca(a.a);q(a,function(a,c){return a.a-c.a});return a};function r(){this.a={};this.g=this.f().a;this.c=this.h=null}r.prototype.has=function(a){return null!=this.a[a.a]};r.prototype.get=function(a,b){return t(this,a.a,b)};r.prototype.set=function(a,b){u(this,a.a,b)};r.prototype.add=function(a,b){v(this,a.a,b)};
function oa(a,b){for(var c=na(a.f()),d=0;d<c.length;d++){var e=c[d],f=e.a;if(null!=b.a[f]){a.c&&delete a.c[e.a];var g=11==e.c||10==e.c;if(e.h){e=w(b,f);for(var h=0;h<e.length;h++)v(a,f,g?e[h].clone():e[h])}else e=x(b,f),g?(g=x(a,f))?oa(g,e):u(a,f,e.clone()):u(a,f,e)}}}r.prototype.clone=function(){var a=new this.constructor;a!=this&&(a.a={},a.c&&(a.c={}),oa(a,this));return a};
function x(a,b){var c=a.a[b];if(null==c)return null;if(a.h){if(!(b in a.c)){var d=a.h,e=a.g[b];if(null!=c)if(e.h){for(var f=[],g=0;g<c.length;g++)f[g]=d.c(e,c[g]);c=f}else c=d.c(e,c);return a.c[b]=c}return a.c[b]}return c}function t(a,b,c){var d=x(a,b);return a.g[b].h?d[c||0]:d}function y(a,b){if(null!=a.a[b])a=t(a,b,void 0);else a:{a=a.g[b];if(void 0===a.g)if(b=a.m,b===Boolean)a.g=!1;else if(b===Number)a.g=0;else if(b===String)a.g=a.l?"0":"";else{a=new b;break a}a=a.g}return a}
function w(a,b){return x(a,b)||[]}function A(a,b){return a.g[b].h?null!=a.a[b]?a.a[b].length:0:null!=a.a[b]?1:0}function u(a,b,c){a.a[b]=c;a.c&&(a.c[b]=c)}function v(a,b,c){a.a[b]||(a.a[b]=[]);a.a[b].push(c);a.c&&delete a.c[b]}function B(a,b){var c=[],d;for(d in b)0!=d&&c.push(new da(d,b[d]));return new ma(a,c)};function C(){}C.prototype.a=function(a){new a.c;throw Error("Unimplemented");};C.prototype.c=function(a,b){if(11==a.c||10==a.c)return b instanceof r?b:this.a(a.m.prototype.f(),b);if(14==a.c)return k(b)&&pa.test(b)&&(a=Number(b),0<a)?a:b;if(!a.l)return b;a=a.m;if(a===String){if("number"==typeof b)return String(b)}else if(a===Number&&k(b)&&("Infinity"===b||"-Infinity"===b||"NaN"===b||pa.test(b)))return Number(b);return b};var pa=/^-?[0-9]+$/;function D(){}n(D,C);D.prototype.a=function(a,b){a=new a.c;a.h=this;a.a=b;a.c={};return a};function E(){}n(E,D);E.prototype.c=function(a,b){return 8==a.c?!!b:C.prototype.c.apply(this,arguments)};E.prototype.a=function(a,b){return E.o.a.call(this,a,b)};function F(a,b){null!=a&&this.a.apply(this,arguments)}F.prototype.c="";F.prototype.set=function(a){this.c=""+a};F.prototype.a=function(a,b,c){this.c+=String(a);if(null!=b)for(var d=1;d<arguments.length;d++)this.c+=arguments[d];return this};F.prototype.toString=function(){return this.c};/*

 Protocol Buffer 2 Copyright 2008 Google Inc.
 All other code copyright its respective owners.
 Copyright (C) 2010 The Libphonenumber Authors

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
*/
function G(){r.call(this)}n(G,r);var qa=null;function H(){r.call(this)}n(H,r);var ra=null;function I(){r.call(this)}n(I,r);var sa=null;
G.prototype.f=function(){var a=qa;a||(qa=a=B(G,{0:{name:"NumberFormat",j:"i18n.phonenumbers.NumberFormat"},1:{name:"pattern",required:!0,b:9,type:String},2:{name:"format",required:!0,b:9,type:String},3:{name:"leading_digits_pattern",i:!0,b:9,type:String},4:{name:"national_prefix_formatting_rule",b:9,type:String},6:{name:"national_prefix_optional_when_formatting",b:8,defaultValue:!1,type:Boolean},5:{name:"domestic_carrier_code_formatting_rule",b:9,type:String}}));return a};G.f=G.prototype.f;
H.prototype.f=function(){var a=ra;a||(ra=a=B(H,{0:{name:"PhoneNumberDesc",j:"i18n.phonenumbers.PhoneNumberDesc"},2:{name:"national_number_pattern",b:9,type:String},9:{name:"possible_length",i:!0,b:5,type:Number},10:{name:"possible_length_local_only",i:!0,b:5,type:Number},6:{name:"example_number",b:9,type:String}}));return a};H.f=H.prototype.f;
I.prototype.f=function(){var a=sa;a||(sa=a=B(I,{0:{name:"PhoneMetadata",j:"i18n.phonenumbers.PhoneMetadata"},1:{name:"general_desc",b:11,type:H},2:{name:"fixed_line",b:11,type:H},3:{name:"mobile",b:11,type:H},4:{name:"toll_free",b:11,type:H},5:{name:"premium_rate",b:11,type:H},6:{name:"shared_cost",b:11,type:H},7:{name:"personal_number",b:11,type:H},8:{name:"voip",b:11,type:H},21:{name:"pager",b:11,type:H},25:{name:"uan",b:11,type:H},27:{name:"emergency",b:11,type:H},28:{name:"voicemail",b:11,type:H},
29:{name:"short_code",b:11,type:H},30:{name:"standard_rate",b:11,type:H},31:{name:"carrier_specific",b:11,type:H},33:{name:"sms_services",b:11,type:H},24:{name:"no_international_dialling",b:11,type:H},9:{name:"id",required:!0,b:9,type:String},10:{name:"country_code",b:5,type:Number},11:{name:"international_prefix",b:9,type:String},17:{name:"preferred_international_prefix",b:9,type:String},12:{name:"national_prefix",b:9,type:String},13:{name:"preferred_extn_prefix",b:9,type:String},15:{name:"national_prefix_for_parsing",
b:9,type:String},16:{name:"national_prefix_transform_rule",b:9,type:String},18:{name:"same_mobile_and_fixed_line_pattern",b:8,defaultValue:!1,type:Boolean},19:{name:"number_format",i:!0,b:11,type:G},20:{name:"intl_number_format",i:!0,b:11,type:G},22:{name:"main_country_for_code",b:8,defaultValue:!1,type:Boolean},23:{name:"leading_digits",b:9,type:String},26:{name:"leading_zero_possible",b:8,defaultValue:!1,type:Boolean}}));return a};I.f=I.prototype.f;function J(){r.call(this)}n(J,r);var ta=null,ua={$:0,w:1,v:5,u:10,s:20};
J.prototype.f=function(){var a=ta;a||(ta=a=B(J,{0:{name:"PhoneNumber",j:"i18n.phonenumbers.PhoneNumber"},1:{name:"country_code",required:!0,b:5,type:Number},2:{name:"national_number",required:!0,b:4,type:Number},3:{name:"extension",b:9,type:String},4:{name:"italian_leading_zero",b:8,type:Boolean},8:{name:"number_of_leading_zeros",b:5,defaultValue:1,type:Number},5:{name:"raw_input",b:9,type:String},6:{name:"country_code_source",b:14,defaultValue:0,type:ua},7:{name:"preferred_domestic_carrier_code",
b:9,type:String}}));return a};J.ctor=J;J.ctor.f=J.prototype.f;/*

 Copyright (C) 2010 The Libphonenumber Authors

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
*/
var K={1:"US AG AI AS BB BM BS CA DM DO GD GU JM KN KY LC MP MS PR SX TC TT VC VG VI".split(" "),7:["RU","KZ"],20:["EG"],27:["ZA"],30:["GR"],31:["NL"],32:["BE"],33:["FR"],34:["ES"],36:["HU"],39:["IT","VA"],40:["RO"],41:["CH"],43:["AT"],44:["GB","GG","IM","JE"],45:["DK"],46:["SE"],47:["NO","SJ"],48:["PL"],49:["DE"],51:["PE"],52:["MX"],53:["CU"],54:["AR"],55:["BR"],56:["CL"],57:["CO"],58:["VE"],60:["MY"],61:["AU","CC","CX"],62:["ID"],63:["PH"],64:["NZ"],65:["SG"],66:["TH"],81:["JP"],82:["KR"],84:["VN"],
86:["CN"],90:["TR"],91:["IN"],92:["PK"],93:["AF"],94:["LK"],95:["MM"],98:["IR"],211:["SS"],212:["MA","EH"],213:["DZ"],216:["TN"],218:["LY"],220:["GM"],221:["SN"],222:["MR"],223:["ML"],224:["GN"],225:["CI"],226:["BF"],227:["NE"],228:["TG"],229:["BJ"],230:["MU"],231:["LR"],232:["SL"],233:["GH"],234:["NG"],235:["TD"],236:["CF"],237:["CM"],238:["CV"],239:["ST"],240:["GQ"],241:["GA"],242:["CG"],243:["CD"],244:["AO"],245:["GW"],246:["IO"],247:["AC"],248:["SC"],249:["SD"],250:["RW"],251:["ET"],252:["SO"],
253:["DJ"],254:["KE"],255:["TZ"],256:["UG"],257:["BI"],258:["MZ"],260:["ZM"],261:["MG"],262:["RE","YT"],263:["ZW"],264:["NA"],265:["MW"],266:["LS"],267:["BW"],268:["SZ"],269:["KM"],290:["SH","TA"],291:["ER"],297:["AW"],298:["FO"],299:["GL"],350:["GI"],351:["PT"],352:["LU"],353:["IE"],354:["IS"],355:["AL"],356:["MT"],357:["CY"],358:["FI","AX"],359:["BG"],370:["LT"],371:["LV"],372:["EE"],373:["MD"],374:["AM"],375:["BY"],376:["AD"],377:["MC"],378:["SM"],380:["UA"],381:["RS"],382:["ME"],383:["XK"],385:["HR"],
386:["SI"],387:["BA"],389:["MK"],420:["CZ"],421:["SK"],423:["LI"],500:["FK"],501:["BZ"],502:["GT"],503:["SV"],504:["HN"],505:["NI"],506:["CR"],507:["PA"],508:["PM"],509:["HT"],590:["GP","BL","MF"],591:["BO"],592:["GY"],593:["EC"],594:["GF"],595:["PY"],596:["MQ"],597:["SR"],598:["UY"],599:["CW","BQ"],670:["TL"],672:["NF"],673:["BN"],674:["NR"],675:["PG"],676:["TO"],677:["SB"],678:["VU"],679:["FJ"],680:["PW"],681:["WF"],682:["CK"],683:["NU"],685:["WS"],686:["KI"],687:["NC"],688:["TV"],689:["PF"],690:["TK"],
691:["FM"],692:["MH"],800:["001"],808:["001"],850:["KP"],852:["HK"],853:["MO"],855:["KH"],856:["LA"],870:["001"],878:["001"],880:["BD"],881:["001"],882:["001"],883:["001"],886:["TW"],888:["001"],960:["MV"],961:["LB"],962:["JO"],963:["SY"],964:["IQ"],965:["KW"],966:["SA"],967:["YE"],968:["OM"],970:["PS"],971:["AE"],972:["IL"],973:["BH"],974:["QA"],975:["BT"],976:["MN"],977:["NP"],979:["001"],992:["TJ"],993:["TM"],994:["AZ"],995:["GE"],996:["KG"],998:["UZ"]},wa={AC:[,[,,"(?:[01589]\\d|[46])\\d{4}",
,,,,,,[5,6]],[,,"6[2-467]\\d{3}",,,,"62889",,,[5]],[,,"4\\d{4}",,,,"40123",,,[5]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],"AC",247,"00",,,,,,,,,,[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,"(?:0[1-9]|[1589]\\d)\\d{4}",,,,"542011",,,[6]],,,[,,,,,,,,,[-1]]],AD:[,[,,"(?:1|6\\d)\\d{7}|[135-9]\\d{5}",,,,,,,[6,8,9]],[,,"[78]\\d{5}",,,,"712345",,,[6]],[,,"690\\d{6}|[356]\\d{5}",,,,"312345",,,[6,9]],[,,"180[02]\\d{4}",,,,"18001234",,,[8]],[,,"[19]\\d{5}",,,,"912345",,,[6]],
[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],"AD",376,"00",,,,,,,,[[,"(\\d{3})(\\d{3})","$1 $2",["[135-9]"]],[,"(\\d{4})(\\d{4})","$1 $2",["1"]],[,"(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["6"]]],,[,,,,,,,,,[-1]],,,[,,"1800\\d{4}",,,,,,,[8]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],AE:[,[,,"(?:[4-7]\\d|9[0-689])\\d{7}|800\\d{2,9}|[2-4679]\\d{7}",,,,,,,[5,6,7,8,9,10,11,12]],[,,"[2-4679][2-8]\\d{6}",,,,"22345678",,,[8],[7]],[,,"5[024-68]\\d{7}",,,,"501234567",,,[9]],[,,"400\\d{6}|800\\d{2,9}",,,,"800123456"],
[,,"900[02]\\d{5}",,,,"900234567",,,[9]],[,,"700[05]\\d{5}",,,,"700012345",,,[9]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],"AE",971,"00","0",,,"0",,,,[[,"(\\d{3})(\\d{2,9})","$1 $2",["60|8"]],[,"(\\d)(\\d{3})(\\d{4})","$1 $2 $3",["[236]|[479][2-8]"],"0$1"],[,"(\\d{3})(\\d)(\\d{5})","$1 $2 $3",["[479]"]],[,"(\\d{2})(\\d{3})(\\d{4})","$1 $2 $3",["5"],"0$1"]],,[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,"600[25]\\d{5}",,,,"600212345",,,[9]],,,[,,,,,,,,,[-1]]],AF:[,[,,"[2-7]\\d{8}",,,,,,,[9],[7]],[,,"(?:[25][0-8]|[34][0-4]|6[0-5])[2-9]\\d{6}",
,,,"234567890",,,,[7]],[,,"7\\d{8}",,,,"701234567",,,,[7]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],"AF",93,"00","0",,,"0",,,,[[,"(\\d{3})(\\d{4})","$1 $2",["[1-9]"]],[,"(\\d{2})(\\d{3})(\\d{4})","$1 $2 $3",["[2-7]"],"0$1"]],[[,"(\\d{2})(\\d{3})(\\d{4})","$1 $2 $3",["[2-7]"],"0$1"]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],AG:[,[,,"(?:268|[58]\\d\\d|900)\\d{7}",,,,,,,[10],[7]],[,,"268(?:4(?:6[0-38]|84)|56[0-2])\\d{4}",,,,"2684601234",
,,,[7]],[,,"268(?:464|7(?:1[3-9]|[28]\\d|3[0246]|64|7[0-689]))\\d{4}",,,,"2684641234",,,,[7]],[,,"8(?:00|33|44|55|66|77|88)[2-9]\\d{6}",,,,"8002123456"],[,,"900[2-9]\\d{6}",,,,"9002123456"],[,,,,,,,,,[-1]],[,,"52(?:35(?:[02-46-9]\\d|1[02-9]|5[0-46-9])|45(?:[034]\\d|1[02-9]|2[024-9]|5[0-46-9]))\\d{4}|52(?:3[2-46-9]|4[2-4])(?:[02-9]\\d|1[02-9])\\d{4}|5(?:00|2[12]|33|44|66|77|88)[2-9]\\d{6}",,,,"5002345678"],[,,"26848[01]\\d{4}",,,,"2684801234",,,,[7]],"AG",1,"011","1",,,"1|([457]\\d{6})$","268$1",,
,,,[,,"26840[69]\\d{4}",,,,"2684061234",,,,[7]],,"268",[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],AI:[,[,,"(?:264|[58]\\d\\d|900)\\d{7}",,,,,,,[10],[7]],[,,"264(?:292|4(?:6[12]|9[78]))\\d{4}",,,,"2644612345",,,,[7]],[,,"264(?:235|4(?:69|76)|5(?:3[6-9]|8[1-4])|7(?:29|72))\\d{4}",,,,"2642351234",,,,[7]],[,,"8(?:00|33|44|55|66|77|88)[2-9]\\d{6}",,,,"8002123456"],[,,"900[2-9]\\d{6}",,,,"9002123456"],[,,,,,,,,,[-1]],[,,"52(?:35(?:[02-46-9]\\d|1[02-9]|5[0-46-9])|45(?:[034]\\d|1[02-9]|2[024-9]|5[0-46-9]))\\d{4}|52(?:3[2-46-9]|4[2-4])(?:[02-9]\\d|1[02-9])\\d{4}|5(?:00|2[12]|33|44|66|77|88)[2-9]\\d{6}",
,,,"5002345678"],[,,,,,,,,,[-1]],"AI",1,"011","1",,,"1|([2457]\\d{6})$","264$1",,,,,[,,"264724\\d{4}",,,,"2647241234",,,,[7]],,"264",[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],AL:[,[,,"(?:700\\d\\d|900)\\d{3}|8\\d{5,7}|(?:[2-5]|6\\d)\\d{7}",,,,,,,[6,7,8,9],[5]],[,,"(?:[2358](?:[16-9]\\d[2-9]|[2-5][2-9]\\d)|4(?:[2-57-9][2-9]|6\\d)\\d)\\d{4}",,,,"22345678",,,[8],[5,6,7]],[,,"6(?:[78][2-9]|9\\d)\\d{6}",,,,"672123456",,,[9]],[,,"800\\d{4}",,,,"8001234",,,[7]],[,,"900[1-9]\\d\\d",,,,"900123",,
,[6]],[,,"808[1-9]\\d\\d",,,,"808123",,,[6]],[,,"700[2-9]\\d{4}",,,,"70021234",,,[8]],[,,,,,,,,,[-1]],"AL",355,"00","0",,,"0",,,,[[,"(\\d{3})(\\d{3,4})","$1 $2",["80|9"],"0$1"],[,"(\\d)(\\d{3})(\\d{4})","$1 $2 $3",["4[2-6]"],"0$1"],[,"(\\d{2})(\\d{3})(\\d{3})","$1 $2 $3",["[2358][2-5]|4"],"0$1"],[,"(\\d{3})(\\d{5})","$1 $2",["[23578]"],"0$1"],[,"(\\d{2})(\\d{3})(\\d{4})","$1 $2 $3",["6"],"0$1"]],,[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],AM:[,[,,"(?:[1-489]\\d|55|60|77)\\d{6}",
,,,,,,[8],[5,6]],[,,"(?:(?:1[0-25]|47)\\d|2(?:2[2-46]|3[1-8]|4[2-69]|5[2-7]|6[1-9]|8[1-7])|3[12]2)\\d{5}",,,,"10123456",,,,[5,6]],[,,"(?:33|4[1349]|55|77|88|9[13-9])\\d{6}",,,,"77123456"],[,,"800\\d{5}",,,,"80012345"],[,,"90[016]\\d{5}",,,,"90012345"],[,,"80[1-4]\\d{5}",,,,"80112345"],[,,,,,,,,,[-1]],[,,"60(?:2[78]|3[5-9]|4[02-9]|5[0-46-9]|[6-8]\\d|90)\\d{4}",,,,"60271234"],"AM",374,"00","0",,,"0",,,,[[,"(\\d{3})(\\d{2})(\\d{3})","$1 $2 $3",["[89]0"],"0 $1"],[,"(\\d{3})(\\d{5})","$1 $2",["2|3[12]"],
"(0$1)"],[,"(\\d{2})(\\d{6})","$1 $2",["1|47"],"(0$1)"],[,"(\\d{2})(\\d{6})","$1 $2",["[3-9]"],"0$1"]],,[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],AO:[,[,,"[29]\\d{8}",,,,,,,[9]],[,,"2\\d(?:[0134][25-9]|[25-9]\\d)\\d{5}",,,,"222123456"],[,,"9[1-49]\\d{7}",,,,"923123456"],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],"AO",244,"00",,,,,,,,[[,"(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["[29]"]]],,[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],
,,[,,,,,,,,,[-1]]],AR:[,[,,"11\\d{8}|(?:[2368]|9\\d)\\d{9}",,,,,,,[10,11],[6,7,8]],[,,"(?:2954|3(?:777|865))[2-8]\\d{5}|3(?:7(?:1[15]|81)|8(?:21|4[16]|69|9[12]))[46]\\d{5}|(?:(?:11[1-8]|670)\\d|2(?:2(?:1[2-6]|3[3-6])|(?:3[06]|49)4|6(?:04|1[2-7]|4[4-6])|9(?:[17][4-6]|9[3-6]))|3(?:(?:36|64)4|4(?:1[2-7]|[235][4-6]|84)|5(?:1[2-8]|[38][4-6])|8(?:1[2-6]|[58][3-6]|7[24-6])))\\d{6}|(?:2(?:284|657|9(?:20|66))|3(?:4(?:8[27]|92)|755|878))[2-7]\\d{5}|(?:2(?:[28]0|37|6[36]|9[48])|3(?:62|7[069]|8[03]))[45]\\d{6}|(?:2(?:2(?:2[59]|44|52)|3(?:26|4[24])|473|9(?:[07]2|2[26]|34|46))|3327)[45]\\d{5}|(?:2(?:(?:26|62)2|3(?:02|2[03])|477|9(?:42|83))|3(?:4(?:[47]6|62|89)|5(?:41|64)|873))[2-6]\\d{5}|2(?:2(?:21|4[23]|6[145]|7[1-4]|8[356]|9[267])|3(?:16|3[13-8]|43|5[346-8]|9[3-5])|475|6(?:2[46]|4[78]|5[1568])|9(?:03|2[1457-9]|3[1356]|4[08]|[56][23]|82))4\\d{5}|(?:2(?:2(?:57|81)|3(?:24|46|92)|9(?:01|23|64))|3(?:329|4(?:42|71)|5(?:25|37|4[347]|71)|7(?:18|5[17])|888))[3-6]\\d{5}|(?:2(?:2(?:02|2[3467]|4[156]|5[45]|6[6-8]|91)|3(?:1[47]|[24]5|5[25]|96)|47[48]|625|932)|3(?:38[2578]|4(?:0[0-24-9]|3[78]|4[457]|58|6[03-9]|72|83|9[136-8])|5(?:2[124]|[368][23]|4[2689]|7[2-6])|7(?:16|2[15]|3[145]|4[13]|5[468]|7[2-5]|8[26])|8(?:2[5-7]|3[278]|4[3-5]|5[78]|6[1-378]|[78]7|94)))[4-6]\\d{5}",
,,,"1123456789",,,[10],[6,7,8]],[,,"9(?:2954|3(?:777|865))[2-8]\\d{5}|93(?:7(?:1[15]|81)|8(?:21|4[16]|69|9[12]))[46]\\d{5}|(?:675\\d|9(?:11[1-8]\\d|2(?:2(?:1[2-6]|3[3-6])|(?:3[06]|49)4|6(?:04|1[2-7]|4[4-6])|9(?:[17][4-6]|9[3-6]))|3(?:(?:36|64)4|4(?:1[2-7]|[235][4-6]|84)|5(?:1[2-8]|[38][4-6])|8(?:1[2-6]|[58][3-6]|7[24-6]))))\\d{6}|9(?:2(?:284|657|9(?:20|66))|3(?:4(?:8[27]|92)|755|878))[2-7]\\d{5}|9(?:2(?:[28]0|37|6[36]|9[48])|3(?:62|7[069]|8[03]))[45]\\d{6}|9(?:2(?:2(?:2[59]|44|52)|3(?:26|4[24])|473|9(?:[07]2|2[26]|34|46))|3327)[45]\\d{5}|9(?:2(?:(?:26|62)2|3(?:02|2[03])|477|9(?:42|83))|3(?:4(?:[47]6|62|89)|5(?:41|64)|873))[2-6]\\d{5}|92(?:2(?:21|4[23]|6[145]|7[1-4]|8[356]|9[267])|3(?:16|3[13-8]|43|5[346-8]|9[3-5])|475|6(?:2[46]|4[78]|5[1568])|9(?:03|2[1457-9]|3[1356]|4[08]|[56][23]|82))4\\d{5}|9(?:2(?:2(?:57|81)|3(?:24|46|92)|9(?:01|23|64))|3(?:329|4(?:42|71)|5(?:25|37|4[347]|71)|7(?:18|5[17])|888))[3-6]\\d{5}|9(?:2(?:2(?:02|2[3467]|4[156]|5[45]|6[6-8]|91)|3(?:1[47]|[24]5|5[25]|96)|47[48]|625|932)|3(?:38[2578]|4(?:0[0-24-9]|3[78]|4[457]|58|6[03-9]|72|83|9[136-8])|5(?:2[124]|[368][23]|4[2689]|7[2-6])|7(?:16|2[15]|3[145]|4[13]|5[468]|7[2-5]|8[26])|8(?:2[5-7]|3[278]|4[3-5]|5[78]|6[1-378]|[78]7|94)))[4-6]\\d{5}",
,,,"91123456789",,,,[6,7,8]],[,,"800\\d{7}",,,,"8001234567",,,[10]],[,,"60[04579]\\d{7}",,,,"6001234567",,,[10]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],"AR",54,"00","0",,,"0?(?:(11|2(?:2(?:02?|[13]|2[13-79]|4[1-6]|5[2457]|6[124-8]|7[1-4]|8[13-6]|9[1267])|3(?:02?|1[467]|2[03-6]|3[13-8]|[49][2-6]|5[2-8]|[67])|4(?:7[3-578]|9)|6(?:[0136]|2[24-6]|4[6-8]?|5[15-8])|80|9(?:0[1-3]|[19]|2\\d|3[1-6]|4[02568]?|5[2-4]|6[2-46]|72?|8[23]?))|3(?:3(?:2[79]|6|8[2578])|4(?:0[0-24-9]|[12]|3[5-8]?|4[24-7]|5[4-68]?|6[02-9]|7[126]|8[2379]?|9[1-36-8])|5(?:1|2[1245]|3[237]?|4[1-46-9]|6[2-4]|7[1-6]|8[2-5]?)|6[24]|7(?:[069]|1[1568]|2[15]|3[145]|4[13]|5[14-8]|7[2-57]|8[126])|8(?:[01]|2[15-7]|3[2578]?|4[13-6]|5[4-8]?|6[1-357-9]|7[36-8]?|8[5-8]?|9[124])))15)?",
"9$1",,,[[,"(\\d{3})","$1",["[09]|1(?:0[0-35-7]|1[02-5]|2[15])"]],[,"(\\d{2})(\\d{4})","$1-$2",["[2-8]"]],[,"(\\d{3})(\\d{4})","$1-$2",["[2-8]"]],[,"(\\d{4})(\\d{4})","$1-$2",["[1-8]"]],[,"(\\d{4})(\\d{2})(\\d{4})","$1 $2-$3",["2(?:2[024-9]|3[0-59]|47|6[245]|9[02-8])|3(?:3[28]|4[03-9]|5[2-46-8]|7[1-578]|8[2-9])","2(?:[23]02|6(?:[25]|4[6-8])|9(?:[02356]|4[02568]|72|8[23]))|3(?:3[28]|4(?:[04679]|3[5-8]|5[4-68]|8[2379])|5(?:[2467]|3[237]|8[2-5])|7[1-578]|8(?:[2469]|3[2578]|5[4-8]|7[36-8]|8[5-8]))|2(?:2[24-9]|3[1-59]|47)",
"2(?:[23]02|6(?:[25]|4(?:64|[78]))|9(?:[02356]|4(?:[0268]|5[2-6])|72|8[23]))|3(?:3[28]|4(?:[04679]|3[78]|5(?:4[46]|8)|8[2379])|5(?:[2467]|3[237]|8[23])|7[1-578]|8(?:[2469]|3[278]|5[56][46]|86[3-6]))|2(?:2[24-9]|3[1-59]|47)|38(?:[58][78]|7[378])|3(?:4[35][56]|58[45]|8(?:[38]5|54|76))[4-6]","2(?:[23]02|6(?:[25]|4(?:64|[78]))|9(?:[02356]|4(?:[0268]|5[2-6])|72|8[23]))|3(?:3[28]|4(?:[04679]|3(?:5(?:4[0-25689]|[56])|[78])|58|8[2379])|5(?:[2467]|3[237]|8(?:[23]|4(?:[45]|60)|5(?:4[0-39]|5|64)))|7[1-578]|8(?:[2469]|3[278]|54(?:4|5[13-7]|6[89])|86[3-6]))|2(?:2[24-9]|3[1-59]|47)|38(?:[58][78]|7[378])|3(?:454|85[56])[46]|3(?:4(?:36|5[56])|8(?:[38]5|76))[4-6]"],
"0$1",,1],[,"(\\d{2})(\\d{4})(\\d{4})","$1 $2-$3",["1"],"0$1",,1],[,"(\\d{3})(\\d{3})(\\d{4})","$1-$2-$3",["[68]"],"0$1"],[,"(\\d{3})(\\d{3})(\\d{4})","$1 $2-$3",["[23]"],"0$1",,1],[,"(\\d)(\\d{4})(\\d{2})(\\d{4})","$2 15-$3-$4",["9(?:2[2-469]|3[3-578])","9(?:2(?:2[024-9]|3[0-59]|47|6[245]|9[02-8])|3(?:3[28]|4[03-9]|5[2-46-8]|7[1-578]|8[2-9]))","9(?:2(?:[23]02|6(?:[25]|4[6-8])|9(?:[02356]|4[02568]|72|8[23]))|3(?:3[28]|4(?:[04679]|3[5-8]|5[4-68]|8[2379])|5(?:[2467]|3[237]|8[2-5])|7[1-578]|8(?:[2469]|3[2578]|5[4-8]|7[36-8]|8[5-8])))|92(?:2[24-9]|3[1-59]|47)",
"9(?:2(?:[23]02|6(?:[25]|4(?:64|[78]))|9(?:[02356]|4(?:[0268]|5[2-6])|72|8[23]))|3(?:3[28]|4(?:[04679]|3[78]|5(?:4[46]|8)|8[2379])|5(?:[2467]|3[237]|8[23])|7[1-578]|8(?:[2469]|3[278]|5(?:[56][46]|[78])|7[378]|8(?:6[3-6]|[78]))))|92(?:2[24-9]|3[1-59]|47)|93(?:4[35][56]|58[45]|8(?:[38]5|54|76))[4-6]","9(?:2(?:[23]02|6(?:[25]|4(?:64|[78]))|9(?:[02356]|4(?:[0268]|5[2-6])|72|8[23]))|3(?:3[28]|4(?:[04679]|3(?:5(?:4[0-25689]|[56])|[78])|5(?:4[46]|8)|8[2379])|5(?:[2467]|3[237]|8(?:[23]|4(?:[45]|60)|5(?:4[0-39]|5|64)))|7[1-578]|8(?:[2469]|3[278]|5(?:4(?:4|5[13-7]|6[89])|[56][46]|[78])|7[378]|8(?:6[3-6]|[78]))))|92(?:2[24-9]|3[1-59]|47)|93(?:4(?:36|5[56])|8(?:[38]5|76))[4-6]"],
"0$1"],[,"(\\d)(\\d{2})(\\d{4})(\\d{4})","$2 15-$3-$4",["91"],"0$1"],[,"(\\d)(\\d{3})(\\d{3})(\\d{4})","$2 15-$3-$4",["9"],"0$1"]],[[,"(\\d{4})(\\d{2})(\\d{4})","$1 $2-$3",["2(?:2[024-9]|3[0-59]|47|6[245]|9[02-8])|3(?:3[28]|4[03-9]|5[2-46-8]|7[1-578]|8[2-9])","2(?:[23]02|6(?:[25]|4[6-8])|9(?:[02356]|4[02568]|72|8[23]))|3(?:3[28]|4(?:[04679]|3[5-8]|5[4-68]|8[2379])|5(?:[2467]|3[237]|8[2-5])|7[1-578]|8(?:[2469]|3[2578]|5[4-8]|7[36-8]|8[5-8]))|2(?:2[24-9]|3[1-59]|47)","2(?:[23]02|6(?:[25]|4(?:64|[78]))|9(?:[02356]|4(?:[0268]|5[2-6])|72|8[23]))|3(?:3[28]|4(?:[04679]|3[78]|5(?:4[46]|8)|8[2379])|5(?:[2467]|3[237]|8[23])|7[1-578]|8(?:[2469]|3[278]|5[56][46]|86[3-6]))|2(?:2[24-9]|3[1-59]|47)|38(?:[58][78]|7[378])|3(?:4[35][56]|58[45]|8(?:[38]5|54|76))[4-6]",
"2(?:[23]02|6(?:[25]|4(?:64|[78]))|9(?:[02356]|4(?:[0268]|5[2-6])|72|8[23]))|3(?:3[28]|4(?:[04679]|3(?:5(?:4[0-25689]|[56])|[78])|58|8[2379])|5(?:[2467]|3[237]|8(?:[23]|4(?:[45]|60)|5(?:4[0-39]|5|64)))|7[1-578]|8(?:[2469]|3[278]|54(?:4|5[13-7]|6[89])|86[3-6]))|2(?:2[24-9]|3[1-59]|47)|38(?:[58][78]|7[378])|3(?:454|85[56])[46]|3(?:4(?:36|5[56])|8(?:[38]5|76))[4-6]"],"0$1",,1],[,"(\\d{2})(\\d{4})(\\d{4})","$1 $2-$3",["1"],"0$1",,1],[,"(\\d{3})(\\d{3})(\\d{4})","$1-$2-$3",["[68]"],"0$1"],[,"(\\d{3})(\\d{3})(\\d{4})",
"$1 $2-$3",["[23]"],"0$1",,1],[,"(\\d)(\\d{4})(\\d{2})(\\d{4})","$1 $2 $3-$4",["9(?:2[2-469]|3[3-578])","9(?:2(?:2[024-9]|3[0-59]|47|6[245]|9[02-8])|3(?:3[28]|4[03-9]|5[2-46-8]|7[1-578]|8[2-9]))","9(?:2(?:[23]02|6(?:[25]|4[6-8])|9(?:[02356]|4[02568]|72|8[23]))|3(?:3[28]|4(?:[04679]|3[5-8]|5[4-68]|8[2379])|5(?:[2467]|3[237]|8[2-5])|7[1-578]|8(?:[2469]|3[2578]|5[4-8]|7[36-8]|8[5-8])))|92(?:2[24-9]|3[1-59]|47)","9(?:2(?:[23]02|6(?:[25]|4(?:64|[78]))|9(?:[02356]|4(?:[0268]|5[2-6])|72|8[23]))|3(?:3[28]|4(?:[04679]|3[78]|5(?:4[46]|8)|8[2379])|5(?:[2467]|3[237]|8[23])|7[1-578]|8(?:[2469]|3[278]|5(?:[56][46]|[78])|7[378]|8(?:6[3-6]|[78]))))|92(?:2[24-9]|3[1-59]|47)|93(?:4[35][56]|58[45]|8(?:[38]5|54|76))[4-6]",
"9(?:2(?:[23]02|6(?:[25]|4(?:64|[78]))|9(?:[02356]|4(?:[0268]|5[2-6])|72|8[23]))|3(?:3[28]|4(?:[04679]|3(?:5(?:4[0-25689]|[56])|[78])|5(?:4[46]|8)|8[2379])|5(?:[2467]|3[237]|8(?:[23]|4(?:[45]|60)|5(?:4[0-39]|5|64)))|7[1-578]|8(?:[2469]|3[278]|5(?:4(?:4|5[13-7]|6[89])|[56][46]|[78])|7[378]|8(?:6[3-6]|[78]))))|92(?:2[24-9]|3[1-59]|47)|93(?:4(?:36|5[56])|8(?:[38]5|76))[4-6]"]],[,"(\\d)(\\d{2})(\\d{4})(\\d{4})","$1 $2 $3-$4",["91"]],[,"(\\d)(\\d{3})(\\d{3})(\\d{4})","$1 $2 $3-$4",["9"]]],[,,,,,,,,,[-1]],
,,[,,"810\\d{7}",,,,,,,[10]],[,,"810\\d{7}",,,,"8101234567",,,[10]],,,[,,,,,,,,,[-1]]],AS:[,[,,"(?:[58]\\d\\d|684|900)\\d{7}",,,,,,,[10],[7]],[,,"6846(?:22|33|44|55|77|88|9[19])\\d{4}",,,,"6846221234",,,,[7]],[,,"684(?:2(?:48|5[2468]|72)|7(?:3[13]|70|82))\\d{4}",,,,"6847331234",,,,[7]],[,,"8(?:00|33|44|55|66|77|88)[2-9]\\d{6}",,,,"8002123456"],[,,"900[2-9]\\d{6}",,,,"9002123456"],[,,,,,,,,,[-1]],[,,"52(?:35(?:[02-46-9]\\d|1[02-9]|5[0-46-9])|45(?:[034]\\d|1[02-9]|2[024-9]|5[0-46-9]))\\d{4}|52(?:3[2-46-9]|4[2-4])(?:[02-9]\\d|1[02-9])\\d{4}|5(?:00|2[12]|33|44|66|77|88)[2-9]\\d{6}",
,,,"5002345678"],[,,,,,,,,,[-1]],"AS",1,"011","1",,,"1|([267]\\d{6})$","684$1",,,,,[,,,,,,,,,[-1]],,"684",[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],AT:[,[,,"1\\d{3,12}|2\\d{6,12}|43(?:(?:0\\d|5[02-9])\\d{3,9}|2\\d{4,5}|[3467]\\d{4}|8\\d{4,6}|9\\d{4,7})|5\\d{4,12}|8\\d{7,12}|9\\d{8,12}|(?:[367]\\d|4[0-24-9])\\d{4,11}",,,,,,,[4,5,6,7,8,9,10,11,12,13],[3]],[,,"1(?:11\\d|[2-9]\\d{3,11})|(?:316|463|(?:51|66|73)2)\\d{3,10}|(?:2(?:1[467]|2[13-8]|5[2357]|6[1-46-8]|7[1-8]|8[124-7]|9[1458])|3(?:1[1-578]|3[23568]|4[5-7]|5[1378]|6[1-38]|8[3-68])|4(?:2[1-8]|35|7[1368]|8[2457])|5(?:2[1-8]|3[357]|4[147]|5[12578]|6[37])|6(?:13|2[1-47]|4[135-8]|5[468])|7(?:2[1-8]|35|4[13478]|5[68]|6[16-8]|7[1-6]|9[45]))\\d{4,10}",
,,,"1234567890",,,,[3]],[,,"6(?:5[0-3579]|6[013-9]|[7-9]\\d)\\d{4,10}",,,,"664123456",,,[7,8,9,10,11,12,13]],[,,"800\\d{6,10}",,,,"800123456",,,[9,10,11,12,13]],[,,"9(?:0[01]|3[019])\\d{6,10}",,,,"900123456",,,[9,10,11,12,13]],[,,"8(?:10|2[018])\\d{6,10}|828\\d{5}",,,,"810123456",,,[8,9,10,11,12,13]],[,,,,,,,,,[-1]],[,,"5(?:0[1-9]|17|[79]\\d)\\d{2,10}|7[28]0\\d{6,10}",,,,"780123456",,,[5,6,7,8,9,10,11,12,13]],"AT",43,"00","0",,,"0",,,,[[,"(\\d)(\\d{3,12})","$1 $2",["1(?:11|[2-9])"],"0$1"],[,"(\\d{3})(\\d{2})",
"$1 $2",["517"],"0$1"],[,"(\\d{2})(\\d{3,5})","$1 $2",["5[079]"],"0$1"],[,"(\\d{6})","$1",["1"]],[,"(\\d{3})(\\d{3,10})","$1 $2",["(?:31|4)6|51|6(?:5[0-3579]|[6-9])|7(?:20|32|8)|[89]"],"0$1"],[,"(\\d{4})(\\d{3,9})","$1 $2",["[2-467]|5[2-6]"],"0$1"],[,"(\\d{2})(\\d{3})(\\d{3,4})","$1 $2 $3",["5"],"0$1"],[,"(\\d{2})(\\d{4})(\\d{4,7})","$1 $2 $3",["5"],"0$1"]],[[,"(\\d)(\\d{3,12})","$1 $2",["1(?:11|[2-9])"],"0$1"],[,"(\\d{3})(\\d{2})","$1 $2",["517"],"0$1"],[,"(\\d{2})(\\d{3,5})","$1 $2",["5[079]"],
"0$1"],[,"(\\d{3})(\\d{3,10})","$1 $2",["(?:31|4)6|51|6(?:5[0-3579]|[6-9])|7(?:20|32|8)|[89]"],"0$1"],[,"(\\d{4})(\\d{3,9})","$1 $2",["[2-467]|5[2-6]"],"0$1"],[,"(\\d{2})(\\d{3})(\\d{3,4})","$1 $2 $3",["5"],"0$1"],[,"(\\d{2})(\\d{4})(\\d{4,7})","$1 $2 $3",["5"],"0$1"]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],AU:[,[,,"1(?:[0-79]\\d{7,8}|8[0-24-9]\\d{7})|(?:[2-478]\\d\\d|550)\\d{6}|1\\d{4,7}",,,,,,,[5,6,7,8,9,10]],[,,"(?:[237]\\d{5}|8(?:51(?:0(?:0[03-9]|[1247]\\d|3[2-9]|5[0-8]|6[1-9]|8[0-6])|1(?:1[69]|[23]\\d|4[0-4]))|(?:[6-8]\\d{3}|9(?:[02-9]\\d\\d|1(?:[0-57-9]\\d|6[0135-9])))\\d))\\d{3}",
,,,"212345678",,,[9],[8]],[,,"483[0-3]\\d{5}|4(?:[0-3]\\d|4[047-9]|5[0-25-9]|6[06-9]|7[02-9]|8[0-2457-9]|9[0-27-9])\\d{6}",,,,"412345678",,,[9]],[,,"180(?:0\\d{3}|2)\\d{3}",,,,"1800123456",,,[7,10]],[,,"190[0-26]\\d{6}",,,,"1900123456",,,[10]],[,,"13(?:00\\d{3}|45[0-4])\\d{3}|13\\d{4}",,,,"1300123456",,,[6,8,10]],[,,,,,,,,,[-1]],[,,"(?:14(?:5(?:1[0458]|[23][458])|71\\d)|550\\d\\d)\\d{4}",,,,"550123456",,,[9]],"AU",61,"001[14-689]|14(?:1[14]|34|4[17]|[56]6|7[47]|88)0011","0",,,"0|(183[12])",,"0011",
,[[,"(\\d{2})(\\d{3,4})","$1 $2",["16"],"0$1"],[,"(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3",["13"]],[,"(\\d{3})(\\d{3})","$1 $2",["19"]],[,"(\\d{3})(\\d{4})","$1 $2",["180","1802"]],[,"(\\d{4})(\\d{3,4})","$1 $2",["19"]],[,"(\\d{2})(\\d{3})(\\d{2,4})","$1 $2 $3",["16"],"0$1"],[,"(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["14|[45]"],"0$1"],[,"(\\d)(\\d{4})(\\d{4})","$1 $2 $3",["[2378]"],"(0$1)","$CC ($1)"],[,"(\\d{4})(\\d{3})(\\d{3})","$1 $2 $3",["1(?:30|[89])"]]],[[,"(\\d{2})(\\d{3,4})","$1 $2",["16"],"0$1"],
[,"(\\d{2})(\\d{3})(\\d{2,4})","$1 $2 $3",["16"],"0$1"],[,"(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["14|[45]"],"0$1"],[,"(\\d)(\\d{4})(\\d{4})","$1 $2 $3",["[2378]"],"(0$1)","$CC ($1)"],[,"(\\d{4})(\\d{3})(\\d{3})","$1 $2 $3",["1(?:30|[89])"]]],[,,"16\\d{3,7}",,,,"1612345",,,[5,6,7,8,9]],1,,[,,"1[38]00\\d{6}|1(?:345[0-4]|802)\\d{3}|13\\d{4}",,,,,,,[6,7,8,10]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],AW:[,[,,"(?:[25-79]\\d\\d|800)\\d{4}",,,,,,,[7]],[,,"5(?:2\\d|8[1-9])\\d{4}",,,,"5212345"],[,,"(?:290|5[69]\\d|6(?:[03]0|22|4[0-2]|[69]\\d)|7(?:[34]\\d|7[07])|9(?:6[45]|9[4-8]))\\d{4}",
,,,"5601234"],[,,"800\\d{4}",,,,"8001234"],[,,"900\\d{4}",,,,"9001234"],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,"(?:28\\d|501)\\d{4}",,,,"5011234"],"AW",297,"00",,,,,,,,[[,"(\\d{3})(\\d{4})","$1 $2",["[25-9]"]]],,[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],AX:[,[,,"2\\d{4,9}|35\\d{4,5}|(?:60\\d\\d|800)\\d{4,6}|7\\d{5,11}|(?:[14]\\d|3[0-46-9]|50)\\d{4,8}",,,,,,,[5,6,7,8,9,10,11,12]],[,,"18[1-8]\\d{3,6}",,,,"181234567",,,[6,7,8,9]],[,,"(?:4[0-8]|50)\\d{4,8}",,,,"412345678",,,[6,
7,8,9,10]],[,,"800\\d{4,6}",,,,"800123456",,,[7,8,9]],[,,"[67]00\\d{5,6}",,,,"600123456",,,[8,9]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],"AX",358,"00|99(?:[01469]|5(?:[14]1|3[23]|5[59]|77|88|9[09]))","0",,,"0",,"00",,,,[,,,,,,,,,[-1]],,"18",[,,,,,,,,,[-1]],[,,"20\\d{4,8}|60[12]\\d{5,6}|7(?:099\\d{4,5}|5[03-9]\\d{3,7})|20[2-59]\\d\\d|(?:606|7(?:0[78]|1|3\\d))\\d{7}|(?:10|29|3[09]|70[1-5]\\d)\\d{4,8}",,,,"10112345"],,,[,,,,,,,,,[-1]]],AZ:[,[,,"365\\d{6}|(?:[124579]\\d|60|88)\\d{7}",,,,,,,[9],
[7]],[,,"(?:222[0-79]\\d|365(?:[0-46-9]\\d|5[0-35-9]))\\d{4}|(?:(?:1[28]|46)\\d|2(?:[045]2|1[24]|2[34]|33|6[23]))\\d{6}",,,,"123123456",,,,[7]],[,,"(?:36554|99[2-9]\\d\\d)\\d{4}|(?:[16]0|4[04]|5[015]|7[07])\\d{7}",,,,"401234567"],[,,"88\\d{7}",,,,"881234567"],[,,"900200\\d{3}",,,,"900200123"],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],"AZ",994,"00","0",,,"0",,,,[[,"(\\d{3})(\\d{2})(\\d{2})","$1 $2 $3",["[1-9]"]],[,"(\\d{3})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["90"],"0$1"],[,"(\\d{2})(\\d{3})(\\d{2})(\\d{2})",
"$1 $2 $3 $4",["1[28]|2|365|46","1[28]|2|365|46","1[28]|2|365(?:[0-46-9]|5[0-35-9])|46"],"(0$1)"],[,"(\\d{2})(\\d{3})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[13-9]"],"0$1"]],[[,"(\\d{3})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["90"],"0$1"],[,"(\\d{2})(\\d{3})(\\d{2})(\\d{2})","$1 $2 $3 $4",["1[28]|2|365|46","1[28]|2|365|46","1[28]|2|365(?:[0-46-9]|5[0-35-9])|46"],"(0$1)"],[,"(\\d{2})(\\d{3})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[13-9]"],"0$1"]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,
[-1]]],BA:[,[,,"6\\d{8}|(?:[35689]\\d|49|70)\\d{6}",,,,,,,[8,9],[6]],[,,"(?:3(?:[05-79][2-9]|1[4579]|[23][24-9]|4[2-4689]|8[2457-9])|49[2-579]|5(?:0[2-49]|[13][2-9]|[268][2-4679]|4[4689]|5[2-79]|7[2-69]|9[2-4689]))\\d{5}",,,,"30212345",,,[8],[6]],[,,"6040[0-4]\\d{4}|6(?:03|[1-356]|44|7\\d)\\d{6}",,,,"61123456"],[,,"8[08]\\d{6}",,,,"80123456",,,[8]],[,,"9[0246]\\d{6}",,,,"90123456",,,[8]],[,,"8[12]\\d{6}",,,,"82123456",,,[8]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],"BA",387,"00","0",,,"0",,,,[[,"(\\d{3})(\\d{3})",
"$1-$2",["[2-9]"]],[,"(\\d{2})(\\d{3})(\\d{3})","$1 $2 $3",["6[1-3]|[7-9]"],"0$1"],[,"(\\d{2})(\\d{3})(\\d{3})","$1 $2-$3",["[3-5]|6[56]"],"0$1"],[,"(\\d{2})(\\d{2})(\\d{2})(\\d{3})","$1 $2 $3 $4",["6"],"0$1"]],[[,"(\\d{2})(\\d{3})(\\d{3})","$1 $2 $3",["6[1-3]|[7-9]"],"0$1"],[,"(\\d{2})(\\d{3})(\\d{3})","$1 $2-$3",["[3-5]|6[56]"],"0$1"],[,"(\\d{2})(\\d{2})(\\d{2})(\\d{3})","$1 $2 $3 $4",["6"],"0$1"]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,"70(?:3[0146]|[56]0)\\d{4}",,,,"70341234",,,[8]],,,[,,,,,,,,
,[-1]]],BB:[,[,,"(?:246|[58]\\d\\d|900)\\d{7}",,,,,,,[10],[7]],[,,"246(?:2(?:2[78]|7[0-4])|4(?:1[024-6]|2\\d|3[2-9])|5(?:20|[34]\\d|54|7[1-3])|6(?:2\\d|38)|7[35]7|9(?:1[89]|63))\\d{4}",,,,"2464123456",,,,[7]],[,,"246(?:2(?:[3568]\\d|4[0-57-9])|45\\d|69[5-7]|8(?:[2-5]\\d|83))\\d{4}",,,,"2462501234",,,,[7]],[,,"8(?:00|33|44|55|66|77|88)[2-9]\\d{6}",,,,"8002123456"],[,,"(?:246976|900[2-9]\\d\\d)\\d{4}",,,,"9002123456",,,,[7]],[,,,,,,,,,[-1]],[,,"52(?:35(?:[02-46-9]\\d|1[02-9]|5[0-46-9])|45(?:[034]\\d|1[02-9]|2[024-9]|5[0-46-9]))\\d{4}|52(?:3[2-46-9]|4[2-4])(?:[02-9]\\d|1[02-9])\\d{4}|5(?:00|2[12]|33|44|66|77|88)[2-9]\\d{6}",
,,,"5002345678"],[,,"24631\\d{5}",,,,"2463101234",,,,[7]],"BB",1,"011","1",,,"1|([2-9]\\d{6})$","246$1",,,,,[,,,,,,,,,[-1]],,"246",[,,,,,,,,,[-1]],[,,"246(?:292|367|4(?:1[7-9]|3[01]|44|67)|7(?:36|53))\\d{4}",,,,"2464301234",,,,[7]],,,[,,,,,,,,,[-1]]],BD:[,[,,"1\\d{9}|2\\d{7,8}|88\\d{4,6}|(?:8[0-79]|9\\d)\\d{4,8}|(?:[346]\\d|[57])\\d{5,8}",,,,,,,[6,7,8,9,10]],[,,"(?:4(?:31\\d\\d|423)|5222)\\d{3}(?:\\d{2})?|8332[6-9]\\d\\d|(?:3(?:03[56]|224)|4(?:22[25]|653))\\d{3,4}|(?:3(?:42[47]|529|823)|4(?:027|525|65(?:28|8))|562|6257|7(?:1(?:5[3-5]|6[12]|7[156]|89)|22[589]56|32|42675|52(?:[25689](?:56|8)|[347]8)|71(?:6[1267]|75|89)|92374)|82(?:2[59]|32)56|9(?:03[23]56|23(?:256|373)|31|5(?:1|2[4589]56)))\\d{3}|(?:3(?:02[348]|22[35]|324|422)|4(?:22[67]|32[236-9]|6(?:2[46]|5[57])|953)|5526|6(?:024|6655)|81)\\d{4,5}|(?:2(?:7(?:1[0-267]|2[0-289]|3[0-29]|4[01]|5[1-3]|6[013]|7[0178]|91)|8(?:0[125]|1[1-6]|2[0157-9]|3[1-69]|41|6[1-35]|7[1-5]|8[1-8]|9[0-6])|9(?:0[0-2]|1[0-4]|2[568]|3[3-6]|5[5-7]|6[0136-9]|7[0-7]|8[014-9]))|3(?:0(?:2[025-79]|3[2-4])|181|22[12]|32[2356]|824)|4(?:02[09]|22[348]|32[045]|523|6(?:27|54))|666(?:22|53)|7(?:22[57-9]|42[56]|82[35])8|8(?:0[124-9]|2(?:181|2[02-4679]8)|4[12]|[5-7]2)|9(?:[04]2|2(?:2|328)|81))\\d{4}|(?:2[45]\\d\\d|3(?:1(?:2[5-7]|[5-7])|425|822)|4(?:033|1\\d|[257]1|332|4(?:2[246]|5[25])|6(?:2[35]|56|62)|8(?:23|54)|92[2-5])|5(?:02[03489]|22[457]|32[35-79]|42[46]|6(?:[18]|53)|724|826)|6(?:023|2(?:2[2-5]|5[3-5]|8)|32[3478]|42[34]|52[47]|6(?:[18]|6(?:2[34]|5[24]))|[78]2[2-5]|92[2-6])|7(?:02|21\\d|[3-589]1|6[12]|72[24])|8(?:217|3[12]|[5-7]1)|9[24]1)\\d{5}|(?:(?:3[2-8]|5[2-57-9]|6[03-589])1|4[4689][18])\\d{5}|[59]1\\d{5}",
,,,"27111234"],[,,"(?:1[13-9]\\d|644)\\d{7}|(?:3[78]|44|66)[02-9]\\d{7}",,,,"1812345678",,,[10]],[,,"80[03]\\d{7}",,,,"8001234567",,,[10]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,"96(?:0[469]|1[0-47]|3[389]|6[69]|7[78])\\d{6}",,,,"9604123456",,,[10]],"BD",880,"00","0",,,"0",,,,[[,"(\\d{2})(\\d{4,6})","$1-$2",["31[5-8]|[459]1"],"0$1"],[,"(\\d{3})(\\d{3,7})","$1-$2",["3(?:[67]|8[013-9])|4(?:6[168]|7|[89][18])|5(?:6[128]|9)|6(?:28|4[14]|5)|7[2-589]|8(?:0[014-9]|[12])|9[358]|(?:3[2-5]|4[235]|5[2-578]|6[0389]|76|8[3-7]|9[24])1|(?:44|66)[01346-9]"],
"0$1"],[,"(\\d{4})(\\d{3,6})","$1-$2",["[13-9]"],"0$1"],[,"(\\d)(\\d{7,8})","$1-$2",["2"],"0$1"]],,[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],BE:[,[,,"4\\d{8}|[1-9]\\d{7}",,,,,,,[8,9]],[,,"80[2-8]\\d{5}|(?:1[0-69]|[23][2-8]|4[23]|5\\d|6[013-57-9]|71|8[1-79]|9[2-4])\\d{6}",,,,"12345678",,,[8]],[,,"4[5-9]\\d{7}",,,,"470123456",,,[9]],[,,"800[1-9]\\d{4}",,,,"80012345",,,[8]],[,,"(?:70(?:2[0-57]|3[0457]|44|69|7[0579])|90(?:0[0-35-8]|1[36]|2[0-3568]|3[0135689]|4[2-68]|5[1-68]|6[0-378]|7[23568]|9[34679]))\\d{4}",
,,,"90012345",,,[8]],[,,"7879\\d{4}",,,,"78791234",,,[8]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],"BE",32,"00","0",,,"0",,,,[[,"(\\d{3})(\\d{2})(\\d{3})","$1 $2 $3",["(?:80|9)0"],"0$1"],[,"(\\d)(\\d{3})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[239]|4[23]"],"0$1"],[,"(\\d{2})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[15-8]"],"0$1"],[,"(\\d{3})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["4"],"0$1"]],,[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,"78(?:0[57]|1[0458]|2[25]|3[15-8]|48|[56]0|7[078])\\d{4}",,,,"78102345",,,[8]],,
,[,,,,,,,,,[-1]]],BF:[,[,,"[025-7]\\d{7}",,,,,,,[8]],[,,"2(?:0(?:49|5[23]|6[56]|9[016-9])|4(?:4[569]|5[4-6]|6[56]|7[0179])|5(?:[34]\\d|50|6[5-7]))\\d{4}",,,,"20491234"],[,,"(?:0[127]|5[1-8]|[67]\\d)\\d{6}",,,,"70123456"],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],"BF",226,"00",,,,,,,,[[,"(\\d{2})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[025-7]"]]],,[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],BG:[,[,,"[2-7]\\d{6,7}|[89]\\d{6,8}|2\\d{5}",
,,,,,,[6,7,8,9],[4,5]],[,,"2\\d{5,7}|(?:43[1-6]|70[1-9])\\d{4,5}|(?:[36]\\d|4[124-7]|[57][1-9]|8[1-6]|9[1-7])\\d{5,6}",,,,"2123456",,,[6,7,8],[4,5]],[,,"43[07-9]\\d{5}|(?:48|8[7-9]\\d|9(?:8\\d|9[69]))\\d{6}",,,,"48123456",,,[8,9]],[,,"800\\d{5}",,,,"80012345",,,[8]],[,,"90\\d{6}",,,,"90123456",,,[8]],[,,"700\\d{5}",,,,"70012345",,,[8]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],"BG",359,"00","0",,,"0",,,,[[,"(\\d{6})","$1",["1"]],[,"(\\d)(\\d)(\\d{2})(\\d{2})","$1 $2 $3 $4",["2"],"0$1"],[,"(\\d{3})(\\d{4})",
"$1 $2",["43[1-6]|70[1-9]"],"0$1"],[,"(\\d)(\\d{3})(\\d{3,4})","$1 $2 $3",["2"],"0$1"],[,"(\\d{2})(\\d{3})(\\d{2,3})","$1 $2 $3",["[356]|4[124-7]|7[1-9]|8[1-6]|9[1-7]"],"0$1"],[,"(\\d{3})(\\d{2})(\\d{3})","$1 $2 $3",["(?:70|8)0"],"0$1"],[,"(\\d{3})(\\d{3})(\\d{2})","$1 $2 $3",["43[1-7]|7"],"0$1"],[,"(\\d{2})(\\d{3})(\\d{3,4})","$1 $2 $3",["[48]|9[08]"],"0$1"],[,"(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["9"],"0$1"]],[[,"(\\d)(\\d)(\\d{2})(\\d{2})","$1 $2 $3 $4",["2"],"0$1"],[,"(\\d{3})(\\d{4})","$1 $2",
["43[1-6]|70[1-9]"],"0$1"],[,"(\\d)(\\d{3})(\\d{3,4})","$1 $2 $3",["2"],"0$1"],[,"(\\d{2})(\\d{3})(\\d{2,3})","$1 $2 $3",["[356]|4[124-7]|7[1-9]|8[1-6]|9[1-7]"],"0$1"],[,"(\\d{3})(\\d{2})(\\d{3})","$1 $2 $3",["(?:70|8)0"],"0$1"],[,"(\\d{3})(\\d{3})(\\d{2})","$1 $2 $3",["43[1-7]|7"],"0$1"],[,"(\\d{2})(\\d{3})(\\d{3,4})","$1 $2 $3",["[48]|9[08]"],"0$1"],[,"(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["9"],"0$1"]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],BH:[,[,,"[136-9]\\d{7}",
,,,,,,[8]],[,,"(?:1(?:3[1356]|6[0156]|7\\d)\\d|6(?:1[16]\\d|500|6(?:0\\d|3[12]|44|7[7-9]|88)|9[69][69])|7(?:1(?:11|78)|7\\d\\d))\\d{4}",,,,"17001234"],[,,"(?:3(?:[1-79]\\d|8[0-47-9])\\d|6(?:3(?:00|33|6[16])|6(?:3[03-9]|[69]\\d|7[0-6])))\\d{4}",,,,"36001234"],[,,"80\\d{6}",,,,"80123456"],[,,"(?:87|9[014578])\\d{6}",,,,"90123456"],[,,"84\\d{6}",,,,"84123456"],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],"BH",973,"00",,,,,,,,[[,"(\\d{4})(\\d{4})","$1 $2",["[13679]|8[047]"]]],,[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,
,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],BI:[,[,,"(?:[267]\\d|31)\\d{6}",,,,,,,[8]],[,,"22\\d{6}",,,,"22201234"],[,,"(?:29|31|6[1289]|7[125-9])\\d{6}",,,,"79561234"],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],"BI",257,"00",,,,,,,,[[,"(\\d{2})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[2367]"]]],,[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],BJ:[,[,,"(?:[2689]\\d|51)\\d{6}",,,,,,,[8]],[,,"2(?:02|1[037]|2[45]|3[68])\\d{5}",,,,"20211234"],[,,"(?:51|6\\d|9[013-9])\\d{6}",
,,,"90011234"],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,"857[58]\\d{4}",,,,"85751234"],"BJ",229,"00",,,,,,,,[[,"(\\d{2})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[25689]"]]],,[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,"81\\d{6}",,,,"81123456"],,,[,,,,,,,,,[-1]]],BL:[,[,,"(?:590|69\\d|976)\\d{6}",,,,,,,[9]],[,,"590(?:2[7-9]|5[12]|87)\\d{4}",,,,"590271234"],[,,"69(?:0\\d\\d|1(?:2[29]|3[0-5]))\\d{4}",,,,"690001234"],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],
[,,"976[01]\\d{5}",,,,"976012345"],"BL",590,"00","0",,,"0",,,,,,[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],BM:[,[,,"(?:441|[58]\\d\\d|900)\\d{7}",,,,,,,[10],[7]],[,,"441(?:[46]\\d\\d|5(?:4\\d|60|89))\\d{4}",,,,"4414123456",,,,[7]],[,,"441(?:[2378]\\d|5[0-39])\\d{5}",,,,"4413701234",,,,[7]],[,,"8(?:00|33|44|55|66|77|88)[2-9]\\d{6}",,,,"8002123456"],[,,"900[2-9]\\d{6}",,,,"9002123456"],[,,,,,,,,,[-1]],[,,"52(?:35(?:[02-46-9]\\d|1[02-9]|5[0-46-9])|45(?:[034]\\d|1[02-9]|2[024-9]|5[0-46-9]))\\d{4}|52(?:3[2-46-9]|4[2-4])(?:[02-9]\\d|1[02-9])\\d{4}|5(?:00|2[12]|33|44|66|77|88)[2-9]\\d{6}",
,,,"5002345678"],[,,,,,,,,,[-1]],"BM",1,"011","1",,,"1|([2-8]\\d{6})$","441$1",,,,,[,,,,,,,,,[-1]],,"441",[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],BN:[,[,,"[2-578]\\d{6}",,,,,,,[7]],[,,"22[0-7]\\d{4}|(?:2[013-9]|[34]\\d|5[0-25-9])\\d{5}",,,,"2345678"],[,,"(?:22[89]|[78]\\d\\d)\\d{4}",,,,"7123456"],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,"5[34]\\d{5}",,,,"5345678"],"BN",673,"00",,,,,,,,[[,"(\\d{3})(\\d{4})","$1 $2",["[2-578]"]]],,[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],
[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],BO:[,[,,"(?:[2-467]\\d\\d|8001)\\d{5}",,,,,,,[8,9],[7]],[,,"(?:2(?:2\\d\\d|5(?:11|[258]\\d|9[67])|6(?:12|2\\d|9[34])|8(?:2[34]|39|62))|3(?:3\\d\\d|4(?:6\\d|8[24])|8(?:25|42|5[257]|86|9[25])|9(?:[27]\\d|3[2-4]|4[248]|5[24]|6[2-6]))|4(?:4\\d\\d|6(?:11|[24689]\\d|72)))\\d{4}",,,,"22123456",,,[8],[7]],[,,"[67]\\d{7}",,,,"71234567",,,[8]],[,,"8001[07]\\d{4}",,,,"800171234",,,[9]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],"BO",591,"00(?:1\\d)?","0",
,,"0(1\\d)?",,,,[[,"(\\d)(\\d{7})","$1 $2",["[23]|4[46]"],,"0$CC $1"],[,"(\\d{8})","$1",["[67]"],,"0$CC $1"],[,"(\\d{3})(\\d{2})(\\d{4})","$1 $2 $3",["8"],,"0$CC $1"]],,[,,,,,,,,,[-1]],,,[,,"8001[07]\\d{4}",,,,,,,[9]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],BQ:[,[,,"(?:[34]1|7\\d)\\d{5}",,,,,,,[7]],[,,"(?:318[023]|41(?:6[023]|70)|7(?:1[578]|2[05]|50)\\d)\\d{3}",,,,"7151234"],[,,"(?:31(?:8[14-8]|9[14578])|416[14-9]|7(?:0[01]|7[07]|8\\d|9[056])\\d)\\d{3}",,,,"3181234"],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,
,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],"BQ",599,"00",,,,,,,,,,[,,,,,,,,,[-1]],,"[347]",[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],BR:[,[,,"(?:[1-46-9]\\d\\d|5(?:[0-46-9]\\d|5[0-24679]))\\d{8}|[1-9]\\d{9}|[3589]\\d{8}|[34]\\d{7}",,,,,,,[8,9,10,11]],[,,"(?:[14689][1-9]|2[12478]|3[1-578]|5[13-5]|7[13-579])[2-5]\\d{7}",,,,"1123456789",,,[10],[8]],[,,"(?:[14689][1-9]|2[12478]|3[1-578]|5[13-5]|7[13-579])(?:7|9\\d)\\d{7}",,,,"11961234567",,,[10,11],[8,9]],[,,"800\\d{6,7}",,,,"800123456",,
,[9,10]],[,,"300\\d{6}|[59]00\\d{6,7}",,,,"300123456",,,[9,10]],[,,"300\\d{7}|[34]00\\d{5}|4(?:02|37)0\\d{4}",,,,"40041234",,,[8,10]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],"BR",55,"00(?:1[245]|2[1-35]|31|4[13]|[56]5|99)","0",,,"0(?:(1[245]|2[1-35]|31|4[13]|[56]5|99)(\\d{10,11}))?","$2",,,[[,"(\\d{3,6})","$1",["1(?:1[25-8]|2[357-9]|3[02-68]|4[12568]|5|6[0-8]|8[015]|9[0-47-9])|321|610"]],[,"(\\d{4})(\\d{4})","$1-$2",["300|4(?:0[02]|37)","4(?:02|37)0|[34]00"]],[,"(\\d{4})(\\d{4})","$1-$2",["[2-57]","[2357]|4(?:[0-24-9]|3(?:[0-689]|7[1-9]))"]],
[,"(\\d{3})(\\d{2,3})(\\d{4})","$1 $2 $3",["(?:[358]|90)0"],"0$1"],[,"(\\d{5})(\\d{4})","$1-$2",["9"]],[,"(\\d{2})(\\d{4})(\\d{4})","$1 $2-$3",["(?:[14689][1-9]|2[12478]|3[1-578]|5[13-5]|7[13-579])[2-57]"],"($1)","0 $CC ($1)"],[,"(\\d{2})(\\d{5})(\\d{4})","$1 $2-$3",["[16][1-9]|[2-57-9]"],"($1)","0 $CC ($1)"]],[[,"(\\d{4})(\\d{4})","$1-$2",["300|4(?:0[02]|37)","4(?:02|37)0|[34]00"]],[,"(\\d{3})(\\d{2,3})(\\d{4})","$1 $2 $3",["(?:[358]|90)0"],"0$1"],[,"(\\d{2})(\\d{4})(\\d{4})","$1 $2-$3",["(?:[14689][1-9]|2[12478]|3[1-578]|5[13-5]|7[13-579])[2-57]"],
"($1)","0 $CC ($1)"],[,"(\\d{2})(\\d{5})(\\d{4})","$1 $2-$3",["[16][1-9]|[2-57-9]"],"($1)","0 $CC ($1)"]],[,,,,,,,,,[-1]],,,[,,"4020\\d{4}|[34]00\\d{5}",,,,,,,[8]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],BS:[,[,,"(?:242|[58]\\d\\d|900)\\d{7}",,,,,,,[10],[7]],[,,"242(?:3(?:02|[236][1-9]|4[0-24-9]|5[0-68]|7[347]|8[0-4]|9[2-467])|461|502|6(?:0[1-4]|12|2[013]|[45]0|7[67]|8[78]|9[89])|7(?:02|88))\\d{4}",,,,"2423456789",,,,[7]],[,,"242(?:3(?:5[79]|7[56]|95)|4(?:[23][1-9]|4[1-35-9]|5[1-8]|6[2-8]|7\\d|81)|5(?:2[45]|3[35]|44|5[1-46-9]|65|77)|6[34]6|7(?:27|38)|8(?:0[1-9]|1[02-9]|2\\d|[89]9))\\d{4}",
,,,"2423591234",,,,[7]],[,,"242300\\d{4}|8(?:00|33|44|55|66|77|88)[2-9]\\d{6}",,,,"8002123456",,,,[7]],[,,"900[2-9]\\d{6}",,,,"9002123456"],[,,,,,,,,,[-1]],[,,"52(?:35(?:[02-46-9]\\d|1[02-9]|5[0-46-9])|45(?:[034]\\d|1[02-9]|2[024-9]|5[0-46-9]))\\d{4}|52(?:3[2-46-9]|4[2-4])(?:[02-9]\\d|1[02-9])\\d{4}|5(?:00|2[12]|33|44|66|77|88)[2-9]\\d{6}",,,,"5002345678"],[,,,,,,,,,[-1]],"BS",1,"011","1",,,"1|([3-8]\\d{6})$","242$1",,,,,[,,,,,,,,,[-1]],,"242",[,,,,,,,,,[-1]],[,,"242225\\d{4}",,,,"2422250123"],,,
[,,,,,,,,,[-1]]],BT:[,[,,"[17]\\d{7}|[2-8]\\d{6}",,,,,,,[7,8],[6]],[,,"(?:2[3-6]|[34][5-7]|5[236]|6[2-46]|7[246]|8[2-4])\\d{5}",,,,"2345678",,,[7],[6]],[,,"(?:1[67]|77)\\d{6}",,,,"17123456",,,[8]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],"BT",975,"00",,,,,,,,[[,"(\\d{3})(\\d{3})","$1 $2",["[2-7]"]],[,"(\\d)(\\d{3})(\\d{3})","$1 $2 $3",["[2-68]|7[246]"]],[,"(\\d{2})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["1[67]|7"]]],[[,"(\\d)(\\d{3})(\\d{3})","$1 $2 $3",["[2-68]|7[246]"]],
[,"(\\d{2})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["1[67]|7"]]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],BW:[,[,,"90\\d{5}|(?:[2-6]|7\\d)\\d{6}",,,,,,,[7,8]],[,,"(?:2(?:4[0-48]|6[0-24]|9[0578])|3(?:1[0-35-9]|55|[69]\\d|7[013])|4(?:6[03]|7[1267]|9[0-5])|5(?:3[0389]|4[0489]|7[1-47]|88|9[0-49])|6(?:2[1-35]|5[149]|8[067]))\\d{4}",,,,"2401234",,,[7]],[,,"77200\\d{3}|7(?:[1-6]\\d|7[013-9])\\d{5}",,,,"71123456",,,[8]],[,,,,,,,,,[-1]],[,,"90\\d{5}",,,,"9012345",,,[7]],[,,,,,,
,,,[-1]],[,,,,,,,,,[-1]],[,,"79(?:1(?:[01]\\d|20)|2[0-2]\\d)\\d{3}",,,,"79101234",,,[8]],"BW",267,"00",,,,,,,,[[,"(\\d{2})(\\d{5})","$1 $2",["90"]],[,"(\\d{3})(\\d{4})","$1 $2",["[2-6]"]],[,"(\\d{2})(\\d{3})(\\d{3})","$1 $2 $3",["7"]]],,[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],BY:[,[,,"(?:[12]\\d|33|44|902)\\d{7}|8(?:0[0-79]\\d{5,7}|[1-7]\\d{9})|8(?:1[0-489]|[5-79]\\d)\\d{7}|8[1-79]\\d{6,7}|8[0-79]\\d{5}|8\\d{5}",,,,,,,[6,7,8,9,10,11],[5]],[,,"(?:1(?:5(?:1[1-5]|[24]\\d|6[2-4]|9[1-7])|6(?:[235]\\d|4[1-7])|7\\d\\d)|2(?:1(?:[246]\\d|3[0-35-9]|5[1-9])|2(?:[235]\\d|4[0-8])|3(?:[26]\\d|3[02-79]|4[024-7]|5[03-7])))\\d{5}",
,,,"152450911",,,[9],[5,6,7]],[,,"(?:2(?:5[5-79]|9[1-9])|(?:33|44)\\d)\\d{6}",,,,"294911911",,,[9]],[,,"800\\d{3,7}|8(?:0[13]|20\\d)\\d{7}",,,,"8011234567"],[,,"(?:810|902)\\d{7}",,,,"9021234567",,,[10]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,"249\\d{6}",,,,"249123456",,,[9]],"BY",375,"810","8",,,"0|80?",,"8~10",,[[,"(\\d{3})(\\d{3})","$1 $2",["800"],"8 $1"],[,"(\\d{3})(\\d{2})(\\d{2,4})","$1 $2 $3",["800"],"8 $1"],[,"(\\d{4})(\\d{2})(\\d{3})","$1 $2-$3",["1(?:5[169]|6[3-5]|7[179])|2(?:1[35]|2[34]|3[3-5])",
"1(?:5[169]|6(?:3[1-3]|4|5[125])|7(?:1[3-9]|7[0-24-6]|9[2-7]))|2(?:1[35]|2[34]|3[3-5])"],"8 0$1"],[,"(\\d{3})(\\d{2})(\\d{2})(\\d{2})","$1 $2-$3-$4",["1(?:[56]|7[467])|2[1-3]"],"8 0$1"],[,"(\\d{2})(\\d{3})(\\d{2})(\\d{2})","$1 $2-$3-$4",["[1-4]"],"8 0$1"],[,"(\\d{3})(\\d{3,4})(\\d{4})","$1 $2 $3",["[89]"],"8 $1"]],,[,,,,,,,,,[-1]],,,[,,"800\\d{3,7}|(?:8(?:0[13]|10|20\\d)|902)\\d{7}"],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],BZ:[,[,,"(?:0800\\d|[2-8])\\d{6}",,,,,,,[7,11]],[,,"(?:236|732)\\d{4}|[2-578][02]\\d{5}",
,,,"2221234",,,[7]],[,,"6[0-35-7]\\d{5}",,,,"6221234",,,[7]],[,,"0800\\d{7}",,,,"08001234123",,,[11]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],"BZ",501,"00",,,,,,,,[[,"(\\d{3})(\\d{4})","$1-$2",["[2-8]"]],[,"(\\d)(\\d{3})(\\d{4})(\\d{3})","$1-$2-$3-$4",["0"]]],,[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],CA:[,[,,"(?:[2-8]\\d|90)\\d{8}",,,,,,,[10],[7]],[,,"(?:2(?:04|[23]6|[48]9|50)|3(?:06|43|6[57])|4(?:03|1[68]|3[178]|50)|5(?:06|1[49]|48|79|8[17])|6(?:04|13|39|47|72)|7(?:0[59]|78|8[02])|8(?:[06]7|19|25|73)|90[25])[2-9]\\d{6}",
,,,"5062345678",,,,[7]],[,,"(?:2(?:04|[23]6|[48]9|50)|3(?:06|43|6[57])|4(?:03|1[68]|3[178]|50)|5(?:06|1[49]|48|79|8[17])|6(?:04|13|39|47|72)|7(?:0[59]|78|8[02])|8(?:[06]7|19|25|73)|90[25])[2-9]\\d{6}",,,,"5062345678",,,,[7]],[,,"8(?:00|33|44|55|66|77|88)[2-9]\\d{6}",,,,"8002123456"],[,,"900[2-9]\\d{6}",,,,"9002123456"],[,,,,,,,,,[-1]],[,,"52(?:35(?:[02-46-9]\\d|1[02-9]|5[0-46-9])|45(?:[034]\\d|1[02-9]|2[024-9]|5[0-46-9]))\\d{4}|52(?:3[2-46-9]|4[2-4])(?:[02-9]\\d|1[02-9])\\d{4}|(?:5(?:00|2[12]|33|44|66|77|88)|622)[2-9]\\d{6}",
,,,"5002345678"],[,,"600[2-9]\\d{6}",,,,"6002012345"],"CA",1,"011","1",,,"1",,,1,,,[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],CC:[,[,,"1(?:[0-79]\\d|8[0-24-9])\\d{7}|(?:[148]\\d\\d|550)\\d{6}|1\\d{5,7}",,,,,,,[6,7,8,9,10]],[,,"8(?:51(?:0(?:02|31|60)|118)|91(?:0(?:1[0-2]|29)|1(?:[28]2|50|79)|2(?:10|64)|3(?:[06]8|22)|4[29]8|62\\d|70[23]|959))\\d{3}",,,,"891621234",,,[9],[8]],[,,"483[0-3]\\d{5}|4(?:[0-3]\\d|4[047-9]|5[0-25-9]|6[06-9]|7[02-9]|8[0-2457-9]|9[0-27-9])\\d{6}",,,
,"412345678",,,[9]],[,,"180(?:0\\d{3}|2)\\d{3}",,,,"1800123456",,,[7,10]],[,,"190[0-26]\\d{6}",,,,"1900123456",,,[10]],[,,"13(?:00\\d{3}|45[0-4])\\d{3}|13\\d{4}",,,,"1300123456",,,[6,8,10]],[,,,,,,,,,[-1]],[,,"(?:14(?:5(?:1[0458]|[23][458])|71\\d)|550\\d\\d)\\d{4}",,,,"550123456",,,[9]],"CC",61,"001[14-689]|14(?:1[14]|34|4[17]|[56]6|7[47]|88)0011","0",,,"0|([59]\\d{7})$","8$1","0011",,,,[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],CD:[,[,,"[189]\\d{8}|[1-68]\\d{6}",,,,,,,[7,
9]],[,,"12\\d{7}|[1-6]\\d{6}",,,,"1234567"],[,,"88\\d{5}|(?:8[0-2459]|9[017-9])\\d{7}",,,,"991234567"],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],"CD",243,"00","0",,,"0",,,,[[,"(\\d{2})(\\d{2})(\\d{3})","$1 $2 $3",["88"],"0$1"],[,"(\\d{2})(\\d{5})","$1 $2",["[1-6]"],"0$1"],[,"(\\d{2})(\\d{3})(\\d{4})","$1 $2 $3",["1"],"0$1"],[,"(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["[89]"],"0$1"]],,[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],CF:[,[,,"(?:[27]\\d{3}|8776)\\d{4}",
,,,,,,[8]],[,,"2[12]\\d{6}",,,,"21612345"],[,,"7[0257]\\d{6}",,,,"70012345"],[,,,,,,,,,[-1]],[,,"8776\\d{4}",,,,"87761234"],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],"CF",236,"00",,,,,,,,[[,"(\\d{2})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[278]"]]],,[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],CG:[,[,,"222\\d{6}|(?:0\\d|80)\\d{7}",,,,,,,[9]],[,,"222[1-589]\\d{5}",,,,"222123456"],[,,"0[14-6]\\d{7}",,,,"061234567"],[,,,,,,,,,[-1]],[,,"80(?:0\\d\\d|11[0-4])\\d{4}",,,,
"800123456"],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],"CG",242,"00",,,,,,,,[[,"(\\d{3})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["801"]],[,"(\\d)(\\d{4})(\\d{4})","$1 $2 $3",["8"]],[,"(\\d{2})(\\d{3})(\\d{4})","$1 $2 $3",["[02]"]]],,[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],CH:[,[,,"8\\d{11}|[2-9]\\d{8}",,,,,,,[9,12]],[,,"(?:2[12467]|3[1-4]|4[134]|5[256]|6[12]|[7-9]1)\\d{7}",,,,"212345678",,,[9]],[,,"7[35-9]\\d{7}",,,,"781234567",,,[9]],[,,"800\\d{6}",,,,"800123456",
,,[9]],[,,"90[016]\\d{6}",,,,"900123456",,,[9]],[,,"84[0248]\\d{6}",,,,"840123456",,,[9]],[,,"878\\d{6}",,,,"878123456",,,[9]],[,,,,,,,,,[-1]],"CH",41,"00","0",,,"0",,,,[[,"(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["8[047]|90"],"0$1"],[,"(\\d{2})(\\d{3})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[2-79]|81"],"0$1"],[,"(\\d{3})(\\d{2})(\\d{3})(\\d{2})(\\d{2})","$1 $2 $3 $4 $5",["8"],"0$1"]],,[,,"74[0248]\\d{6}",,,,"740123456",,,[9]],,,[,,,,,,,,,[-1]],[,,"5[18]\\d{7}",,,,"581234567",,,[9]],,,[,,"860\\d{9}",,,,"860123456789",
,,[12]]],CI:[,[,,"[02-9]\\d{7}",,,,,,,[8]],[,,"(?:2(?:0[023]|1[02357]|[23][045]|4[03-5])|3(?:0[06]|1[069]|[2-4][07]|5[09]|6[08]))\\d{5}",,,,"21234567"],[,,"(?:2[0-3]80|97[0-3]\\d)\\d{4}|(?:0[1-9]|[457]\\d|6[014-9]|8[4-9]|95)\\d{6}",,,,"01234567"],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],"CI",225,"00",,,,,,,,[[,"(\\d{2})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[02-9]"]]],,[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],CK:[,[,,"[2-578]\\d{4}",
,,,,,,[5]],[,,"(?:2\\d|3[13-7]|4[1-5])\\d{3}",,,,"21234"],[,,"[578]\\d{4}",,,,"71234"],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],"CK",682,"00",,,,,,,,[[,"(\\d{2})(\\d{3})","$1 $2",["[2-578]"]]],,[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],CL:[,[,,"12300\\d{6}|6\\d{9,10}|[2-9]\\d{8}",,,,,,,[9,10,11]],[,,"2(?:1982[0-6]|3314[05-9])\\d{3}|(?:2(?:1(?:160|962)|3(?:2\\d\\d|3(?:0\\d|1[0-35-9]|2[1-9]|3[0-2]|40)))|80[1-9]\\d\\d|9(?:3(?:[0-57-9]\\d\\d|6(?:0[02-9]|[1-9]\\d))|6(?:[0-8]\\d\\d|9(?:[02-79]\\d|1[05-9]))|7[1-9]\\d\\d|9(?:[03-9]\\d\\d|1(?:[0235-9]\\d|4[0-24-9])|2(?:[0-79]\\d|8[0-46-9]))))\\d{4}|(?:22|3[2-5]|[47][1-35]|5[1-3578]|6[13-57]|8[1-9]|9[2458])\\d{7}",
,,,"221234567",,,[9]],[,,"2(?:1982[0-6]|3314[05-9])\\d{3}|(?:2(?:1(?:160|962)|3(?:2\\d\\d|3(?:0\\d|1[0-35-9]|2[1-9]|3[0-2]|40)))|80[1-9]\\d\\d|9(?:3(?:[0-57-9]\\d\\d|6(?:0[02-9]|[1-9]\\d))|6(?:[0-8]\\d\\d|9(?:[02-79]\\d|1[05-9]))|7[1-9]\\d\\d|9(?:[03-9]\\d\\d|1(?:[0235-9]\\d|4[0-24-9])|2(?:[0-79]\\d|8[0-46-9]))))\\d{4}|(?:22|3[2-5]|[47][1-35]|5[1-3578]|6[13-57]|8[1-9]|9[2458])\\d{7}",,,,"221234567",,,[9]],[,,"(?:123|8)00\\d{6}",,,,"800123456",,,[9,11]],[,,,,,,,,,[-1]],[,,"600\\d{7,8}",,,,"6001234567",
,,[10,11]],[,,,,,,,,,[-1]],[,,"44\\d{7}",,,,"441234567",,,[9]],"CL",56,"(?:0|1(?:1[0-69]|2[02-5]|5[13-58]|69|7[0167]|8[018]))0",,,,,,,1,[[,"(\\d{4})","$1",["1(?:[03-589]|21)|[29]0|78"]],[,"(\\d{5})(\\d{4})","$1 $2",["219","2196"],"($1)"],[,"(\\d{2})(\\d{3})(\\d{4})","$1 $2 $3",["44"]],[,"(\\d)(\\d{4})(\\d{4})","$1 $2 $3",["2[1-3]"],"($1)"],[,"(\\d)(\\d{4})(\\d{4})","$1 $2 $3",["9[2-9]"]],[,"(\\d{2})(\\d{3})(\\d{4})","$1 $2 $3",["3[2-5]|[47]|5[1-3578]|6[13-57]|8(?:0[1-9]|[1-9])"],"($1)"],[,"(\\d{3})(\\d{3})(\\d{3,4})",
"$1 $2 $3",["60|8"]],[,"(\\d{4})(\\d{3})(\\d{4})","$1 $2 $3",["1"]],[,"(\\d{3})(\\d{3})(\\d{2})(\\d{3})","$1 $2 $3 $4",["60"]]],[[,"(\\d{5})(\\d{4})","$1 $2",["219","2196"],"($1)"],[,"(\\d{2})(\\d{3})(\\d{4})","$1 $2 $3",["44"]],[,"(\\d)(\\d{4})(\\d{4})","$1 $2 $3",["2[1-3]"],"($1)"],[,"(\\d)(\\d{4})(\\d{4})","$1 $2 $3",["9[2-9]"]],[,"(\\d{2})(\\d{3})(\\d{4})","$1 $2 $3",["3[2-5]|[47]|5[1-3578]|6[13-57]|8(?:0[1-9]|[1-9])"],"($1)"],[,"(\\d{3})(\\d{3})(\\d{3,4})","$1 $2 $3",["60|8"]],[,"(\\d{4})(\\d{3})(\\d{4})",
"$1 $2 $3",["1"]],[,"(\\d{3})(\\d{3})(\\d{2})(\\d{3})","$1 $2 $3 $4",["60"]]],[,,,,,,,,,[-1]],,,[,,"600\\d{7,8}",,,,,,,[10,11]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],CM:[,[,,"(?:[26]\\d\\d|88)\\d{6}",,,,,,,[8,9]],[,,"2(?:22|33)\\d{6}",,,,"222123456",,,[9]],[,,"(?:24[23]|6[5-9]\\d)\\d{6}",,,,"671234567",,,[9]],[,,"88\\d{6}",,,,"88012345",,,[8]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],"CM",237,"00",,,,,,,,[[,"(\\d{2})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["88"]],[,"(\\d)(\\d{2})(\\d{2})(\\d{2})(\\d{2})",
"$1 $2 $3 $4 $5",["[26]"]]],,[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],CN:[,[,,"1[127]\\d{8,9}|2\\d{9}(?:\\d{2})?|[12]\\d{6,7}|86\\d{6}|(?:1[03-689]\\d|6)\\d{7,9}|(?:[3-579]\\d|8[0-57-9])\\d{6,9}",,,,,,,[7,8,9,10,11,12],[5,6]],[,,"(?:10(?:[02-79]\\d\\d|[18](?:0[1-9]|[1-9]\\d))|21(?:[18](?:0[1-9]|[1-9]\\d)|[2-79]\\d\\d))\\d{5}|(?:43[35]|754)\\d{7,8}|8(?:078\\d{7}|51\\d{7,8})|(?:10|(?:2|85)1|43[35]|754)(?:100\\d\\d|95\\d{3,4})|(?:2[02-57-9]|3(?:11|7[179])|4(?:[15]1|3[12])|5(?:1\\d|2[37]|3[12]|51|7[13-79]|9[15])|7(?:[39]1|5[57]|6[09])|8(?:71|98))(?:[02-8]\\d{7}|1(?:0(?:0\\d\\d(?:\\d{3})?|[1-9]\\d{5})|[1-9]\\d{6})|9(?:[0-46-9]\\d{6}|5\\d{3}(?:\\d(?:\\d{2})?)?))|(?:3(?:1[02-9]|35|49|5\\d|7[02-68]|9[1-68])|4(?:1[02-9]|2[179]|3[46-9]|5[2-9]|6[47-9]|7\\d|8[23])|5(?:3[03-9]|4[36]|5[02-9]|6[1-46]|7[028]|80|9[2-46-9])|6(?:3[1-5]|6[0238]|9[12])|7(?:01|[17]\\d|2[248]|3[04-9]|4[3-6]|5[0-3689]|6[2368]|9[02-9])|8(?:1[236-8]|2[5-7]|3\\d|5[2-9]|7[02-9]|8[36-8]|9[1-7])|9(?:0[1-3689]|1[1-79]|[379]\\d|4[13]|5[1-5]))(?:[02-8]\\d{6}|1(?:0(?:0\\d\\d(?:\\d{2})?|[1-9]\\d{4})|[1-9]\\d{5})|9(?:[0-46-9]\\d{5}|5\\d{3,5}))",
,,,"1012345678",,,[7,8,9,10,11],[5,6]],[,,"1740[0-5]\\d{6}|1(?:[38]\\d|4[57]|5[0-35-9]|6[25-7]|7[0-35-8]|9[0135-9])\\d{8}",,,,"13123456789",,,[11]],[,,"(?:(?:10|21)8|8)00\\d{7}",,,,"8001234567",,,[10,12]],[,,"16[08]\\d{5}",,,,"16812345",,,[8]],[,,"400\\d{7}|950\\d{7,8}|(?:10|2[0-57-9]|3(?:[157]\\d|35|49|9[1-68])|4(?:[17]\\d|2[179]|[35][1-9]|6[47-9]|8[23])|5(?:[1357]\\d|2[37]|4[36]|6[1-46]|80|9[1-9])|6(?:3[1-5]|6[0238]|9[12])|7(?:01|[1579]\\d|2[248]|3[014-9]|4[3-6]|6[023689])|8(?:1[236-8]|2[5-7]|[37]\\d|5[14-9]|8[36-8]|9[1-8])|9(?:0[1-3689]|1[1-79]|[379]\\d|4[13]|5[1-5]))96\\d{3,4}",
,,,"4001234567",,,[7,8,9,10,11],[5,6]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],"CN",86,"00|1(?:[12]\\d|79)\\d\\d00","0",,,"0|(1(?:[12]\\d|79)\\d\\d)",,"00",,[[,"(\\d{5,6})","$1",["96"]],[,"(\\d{2})(\\d{5,6})","$1 $2",["(?:10|2[0-57-9])[19]","(?:10|2[0-57-9])(?:10|9[56])","(?:10|2[0-57-9])(?:100|9[56])"],"0$1","$CC $1"],[,"(\\d{3})(\\d{4})","$1 $2",["[1-9]","1[1-9]|26|[3-9]|(?:10|2[0-57-9])(?:[0-8]|9[0-47-9])","1[1-9]|26|[3-9]|(?:10|2[0-57-9])(?:[02-8]|1(?:0[1-9]|[1-9])|9[0-47-9])"]],[,"(\\d{4})(\\d{4})",
"$1 $2",["16[08]"]],[,"(\\d{3})(\\d{5,6})","$1 $2",["3(?:[157]|35|49|9[1-68])|4(?:[17]|2[179]|6[47-9]|8[23])|5(?:[1357]|2[37]|4[36]|6[1-46]|80)|6(?:3[1-5]|6[0238]|9[12])|7(?:01|[1579]|2[248]|3[014-9]|4[3-6]|6[023689])|8(?:1[236-8]|2[5-7]|[37]|8[36-8]|9[1-8])|9(?:0[1-3689]|1[1-79]|[379]|4[13]|5[1-5])|(?:4[35]|59|85)[1-9]","(?:3(?:[157]\\d|35|49|9[1-68])|4(?:[17]\\d|2[179]|[35][1-9]|6[47-9]|8[23])|5(?:[1357]\\d|2[37]|4[36]|6[1-46]|80|9[1-9])|6(?:3[1-5]|6[0238]|9[12])|7(?:01|[1579]\\d|2[248]|3[014-9]|4[3-6]|6[023689])|8(?:1[236-8]|2[5-7]|[37]\\d|5[1-9]|8[36-8]|9[1-8])|9(?:0[1-3689]|1[1-79]|[379]\\d|4[13]|5[1-5]))[19]",
"85[23](?:10|95)|(?:3(?:[157]\\d|35|49|9[1-68])|4(?:[17]\\d|2[179]|[35][1-9]|6[47-9]|8[23])|5(?:[1357]\\d|2[37]|4[36]|6[1-46]|80|9[1-9])|6(?:3[1-5]|6[0238]|9[12])|7(?:01|[1579]\\d|2[248]|3[014-9]|4[3-6]|6[023689])|8(?:1[236-8]|2[5-7]|[37]\\d|5[14-9]|8[36-8]|9[1-8])|9(?:0[1-3689]|1[1-79]|[379]\\d|4[13]|5[1-5]))(?:10|9[56])","85[23](?:100|95)|(?:3(?:[157]\\d|35|49|9[1-68])|4(?:[17]\\d|2[179]|[35][1-9]|6[47-9]|8[23])|5(?:[1357]\\d|2[37]|4[36]|6[1-46]|80|9[1-9])|6(?:3[1-5]|6[0238]|9[12])|7(?:01|[1579]\\d|2[248]|3[014-9]|4[3-6]|6[023689])|8(?:1[236-8]|2[5-7]|[37]\\d|5[14-9]|8[36-8]|9[1-8])|9(?:0[1-3689]|1[1-79]|[379]\\d|4[13]|5[1-5]))(?:100|9[56])"],
"0$1","$CC $1"],[,"(\\d{4})(\\d{4})","$1 $2",["[1-9]","1[1-9]|26|[3-9]|(?:10|2[0-57-9])(?:[0-8]|9[0-47-9])","26|3(?:[0268]|9[079])|4(?:[049]|2[02-68]|[35]0|6[0-356]|8[014-9])|5(?:0|2[0-24-689]|4[0-2457-9]|6[057-9]|90)|6(?:[0-24578]|6[14-79]|9[03-9])|7(?:0[02-9]|2[0135-79]|3[23]|4[0-27-9]|6[1457]|8)|8(?:[046]|1[01459]|2[0-489]|50|8[0-2459]|9[09])|9(?:0[0457]|1[08]|[268]|4[024-9])|(?:34|85[23])[0-8]|(?:1|58)[1-9]|(?:63|95)[06-9]|(?:33|85[23]9)[0-46-9]|(?:10|2[0-57-9]|3(?:[157]\\d|35|49|9[1-68])|4(?:[17]\\d|2[179]|[35][1-9]|6[47-9]|8[23])|5(?:[1357]\\d|2[37]|4[36]|6[1-46]|80|9[1-9])|6(?:3[1-5]|6[0238]|9[12])|7(?:01|[1579]\\d|2[248]|3[014-9]|4[3-6]|6[023689])|8(?:1[236-8]|2[5-7]|[37]\\d|5[14-9]|8[36-8]|9[1-8])|9(?:0[1-3689]|1[1-79]|[379]\\d|4[13]|5[1-5]))(?:[0-8]|9[0-47-9])",
"26|3(?:[0268]|3[0-46-9]|4[0-8]|9[079])|4(?:[049]|2[02-68]|[35]0|6[0-356]|8[014-9])|5(?:0|2[0-24-689]|4[0-2457-9]|6[057-9]|90)|6(?:[0-24578]|3[06-9]|6[14-79]|9[03-9])|7(?:0[02-9]|2[0135-79]|3[23]|4[0-27-9]|6[1457]|8)|8(?:[046]|1[01459]|2[0-489]|5(?:0|[23](?:[02-8]|1[1-9]|9[0-46-9]))|8[0-2459]|9[09])|9(?:0[0457]|1[08]|[268]|4[024-9]|5[06-9])|(?:1|58|85[23]10)[1-9]|(?:10|2[0-57-9])(?:[0-8]|9[0-47-9])|(?:3(?:[157]\\d|35|49|9[1-68])|4(?:[17]\\d|2[179]|[35][1-9]|6[47-9]|8[23])|5(?:[1357]\\d|2[37]|4[36]|6[1-46]|80|9[1-9])|6(?:3[1-5]|6[0238]|9[12])|7(?:01|[1579]\\d|2[248]|3[014-9]|4[3-6]|6[023689])|8(?:1[236-8]|2[5-7]|[37]\\d|5[14-9]|8[36-8]|9[1-8])|9(?:0[1-3689]|1[1-79]|[379]\\d|4[13]|5[1-5]))(?:[02-8]|1(?:0[1-9]|[1-9])|9[0-47-9])"]],
[,"(\\d{3})(\\d{3})(\\d{4})","$1 $2 $3",["(?:4|80)0"]],[,"(\\d{2})(\\d{4})(\\d{4})","$1 $2 $3",["10|2(?:[02-57-9]|1[1-9])","10|2(?:[02-57-9]|1[1-9])","10[0-79]|2(?:[02-57-9]|1[1-79])|(?:10|21)8(?:0[1-9]|[1-9])"],"0$1","$CC $1",1],[,"(\\d{3})(\\d{3})(\\d{4})","$1 $2 $3",["3(?:[3-59]|7[02-68])|4(?:[26-8]|3[3-9]|5[2-9])|5(?:3[03-9]|[468]|7[028]|9[2-46-9])|6|7(?:[0-247]|3[04-9]|5[0-4689]|6[2368])|8(?:[1-358]|9[1-7])|9(?:[013479]|5[1-5])|(?:[34]1|55|79|87)[02-9]"],"0$1","$CC $1",1],[,"(\\d{3})(\\d{7,8})",
"$1 $2",["9"]],[,"(\\d{4})(\\d{3})(\\d{4})","$1 $2 $3",["80"],"0$1","$CC $1",1],[,"(\\d{3})(\\d{4})(\\d{4})","$1 $2 $3",["[3-578]"],"0$1","$CC $1",1],[,"(\\d{3})(\\d{4})(\\d{4})","$1 $2 $3",["1[3-9]"],,"$CC $1"],[,"(\\d{2})(\\d{3})(\\d{3})(\\d{4})","$1 $2 $3 $4",["[12]"],"0$1",,1]],[[,"(\\d{2})(\\d{5,6})","$1 $2",["(?:10|2[0-57-9])[19]","(?:10|2[0-57-9])(?:10|9[56])","(?:10|2[0-57-9])(?:100|9[56])"],"0$1","$CC $1"],[,"(\\d{3})(\\d{5,6})","$1 $2",["3(?:[157]|35|49|9[1-68])|4(?:[17]|2[179]|6[47-9]|8[23])|5(?:[1357]|2[37]|4[36]|6[1-46]|80)|6(?:3[1-5]|6[0238]|9[12])|7(?:01|[1579]|2[248]|3[014-9]|4[3-6]|6[023689])|8(?:1[236-8]|2[5-7]|[37]|8[36-8]|9[1-8])|9(?:0[1-3689]|1[1-79]|[379]|4[13]|5[1-5])|(?:4[35]|59|85)[1-9]",
"(?:3(?:[157]\\d|35|49|9[1-68])|4(?:[17]\\d|2[179]|[35][1-9]|6[47-9]|8[23])|5(?:[1357]\\d|2[37]|4[36]|6[1-46]|80|9[1-9])|6(?:3[1-5]|6[0238]|9[12])|7(?:01|[1579]\\d|2[248]|3[014-9]|4[3-6]|6[023689])|8(?:1[236-8]|2[5-7]|[37]\\d|5[1-9]|8[36-8]|9[1-8])|9(?:0[1-3689]|1[1-79]|[379]\\d|4[13]|5[1-5]))[19]","85[23](?:10|95)|(?:3(?:[157]\\d|35|49|9[1-68])|4(?:[17]\\d|2[179]|[35][1-9]|6[47-9]|8[23])|5(?:[1357]\\d|2[37]|4[36]|6[1-46]|80|9[1-9])|6(?:3[1-5]|6[0238]|9[12])|7(?:01|[1579]\\d|2[248]|3[014-9]|4[3-6]|6[023689])|8(?:1[236-8]|2[5-7]|[37]\\d|5[14-9]|8[36-8]|9[1-8])|9(?:0[1-3689]|1[1-79]|[379]\\d|4[13]|5[1-5]))(?:10|9[56])",
"85[23](?:100|95)|(?:3(?:[157]\\d|35|49|9[1-68])|4(?:[17]\\d|2[179]|[35][1-9]|6[47-9]|8[23])|5(?:[1357]\\d|2[37]|4[36]|6[1-46]|80|9[1-9])|6(?:3[1-5]|6[0238]|9[12])|7(?:01|[1579]\\d|2[248]|3[014-9]|4[3-6]|6[023689])|8(?:1[236-8]|2[5-7]|[37]\\d|5[14-9]|8[36-8]|9[1-8])|9(?:0[1-3689]|1[1-79]|[379]\\d|4[13]|5[1-5]))(?:100|9[56])"],"0$1","$CC $1"],[,"(\\d{3})(\\d{3})(\\d{4})","$1 $2 $3",["(?:4|80)0"]],[,"(\\d{2})(\\d{4})(\\d{4})","$1 $2 $3",["10|2(?:[02-57-9]|1[1-9])","10|2(?:[02-57-9]|1[1-9])","10[0-79]|2(?:[02-57-9]|1[1-79])|(?:10|21)8(?:0[1-9]|[1-9])"],
"0$1","$CC $1",1],[,"(\\d{3})(\\d{3})(\\d{4})","$1 $2 $3",["3(?:[3-59]|7[02-68])|4(?:[26-8]|3[3-9]|5[2-9])|5(?:3[03-9]|[468]|7[028]|9[2-46-9])|6|7(?:[0-247]|3[04-9]|5[0-4689]|6[2368])|8(?:[1-358]|9[1-7])|9(?:[013479]|5[1-5])|(?:[34]1|55|79|87)[02-9]"],"0$1","$CC $1",1],[,"(\\d{3})(\\d{7,8})","$1 $2",["9"]],[,"(\\d{4})(\\d{3})(\\d{4})","$1 $2 $3",["80"],"0$1","$CC $1",1],[,"(\\d{3})(\\d{4})(\\d{4})","$1 $2 $3",["[3-578]"],"0$1","$CC $1",1],[,"(\\d{3})(\\d{4})(\\d{4})","$1 $2 $3",["1[3-9]"],,"$CC $1"],
[,"(\\d{2})(\\d{3})(\\d{3})(\\d{4})","$1 $2 $3 $4",["[12]"],"0$1",,1]],[,,,,,,,,,[-1]],,,[,,"(?:(?:10|21)8|[48])00\\d{7}|950\\d{7,8}",,,,,,,[10,11,12]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],CO:[,[,,"(?:1\\d|3)\\d{9}|[124-8]\\d{7}",,,,,,,[8,10,11],[7]],[,,"[124-8][2-9]\\d{6}",,,,"12345678",,,[8],[7]],[,,"3333(?:0(?:0\\d|1[0-5])|[4-9]\\d\\d)\\d{3}|33(?:00|3[0-24-9])\\d{6}|3(?:0[0-5]|1\\d|2[0-3]|5[01]|70)\\d{7}",,,,"3211234567",,,[10]],[,,"1800\\d{7}",,,,"18001234567",,,[11]],[,,"19(?:0[01]|4[78])\\d{7}",
,,,"19001234567",,,[11]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],"CO",57,"00(?:4(?:[14]4|56)|[579])","0",,,"0([3579]|4(?:[14]4|56))?",,,,[[,"(\\d)(\\d{7})","$1 $2",["[14][2-9]|[25-8]"],"($1)","0$CC $1"],[,"(\\d{3})(\\d{7})","$1 $2",["3"],,"0$CC $1"],[,"(\\d)(\\d{3})(\\d{7})","$1-$2-$3",["1"],"0$1"]],[[,"(\\d)(\\d{7})","$1 $2",["[14][2-9]|[25-8]"],"($1)","0$CC $1"],[,"(\\d{3})(\\d{7})","$1 $2",["3"],,"0$CC $1"],[,"(\\d)(\\d{3})(\\d{7})","$1 $2 $3",["1"]]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],
[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],CR:[,[,,"(?:8\\d|90)\\d{8}|(?:[24-8]\\d{3}|3005)\\d{4}",,,,,,,[8,10]],[,,"210[7-9]\\d{4}|2(?:[024-7]\\d|1[1-9])\\d{5}",,,,"22123456",,,[8]],[,,"(?:3005\\d|6500[01])\\d{3}|(?:5[07]|6[0-4]|7[0-3]|8[3-9])\\d{6}",,,,"83123456",,,[8]],[,,"800\\d{7}",,,,"8001234567",,,[10]],[,,"90[059]\\d{7}",,,,"9001234567",,,[10]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,"(?:210[0-6]|4\\d{3}|5100)\\d{4}",,,,"40001234",,,[8]],"CR",506,"00",,,,"(19(?:0[0-2468]|1[09]|20|66|77|99))",,,,[[,"(\\d{4})(\\d{4})",
"$1 $2",["[2-7]|8[3-9]"],,"$CC $1"],[,"(\\d{3})(\\d{3})(\\d{4})","$1-$2-$3",["[89]"],,"$CC $1"]],,[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],CU:[,[,,"[27]\\d{6,7}|[34]\\d{5,7}|(?:5|8\\d\\d)\\d{7}",,,,,,,[6,7,8,10],[4,5]],[,,"(?:3[23]|48)\\d{4,6}|(?:31|4[36]|8(?:0[25]|78)\\d)\\d{6}|(?:2[1-4]|4[1257]|7\\d)\\d{5,6}",,,,"71234567",,,,[4,5]],[,,"5\\d{7}",,,,"51234567",,,[8]],[,,"800\\d{7}",,,,"8001234567",,,[10]],[,,,,,,,,,[-1]],[,,"807\\d{7}",,,,"8071234567",,,[10]],[,,,,,,,
,,[-1]],[,,,,,,,,,[-1]],"CU",53,"119","0",,,"0",,,,[[,"(\\d{2})(\\d{4,6})","$1 $2",["2[1-4]|[34]"],"(0$1)"],[,"(\\d)(\\d{6,7})","$1 $2",["7"],"(0$1)"],[,"(\\d)(\\d{7})","$1 $2",["5"],"0$1"],[,"(\\d{3})(\\d{7})","$1 $2",["8"],"0$1"]],,[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],CV:[,[,,"(?:[2-59]\\d\\d|800)\\d{4}",,,,,,,[7]],[,,"2(?:2[1-7]|3[0-8]|4[12]|5[1256]|6\\d|7[1-3]|8[1-5])\\d{4}",,,,"2211234"],[,,"(?:[34][36]|5[1-389]|9\\d)\\d{5}",,,,"9911234"],[,,"800\\d{4}",,,,"8001234"],
[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],"CV",238,"0",,,,,,,,[[,"(\\d{3})(\\d{2})(\\d{2})","$1 $2 $3",["[2-589]"]]],,[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],CW:[,[,,"(?:[34]1|60|(?:7|9\\d)\\d)\\d{5}",,,,,,,[7,8]],[,,"9(?:4(?:3[0-5]|4[14]|6\\d)|50\\d|7(?:2[014]|3[02-9]|4[4-9]|6[357]|77|8[7-9])|8(?:3[39]|[46]\\d|7[01]|8[57-9]))\\d{4}",,,,"94351234"],[,,"953[01]\\d{4}|9(?:5[12467]|6[5-9])\\d{5}",,,,"95181234"],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,"60[0-2]\\d{4}",
,,,"6001234",,,[7]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],"CW",599,"00",,,,,,,,[[,"(\\d{3})(\\d{4})","$1 $2",["[3467]"]],[,"(\\d)(\\d{3})(\\d{4})","$1 $2 $3",["9[4-8]"]]],,[,,"955\\d{5}",,,,"95581234",,,[8]],1,"[69]",[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],CX:[,[,,"1(?:[0-79]\\d|8[0-24-9])\\d{7}|(?:[148]\\d\\d|550)\\d{6}|1\\d{5,7}",,,,,,,[6,7,8,9,10]],[,,"8(?:51(?:0(?:01|30|59)|117)|91(?:00[6-9]|1(?:[28]1|49|78)|2(?:09|63)|3(?:12|26|75)|4(?:56|97)|64\\d|7(?:0[01]|1[0-2])|958))\\d{3}",,,,"891641234",
,,[9],[8]],[,,"483[0-3]\\d{5}|4(?:[0-3]\\d|4[047-9]|5[0-25-9]|6[06-9]|7[02-9]|8[0-2457-9]|9[0-27-9])\\d{6}",,,,"412345678",,,[9]],[,,"180(?:0\\d{3}|2)\\d{3}",,,,"1800123456",,,[7,10]],[,,"190[0-26]\\d{6}",,,,"1900123456",,,[10]],[,,"13(?:00\\d{3}|45[0-4])\\d{3}|13\\d{4}",,,,"1300123456",,,[6,8,10]],[,,,,,,,,,[-1]],[,,"(?:14(?:5(?:1[0458]|[23][458])|71\\d)|550\\d\\d)\\d{4}",,,,"550123456",,,[9]],"CX",61,"001[14-689]|14(?:1[14]|34|4[17]|[56]6|7[47]|88)0011","0",,,"0|([59]\\d{7})$","8$1","0011",,,,[,
,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],CY:[,[,,"(?:[279]\\d|[58]0)\\d{6}",,,,,,,[8]],[,,"2[2-6]\\d{6}",,,,"22345678"],[,,"9[4-79]\\d{6}",,,,"96123456"],[,,"800\\d{5}",,,,"80001234"],[,,"90[09]\\d{5}",,,,"90012345"],[,,"80[1-9]\\d{5}",,,,"80112345"],[,,"700\\d{5}",,,,"70012345"],[,,,,,,,,,[-1]],"CY",357,"00",,,,,,,,[[,"(\\d{2})(\\d{6})","$1 $2",["[257-9]"]]],,[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,"(?:50|77)\\d{6}",,,,"77123456"],,,[,,,,,,,,,[-1]]],CZ:[,[,,"(?:[2-578]\\d|60)\\d{7}|9\\d{8,11}",
,,,,,,[9,10,11,12]],[,,"(?:2\\d|3[1257-9]|4[16-9]|5[13-9])\\d{7}",,,,"212345678",,,[9]],[,,"(?:60[1-8]|7(?:0[2-5]|[2379]\\d))\\d{6}",,,,"601123456",,,[9]],[,,"800\\d{6}",,,,"800123456",,,[9]],[,,"9(?:0[05689]|76)\\d{6}",,,,"900123456",,,[9]],[,,"8[134]\\d{7}",,,,"811234567",,,[9]],[,,"70[01]\\d{6}",,,,"700123456",,,[9]],[,,"9[17]0\\d{6}",,,,"910123456",,,[9]],"CZ",420,"00",,,,,,,,[[,"(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["[2-8]|9[015-7]"]],[,"(\\d{2})(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3 $4",["9"]],
[,"(\\d{3})(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3 $4",["9"]]],,[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,"9(?:5\\d|7[2-4])\\d{6}",,,,"972123456",,,[9]],,,[,,"9(?:3\\d{9}|6\\d{7,10})",,,,"93123456789"]],DE:[,[,,"[2579]\\d{5,14}|49(?:[05]\\d{10}|[46][1-8]\\d{4,9})|49(?:[0-25]\\d|3[1-689]|7[1-7])\\d{4,8}|49(?:[0-2579]\\d|[34][1-9]|6[0-8])\\d{3}|49\\d{3,4}|(?:1|[368]\\d|4[0-8])\\d{3,13}",,,,,,,[4,5,6,7,8,9,10,11,12,13,14,15],[2,3]],[,,"(?:32|49[4-6]\\d)\\d{9}|49[0-7]\\d{3,9}|(?:[34]0|[68]9)\\d{3,13}|(?:2(?:0[1-689]|[1-3569]\\d|4[0-8]|7[1-7]|8[0-7])|3(?:[3569]\\d|4[0-79]|7[1-7]|8[1-8])|4(?:1[02-9]|[2-48]\\d|5[0-6]|6[0-8]|7[0-79])|5(?:0[2-8]|[124-6]\\d|[38][0-8]|[79][0-7])|6(?:0[02-9]|[1-358]\\d|[47][0-8]|6[1-9])|7(?:0[2-8]|1[1-9]|[27][0-7]|3\\d|[4-6][0-8]|8[0-5]|9[013-7])|8(?:0[2-9]|1[0-79]|2\\d|3[0-46-9]|4[0-6]|5[013-9]|6[1-8]|7[0-8]|8[0-24-6])|9(?:0[6-9]|[1-4]\\d|[589][0-7]|6[0-8]|7[0-467]))\\d{3,12}",
,,,"30123456",,,[5,6,7,8,9,10,11,12,13,14,15],[2,3,4]],[,,"15[0-25-9]\\d{8}|1(?:6[023]|7\\d)\\d{7,8}",,,,"15123456789",,,[10,11]],[,,"800\\d{7,12}",,,,"8001234567890",,,[10,11,12,13,14,15]],[,,"(?:137[7-9]|900(?:[135]|9\\d))\\d{6}",,,,"9001234567",,,[10,11]],[,,"180\\d{5,11}|13(?:7[1-6]\\d\\d|8)\\d{4}",,,,"18012345",,,[7,8,9,10,11,12,13,14]],[,,"700\\d{8}",,,,"70012345678",,,[11]],[,,,,,,,,,[-1]],"DE",49,"00","0",,,"0",,,,[[,"(\\d{2})(\\d{3,13})","$1 $2",["3[02]|40|[68]9"],"0$1"],[,"(\\d{3})(\\d{3,12})",
"$1 $2",["2(?:0[1-389]|1[124]|2[18]|3[14])|3(?:[35-9][15]|4[015])|906|(?:2[4-9]|4[2-9]|[579][1-9]|[68][1-8])1","2(?:0[1-389]|12[0-8])|3(?:[35-9][15]|4[015])|906|2(?:[13][14]|2[18])|(?:2[4-9]|4[2-9]|[579][1-9]|[68][1-8])1"],"0$1"],[,"(\\d{4})(\\d{2,11})","$1 $2",["[24-6]|3(?:[3569][02-46-9]|4[2-4679]|7[2-467]|8[2-46-8])|70[2-8]|8(?:0[2-9]|[1-8])|90[7-9]|[79][1-9]","[24-6]|3(?:3(?:0[1-467]|2[127-9]|3[124578]|7[1257-9]|8[1256]|9[145])|4(?:2[135]|4[13578]|9[1346])|5(?:0[14]|2[1-3589]|6[1-4]|7[13468]|8[13568])|6(?:2[1-489]|3[124-6]|6[13]|7[12579]|8[1-356]|9[135])|7(?:2[1-7]|4[145]|6[1-5]|7[1-4])|8(?:21|3[1468]|6|7[1467]|8[136])|9(?:0[12479]|2[1358]|4[134679]|6[1-9]|7[136]|8[147]|9[1468]))|70[2-8]|8(?:0[2-9]|[1-8])|90[7-9]|[79][1-9]|3[68]4[1347]|3(?:47|60)[1356]|3(?:3[46]|46|5[49])[1246]|3[4579]3[1357]"],
"0$1"],[,"(\\d{3})(\\d{4})","$1 $2",["138"],"0$1"],[,"(\\d{5})(\\d{2,10})","$1 $2",["3"],"0$1"],[,"(\\d{3})(\\d{5,11})","$1 $2",["181"],"0$1"],[,"(\\d{3})(\\d)(\\d{4,10})","$1 $2 $3",["1(?:3|80)|9"],"0$1"],[,"(\\d{3})(\\d{7,8})","$1 $2",["1[67]"],"0$1"],[,"(\\d{3})(\\d{7,12})","$1 $2",["8"],"0$1"],[,"(\\d{5})(\\d{6})","$1 $2",["185","1850","18500"],"0$1"],[,"(\\d{3})(\\d{4})(\\d{4})","$1 $2 $3",["7"],"0$1"],[,"(\\d{4})(\\d{7})","$1 $2",["18[68]"],"0$1"],[,"(\\d{5})(\\d{6})","$1 $2",["15[0568]"],"0$1"],
[,"(\\d{4})(\\d{7})","$1 $2",["15[1279]"],"0$1"],[,"(\\d{3})(\\d{8})","$1 $2",["18"],"0$1"],[,"(\\d{3})(\\d{2})(\\d{7,8})","$1 $2 $3",["1(?:6[023]|7)"],"0$1"],[,"(\\d{4})(\\d{2})(\\d{7})","$1 $2 $3",["15[279]"],"0$1"],[,"(\\d{3})(\\d{2})(\\d{8})","$1 $2 $3",["15"],"0$1"]],,[,,"16(?:4\\d{1,10}|[89]\\d{1,11})",,,,"16412345",,,[4,5,6,7,8,9,10,11,12,13,14]],,,[,,,,,,,,,[-1]],[,,"18(?:1\\d{5,11}|[2-9]\\d{8})",,,,"18500123456",,,[8,9,10,11,12,13,14]],,,[,,"1(?:6(?:013|255|399)|7(?:(?:[015]1|[69]3)3|[2-4]55|[78]99))\\d{7,8}|15(?:(?:[03-68]00|113)\\d|2\\d55|7\\d99|9\\d33)\\d{7}",
,,,"177991234567",,,[12,13]]],DJ:[,[,,"(?:2\\d|77)\\d{6}",,,,,,,[8]],[,,"2(?:1[2-5]|7[45])\\d{5}",,,,"21360003"],[,,"77\\d{6}",,,,"77831001"],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],"DJ",253,"00",,,,,,,,[[,"(\\d{2})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[27]"]]],,[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],DK:[,[,,"[2-9]\\d{7}",,,,,,,[8]],[,,"(?:[2-7]\\d|8[126-9]|9[1-46-9])\\d{6}",,,,"32123456"],[,,"(?:[2-7]\\d|8[126-9]|9[1-46-9])\\d{6}",
,,,"32123456"],[,,"80\\d{6}",,,,"80123456"],[,,"90\\d{6}",,,,"90123456"],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],"DK",45,"00",,,,,,,1,[[,"(\\d{2})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[2-9]"]]],,[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],DM:[,[,,"(?:[58]\\d\\d|767|900)\\d{7}",,,,,,,[10],[7]],[,,"767(?:2(?:55|66)|4(?:2[01]|4[0-25-9])|50[0-4])\\d{4}",,,,"7674201234",,,,[7]],[,,"767(?:2(?:[2-4689]5|7[5-7])|31[5-7]|61[1-7]|70[1-6])\\d{4}",,,,"7672251234",,,,[7]],
[,,"8(?:00|33|44|55|66|77|88)[2-9]\\d{6}",,,,"8002123456"],[,,"900[2-9]\\d{6}",,,,"9002123456"],[,,,,,,,,,[-1]],[,,"52(?:35(?:[02-46-9]\\d|1[02-9]|5[0-46-9])|45(?:[034]\\d|1[02-9]|2[024-9]|5[0-46-9]))\\d{4}|52(?:3[2-46-9]|4[2-4])(?:[02-9]\\d|1[02-9])\\d{4}|5(?:00|2[12]|33|44|66|77|88)[2-9]\\d{6}",,,,"5002345678"],[,,,,,,,,,[-1]],"DM",1,"011","1",,,"1|([2-7]\\d{6})$","767$1",,,,,[,,,,,,,,,[-1]],,"767",[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],DO:[,[,,"(?:[58]\\d\\d|900)\\d{7}",,,,,,,[10],
[7]],[,,"8(?:[04]9[2-9]\\d\\d|29(?:2(?:[0-59]\\d|6[04-9]|7[0-27]|8[0237-9])|3(?:[0-35-9]\\d|4[7-9])|[45]\\d\\d|6(?:[0-27-9]\\d|[3-5][1-9]|6[0135-8])|7(?:0[013-9]|[1-37]\\d|4[1-35689]|5[1-4689]|6[1-57-9]|8[1-79]|9[1-8])|8(?:0[146-9]|1[0-48]|[248]\\d|3[1-79]|5[01589]|6[013-68]|7[124-8]|9[0-8])|9(?:[0-24]\\d|3[02-46-9]|5[0-79]|60|7[0169]|8[57-9]|9[02-9])))\\d{4}",,,,"8092345678",,,,[7]],[,,"8[024]9[2-9]\\d{6}",,,,"8092345678",,,,[7]],[,,"8(?:00|33|44|55|66|77|88)[2-9]\\d{6}",,,,"8002123456"],[,,"900[2-9]\\d{6}",
,,,"9002123456"],[,,,,,,,,,[-1]],[,,"52(?:35(?:[02-46-9]\\d|1[02-9]|5[0-46-9])|45(?:[034]\\d|1[02-9]|2[024-9]|5[0-46-9]))\\d{4}|52(?:3[2-46-9]|4[2-4])(?:[02-9]\\d|1[02-9])\\d{4}|5(?:00|2[12]|33|44|66|77|88)[2-9]\\d{6}",,,,"5002345678"],[,,,,,,,,,[-1]],"DO",1,"011","1",,,"1",,,,,,[,,,,,,,,,[-1]],,"8[024]9",[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],DZ:[,[,,"(?:[1-4]|[5-79]\\d|80)\\d{7}",,,,,,,[8,9]],[,,"9619\\d{5}|(?:1\\d|2[013-79]|3[0-8]|4[0135689])\\d{6}",,,,"12345678"],[,,"(?:5(?:4[0-29]|5\\d|6[01])|6(?:[569]\\d|7[0-6])|7[7-9]\\d)\\d{6}",
,,,"551234567",,,[9]],[,,"800\\d{6}",,,,"800123456",,,[9]],[,,"80[3-689]1\\d{5}",,,,"808123456",,,[9]],[,,"80[12]1\\d{5}",,,,"801123456",,,[9]],[,,,,,,,,,[-1]],[,,"98[23]\\d{6}",,,,"983123456",,,[9]],"DZ",213,"00","0",,,"0",,,,[[,"(\\d{2})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[1-4]"],"0$1"],[,"(\\d{2})(\\d{3})(\\d{2})(\\d{2})","$1 $2 $3 $4",["9"],"0$1"],[,"(\\d{3})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[5-8]"],"0$1"]],,[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],EC:[,
[,,"1\\d{9,10}|(?:[2-7]|9\\d)\\d{7}",,,,,,,[8,9,10,11],[7]],[,,"[2-7][2-7]\\d{6}",,,,"22123456",,,[8],[7]],[,,"964[0-2]\\d{5}|9(?:39|[57][89]|6[0-36-9]|[89]\\d)\\d{6}",,,,"991234567",,,[9]],[,,"1800\\d{7}|1[78]00\\d{6}",,,,"18001234567",,,[10,11]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,"[2-7]890\\d{4}",,,,"28901234",,,[8]],"EC",593,"00","0",,,"0",,,,[[,"(\\d{3})(\\d{4})","$1-$2",["[2-7]"]],[,"(\\d)(\\d{3})(\\d{4})","$1 $2-$3",["[2-7]"],"(0$1)"],[,"(\\d{2})(\\d{3})(\\d{4})","$1 $2 $3",
["9"],"0$1"],[,"(\\d{4})(\\d{3})(\\d{3,4})","$1 $2 $3",["1"]]],[[,"(\\d)(\\d{3})(\\d{4})","$1-$2-$3",["[2-7]"]],[,"(\\d{2})(\\d{3})(\\d{4})","$1 $2 $3",["9"],"0$1"],[,"(\\d{4})(\\d{3})(\\d{3,4})","$1 $2 $3",["1"]]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],EE:[,[,,"8\\d{9}|[4578]\\d{7}|(?:[3-8]\\d|90)\\d{5}",,,,,,,[7,8,10]],[,,"(?:3[23589]|4[3-8]|6\\d|7[1-9]|88)\\d{5}",,,,"3212345",,,[7]],[,,"5(?:[0-35-9]\\d{6}|4(?:[0-57-9]\\d{5}|6(?:[0-24-9]\\d{4}|3(?:[0-35-9]\\d{3}|4000))))|8(?:1(?:0(?:000|[3-9]\\d\\d)|(?:1(?:0[236]|1\\d)|(?:23|[3-79]\\d)\\d)\\d)|2(?:0(?:000|(?:19|[24-7]\\d)\\d)|(?:(?:[124-6]\\d|3[5-9]|8[2-4])\\d|7(?:[679]\\d|8[13-9]))\\d)|[349]\\d{4})\\d\\d|5(?:(?:[02]\\d|5[0-478])\\d|1(?:[0-8]\\d|95)|6(?:4[0-4]|5[1-589]))\\d{3}",
,,,"51234567",,,[7,8]],[,,"800(?:(?:0\\d\\d|1)\\d|[2-9])\\d{3}",,,,"80012345"],[,,"(?:40\\d\\d|900)\\d{4}",,,,"9001234",,,[7,8]],[,,,,,,,,,[-1]],[,,"70[0-2]\\d{5}",,,,"70012345",,,[8]],[,,,,,,,,,[-1]],"EE",372,"00",,,,,,,,[[,"(\\d{3})(\\d{4})","$1 $2",["[369]|4[3-8]|5(?:[0-2]|5[0-478]|6[45])|7[1-9]|88","[369]|4[3-8]|5(?:[02]|1(?:[0-8]|95)|5[0-478]|6(?:4[0-4]|5[1-589]))|7[1-9]|88"]],[,"(\\d{4})(\\d{3,4})","$1 $2",["[45]|8(?:00|[1-49])","[45]|8(?:00[1-9]|[1-49])"]],[,"(\\d{2})(\\d{2})(\\d{4})","$1 $2 $3",
["7"]],[,"(\\d{4})(\\d{3})(\\d{3})","$1 $2 $3",["8"]]],,[,,,,,,,,,[-1]],,,[,,"800[2-9]\\d{3}",,,,,,,[7]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],EG:[,[,,"[189]\\d{8,9}|[24-6]\\d{8}|[135]\\d{7}",,,,,,,[8,9,10],[6,7]],[,,"13[23]\\d{6}|(?:15|57)\\d{6,7}|(?:2[2-4]|3|4[05-8]|5[05]|6[24-689]|8[2468]|9[235-7])\\d{7}",,,,"234567890",,,[8,9],[6,7]],[,,"1[0-25]\\d{8}",,,,"1001234567",,,[10]],[,,"800\\d{7}",,,,"8001234567",,,[10]],[,,"900\\d{7}",,,,"9001234567",,,[10]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],
"EG",20,"00","0",,,"0",,,,[[,"(\\d)(\\d{7,8})","$1 $2",["[23]"],"0$1"],[,"(\\d{2})(\\d{6,7})","$1 $2",["1[35]|[4-6]|8[2468]|9[235-7]"],"0$1"],[,"(\\d{3})(\\d{3})(\\d{4})","$1 $2 $3",["[189]"],"0$1"]],,[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],EH:[,[,,"[5-8]\\d{8}",,,,,,,[9]],[,,"528[89]\\d{5}",,,,"528812345"],[,,"(?:6(?:[0-79]\\d|8[0-247-9])|7(?:0[016-8]|6[1267]|7[0-27]))\\d{6}",,,,"650123456"],[,,"80\\d{7}",,,,"801234567"],[,,"89\\d{7}",,,,"891234567"],[,,,,,,,,,[-1]],
[,,,,,,,,,[-1]],[,,"592(?:4[0-2]|93)\\d{4}",,,,"592401234"],"EH",212,"00","0",,,"0",,,,,,[,,,,,,,,,[-1]],,"528[89]",[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],ER:[,[,,"[178]\\d{6}",,,,,,,[7],[6]],[,,"(?:1(?:1[12568]|[24]0|55|6[146])|8\\d\\d)\\d{4}",,,,"8370362",,,,[6]],[,,"(?:17[1-3]|7\\d\\d)\\d{4}",,,,"7123456"],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],"ER",291,"00","0",,,"0",,,,[[,"(\\d)(\\d{3})(\\d{3})","$1 $2 $3",["[178]"],"0$1"]],,[,,,,,,,,,[-1]],
,,[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],ES:[,[,,"(?:51|[6-9]\\d)\\d{7}",,,,,,,[9]],[,,"96906(?:0[0-8]|1[1-9]|[2-9]\\d)\\d\\d|9(?:69(?:0[0-57-9]|[1-9]\\d)|73(?:[0-8]\\d|9[1-9]))\\d{4}|(?:8(?:[1356]\\d|[28][0-8]|[47][1-9])|9(?:[135]\\d|[268][0-8]|4[1-9]|7[124-9]))\\d{6}",,,,"810123456"],[,,"9(?:6906(?:09|10)|7390\\d\\d)\\d\\d|(?:6\\d|7[1-48])\\d{7}",,,,"612345678"],[,,"[89]00\\d{6}",,,,"800123456"],[,,"80[367]\\d{6}",,,,"803123456"],[,,"90[12]\\d{6}",,,,"901123456"],[,,"70\\d{7}",,,,"701234567"],
[,,,,,,,,,[-1]],"ES",34,"00",,,,,,,,[[,"(\\d{4})","$1",["905"]],[,"(\\d{6})","$1",["[79]9"]],[,"(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["[89]00"]],[,"(\\d{3})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[5-9]"]]],[[,"(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["[89]00"]],[,"(\\d{3})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[5-9]"]]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,"51\\d{7}",,,,"511234567"],,,[,,,,,,,,,[-1]]],ET:[,[,,"(?:11|[2-59]\\d)\\d{7}",,,,,,,[9],[7]],[,,"116671\\d{3}|(?:11(?:1(?:1[124]|2[2-57]|3[1-5]|5[5-8]|8[6-8])|2(?:13|3[6-8]|5[89]|7[05-9]|8[2-6])|3(?:2[01]|3[0-289]|4[1289]|7[1-4]|87)|4(?:1[69]|3[2-49]|4[0-3]|6[5-8])|5(?:1[578]|44|5[0-4])|6(?:1[78]|2[69]|39|4[5-7]|5[1-5]|6[0-59]|8[015-8]))|2(?:2(?:11[1-9]|22[0-7]|33\\d|44[1467]|66[1-68])|5(?:11[124-6]|33[2-8]|44[1467]|55[14]|66[1-3679]|77[124-79]|880))|3(?:3(?:11[0-46-8]|(?:22|55)[0-6]|33[0134689]|44[04]|66[01467])|4(?:44[0-8]|55[0-69]|66[0-3]|77[1-5]))|4(?:6(?:119|22[0-24-7]|33[1-5]|44[13-69]|55[14-689]|660|88[1-4])|7(?:(?:11|22)[1-9]|33[13-7]|44[13-6]|55[1-689]))|5(?:7(?:227|55[05]|(?:66|77)[14-8])|8(?:11[149]|22[013-79]|33[0-68]|44[013-8]|550|66[1-5]|77\\d)))\\d{4}",
,,,"111112345",,,,[7]],[,,"9\\d{8}",,,,"911234567"],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],"ET",251,"00","0",,,"0",,,,[[,"(\\d{2})(\\d{3})(\\d{4})","$1 $2 $3",["[1-59]"],"0$1"]],,[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],FI:[,[,,"[1-35689]\\d{4}|7\\d{10,11}|(?:[124-7]\\d|3[0-46-9])\\d{8}|[1-9]\\d{5,8}",,,,,,,[5,6,7,8,9,10,11,12]],[,,"(?:1[3-79][1-8]|[235689][1-8]\\d)\\d{2,6}",,,,"131234567",,,[5,6,7,8,9]],[,,"(?:4[0-8]|50)\\d{4,8}",
,,,"412345678",,,[6,7,8,9,10]],[,,"800\\d{4,6}",,,,"800123456",,,[7,8,9]],[,,"[67]00\\d{5,6}",,,,"600123456",,,[8,9]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],"FI",358,"00|99(?:[01469]|5(?:[14]1|3[23]|5[59]|77|88|9[09]))","0",,,"0",,"00",,[[,"(\\d{5})","$1",["75[12]"],"0$1"],[,"(\\d)(\\d{4,9})","$1 $2",["[2568][1-8]|3(?:0[1-9]|[1-9])|9"],"0$1"],[,"(\\d{6})","$1",["11"]],[,"(\\d{3})(\\d{3,7})","$1 $2",["[12]00|[368]|70[07-9]"],"0$1"],[,"(\\d{2})(\\d{4,8})","$1 $2",["[1245]|7[135]"],"0$1"],[,
"(\\d{2})(\\d{6,10})","$1 $2",["7"],"0$1"]],[[,"(\\d)(\\d{4,9})","$1 $2",["[2568][1-8]|3(?:0[1-9]|[1-9])|9"],"0$1"],[,"(\\d{3})(\\d{3,7})","$1 $2",["[12]00|[368]|70[07-9]"],"0$1"],[,"(\\d{2})(\\d{4,8})","$1 $2",["[1245]|7[135]"],"0$1"],[,"(\\d{2})(\\d{6,10})","$1 $2",["7"],"0$1"]],[,,,,,,,,,[-1]],1,"1[03-79]|[2-9]",[,,"20(?:2[023]|9[89])\\d{1,6}|(?:60[12]\\d|7099)\\d{4,5}|(?:606|7(?:0[78]|1|3\\d))\\d{7}|(?:[1-3]00|7(?:0[1-5]\\d\\d|5[03-9]))\\d{3,7}"],[,,"20\\d{4,8}|60[12]\\d{5,6}|7(?:099\\d{4,5}|5[03-9]\\d{3,7})|20[2-59]\\d\\d|(?:606|7(?:0[78]|1|3\\d))\\d{7}|(?:10|29|3[09]|70[1-5]\\d)\\d{4,8}",
,,,"10112345"],,,[,,,,,,,,,[-1]]],FJ:[,[,,"45\\d{5}|(?:0800\\d|[235-9])\\d{6}",,,,,,,[7,11]],[,,"603\\d{4}|(?:3[0-5]|6[25-7]|8[58])\\d{5}",,,,"3212345",,,[7]],[,,"(?:[279]\\d|45|5[01568]|8[034679])\\d{5}",,,,"7012345",,,[7]],[,,"0800\\d{7}",,,,"08001234567",,,[11]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],"FJ",679,"0(?:0|52)",,,,,,"00",,[[,"(\\d{3})(\\d{4})","$1 $2",["[235-9]|45"]],[,"(\\d{4})(\\d{3})(\\d{4})","$1 $2 $3",["0"]]],,[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,,,,,,,,
[-1]],,,[,,,,,,,,,[-1]]],FK:[,[,,"[2-7]\\d{4}",,,,,,,[5]],[,,"[2-47]\\d{4}",,,,"31234"],[,,"[56]\\d{4}",,,,"51234"],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],"FK",500,"00",,,,,,,,,,[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],FM:[,[,,"(?:[39]\\d\\d|820)\\d{4}",,,,,,,[7]],[,,"31(?:00[67]|208|309)\\d\\d|(?:3(?:[2357]0[1-9]|602|804|905)|(?:820|9[2-6]\\d)\\d)\\d{3}",,,,"3201234"],[,,"31(?:00[67]|208|309)\\d\\d|(?:3(?:[2357]0[1-9]|602|804|905)|(?:820|9[2-7]\\d)\\d)\\d{3}",
,,,"3501234"],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],"FM",691,"00",,,,,,,,[[,"(\\d{3})(\\d{4})","$1 $2",["[389]"]]],,[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],FO:[,[,,"(?:[2-8]\\d|90)\\d{4}",,,,,,,[6]],[,,"(?:20|[34]\\d|8[19])\\d{4}",,,,"201234"],[,,"(?:[27][1-9]|5\\d)\\d{4}",,,,"211234"],[,,"80[257-9]\\d{3}",,,,"802123"],[,,"90(?:[13-5][15-7]|2[125-7]|9\\d)\\d\\d",,,,"901123"],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,"(?:6[0-36]|88)\\d{4}",
,,,"601234"],"FO",298,"00",,,,"(10(?:01|[12]0|88))",,,,[[,"(\\d{6})","$1",["[2-9]"],,"$CC $1"]],,[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],FR:[,[,,"[1-9]\\d{8}",,,,,,,[9]],[,,"(?:[1-35]\\d|4[1-9])\\d{7}",,,,"123456789"],[,,"700\\d{6}|(?:6\\d|7[3-9])\\d{7}",,,,"612345678"],[,,"80[0-5]\\d{6}",,,,"801234567"],[,,"836(?:0[0-36-9]|[1-9]\\d)\\d{4}|8(?:1[2-9]|2[2-47-9]|3[0-57-9]|[569]\\d|8[0-35-9])\\d{6}",,,,"891123456"],[,,"8(?:1[01]|2[0156]|84)\\d{6}",,,,"884012345"],[,,,,,,
,,,[-1]],[,,"9\\d{8}",,,,"912345678"],"FR",33,"00","0",,,"0",,,,[[,"(\\d{4})","$1",["10"]],[,"(\\d{3})(\\d{3})","$1 $2",["1"]],[,"(\\d{3})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["8"],"0 $1"],[,"(\\d)(\\d{2})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4 $5",["[1-79]"],"0$1"]],[[,"(\\d{3})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["8"],"0 $1"],[,"(\\d)(\\d{2})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4 $5",["[1-79]"],"0$1"]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,"80[6-9]\\d{6}",,,,"806123456"],,,[,,,,,,,,,[-1]]],
GA:[,[,,"(?:[067]\\d|11)\\d{6}|[2-7]\\d{6}",,,,,,,[7,8]],[,,"[01]1\\d{6}",,,,"01441234",,,[8]],[,,"(?:0[2-7]|6[256]|7[47])\\d{6}|[2-7]\\d{6}",,,,"06031234"],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],"GA",241,"00",,,,"0(11\\d{6}|6[256]\\d{6}|7[47]\\d{6})","$1",,,[[,"(\\d)(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[2-7]"],"0$1"],[,"(\\d{2})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["11|[67]"],"0$1"],[,"(\\d{2})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["0"]]],,[,,,,
,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],GB:[,[,,"[1-357-9]\\d{9}|[18]\\d{8}|8\\d{6}",,,,,,,[7,9,10],[4,5,6,8]],[,,"(?:1(?:1(?:3(?:[0-58]\\d\\d|73[03])|(?:4[0-5]|5[0-26-9]|6[0-4]|[78][0-49])\\d\\d)|2(?:(?:0[024-9]|2[3-9]|3[3-79]|4[1-689]|[58][02-9]|6[0-47-9]|7[013-9]|9\\d)\\d\\d|1(?:[0-7]\\d\\d|8(?:0\\d|20)))|(?:3(?:0\\d|1[0-8]|[25][02-9]|3[02-579]|[468][0-46-9]|7[1-35-79]|9[2-578])|4(?:0[03-9]|[137]\\d|[28][02-57-9]|4[02-69]|5[0-8]|[69][0-79])|5(?:0[1-35-9]|[16]\\d|2[024-9]|3[015689]|4[02-9]|5[03-9]|7[0-35-9]|8[0-468]|9[0-57-9])|6(?:0[034689]|1\\d|2[0-35689]|[38][013-9]|4[1-467]|5[0-69]|6[13-9]|7[0-8]|9[0-24578])|7(?:0[0246-9]|2\\d|3[0236-8]|4[03-9]|5[0-46-9]|6[013-9]|7[0-35-9]|8[024-9]|9[02-9])|8(?:0[35-9]|2[1-57-9]|3[02-578]|4[0-578]|5[124-9]|6[2-69]|7\\d|8[02-9]|9[02569])|9(?:0[02-589]|[18]\\d|2[02-689]|3[1-57-9]|4[2-9]|5[0-579]|6[2-47-9]|7[0-24578]|9[2-57]))\\d\\d)|2(?:0[013478]|3[0189]|4[017]|8[0-46-9]|9[0-2])\\d{3})\\d{4}|1(?:2(?:0(?:46[1-4]|87[2-9])|545[1-79]|76(?:2\\d|3[1-8]|6[1-6])|9(?:7(?:2[0-4]|3[2-5])|8(?:2[2-8]|7[0-47-9]|8[3-5])))|3(?:6(?:38[2-5]|47[23])|8(?:47[04-9]|64[0157-9]))|4(?:044[1-7]|20(?:2[23]|8\\d)|6(?:0(?:30|5[2-57]|6[1-8]|7[2-8])|140)|8(?:052|87[1-3]))|5(?:2(?:4(?:3[2-79]|6\\d)|76\\d)|6(?:26[06-9]|686))|6(?:06(?:4\\d|7[4-79])|295[5-7]|35[34]\\d|47(?:24|61)|59(?:5[08]|6[67]|74)|9(?:55[0-4]|77[23]))|7(?:26(?:6[13-9]|7[0-7])|(?:442|688)\\d|50(?:2[0-3]|[3-68]2|76))|8(?:27[56]\\d|37(?:5[2-5]|8[239])|843[2-58])|9(?:0(?:0(?:6[1-8]|85)|52\\d)|3583|4(?:66[1-8]|9(?:2[01]|81))|63(?:23|3[1-4])|9561))\\d{3}",
,,,"1212345678",,,[9,10],[4,5,6,7,8]],[,,"7(?:457[0-57-9]|700[01]|911[028])\\d{5}|7(?:[1-3]\\d\\d|4(?:[0-46-9]\\d|5[0-689])|5(?:0[0-8]|[13-9]\\d|2[0-35-9])|7(?:0[1-9]|[1-7]\\d|8[02-9]|9[0-689])|8(?:[014-9]\\d|[23][0-8])|9(?:[024-9]\\d|1[02-9]|3[0-689]))\\d{6}",,,,"7400123456",,,[10]],[,,"80[08]\\d{7}|800\\d{6}|8001111",,,,"8001234567"],[,,"(?:8(?:4[2-5]|7[0-3])|9(?:[01]\\d|8[2-49]))\\d{7}|845464\\d",,,,"9012345678",,,[7,10]],[,,,,,,,,,[-1]],[,,"70\\d{8}",,,,"7012345678",,,[10]],[,,"56\\d{8}",,,,"5612345678",
,,[10]],"GB",44,"00","0"," x",,"0",,,,[[,"(\\d{3})(\\d{4})","$1 $2",["800","8001","80011","800111","8001111"],"0$1"],[,"(\\d{3})(\\d{2})(\\d{2})","$1 $2 $3",["845","8454","84546","845464"],"0$1"],[,"(\\d{3})(\\d{6})","$1 $2",["800"],"0$1"],[,"(\\d{5})(\\d{4,5})","$1 $2",["1(?:38|5[23]|69|76|94)","1(?:(?:38|69)7|5(?:24|39)|768|946)","1(?:3873|5(?:242|39[4-6])|(?:697|768)[347]|9467)"],"0$1"],[,"(\\d{4})(\\d{5,6})","$1 $2",["1(?:[2-69][02-9]|[78])"],"0$1"],[,"(\\d{2})(\\d{4})(\\d{4})","$1 $2 $3",["[25]|7(?:0|6[02-9])",
"[25]|7(?:0|6(?:[03-9]|2[356]))"],"0$1"],[,"(\\d{4})(\\d{6})","$1 $2",["7"],"0$1"],[,"(\\d{3})(\\d{3})(\\d{4})","$1 $2 $3",["[1389]"],"0$1"]],,[,,"76(?:0[0-2]|2[356]|34|4[0134]|5[49]|6[0-369]|77|81|9[39])\\d{6}",,,,"7640123456",,,[10]],1,,[,,,,,,,,,[-1]],[,,"(?:3[0347]|55)\\d{8}",,,,"5512345678",,,[10]],,,[,,,,,,,,,[-1]]],GD:[,[,,"(?:473|[58]\\d\\d|900)\\d{7}",,,,,,,[10],[7]],[,,"473(?:2(?:3[0-2]|69)|3(?:2[89]|86)|4(?:[06]8|3[5-9]|4[0-49]|5[5-79]|73|90)|63[68]|7(?:58|84)|800|938)\\d{4}",,,,"4732691234",
,,,[7]],[,,"473(?:4(?:0[2-79]|1[04-9]|2[0-5]|58)|5(?:2[01]|3[3-8])|901)\\d{4}",,,,"4734031234",,,,[7]],[,,"8(?:00|33|44|55|66|77|88)[2-9]\\d{6}",,,,"8002123456"],[,,"900[2-9]\\d{6}",,,,"9002123456"],[,,,,,,,,,[-1]],[,,"52(?:35(?:[02-46-9]\\d|1[02-9]|5[0-46-9])|45(?:[034]\\d|1[02-9]|2[024-9]|5[0-46-9]))\\d{4}|52(?:3[2-46-9]|4[2-4])(?:[02-9]\\d|1[02-9])\\d{4}|5(?:00|2[12]|33|44|66|77|88)[2-9]\\d{6}",,,,"5002345678"],[,,,,,,,,,[-1]],"GD",1,"011","1",,,"1|([2-9]\\d{6})$","473$1",,,,,[,,,,,,,,,[-1]],,
"473",[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],GE:[,[,,"(?:[3-57]\\d\\d|800)\\d{6}",,,,,,,[9],[6,7]],[,,"(?:3(?:[256]\\d|4[124-9]|7[0-4])|4(?:1\\d|2[2-7]|3[1-79]|4[2-8]|7[239]|9[1-7]))\\d{6}",,,,"322123456",,,,[6,7]],[,,"5(?:0555[5-9]|757(?:7[7-9]|8[01]))\\d{3}|5(?:000\\d|(?:52|75)00|8(?:58[89]|888))\\d{4}|5(?:0050|1111|2222|3333)[0-4]\\d{3}|(?:5(?:[14]4|5[0157-9]|68|7[0147-9]|9[1-35-9])|790)\\d{6}",,,,"555123456"],[,,"800\\d{6}",,,,"800123456"],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,
,[-1]],[,,"706\\d{6}",,,,"706123456"],"GE",995,"00","0",,,"0",,,,[[,"(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["70"],"0$1"],[,"(\\d{2})(\\d{3})(\\d{2})(\\d{2})","$1 $2 $3 $4",["32"],"0$1"],[,"(\\d{3})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[57]"]],[,"(\\d{3})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[348]"],"0$1"]],,[,,,,,,,,,[-1]],,,[,,"706\\d{6}"],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],GF:[,[,,"(?:[56]94|976)\\d{6}",,,,,,,[9]],[,,"594(?:[023]\\d|1[01]|4[03-9]|5[6-9]|6[0-3]|80|9[014])\\d{4}",,,,"594101234"],
[,,"694(?:[0-249]\\d|3[0-48])\\d{4}",,,,"694201234"],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,"976\\d{6}",,,,"976012345"],"GF",594,"00","0",,,"0",,,,[[,"(\\d{3})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[569]"],"0$1"]],,[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],GG:[,[,,"(?:1481|[357-9]\\d{3})\\d{6}|8\\d{6}(?:\\d{2})?",,,,,,,[7,9,10],[6]],[,,"1481[25-9]\\d{5}",,,,"1481256789",,,[10],[6]],[,,"7(?:(?:781|839)\\d|911[17])\\d{5}",,,,"7781123456",,,[10]],
[,,"80[08]\\d{7}|800\\d{6}|8001111",,,,"8001234567"],[,,"(?:8(?:4[2-5]|7[0-3])|9(?:[01]\\d|8[0-3]))\\d{7}|845464\\d",,,,"9012345678",,,[7,10]],[,,,,,,,,,[-1]],[,,"70\\d{8}",,,,"7012345678",,,[10]],[,,"56\\d{8}",,,,"5612345678",,,[10]],"GG",44,"00","0",,,"0|([25-9]\\d{5})$","1481$1",,,,,[,,"76(?:0[0-2]|2[356]|34|4[0134]|5[49]|6[0-369]|77|81|9[39])\\d{6}",,,,"7640123456",,,[10]],,,[,,,,,,,,,[-1]],[,,"(?:3[0347]|55)\\d{8}",,,,"5512345678",,,[10]],,,[,,,,,,,,,[-1]]],GH:[,[,,"(?:[235]\\d{3}|800)\\d{5}",
,,,,,,[8,9],[7]],[,,"3(?:[167]2[0-6]|22[0-5]|32[0-3]|4(?:2[013-9]|3[01])|52[0-7]|82[0-2])\\d{5}|3(?:[0-8]8|9[28])0\\d{5}|3(?:0[237]|[1-9]7)\\d{6}",,,,"302345678",,,[9],[7]],[,,"(?:2[0346-8]\\d|5(?:[0457]\\d|6[01]|9[1-6]))\\d{6}",,,,"231234567",,,[9]],[,,"800\\d{5}",,,,"80012345",,,[8]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],"GH",233,"00","0",,,"0",,,,[[,"(\\d{3})(\\d{4})","$1 $2",["[237]|80"]],[,"(\\d{3})(\\d{5})","$1 $2",["8"],"0$1"],[,"(\\d{2})(\\d{3})(\\d{4})","$1 $2 $3",
["[235]"],"0$1"]],[[,"(\\d{3})(\\d{5})","$1 $2",["8"],"0$1"],[,"(\\d{2})(\\d{3})(\\d{4})","$1 $2 $3",["[235]"],"0$1"]],[,,,,,,,,,[-1]],,,[,,"800\\d{5}",,,,,,,[8]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],GI:[,[,,"[256]\\d{7}",,,,,,,[8]],[,,"21(?:6[24-7]\\d|90[0-2])\\d{3}|2(?:00|2[25])\\d{5}",,,,"20012345"],[,,"(?:5[146-8]\\d|6(?:06|29))\\d{5}",,,,"57123456"],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],"GI",350,"00",,,,,,,,[[,"(\\d{3})(\\d{5})","$1 $2",["2"]]],,[,,,,,
,,,,[-1]],,,[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],GL:[,[,,"(?:19|[2-689]\\d)\\d{4}",,,,,,,[6]],[,,"(?:19|3[1-7]|6[14689]|8[14-79]|9\\d)\\d{4}",,,,"321000"],[,,"[245]\\d{5}",,,,"221234"],[,,"80\\d{4}",,,,"801234"],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,"3[89]\\d{4}",,,,"381234"],"GL",299,"00",,,,,,,,[[,"(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3",["19|[2-689]"]]],,[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],GM:[,[,,"[2-9]\\d{6}",,,,,,,[7]],[,,"(?:4(?:[23]\\d\\d|4(?:1[024679]|[6-9]\\d))|5(?:5(?:3\\d|4[0-7])|6[67]\\d|7(?:1[04]|2[035]|3[58]|48))|8\\d{3})\\d{3}",
,,,"5661234"],[,,"(?:[23679]\\d|5[0-389])\\d{5}",,,,"3012345"],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],"GM",220,"00",,,,,,,,[[,"(\\d{3})(\\d{4})","$1 $2",["[2-9]"]]],,[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],GN:[,[,,"722\\d{6}|(?:3|6\\d)\\d{7}",,,,,,,[8,9]],[,,"3(?:0(?:24|3[12]|4[1-35-7]|5[13]|6[189]|[78]1|9[1478])|1\\d\\d)\\d{4}",,,,"30241234",,,[8]],[,,"6[02356]\\d{7}",,,,"601123456",,,[9]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,
,,,,,[-1]],[,,,,,,,,,[-1]],[,,"722\\d{6}",,,,"722123456",,,[9]],"GN",224,"00",,,,,,,,[[,"(\\d{2})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["3"]],[,"(\\d{3})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[67]"]]],,[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],GP:[,[,,"(?:590|69\\d|976)\\d{6}",,,,,,,[9]],[,,"590(?:0[1-68]|1[0-2]|2[0-68]|3[1289]|4[0-24-9]|5[3-579]|6[0189]|7[08]|8[0-689]|9\\d)\\d{4}",,,,"590201234"],[,,"69(?:0\\d\\d|1(?:2[29]|3[0-5]))\\d{4}",,,,"690001234"],[,,,,,,,,
,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,"976[01]\\d{5}",,,,"976012345"],"GP",590,"00","0",,,"0",,,,[[,"(\\d{3})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[569]"],"0$1"]],,[,,,,,,,,,[-1]],1,,[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],GQ:[,[,,"222\\d{6}|(?:3\\d|55|[89]0)\\d{7}",,,,,,,[9]],[,,"33[0-24-9]\\d[46]\\d{4}|3(?:33|5\\d)\\d[7-9]\\d{4}",,,,"333091234"],[,,"(?:222|55[015])\\d{6}",,,,"222123456"],[,,"80\\d[1-9]\\d{5}",,,,"800123456"],[,,"90\\d[1-9]\\d{5}",,,,"900123456"],
[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],"GQ",240,"00",,,,,,,,[[,"(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["[235]"]],[,"(\\d{3})(\\d{6})","$1 $2",["[89]"]]],,[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],GR:[,[,,"5005000\\d{3}|(?:[2689]\\d|70)\\d{8}",,,,,,,[10]],[,,"2(?:1\\d\\d|2(?:2[1-46-9]|[36][1-8]|4[1-7]|5[1-4]|7[1-5]|[89][1-9])|3(?:1\\d|2[1-57]|[35][1-3]|4[13]|7[1-7]|8[124-6]|9[1-79])|4(?:1\\d|2[1-8]|3[1-4]|4[13-5]|6[1-578]|9[1-5])|5(?:1\\d|[29][1-4]|3[1-5]|4[124]|5[1-6])|6(?:1\\d|[269][1-6]|3[1245]|4[1-7]|5[13-9]|7[14]|8[1-5])|7(?:1\\d|2[1-5]|3[1-6]|4[1-7]|5[1-57]|6[135]|9[125-7])|8(?:1\\d|2[1-5]|[34][1-4]|9[1-57]))\\d{6}",
,,,"2123456789"],[,,"68[57-9]\\d{7}|(?:69|94)\\d{8}",,,,"6912345678"],[,,"800\\d{7}",,,,"8001234567"],[,,"90[19]\\d{7}",,,,"9091234567"],[,,"8(?:0[16]|12|25)\\d{7}",,,,"8011234567"],[,,"70\\d{8}",,,,"7012345678"],[,,,,,,,,,[-1]],"GR",30,"00",,,,,,,,[[,"(\\d{2})(\\d{4})(\\d{4})","$1 $2 $3",["21|7"]],[,"(\\d{4})(\\d{6})","$1 $2",["2(?:2|3[2-57-9]|4[2-469]|5[2-59]|6[2-9]|7[2-69]|8[2-49])|5"]],[,"(\\d{3})(\\d{3})(\\d{4})","$1 $2 $3",["[2689]"]]],,[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,"5005000\\d{3}",,
,,"5005000123"],,,[,,,,,,,,,[-1]]],GT:[,[,,"(?:1\\d{3}|[2-7])\\d{7}",,,,,,,[8,11]],[,,"[267][2-9]\\d{6}",,,,"22456789",,,[8]],[,,"[3-5]\\d{7}",,,,"51234567",,,[8]],[,,"18[01]\\d{8}",,,,"18001112222",,,[11]],[,,"19\\d{9}",,,,"19001112222",,,[11]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],"GT",502,"00",,,,,,,,[[,"(\\d{4})(\\d{4})","$1 $2",["[2-7]"]],[,"(\\d{4})(\\d{3})(\\d{4})","$1 $2 $3",["1"]]],,[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],GU:[,[,,"(?:[58]\\d\\d|671|900)\\d{7}",
,,,,,,[10],[7]],[,,"671(?:3(?:00|3[39]|4[349]|55|6[26])|4(?:00|56|7[1-9]|8[0236-9])|5(?:55|6[2-5]|88)|6(?:3[2-578]|4[24-9]|5[34]|78|8[235-9])|7(?:[0479]7|2[0167]|3[45]|8[7-9])|8(?:[2-57-9]8|6[48])|9(?:2[29]|6[79]|7[1279]|8[7-9]|9[78]))\\d{4}",,,,"6713001234",,,,[7]],[,,"671(?:3(?:00|3[39]|4[349]|55|6[26])|4(?:00|56|7[1-9]|8[0236-9])|5(?:55|6[2-5]|88)|6(?:3[2-578]|4[24-9]|5[34]|78|8[235-9])|7(?:[0479]7|2[0167]|3[45]|8[7-9])|8(?:[2-57-9]8|6[48])|9(?:2[29]|6[79]|7[1279]|8[7-9]|9[78]))\\d{4}",,,,"6713001234",
,,,[7]],[,,"8(?:00|33|44|55|66|77|88)[2-9]\\d{6}",,,,"8002123456"],[,,"900[2-9]\\d{6}",,,,"9002123456"],[,,,,,,,,,[-1]],[,,"52(?:35(?:[02-46-9]\\d|1[02-9]|5[0-46-9])|45(?:[034]\\d|1[02-9]|2[024-9]|5[0-46-9]))\\d{4}|52(?:3[2-46-9]|4[2-4])(?:[02-9]\\d|1[02-9])\\d{4}|5(?:00|2[12]|33|44|66|77|88)[2-9]\\d{6}",,,,"5002345678"],[,,,,,,,,,[-1]],"GU",1,"011","1",,,"1|([3-9]\\d{6})$","671$1",,1,,,[,,,,,,,,,[-1]],,"671",[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],GW:[,[,,"[49]\\d{8}|4\\d{6}",,,,,,,[7,
9]],[,,"443\\d{6}",,,,"443201234",,,[9]],[,,"9(?:5\\d|6[569]|77)\\d{6}",,,,"955012345",,,[9]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,"40\\d{5}",,,,"4012345",,,[7]],"GW",245,"00",,,,,,,,[[,"(\\d{3})(\\d{4})","$1 $2",["40"]],[,"(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["[49]"]]],,[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],GY:[,[,,"(?:862\\d|9008)\\d{3}|(?:[2-46]\\d|77)\\d{5}",,,,,,,[7]],[,,"(?:2(?:1[6-9]|2[0-35-9]|3[1-4]|5[3-9]|6\\d|7[0-24-79])|3(?:2[25-9]|3\\d)|4(?:4[0-24]|5[56])|77[1-57])\\d{4}",
,,,"2201234"],[,,"6\\d{6}",,,,"6091234"],[,,"(?:289|862)\\d{4}",,,,"2891234"],[,,"9008\\d{3}",,,,"9008123"],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],"GY",592,"001",,,,,,,,[[,"(\\d{3})(\\d{4})","$1 $2",["[2-46-9]"]]],,[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],HK:[,[,,"8[0-46-9]\\d{6,7}|9\\d{4}(?:\\d(?:\\d(?:\\d{4})?)?)?|(?:[235-79]\\d|46)\\d{6}",,,,,,,[5,6,7,8,9,11]],[,,"(?:384[0-5]|58(?:0[1-8]|1[2-9]))\\d{4}|(?:2(?:[13-9]\\d|2[013-9])|3(?:[1569][0-24-9]|4[0-246-9]|7[0-24-69]|89))\\d{5}",
,,,"21234567",,,[8]],[,,"(?:46(?:[01][0-6]|4[0-57-9])|5730|(?:626|848)[01]|707[1-5]|929[03-9])\\d{4}|(?:5(?:[1-59][0-46-9]|6[0-4689]|7[0-2469])|6(?:0[1-9]|[13-59]\\d|[268][0-57-9]|7[0-79])|9(?:0[1-9]|1[02-9]|[2358][0-8]|[467]\\d))\\d{5}",,,,"51234567",,,[8]],[,,"800\\d{6}",,,,"800123456",,,[9]],[,,"900(?:[0-24-9]\\d{7}|3\\d{1,4})",,,,"90012345678",,,[5,6,7,8,11]],[,,,,,,,,,[-1]],[,,"8(?:1[0-4679]\\d|2(?:[0-36]\\d|7[0-4])|3(?:[034]\\d|2[09]|70))\\d{4}",,,,"81123456",,,[8]],[,,,,,,,,,[-1]],"HK",852,
"00(?:30|5[09]|[126-9]?)",,,,,,"00",,[[,"(\\d{3})(\\d{2,5})","$1 $2",["900","9003"]],[,"(\\d{4})(\\d{4})","$1 $2",["[2-7]|8[1-4]|9(?:0[1-9]|[1-8])"]],[,"(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["8"]],[,"(\\d{3})(\\d{2})(\\d{3})(\\d{3})","$1 $2 $3 $4",["9"]]],,[,,"7(?:1(?:0[0-38]|1[0-3679]|3[013]|69|9[0136])|2(?:[02389]\\d|1[18]|7[27-9])|3(?:[0-38]\\d|7[0-369]|9[2357-9])|47\\d|5(?:[178]\\d|5[0-5])|6(?:0[0-7]|2[236-9]|[35]\\d)|7(?:[27]\\d|8[7-9])|8(?:[23689]\\d|7[1-9])|9(?:[025]\\d|6[0-246-8]|7[0-36-9]|8[238]))\\d{4}",
,,,"71123456",,,[8]],,,[,,,,,,,,,[-1]],[,,"30(?:0[1-9]|[15-7]\\d|2[047]|89)\\d{4}",,,,"30161234",,,[8]],,,[,,,,,,,,,[-1]]],HN:[,[,,"8\\d{10}|[237-9]\\d{7}",,,,,,,[8,11]],[,,"2(?:2(?:0[0139]|1[1-36]|[23]\\d|4[04-6]|5[57]|6[24]|7[0135689]|8[01346-9]|9[0-2])|4(?:07|2[3-59]|3[13-689]|4[0-68]|5[1-35])|5(?:0[78]|16|4[03-5]|5\\d|6[014-6]|74|80)|6(?:[056]\\d|17|2[07]|3[04]|4[0-378]|[78][0-8]|9[01])|7(?:6[46-9]|7[02-9]|8[034]|91)|8(?:79|8[0-357-9]|9[1-57-9]))\\d{4}",,,,"22123456",,,[8]],[,,"[37-9]\\d{7}",
,,,"91234567",,,[8]],[,,"8002\\d{7}",,,,"80021234567",,,[11]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],"HN",504,"00",,,,,,,,[[,"(\\d{4})(\\d{4})","$1-$2",["[237-9]"]],[,"(\\d{3})(\\d{4})(\\d{4})","$1 $2 $3",["8"]]],[[,"(\\d{4})(\\d{4})","$1-$2",["[237-9]"]]],[,,,,,,,,,[-1]],,,[,,"8002\\d{7}",,,,,,,[11]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],HR:[,[,,"(?:[24-69]\\d|3[0-79])\\d{7}|80\\d{5,7}|[1-79]\\d{7}|6\\d{5,6}",,,,,,,[6,7,8,9]],[,,"1\\d{7}|(?:2[0-3]|3[1-5]|4[02-47-9]|5[1-3])\\d{6,7}",
,,,"12345678",,,[8,9],[6,7]],[,,"9(?:751\\d{5}|8\\d{6,7})|9(?:0[1-9]|[1259]\\d|7[0679])\\d{6}",,,,"921234567",,,[8,9]],[,,"80[01]\\d{4,6}",,,,"800123456",,,[7,8,9]],[,,"6[01459]\\d{6}|6[01]\\d{4,5}",,,,"611234",,,[6,7,8]],[,,,,,,,,,[-1]],[,,"7[45]\\d{6}",,,,"74123456",,,[8]],[,,,,,,,,,[-1]],"HR",385,"00","0",,,"0",,,,[[,"(\\d{2})(\\d{2})(\\d{2,3})","$1 $2 $3",["6[01]"],"0$1"],[,"(\\d{3})(\\d{2})(\\d{2,3})","$1 $2 $3",["8"],"0$1"],[,"(\\d)(\\d{4})(\\d{3})","$1 $2 $3",["1"],"0$1"],[,"(\\d{2})(\\d{3})(\\d{3,4})",
"$1 $2 $3",["[67]"],"0$1"],[,"(\\d{2})(\\d{3})(\\d{3,4})","$1 $2 $3",["9"],"0$1"],[,"(\\d{2})(\\d{3})(\\d{3,4})","$1 $2 $3",["[2-5]"],"0$1"],[,"(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["8"],"0$1"]],,[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,"62\\d{6,7}|72\\d{6}",,,,"62123456",,,[8,9]],,,[,,,,,,,,,[-1]]],HT:[,[,,"[2-489]\\d{7}",,,,,,,[8]],[,,"2(?:2\\d|5[1-5]|81|9[149])\\d{5}",,,,"22453300"],[,,"[34]\\d{7}",,,,"34101234"],[,,"8\\d{7}",,,,"80012345"],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,"9(?:[67][0-4]|8[0-3589]|9\\d)\\d{5}",
,,,"98901234"],"HT",509,"00",,,,,,,,[[,"(\\d{2})(\\d{2})(\\d{4})","$1 $2 $3",["[2-489]"]]],,[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],HU:[,[,,"[2357]\\d{8}|[1-9]\\d{7}",,,,,,,[8,9],[6,7]],[,,"(?:1\\d|[27][2-9]|3[2-7]|4[24-9]|5[2-79]|6[23689]|8[2-57-9]|9[2-69])\\d{6}",,,,"12345678",,,[8],[6,7]],[,,"(?:[257]0|3[01])\\d{7}",,,,"201234567",,,[9]],[,,"[48]0\\d{6}",,,,"80123456",,,[8]],[,,"9[01]\\d{6}",,,,"90123456",,,[8]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,"21\\d{7}",,,,"211234567",
,,[9]],"HU",36,"00","06",,,"06",,,,[[,"(\\d)(\\d{3})(\\d{4})","$1 $2 $3",["1"],"(06 $1)"],[,"(\\d{2})(\\d{3})(\\d{3})","$1 $2 $3",["[27][2-9]|3[2-7]|4[24-9]|5[2-79]|6|8[2-57-9]|9[2-69]"],"(06 $1)"],[,"(\\d{2})(\\d{3})(\\d{3,4})","$1 $2 $3",["[2-57-9]"],"06 $1"]],,[,,,,,,,,,[-1]],,,[,,"[48]0\\d{6}",,,,,,,[8]],[,,"38\\d{7}",,,,"381234567",,,[9]],,,[,,,,,,,,,[-1]]],ID:[,[,,"(?:(?:007803|8\\d{4})\\d|[1-36])\\d{6}|[1-9]\\d{8,10}|[2-9]\\d{7}",,,,,,,[7,8,9,10,11,12,13],[5,6]],[,,"2[124]\\d{7,8}|619\\d{8}|2(?:1(?:14|500)|2\\d{3})\\d{3}|61\\d{5,8}|(?:2(?:[35][1-4]|6[0-8]|7[1-6]|8\\d|9[1-8])|3(?:1|[25][1-8]|3[1-68]|4[1-3]|6[1-3568]|7[0-469]|8\\d)|4(?:0[1-589]|1[01347-9]|2[0-36-8]|3[0-24-68]|43|5[1-378]|6[1-5]|7[134]|8[1245])|5(?:1[1-35-9]|2[25-8]|3[124-9]|4[1-3589]|5[1-46]|6[1-8])|6(?:[25]\\d|3[1-69]|4[1-6])|7(?:02|[125][1-9]|[36]\\d|4[1-8]|7[0-36-9])|9(?:0[12]|1[013-8]|2[0-479]|5[125-8]|6[23679]|7[159]|8[01346]))\\d{5,8}",
,,,"218350123",,,[7,8,9,10,11],[5,6]],[,,"8[1-35-9]\\d{7,10}",,,,"812345678",,,[9,10,11,12]],[,,"007803\\d{7}|(?:177\\d|800)\\d{5,7}",,,,"8001234567",,,[8,9,10,11,13]],[,,"809\\d{7}",,,,"8091234567",,,[10]],[,,"804\\d{7}",,,,"8041234567",,,[10]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],"ID",62,"00[189]","0",,,"0",,,,[[,"(\\d)(\\d{3})(\\d{3})","$1 $2 $3",["15"]],[,"(\\d{2})(\\d{5,9})","$1 $2",["2[124]|[36]1"],"(0$1)"],[,"(\\d{3})(\\d{5,7})","$1 $2",["800"],"0$1"],[,"(\\d{3})(\\d{5,8})","$1 $2",["[2-79]"],"(0$1)"],
[,"(\\d{3})(\\d{3,4})(\\d{3})","$1-$2-$3",["8[1-35-9]"],"0$1"],[,"(\\d{3})(\\d{6,8})","$1 $2",["1"],"0$1"],[,"(\\d{3})(\\d{3})(\\d{4})","$1 $2 $3",["804"],"0$1"],[,"(\\d{3})(\\d)(\\d{3})(\\d{3})","$1 $2 $3 $4",["80"],"0$1"],[,"(\\d{3})(\\d{4})(\\d{4,5})","$1-$2-$3",["8"],"0$1"],[,"(\\d{2})(\\d{4})(\\d{3})(\\d{4})","$1 $2 $3 $4",["0"]]],[[,"(\\d)(\\d{3})(\\d{3})","$1 $2 $3",["15"]],[,"(\\d{2})(\\d{5,9})","$1 $2",["2[124]|[36]1"],"(0$1)"],[,"(\\d{3})(\\d{5,7})","$1 $2",["800"],"0$1"],[,"(\\d{3})(\\d{5,8})",
"$1 $2",["[2-79]"],"(0$1)"],[,"(\\d{3})(\\d{3,4})(\\d{3})","$1-$2-$3",["8[1-35-9]"],"0$1"],[,"(\\d{3})(\\d{6,8})","$1 $2",["1"],"0$1"],[,"(\\d{3})(\\d{3})(\\d{4})","$1 $2 $3",["804"],"0$1"],[,"(\\d{3})(\\d)(\\d{3})(\\d{3})","$1 $2 $3 $4",["80"],"0$1"],[,"(\\d{3})(\\d{4})(\\d{4,5})","$1-$2-$3",["8"],"0$1"]],[,,,,,,,,,[-1]],,,[,,"(?:007803\\d|8071)\\d{6}",,,,,,,[10,13]],[,,"(?:1500|8071\\d{3})\\d{3}",,,,"8071123456",,,[7,10]],,,[,,,,,,,,,[-1]]],IE:[,[,,"(?:1\\d|[2569])\\d{6,8}|4\\d{6,9}|7\\d{8}|8\\d{8,9}",
,,,,,,[7,8,9,10],[5,6]],[,,"(?:1\\d|21)\\d{6,7}|(?:2[24-9]|4(?:0[24]|5\\d|7)|5(?:0[45]|1\\d|8)|6(?:1\\d|[237-9])|9(?:1\\d|[35-9]))\\d{5}|(?:23|4(?:[1-469]|8\\d)|5[23679]|6[4-6]|7[14]|9[04])\\d{7}",,,,"2212345",,,,[5,6]],[,,"8(?:22|[35-9]\\d)\\d{6}",,,,"850123456",,,[9]],[,,"1800\\d{6}",,,,"1800123456",,,[10]],[,,"15(?:1[2-8]|[2-8]0|9[089])\\d{6}",,,,"1520123456",,,[10]],[,,"18[59]0\\d{6}",,,,"1850123456",,,[10]],[,,"700\\d{6}",,,,"700123456",,,[9]],[,,"76\\d{7}",,,,"761234567",,,[9]],"IE",353,"00",
"0",,,"0",,,,[[,"(\\d{2})(\\d{5})","$1 $2",["2[24-9]|47|58|6[237-9]|9[35-9]"],"(0$1)"],[,"(\\d{3})(\\d{5})","$1 $2",["[45]0"],"(0$1)"],[,"(\\d)(\\d{3,4})(\\d{4})","$1 $2 $3",["1"],"(0$1)"],[,"(\\d{2})(\\d{3})(\\d{3,4})","$1 $2 $3",["[2569]|4[1-69]|7[14]"],"(0$1)"],[,"(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["70"],"0$1"],[,"(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["81"],"(0$1)"],[,"(\\d{2})(\\d{3})(\\d{4})","$1 $2 $3",["[78]"],"0$1"],[,"(\\d{4})(\\d{3})(\\d{3})","$1 $2 $3",["1"]],[,"(\\d{2})(\\d{4})(\\d{4})",
"$1 $2 $3",["4"],"(0$1)"],[,"(\\d{2})(\\d)(\\d{3})(\\d{4})","$1 $2 $3 $4",["8"],"0$1"]],,[,,,,,,,,,[-1]],,,[,,"18[59]0\\d{6}",,,,,,,[10]],[,,"818\\d{6}",,,,"818123456",,,[9]],,,[,,"88210[1-9]\\d{4}|8(?:[35-79]5\\d\\d|8(?:[013-9]\\d\\d|2(?:[01][1-9]|[2-9]\\d)))\\d{5}",,,,"8551234567",,,[10]]],IL:[,[,,"1\\d{6}(?:\\d{3,5})?|[57]\\d{8}|[1-489]\\d{7}",,,,,,,[7,8,9,10,11,12]],[,,"153\\d{8,9}|29[1-9]\\d{5}|(?:2[0-8]|[3489]\\d)\\d{6}",,,,"21234567",,,[8,11,12],[7]],[,,"5(?:(?:[02368]\\d|[19][2-9]|4[1-9])\\d|5(?:01|1[79]|2[2-8]|3[23]|44|5[05689]|6[6-8]|7[0-267]|8[7-9]|9[1-9]))\\d{5}",
,,,"502345678",,,[9]],[,,"1(?:255|80[019]\\d{3})\\d{3}",,,,"1800123456",,,[7,10]],[,,"1212\\d{4}|1(?:200|9(?:0[01]|19))\\d{6}",,,,"1919123456",,,[8,10]],[,,"1700\\d{6}",,,,"1700123456",,,[10]],[,,,,,,,,,[-1]],[,,"78(?:33|55|77|81)\\d{5}|7(?:18|2[23]|3[237]|47|6[58]|7\\d|82|9[235-9])\\d{6}",,,,"771234567",,,[9]],"IL",972,"0(?:0|1[2-9])","0",,,"0",,,,[[,"(\\d{4})(\\d{3})","$1-$2",["125"]],[,"(\\d{4})(\\d{2})(\\d{2})","$1-$2-$3",["121"]],[,"(\\d)(\\d{3})(\\d{4})","$1-$2-$3",["[2-489]"],"0$1"],[,"(\\d{2})(\\d{3})(\\d{4})",
"$1-$2-$3",["[57]"],"0$1"],[,"(\\d{4})(\\d{3})(\\d{3})","$1-$2-$3",["12"]],[,"(\\d{4})(\\d{6})","$1-$2",["159"]],[,"(\\d)(\\d{3})(\\d{3})(\\d{3})","$1-$2-$3-$4",["1[7-9]"]],[,"(\\d{3})(\\d{1,2})(\\d{3})(\\d{4})","$1-$2 $3-$4",["15"]]],,[,,,,,,,,,[-1]],,,[,,"1700\\d{6}",,,,,,,[10]],[,,"1599\\d{6}",,,,"1599123456",,,[10]],,,[,,"151\\d{8,9}",,,,"15112340000",,,[11,12]]],IM:[,[,,"1624\\d{6}|(?:[3578]\\d|90)\\d{8}",,,,,,,[10],[6]],[,,"1624[5-8]\\d{5}",,,,"1624756789",,,,[6]],[,,"76245[06]\\d{4}|7(?:4576|[59]24\\d|624[0-4689])\\d{5}",
,,,"7924123456"],[,,"808162\\d{4}",,,,"8081624567"],[,,"8(?:440[49]06|72299\\d)\\d{3}|(?:8(?:45|70)|90[0167])624\\d{4}",,,,"9016247890"],[,,,,,,,,,[-1]],[,,"70\\d{8}",,,,"7012345678"],[,,"56\\d{8}",,,,"5612345678"],"IM",44,"00","0",,,"0|([5-8]\\d{5})$","1624$1",,,,,[,,,,,,,,,[-1]],,"74576|(?:16|7[56])24",[,,,,,,,,,[-1]],[,,"3440[49]06\\d{3}|(?:3(?:08162|3\\d{4}|45624|7(?:0624|2299))|55\\d{4})\\d{4}",,,,"5512345678"],,,[,,,,,,,,,[-1]]],IN:[,[,,"(?:000800|[2-9]\\d\\d)\\d{7}|1\\d{7,12}",,,,,,,[8,9,10,
11,12,13],[6,7]],[,,"2717(?:[2-7]\\d|95)\\d{4}|(?:271[0-689]|782[0-6])[2-7]\\d{5}|(?:170[24]|2(?:(?:[02][2-79]|90)\\d|80[13468])|(?:3(?:23|80)|683|79[1-7])\\d|4(?:20[24]|72[2-8])|552[1-7])\\d{6}|(?:11|33|4[04]|80)[2-7]\\d{7}|(?:342|674|788)(?:[0189][2-7]|[2-7]\\d)\\d{5}|(?:1(?:2[0-249]|3[0-25]|4[145]|[59][14]|6[014]|7[1257]|8[01346])|2(?:1[257]|3[013]|4[01]|5[0137]|6[0158]|78|8[1568]|9[14])|3(?:26|4[13]|5[34]|6[01489]|7[02-46]|8[159])|4(?:1[36]|2[1-47]|3[15]|5[12]|6[0-26-9]|7[014-9]|8[013-57]|9[014-7])|5(?:1[025]|22|[36][25]|4[28]|[578]1|9[15])|6(?:12|[2-47]1|5[17]|6[13]|80)|7(?:12|2[14]|3[134]|4[47]|5[15]|[67]1)|8(?:16|2[014]|3[126]|6[136]|7[078]|8[34]|91))[2-7]\\d{6}|(?:1(?:2[35-8]|3[346-9]|4[236-9]|[59][0235-9]|6[235-9]|7[34689]|8[257-9])|2(?:1[134689]|3[24-8]|4[2-8]|5[25689]|6[2-4679]|7[3-79]|8[2-479]|9[235-9])|3(?:01|1[79]|2[1245]|4[5-8]|5[125689]|6[235-7]|7[157-9]|8[2-46-8])|4(?:1[14578]|2[5689]|3[2-467]|5[4-7]|6[35]|73|8[2689]|9[2389])|5(?:[16][146-9]|2[14-8]|3[1346]|4[14-69]|5[46]|7[2-4]|8[2-8]|9[246])|6(?:1[1358]|2[2457]|3[2-4]|4[235-7]|5[2-689]|6[24578]|7[235689]|8[124-6])|7(?:1[013-9]|2[0235-9]|3[2679]|4[1-35689]|5[2-46-9]|[67][02-9]|8[013-7]|9[089])|8(?:1[1357-9]|2[235-8]|3[03-57-9]|4[0-24-9]|5\\d|6[2457-9]|7[1-6]|8[1256]|9[2-4]))\\d[2-7]\\d{5}",
,,,"7410410123",,,[10],[6,7,8]],[,,"(?:61279|7(?:887[02-9]|9(?:313|79[07-9]))|8(?:079[04-9]|(?:84|91)7[02-8]))\\d{5}|(?:6(?:12|[2-47]1|5[17]|6[13]|80)[0189]|7(?:1(?:2[0189]|9[0-5])|2(?:[14][017-9]|8[0-59])|3(?:2[5-8]|[34][017-9]|9[016-9])|4(?:1[015-9]|[29][89]|39|8[389])|5(?:[15][017-9]|2[04-9]|9[7-9])|6(?:0[0-47]|1[0-257-9]|2[0-4]|3[19]|5[4589])|70[0289]|88[089]|97[02-8])|8(?:0(?:6[67]|7[02-8])|70[017-9]|84[01489]|91[0-289]))\\d{6}|(?:7(?:31|4[47])|8(?:16|2[014]|3[126]|6[136]|7[78]|83))(?:[0189]\\d|7[02-8])\\d{5}|(?:6(?:[09]\\d|1[04679]|2[03689]|3[05-9]|4[0489]|50|6[069]|7[07]|8[7-9])|7(?:0\\d|2[0235-79]|3[05-8]|40|5[0346-8]|6[6-9]|7[1-9]|8[0-79]|9[089])|8(?:0[01589]|1[0-57-9]|2[235-9]|3[03-57-9]|[45]\\d|6[02457-9]|7[1-69]|8[0-25-9]|9[02-9])|9\\d\\d)\\d{7}|(?:6(?:(?:1[1358]|2[2457]|3[2-4]|4[235-7]|5[2-689]|6[24578]|8[124-6])\\d|7(?:[235689]\\d|4[0189]))|7(?:1(?:[013-8]\\d|9[6-9])|28[6-8]|3(?:2[0-49]|9[2-5])|4(?:1[2-4]|[29][0-7]|3[0-8]|[56]\\d|8[0-24-7])|5(?:2[1-3]|9[0-6])|6(?:0[5689]|2[5-9]|3[02-8]|4\\d|5[0-367])|70[13-7]|881))[0189]\\d{5}",
,,,"8123456789",,,[10]],[,,"000800\\d{7}|1(?:600\\d{6}|80(?:0\\d{4,9}|3\\d{9}))",,,,"1800123456"],[,,"186[12]\\d{9}",,,,"1861123456789",,,[13]],[,,"1860\\d{7}",,,,"18603451234",,,[11]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],"IN",91,"00","0",,,"0",,,,[[,"(\\d{7})","$1",["575"]],[,"(\\d{8})","$1",["5(?:0|2[23]|3[03]|[67]1|88)","5(?:0|2(?:21|3)|3(?:0|3[23])|616|717|888)","5(?:0|2(?:21|3)|3(?:0|3[23])|616|717|8888)"],,,1],[,"(\\d{4})(\\d{4,5})","$1 $2",["180","1800"],,,1],[,"(\\d{3})(\\d{3})(\\d{4})","$1 $2 $3",
["140"],,,1],[,"(\\d{2})(\\d{4})(\\d{4})","$1 $2 $3",["11|2[02]|33|4[04]|79[1-7]|80[2-46]","11|2[02]|33|4[04]|79(?:[1-6]|7[19])|80(?:[2-4]|6[0-589])","11|2[02]|33|4[04]|79(?:[124-6]|3(?:[02-9]|1[0-24-9])|7(?:1|9[1-6]))|80(?:[2-4]|6[0-589])"],"0$1",,1],[,"(\\d{3})(\\d{3})(\\d{4})","$1 $2 $3",["1(?:2[0-249]|3[0-25]|4[145]|[68]|7[1257])|2(?:1[257]|3[013]|4[01]|5[0137]|6[0158]|78|8[1568])|3(?:26|4[1-3]|5[34]|6[01489]|7[02-46]|8[159])|4(?:1[36]|2[1-47]|5[12]|6[0-26-9]|7[0-24-9]|8[013-57]|9[014-7])|5(?:1[025]|22|[36][25]|4[28]|5[12]|[78]1)|6(?:12|[2-4]1|5[17]|6[13]|80)|7(?:12|3[134]|4[47]|61|88)|8(?:16|2[014]|3[126]|6[136]|7[078]|8[34]|91)|(?:43|59|75)[15]|(?:1[59]|29|67|72)[14]",
"1(?:2[0-24]|3[0-25]|4[145]|[59][14]|6[1-9]|7[1257]|8[1-57-9])|2(?:1[257]|3[013]|4[01]|5[0137]|6[058]|78|8[1568]|9[14])|3(?:26|4[1-3]|5[34]|6[01489]|7[02-46]|8[159])|4(?:1[36]|2[1-47]|3[15]|5[12]|6[0-26-9]|7[0-24-9]|8[013-57]|9[014-7])|5(?:1[025]|22|[36][25]|4[28]|[578]1|9[15])|674|7(?:(?:2[14]|3[34]|5[15])[2-6]|61[346]|88[0-8])|8(?:70[2-6]|84[235-7]|91[3-7])|(?:1(?:29|60|8[06])|261|552|6(?:12|[2-47]1|5[17]|6[13]|80)|7(?:12|31|4[47])|8(?:16|2[014]|3[126]|6[136]|7[78]|83))[2-7]","1(?:2[0-24]|3[0-25]|4[145]|[59][14]|6[1-9]|7[1257]|8[1-57-9])|2(?:1[257]|3[013]|4[01]|5[0137]|6[058]|78|8[1568]|9[14])|3(?:26|4[1-3]|5[34]|6[01489]|7[02-46]|8[159])|4(?:1[36]|2[1-47]|3[15]|5[12]|6[0-26-9]|7[0-24-9]|8[013-57]|9[014-7])|5(?:1[025]|22|[36][25]|4[28]|[578]1|9[15])|6(?:12(?:[2-6]|7[0-8])|74[2-7])|7(?:(?:2[14]|5[15])[2-6]|3171|61[346]|88(?:[2-7]|82))|8(?:70[2-6]|84(?:[2356]|7[19])|91(?:[3-6]|7[19]))|73[134][2-6]|(?:74[47]|8(?:16|2[014]|3[126]|6[136]|7[78]|83))(?:[2-6]|7[19])|(?:1(?:29|60|8[06])|261|552|6(?:[2-4]1|5[17]|6[13]|7(?:1|4[0189])|80)|7(?:12|88[01]))[2-7]"],
"0$1",,1],[,"(\\d{4})(\\d{3})(\\d{3})","$1 $2 $3",["1(?:[2-479]|5[0235-9])|[2-5]|6(?:1[1358]|2[2457-9]|3[2-5]|4[235-7]|5[2-689]|6[24578]|7[235689]|8[1-6])|7(?:1[013-9]|28|3[129]|4[1-35689]|5[29]|6[02-5]|70)|807","1(?:[2-479]|5[0235-9])|[2-5]|6(?:1[1358]|2(?:[2457]|84|95)|3(?:[2-4]|55)|4[235-7]|5[2-689]|6[24578]|7[235689]|8[1-6])|7(?:1(?:[013-8]|9[6-9])|28[6-8]|3(?:17|2[0-49]|9[2-57])|4(?:1[2-4]|[29][0-7]|3[0-8]|[56]|8[0-24-7])|5(?:2[1-3]|9[0-6])|6(?:0[5689]|2[5-9]|3[02-8]|4|5[0-367])|70[13-7])|807[19]",
"1(?:[2-479]|5(?:[0236-9]|5[013-9]))|[2-5]|6(?:2(?:84|95)|355|83)|73179|807(?:1|9[1-3])|(?:1552|6(?:1[1358]|2[2457]|3[2-4]|4[235-7]|5[2-689]|6[24578]|7[235689]|8[124-6])\\d|7(?:1(?:[013-8]\\d|9[6-9])|28[6-8]|3(?:2[0-49]|9[2-57])|4(?:1[2-4]|[29][0-7]|3[0-8]|[56]\\d|8[0-24-7])|5(?:2[1-3]|9[0-6])|6(?:0[5689]|2[5-9]|3[02-8]|4\\d|5[0-367])|70[13-7]))[2-7]"],"0$1",,1],[,"(\\d{5})(\\d{5})","$1 $2",["[6-9]"],"0$1",,1],[,"(\\d{4})(\\d{2,4})(\\d{4})","$1 $2 $3",["1(?:6|8[06])","1(?:6|8[06]0)"],,,1],[,"(\\d{3})(\\d{3})(\\d{3})(\\d{4})",
"$1 $2 $3 $4",["0"]],[,"(\\d{4})(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3 $4",["18"],,,1]],[[,"(\\d{8})","$1",["5(?:0|2[23]|3[03]|[67]1|88)","5(?:0|2(?:21|3)|3(?:0|3[23])|616|717|888)","5(?:0|2(?:21|3)|3(?:0|3[23])|616|717|8888)"],,,1],[,"(\\d{4})(\\d{4,5})","$1 $2",["180","1800"],,,1],[,"(\\d{3})(\\d{3})(\\d{4})","$1 $2 $3",["140"],,,1],[,"(\\d{2})(\\d{4})(\\d{4})","$1 $2 $3",["11|2[02]|33|4[04]|79[1-7]|80[2-46]","11|2[02]|33|4[04]|79(?:[1-6]|7[19])|80(?:[2-4]|6[0-589])","11|2[02]|33|4[04]|79(?:[124-6]|3(?:[02-9]|1[0-24-9])|7(?:1|9[1-6]))|80(?:[2-4]|6[0-589])"],
"0$1",,1],[,"(\\d{3})(\\d{3})(\\d{4})","$1 $2 $3",["1(?:2[0-249]|3[0-25]|4[145]|[68]|7[1257])|2(?:1[257]|3[013]|4[01]|5[0137]|6[0158]|78|8[1568])|3(?:26|4[1-3]|5[34]|6[01489]|7[02-46]|8[159])|4(?:1[36]|2[1-47]|5[12]|6[0-26-9]|7[0-24-9]|8[013-57]|9[014-7])|5(?:1[025]|22|[36][25]|4[28]|5[12]|[78]1)|6(?:12|[2-4]1|5[17]|6[13]|80)|7(?:12|3[134]|4[47]|61|88)|8(?:16|2[014]|3[126]|6[136]|7[078]|8[34]|91)|(?:43|59|75)[15]|(?:1[59]|29|67|72)[14]","1(?:2[0-24]|3[0-25]|4[145]|[59][14]|6[1-9]|7[1257]|8[1-57-9])|2(?:1[257]|3[013]|4[01]|5[0137]|6[058]|78|8[1568]|9[14])|3(?:26|4[1-3]|5[34]|6[01489]|7[02-46]|8[159])|4(?:1[36]|2[1-47]|3[15]|5[12]|6[0-26-9]|7[0-24-9]|8[013-57]|9[014-7])|5(?:1[025]|22|[36][25]|4[28]|[578]1|9[15])|674|7(?:(?:2[14]|3[34]|5[15])[2-6]|61[346]|88[0-8])|8(?:70[2-6]|84[235-7]|91[3-7])|(?:1(?:29|60|8[06])|261|552|6(?:12|[2-47]1|5[17]|6[13]|80)|7(?:12|31|4[47])|8(?:16|2[014]|3[126]|6[136]|7[78]|83))[2-7]",
"1(?:2[0-24]|3[0-25]|4[145]|[59][14]|6[1-9]|7[1257]|8[1-57-9])|2(?:1[257]|3[013]|4[01]|5[0137]|6[058]|78|8[1568]|9[14])|3(?:26|4[1-3]|5[34]|6[01489]|7[02-46]|8[159])|4(?:1[36]|2[1-47]|3[15]|5[12]|6[0-26-9]|7[0-24-9]|8[013-57]|9[014-7])|5(?:1[025]|22|[36][25]|4[28]|[578]1|9[15])|6(?:12(?:[2-6]|7[0-8])|74[2-7])|7(?:(?:2[14]|5[15])[2-6]|3171|61[346]|88(?:[2-7]|82))|8(?:70[2-6]|84(?:[2356]|7[19])|91(?:[3-6]|7[19]))|73[134][2-6]|(?:74[47]|8(?:16|2[014]|3[126]|6[136]|7[78]|83))(?:[2-6]|7[19])|(?:1(?:29|60|8[06])|261|552|6(?:[2-4]1|5[17]|6[13]|7(?:1|4[0189])|80)|7(?:12|88[01]))[2-7]"],
"0$1",,1],[,"(\\d{4})(\\d{3})(\\d{3})","$1 $2 $3",["1(?:[2-479]|5[0235-9])|[2-5]|6(?:1[1358]|2[2457-9]|3[2-5]|4[235-7]|5[2-689]|6[24578]|7[235689]|8[1-6])|7(?:1[013-9]|28|3[129]|4[1-35689]|5[29]|6[02-5]|70)|807","1(?:[2-479]|5[0235-9])|[2-5]|6(?:1[1358]|2(?:[2457]|84|95)|3(?:[2-4]|55)|4[235-7]|5[2-689]|6[24578]|7[235689]|8[1-6])|7(?:1(?:[013-8]|9[6-9])|28[6-8]|3(?:17|2[0-49]|9[2-57])|4(?:1[2-4]|[29][0-7]|3[0-8]|[56]|8[0-24-7])|5(?:2[1-3]|9[0-6])|6(?:0[5689]|2[5-9]|3[02-8]|4|5[0-367])|70[13-7])|807[19]",
"1(?:[2-479]|5(?:[0236-9]|5[013-9]))|[2-5]|6(?:2(?:84|95)|355|83)|73179|807(?:1|9[1-3])|(?:1552|6(?:1[1358]|2[2457]|3[2-4]|4[235-7]|5[2-689]|6[24578]|7[235689]|8[124-6])\\d|7(?:1(?:[013-8]\\d|9[6-9])|28[6-8]|3(?:2[0-49]|9[2-57])|4(?:1[2-4]|[29][0-7]|3[0-8]|[56]\\d|8[0-24-7])|5(?:2[1-3]|9[0-6])|6(?:0[5689]|2[5-9]|3[02-8]|4\\d|5[0-367])|70[13-7]))[2-7]"],"0$1",,1],[,"(\\d{5})(\\d{5})","$1 $2",["[6-9]"],"0$1",,1],[,"(\\d{4})(\\d{2,4})(\\d{4})","$1 $2 $3",["1(?:6|8[06])","1(?:6|8[06]0)"],,,1],[,"(\\d{4})(\\d{3})(\\d{3})(\\d{3})",
"$1 $2 $3 $4",["18"],,,1]],[,,,,,,,,,[-1]],,,[,,"1(?:600\\d{6}|800\\d{4,9})|(?:000800|18(?:03\\d\\d|6(?:0|[12]\\d\\d)))\\d{7}"],[,,"140\\d{7}",,,,"1409305260",,,[10]],,,[,,,,,,,,,[-1]]],IO:[,[,,"3\\d{6}",,,,,,,[7]],[,,"37\\d{5}",,,,"3709100"],[,,"38\\d{5}",,,,"3801234"],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],"IO",246,"00",,,,,,,,[[,"(\\d{3})(\\d{4})","$1 $2",["3"]]],,[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],IQ:[,[,,"(?:1|7\\d\\d)\\d{7}|[2-6]\\d{7,8}",
,,,,,,[8,9,10],[6,7]],[,,"1\\d{7}|(?:2[13-5]|3[02367]|4[023]|5[03]|6[026])\\d{6,7}",,,,"12345678",,,[8,9],[6,7]],[,,"7[3-9]\\d{8}",,,,"7912345678",,,[10]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],"IQ",964,"00","0",,,"0",,,,[[,"(\\d)(\\d{3})(\\d{4})","$1 $2 $3",["1"],"0$1"],[,"(\\d{2})(\\d{3})(\\d{3,4})","$1 $2 $3",["[2-6]"],"0$1"],[,"(\\d{3})(\\d{3})(\\d{4})","$1 $2 $3",["7"],"0$1"]],,[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],IR:[,
[,,"[1-9]\\d{9}|(?:[1-8]\\d\\d|9)\\d{3,4}",,,,,,,[4,5,6,7,10],[8]],[,,"(?:1[137]|2[13-68]|3[1458]|4[145]|5[1468]|6[16]|7[1467]|8[13467])(?:[03-57]\\d{7}|[16]\\d{3}(?:\\d{4})?|[289]\\d{3}(?:\\d(?:\\d{3})?)?)|94(?:000[09]|2(?:121|[2689]0\\d)|30[0-2]\\d|4(?:111|40\\d))\\d{4}",,,,"2123456789",,,[6,7,10],[4,5,8]],[,,"9(?:(?:0(?:[1-35]\\d|44)|(?:[13]\\d|2[0-2])\\d)\\d|9(?:(?:[0-2]\\d|4[45])\\d|5[15]0|8(?:1\\d|88)|9(?:0[013]|1[0134]|21|77|9[6-9])))\\d{5}",,,,"9123456789",,,[10]],[,,,,,,,,,[-1]],[,,,,,,,
,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,"993\\d{7}",,,,"9932123456",,,[10]],"IR",98,"00","0",,,"0",,,,[[,"(\\d{4,5})","$1",["96"],"0$1"],[,"(\\d{2})(\\d{4,5})","$1 $2",["(?:1[137]|2[13-68]|3[1458]|4[145]|5[1468]|6[16]|7[1467]|8[13467])[12689]"],"0$1"],[,"(\\d{3})(\\d{3})(\\d{3,4})","$1 $2 $3",["9"],"0$1"],[,"(\\d{2})(\\d{4})(\\d{4})","$1 $2 $3",["[1-8]"],"0$1"]],,[,,,,,,,,,[-1]],,,[,,"9(?:4440\\d{5}|6(?:0[12]|2[16-8]|3(?:08|[14]5|[23]|66)|4(?:0|80)|5[01]|6[89]|86|9[19]))",,,,,,,[4,5,10]],[,,"96(?:0[12]|2[16-8]|3(?:08|[14]5|[23]|66)|4(?:0|80)|5[01]|6[89]|86|9[19])",
,,,"9601",,,[4,5]],,,[,,,,,,,,,[-1]]],IS:[,[,,"(?:38\\d|[4-9])\\d{6}",,,,,,,[7,9]],[,,"(?:4(?:1[0-24-69]|2[0-7]|[37][0-8]|4[0-245]|5[0-68]|6\\d|8[0-36-8])|5(?:05|[156]\\d|2[02578]|3[0-579]|4[03-7]|7[0-2578]|8[0-35-9]|9[013-689])|872)\\d{4}",,,,"4101234",,,[7]],[,,"(?:38[589]\\d\\d|6(?:1[1-8]|2[0-6]|3[027-9]|4[014679]|5[0159]|6[0-69]|70|8[06-8]|9\\d)|7(?:5[057]|[6-9]\\d)|8(?:2[0-59]|[3-69]\\d|8[28]))\\d{4}",,,,"6111234"],[,,"80[08]\\d{4}",,,,"8001234",,,[7]],[,,"90(?:0\\d|1[5-79]|2[015-79]|3[135-79]|4[125-7]|5[25-79]|7[1-37]|8[0-35-7])\\d{3}",
,,,"9001234",,,[7]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,"49[0-24-79]\\d{4}",,,,"4921234",,,[7]],"IS",354,"00|1(?:0(?:01|[12]0)|100)",,,,,,"00",,[[,"(\\d{3})(\\d{4})","$1 $2",["[4-9]"]],[,"(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["3"]]],,[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,"809\\d{4}",,,,"8091234",,,[7]],,,[,,"(?:689|8(?:7[18]|80)|95[48])\\d{4}",,,,"6891234",,,[7]]],IT:[,[,,"0\\d{5,10}|3[0-8]\\d{7,10}|55\\d{8}|8\\d{5}(?:\\d{2,4})?|(?:1\\d|39)\\d{7,8}",,,,,,,[6,7,8,9,10,11,12]],[,,"0669[0-79]\\d{1,6}|0(?:1(?:[0159]\\d|[27][1-5]|31|4[1-4]|6[1356]|8[2-57])|2\\d\\d|3(?:[0159]\\d|2[1-4]|3[12]|[48][1-6]|6[2-59]|7[1-7])|4(?:[0159]\\d|[23][1-9]|4[245]|6[1-5]|7[1-4]|81)|5(?:[0159]\\d|2[1-5]|3[2-6]|4[1-79]|6[4-6]|7[1-578]|8[3-8])|6(?:[0-57-9]\\d|6[0-8])|7(?:[0159]\\d|2[12]|3[1-7]|4[2-46]|6[13569]|7[13-6]|8[1-59])|8(?:[0159]\\d|2[3-578]|3[1-356]|[6-8][1-5])|9(?:[0159]\\d|[238][1-5]|4[12]|6[1-8]|7[1-6]))\\d{2,7}",
,,,"0212345678",,,[6,7,8,9,10,11]],[,,"3[1-9]\\d{8}|3[2-9]\\d{7}",,,,"3123456789",,,[9,10]],[,,"80(?:0\\d{3}|3)\\d{3}",,,,"800123456",,,[6,9]],[,,"(?:0878\\d\\d|89(?:2|4[5-9]\\d))\\d{3}|89[45][0-4]\\d\\d|(?:1(?:44|6[346])|89(?:5[5-9]|9))\\d{6}",,,,"899123456",,,[6,8,9,10]],[,,"84(?:[08]\\d{3}|[17])\\d{3}",,,,"848123456",,,[6,9]],[,,"1(?:78\\d|99)\\d{6}",,,,"1781234567",,,[9,10]],[,,"55\\d{8}",,,,"5512345678",,,[10]],"IT",39,"00",,,,,,,,[[,"(\\d{4,5})","$1",["1(?:0|9[246])","1(?:0|9(?:2[2-9]|[46]))"]],
[,"(\\d{6})","$1",["1(?:1|92)"]],[,"(\\d{2})(\\d{4,6})","$1 $2",["0[26]"]],[,"(\\d{3})(\\d{3,6})","$1 $2",["0[13-57-9][0159]|8(?:03|4[17]|9[245])","0[13-57-9][0159]|8(?:03|4[17]|9(?:2|[45][0-4]))"]],[,"(\\d{4})(\\d{2,6})","$1 $2",["0(?:[13-579][2-46-8]|8[236-8])"]],[,"(\\d{4})(\\d{4})","$1 $2",["894"]],[,"(\\d{2})(\\d{3,4})(\\d{4})","$1 $2 $3",["0[26]|5"]],[,"(\\d{3})(\\d{3})(\\d{3,4})","$1 $2 $3",["1[4679]|[38]"]],[,"(\\d{3})(\\d{3,4})(\\d{4})","$1 $2 $3",["0[13-57-9][0159]"]],[,"(\\d{2})(\\d{4})(\\d{5})",
"$1 $2 $3",["0[26]"]],[,"(\\d{4})(\\d{3})(\\d{4})","$1 $2 $3",["0"]],[,"(\\d{3})(\\d{4})(\\d{4,5})","$1 $2 $3",["3"]]],[[,"(\\d{2})(\\d{4,6})","$1 $2",["0[26]"]],[,"(\\d{3})(\\d{3,6})","$1 $2",["0[13-57-9][0159]|8(?:03|4[17]|9[245])","0[13-57-9][0159]|8(?:03|4[17]|9(?:2|[45][0-4]))"]],[,"(\\d{4})(\\d{2,6})","$1 $2",["0(?:[13-579][2-46-8]|8[236-8])"]],[,"(\\d{4})(\\d{4})","$1 $2",["894"]],[,"(\\d{2})(\\d{3,4})(\\d{4})","$1 $2 $3",["0[26]|5"]],[,"(\\d{3})(\\d{3})(\\d{3,4})","$1 $2 $3",["1[4679]|[38]"]],
[,"(\\d{3})(\\d{3,4})(\\d{4})","$1 $2 $3",["0[13-57-9][0159]"]],[,"(\\d{2})(\\d{4})(\\d{5})","$1 $2 $3",["0[26]"]],[,"(\\d{4})(\\d{3})(\\d{4})","$1 $2 $3",["0"]],[,"(\\d{3})(\\d{4})(\\d{4,5})","$1 $2 $3",["3"]]],[,,,,,,,,,[-1]],1,,[,,"848\\d{6}",,,,,,,[9]],[,,,,,,,,,[-1]],,,[,,"3[2-8]\\d{9,10}",,,,"33101234501",,,[11,12]]],JE:[,[,,"1534\\d{6}|(?:[3578]\\d|90)\\d{8}",,,,,,,[10],[6]],[,,"1534[0-24-8]\\d{5}",,,,"1534456789",,,,[6]],[,,"7(?:(?:(?:50|82)9|937)\\d|7(?:00[378]|97[7-9]))\\d{5}",,,,"7797712345"],
[,,"80(?:07(?:35|81)|8901)\\d{4}",,,,"8007354567"],[,,"(?:8(?:4(?:4(?:4(?:05|42|69)|703)|5(?:041|800))|7(?:0002|1206))|90(?:066[59]|1810|71(?:07|55)))\\d{4}",,,,"9018105678"],[,,,,,,,,,[-1]],[,,"701511\\d{4}",,,,"7015115678"],[,,"56\\d{8}",,,,"5612345678"],"JE",44,"00","0",,,"0|([0-24-8]\\d{5})$","1534$1",,,,,[,,"76(?:0[0-2]|2[356]|34|4[0134]|5[49]|6[0-369]|77|81|9[39])\\d{6}",,,,"7640123456"],,,[,,,,,,,,,[-1]],[,,"(?:3(?:0(?:07(?:35|81)|8901)|3\\d{4}|4(?:4(?:4(?:05|42|69)|703)|5(?:041|800))|7(?:0002|1206))|55\\d{4})\\d{4}",
,,,"5512345678"],,,[,,,,,,,,,[-1]]],JM:[,[,,"(?:[58]\\d\\d|658|900)\\d{7}",,,,,,,[10],[7]],[,,"(?:658(?:2(?:[0-8]\\d|9[0-46-9])|[3-9]\\d\\d)|876(?:5(?:02|1[0-468]|2[35]|63)|6(?:0[1-3579]|1[0237-9]|[23]\\d|40|5[06]|6[2-589]|7[05]|8[04]|9[4-9])|7(?:0[2-689]|[1-6]\\d|8[056]|9[45])|9(?:0[1-8]|1[02378]|[2-8]\\d|9[2-468])))\\d{4}",,,,"8765230123",,,,[7]],[,,"(?:658295|876(?:(?:2[14-9]|[348]\\d)\\d|5(?:0[13-9]|1[579]|[2-57-9]\\d|6[0-24-9])|6(?:4[89]|6[67])|7(?:0[07]|7\\d|8[1-47-9]|9[0-36-9])|9(?:[01]9|9[0579])))\\d{4}",
,,,"8762101234",,,,[7]],[,,"8(?:00|33|44|55|66|77|88)[2-9]\\d{6}",,,,"8002123456"],[,,"900[2-9]\\d{6}",,,,"9002123456"],[,,,,,,,,,[-1]],[,,"52(?:35(?:[02-46-9]\\d|1[02-9]|5[0-46-9])|45(?:[034]\\d|1[02-9]|2[024-9]|5[0-46-9]))\\d{4}|52(?:3[2-46-9]|4[2-4])(?:[02-9]\\d|1[02-9])\\d{4}|5(?:00|2[12]|33|44|66|77|88)[2-9]\\d{6}",,,,"5002345678"],[,,,,,,,,,[-1]],"JM",1,"011","1",,,"1",,,,,,[,,,,,,,,,[-1]],,"658|876",[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],JO:[,[,,"(?:(?:[2689]|7\\d)\\d|32|53)\\d{6}",
,,,,,,[8,9]],[,,"87(?:000|90[01])\\d{3}|(?:2(?:6(?:2[0-35-9]|3[0-578]|4[24-7]|5[0-24-8]|[6-8][023]|9[0-3])|7(?:0[1-79]|10|2[014-7]|3[0-689]|4[019]|5[0-3578]))|32(?:0[1-69]|1[1-35-7]|2[024-7]|3\\d|4[0-3]|[5-7][023])|53(?:0[0-3]|[13][023]|2[0-59]|49|5[0-35-9]|6[15]|7[45]|8[1-6]|9[0-36-9])|6(?:2(?:[05]0|22)|3(?:00|33)|4(?:0[0-25]|1[2-467]|2[0569]|[38][07-9]|4[025689]|6[0-589]|7\\d|9[0-2])|5(?:[01][056]|2[034]|3[0-57-9]|4[178]|5[0-69]|6[0-35-9]|7[1-379]|8[0-68]|9[0239]))|87(?:20|7[078]|99))\\d{4}",,,
,"62001234",,,[8]],[,,"7(?:[78][0-25-9]|9\\d)\\d{6}",,,,"790123456",,,[9]],[,,"80\\d{6}",,,,"80012345",,,[8]],[,,"9\\d{7}",,,,"90012345",,,[8]],[,,"85\\d{6}",,,,"85012345",,,[8]],[,,"70\\d{7}",,,,"700123456",,,[9]],[,,,,,,,,,[-1]],"JO",962,"00","0",,,"0",,,,[[,"(\\d)(\\d{3})(\\d{4})","$1 $2 $3",["[2356]|87"],"(0$1)"],[,"(\\d{3})(\\d{5,6})","$1 $2",["[89]"],"0$1"],[,"(\\d{2})(\\d{7})","$1 $2",["70"],"0$1"],[,"(\\d)(\\d{4})(\\d{4})","$1 $2 $3",["7"],"0$1"]],,[,,"74(?:66|77)\\d{5}",,,,"746612345",,,
[9]],,,[,,,,,,,,,[-1]],[,,"8(?:10|8\\d)\\d{5}",,,,"88101234",,,[8]],,,[,,,,,,,,,[-1]]],JP:[,[,,"00[1-9]\\d{6,14}|[257-9]\\d{9}|(?:00|[1-9]\\d\\d)\\d{6}",,,,,,,[8,9,10,11,12,13,14,15,16,17]],[,,"(?:1(?:1[235-8]|2[3-6]|3[3-9]|4[2-6]|[58][2-8]|6[2-7]|7[2-9]|9[1-9])|(?:2[2-9]|[36][1-9])\\d|4(?:[2-578]\\d|6[02-8]|9[2-59])|5(?:[2-589]\\d|6[1-9]|7[2-8])|7(?:[25-9]\\d|3[4-9]|4[02-9])|8(?:[2679]\\d|3[2-9]|4[5-9]|5[1-9]|8[03-9])|9(?:[2-58]\\d|[679][1-9]))\\d{6}",,,,"312345678",,,[9]],[,,"[7-9]0[1-9]\\d{7}",
,,,"9012345678",,,[10]],[,,"00(?:(?:37|66)\\d{6,13}|(?:777(?:[01]|(?:5|8\\d)\\d)|882[1245]\\d\\d)\\d\\d)|(?:120|800\\d)\\d{6}",,,,"120123456"],[,,"990\\d{6}",,,,"990123456",,,[9]],[,,,,,,,,,[-1]],[,,"60\\d{7}",,,,"601234567",,,[9]],[,,"50[1-9]\\d{7}",,,,"5012345678",,,[10]],"JP",81,"010","0",,,"0",,,,[[,"(\\d{4})(\\d{4})","$1-$2",["007","0077","00777","00777[01]"]],[,"(\\d{3})(\\d{3})(\\d{3})","$1-$2-$3",["(?:12|57|99)0"],"0$1"],[,"(\\d{4})(\\d)(\\d{4})","$1-$2-$3",["1(?:26|3[79]|4[56]|5[4-68]|6[3-5])|499|5(?:76|97)|746|8(?:3[89]|47|51|63)|9(?:49|80|9[16])",
"1(?:267|3(?:7[247]|9[278])|466|5(?:47|58|64)|6(?:3[245]|48|5[4-68]))|499[2468]|5(?:76|97)9|7468|8(?:3(?:8[78]|96)|477|51[24]|636)|9(?:496|802|9(?:1[23]|69))|1(?:45|58)[67]","1(?:267|3(?:7[247]|9[278])|466|5(?:47|58|64)|6(?:3[245]|48|5[4-68]))|499[2468]|5(?:769|979[2-69])|7468|8(?:3(?:8[78]|96[2457-9])|477|51[24]|636[2-57-9])|9(?:496|802|9(?:1[23]|69))|1(?:45|58)[67]"],"0$1"],[,"(\\d{2})(\\d{3})(\\d{4})","$1-$2-$3",["60"],"0$1"],[,"(\\d)(\\d{4})(\\d{4})","$1-$2-$3",["[36]|4(?:2[09]|7[01])","[36]|4(?:2(?:0|9[02-69])|7(?:0[019]|1))"],
"0$1"],[,"(\\d{2})(\\d{3})(\\d{4})","$1-$2-$3",["1(?:1|5[45]|77|88|9[69])|2(?:2[1-37]|3[0-269]|4[59]|5|6[24]|7[1-358]|8[1369]|9[0-38])|4(?:[28][1-9]|3[0-57]|[45]|6[248]|7[2-579]|9[29])|5(?:2|3[045]|4[0-369]|5[29]|8[02389]|9[0-389])|7(?:2[02-46-9]|34|[58]|6[0249]|7[57]|9[2-6])|8(?:2[124589]|3[279]|49|6[0-24-9]|7[0-468]|8[68]|9[019])|9(?:[23][1-9]|4[15]|5[138]|6[1-3]|7[156]|8[189]|9[1-489])","1(?:1|5(?:4[018]|5[017])|77|88|9[69])|2(?:2(?:[127]|3[014-9])|3[0-269]|4[59]|5(?:[0468][01]|[1-3]|5[0-69]|9[19])|62|7(?:[1-35]|8[0189])|8(?:[16]|3[0134]|9[0-5])|9(?:[028]|17))|4(?:2(?:[13-79]|2[01]|8[014-6])|3[0-57]|[45]|6[248]|7[2-47]|8[1-9])|5(?:2|3[045]|4[0-369]|8[02389]|9[0-3])|7(?:2[02-46-9]|34|[58]|6[0249]|7[57]|9(?:[23]|4[0-59]|5[01569]|6[0167]))|8(?:2(?:[1258]|4[0-39]|9[0-2469])|49|6(?:[0-24]|5[0-3589]|72|9[01459])|7[0-468]|8[68])|9(?:[23][1-9]|4[15]|5[138]|6[1-3]|7[156]|8[189]|9(?:[1289]|3[34]|4[0178]))|(?:49|55|83)[29]|(?:264|837)[016-9]|2(?:57|93)[015-9]|(?:47[59]|59[89]|8(?:6[68]|9))[019]",
"1(?:1|5(?:4[018]|5[017])|77|88|9[69])|2(?:2[127]|3[0-269]|4[59]|5(?:[0468][01]|[1-3]|5[0-69]|9(?:17|99))|6(?:2|4[016-9])|7(?:[1-35]|8[0189])|8(?:[16]|3[0134]|9[0-5])|9(?:[028]|17))|4(?:2(?:[13-79]|2[01]|8[014-6])|3[0-57]|[45]|6[248]|7[2-47]|9[29])|5(?:2|3[045]|4[0-369]|5[29]|8[02389]|9[0-3])|7(?:2[02-46-9]|34|[58]|6[0249]|7[57]|9(?:[23]|4[0-59]|5[01569]|6[0167]))|8(?:2(?:[1258]|4[0-39]|9[0169])|3(?:[29]|7(?:[017-9]|6[6-8]))|49|6(?:[0-24]|5(?:[0-389]|5[23])|6(?:[01]|9[178])|72|9[0145])|7[0-468]|8[68])|9(?:4[15]|5[138]|7[156]|8[189]|9(?:[1289]|3(?:31|4[357])|4[0178]))|(?:8294|96)[1-3]|2(?:57|93)[015-9]|(?:223|8699)[014-9]|(?:48|8292|9[23])[1-9]|(?:47[59]|59[89]|8(?:68|9))[019]",
"1(?:1|5(?:4[018]|5[017])|77|88|9[69])|2(?:2[127]|3[0-269]|4[59]|5(?:[0468][01]|[1-3]|5[0-69]|7[015-9]|9(?:17|99))|6(?:2|4[016-9])|7(?:[1-35]|8[0189])|8(?:[16]|3[0134]|9[0-5])|9(?:[028]|17|3[015-9]))|4(?:2(?:[13-79]|2[01]|8[014-6])|3[0-57]|[45]|6[248]|7[2-47]|9[29])|5(?:2|3[045]|4[0-369]|5[29]|8[02389]|9[0-3])|7(?:2[02-46-9]|34|[58]|6[0249]|7[57]|9(?:[23]|4[0-59]|5[01569]|6[0167]))|8(?:2(?:[1258]|4[0-39]|9(?:[019]|4[1-3]|6(?:[0-47-9]|5[01346-9])))|3(?:[29]|7(?:[017-9]|6[6-8]))|49|6(?:[0-24]|5(?:[0-389]|5[23])|6(?:[01]|9[178])|72|9[0145])|7[0-468]|8[68])|9(?:4[15]|5[138]|6[1-3]|7[156]|8[189]|9(?:[1289]|3(?:31|4[357])|4[0178]))|(?:223|8699)[014-9]|(?:48|829(?:2|66)|9[23])[1-9]|(?:47[59]|59[89]|8(?:68|9))[019]"],
"0$1"],[,"(\\d{3})(\\d{2})(\\d{4})","$1-$2-$3",["[14]|[29][2-9]|5[3-9]|7[2-4679]|8(?:[246-9]|3[3-8]|5[2-9])","[14]|[29][2-9]|5[3-9]|7[2-4679]|8(?:[246-9]|3(?:[3-6][2-9]|7|8[2-5])|5[2-9])"],"0$1"],[,"(\\d{4})(\\d{2})(\\d{3,4})","$1-$2-$3",["007"]],[,"(\\d{4})(\\d{2})(\\d{4})","$1-$2-$3",["008"]],[,"(\\d{3})(\\d{3})(\\d{4})","$1-$2-$3",["800"],"0$1"],[,"(\\d{2})(\\d{4})(\\d{4})","$1-$2-$3",["[2579]|80"],"0$1"],[,"(\\d{4})(\\d{3})(\\d{3,4})","$1-$2-$3",["0"]],[,"(\\d{4})(\\d{4})(\\d{4,5})","$1-$2-$3",
["0"]],[,"(\\d{4})(\\d{5})(\\d{5,6})","$1-$2-$3",["0"]],[,"(\\d{4})(\\d{6})(\\d{6,7})","$1-$2-$3",["0"]]],[[,"(\\d{3})(\\d{3})(\\d{3})","$1-$2-$3",["(?:12|57|99)0"],"0$1"],[,"(\\d{4})(\\d)(\\d{4})","$1-$2-$3",["1(?:26|3[79]|4[56]|5[4-68]|6[3-5])|499|5(?:76|97)|746|8(?:3[89]|47|51|63)|9(?:49|80|9[16])","1(?:267|3(?:7[247]|9[278])|466|5(?:47|58|64)|6(?:3[245]|48|5[4-68]))|499[2468]|5(?:76|97)9|7468|8(?:3(?:8[78]|96)|477|51[24]|636)|9(?:496|802|9(?:1[23]|69))|1(?:45|58)[67]","1(?:267|3(?:7[247]|9[278])|466|5(?:47|58|64)|6(?:3[245]|48|5[4-68]))|499[2468]|5(?:769|979[2-69])|7468|8(?:3(?:8[78]|96[2457-9])|477|51[24]|636[2-57-9])|9(?:496|802|9(?:1[23]|69))|1(?:45|58)[67]"],
"0$1"],[,"(\\d{2})(\\d{3})(\\d{4})","$1-$2-$3",["60"],"0$1"],[,"(\\d)(\\d{4})(\\d{4})","$1-$2-$3",["[36]|4(?:2[09]|7[01])","[36]|4(?:2(?:0|9[02-69])|7(?:0[019]|1))"],"0$1"],[,"(\\d{2})(\\d{3})(\\d{4})","$1-$2-$3",["1(?:1|5[45]|77|88|9[69])|2(?:2[1-37]|3[0-269]|4[59]|5|6[24]|7[1-358]|8[1369]|9[0-38])|4(?:[28][1-9]|3[0-57]|[45]|6[248]|7[2-579]|9[29])|5(?:2|3[045]|4[0-369]|5[29]|8[02389]|9[0-389])|7(?:2[02-46-9]|34|[58]|6[0249]|7[57]|9[2-6])|8(?:2[124589]|3[279]|49|6[0-24-9]|7[0-468]|8[68]|9[019])|9(?:[23][1-9]|4[15]|5[138]|6[1-3]|7[156]|8[189]|9[1-489])",
"1(?:1|5(?:4[018]|5[017])|77|88|9[69])|2(?:2(?:[127]|3[014-9])|3[0-269]|4[59]|5(?:[0468][01]|[1-3]|5[0-69]|9[19])|62|7(?:[1-35]|8[0189])|8(?:[16]|3[0134]|9[0-5])|9(?:[028]|17))|4(?:2(?:[13-79]|2[01]|8[014-6])|3[0-57]|[45]|6[248]|7[2-47]|8[1-9])|5(?:2|3[045]|4[0-369]|8[02389]|9[0-3])|7(?:2[02-46-9]|34|[58]|6[0249]|7[57]|9(?:[23]|4[0-59]|5[01569]|6[0167]))|8(?:2(?:[1258]|4[0-39]|9[0-2469])|49|6(?:[0-24]|5[0-3589]|72|9[01459])|7[0-468]|8[68])|9(?:[23][1-9]|4[15]|5[138]|6[1-3]|7[156]|8[189]|9(?:[1289]|3[34]|4[0178]))|(?:49|55|83)[29]|(?:264|837)[016-9]|2(?:57|93)[015-9]|(?:47[59]|59[89]|8(?:6[68]|9))[019]",
"1(?:1|5(?:4[018]|5[017])|77|88|9[69])|2(?:2[127]|3[0-269]|4[59]|5(?:[0468][01]|[1-3]|5[0-69]|9(?:17|99))|6(?:2|4[016-9])|7(?:[1-35]|8[0189])|8(?:[16]|3[0134]|9[0-5])|9(?:[028]|17))|4(?:2(?:[13-79]|2[01]|8[014-6])|3[0-57]|[45]|6[248]|7[2-47]|9[29])|5(?:2|3[045]|4[0-369]|5[29]|8[02389]|9[0-3])|7(?:2[02-46-9]|34|[58]|6[0249]|7[57]|9(?:[23]|4[0-59]|5[01569]|6[0167]))|8(?:2(?:[1258]|4[0-39]|9[0169])|3(?:[29]|7(?:[017-9]|6[6-8]))|49|6(?:[0-24]|5(?:[0-389]|5[23])|6(?:[01]|9[178])|72|9[0145])|7[0-468]|8[68])|9(?:4[15]|5[138]|7[156]|8[189]|9(?:[1289]|3(?:31|4[357])|4[0178]))|(?:8294|96)[1-3]|2(?:57|93)[015-9]|(?:223|8699)[014-9]|(?:48|8292|9[23])[1-9]|(?:47[59]|59[89]|8(?:68|9))[019]",
"1(?:1|5(?:4[018]|5[017])|77|88|9[69])|2(?:2[127]|3[0-269]|4[59]|5(?:[0468][01]|[1-3]|5[0-69]|7[015-9]|9(?:17|99))|6(?:2|4[016-9])|7(?:[1-35]|8[0189])|8(?:[16]|3[0134]|9[0-5])|9(?:[028]|17|3[015-9]))|4(?:2(?:[13-79]|2[01]|8[014-6])|3[0-57]|[45]|6[248]|7[2-47]|9[29])|5(?:2|3[045]|4[0-369]|5[29]|8[02389]|9[0-3])|7(?:2[02-46-9]|34|[58]|6[0249]|7[57]|9(?:[23]|4[0-59]|5[01569]|6[0167]))|8(?:2(?:[1258]|4[0-39]|9(?:[019]|4[1-3]|6(?:[0-47-9]|5[01346-9])))|3(?:[29]|7(?:[017-9]|6[6-8]))|49|6(?:[0-24]|5(?:[0-389]|5[23])|6(?:[01]|9[178])|72|9[0145])|7[0-468]|8[68])|9(?:4[15]|5[138]|6[1-3]|7[156]|8[189]|9(?:[1289]|3(?:31|4[357])|4[0178]))|(?:223|8699)[014-9]|(?:48|829(?:2|66)|9[23])[1-9]|(?:47[59]|59[89]|8(?:68|9))[019]"],
"0$1"],[,"(\\d{3})(\\d{2})(\\d{4})","$1-$2-$3",["[14]|[29][2-9]|5[3-9]|7[2-4679]|8(?:[246-9]|3[3-8]|5[2-9])","[14]|[29][2-9]|5[3-9]|7[2-4679]|8(?:[246-9]|3(?:[3-6][2-9]|7|8[2-5])|5[2-9])"],"0$1"],[,"(\\d{3})(\\d{3})(\\d{4})","$1-$2-$3",["800"],"0$1"],[,"(\\d{2})(\\d{4})(\\d{4})","$1-$2-$3",["[2579]|80"],"0$1"]],[,,"20\\d{8}",,,,"2012345678",,,[10]],,,[,,"00(?:777(?:[01]|(?:5|8\\d)\\d)|882[1245]\\d\\d)\\d\\d|00(?:37|66)\\d{6,13}"],[,,"570\\d{6}",,,,"570123456",,,[9]],,,[,,,,,,,,,[-1]]],KE:[,[,,"(?:[17]\\d\\d|900)\\d{6}|(?:2|80)0\\d{6,7}|[4-6]\\d{6,8}",
,,,,,,[7,8,9,10]],[,,"(?:4[245]|5[1-79]|6[01457-9])\\d{5,7}|(?:4[136]|5[08]|62)\\d{7}|(?:[24]0|66)\\d{6,7}",,,,"202012345",,,[7,8,9]],[,,"(?:1(?:0[0-2]|1[01])|7\\d\\d)\\d{6}",,,,"712123456",,,[9]],[,,"800[24-8]\\d{5,6}",,,,"800223456",,,[9,10]],[,,"900[02-9]\\d{5}",,,,"900223456",,,[9]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],"KE",254,"000","0",,,"0",,,,[[,"(\\d{2})(\\d{5,7})","$1 $2",["[24-6]"],"0$1"],[,"(\\d{3})(\\d{6})","$1 $2",["[17]"],"0$1"],[,"(\\d{3})(\\d{3})(\\d{3,4})","$1 $2 $3",
["[89]"],"0$1"]],,[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],KG:[,[,,"8\\d{9}|(?:[235-8]\\d|99)\\d{7}",,,,,,,[9,10],[5,6]],[,,"312(?:5[0-79]\\d|9(?:[0-689]\\d|7[0-24-9]))\\d{3}|(?:3(?:1(?:2[0-46-8]|3[1-9]|47|[56]\\d)|2(?:22|3[0-479]|6[0-7])|4(?:22|5[6-9]|6\\d)|5(?:22|3[4-7]|59|6\\d)|6(?:22|5[35-7]|6\\d)|7(?:22|3[468]|4[1-9]|59|[67]\\d)|9(?:22|4[1-8]|6\\d))|6(?:09|12|2[2-4])\\d)\\d{5}",,,,"312123456",,,[9],[5,6]],[,,"(?:312(?:58\\d|973)|8801\\d\\d)\\d{3}|(?:2(?:0[0-35]|2\\d)|5[0-24-7]\\d|7(?:[07]\\d|55)|99[05-9])\\d{6}",
,,,"700123456",,,[9]],[,,"800\\d{6,7}",,,,"800123456"],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],"KG",996,"00","0",,,"0",,,,[[,"(\\d{4})(\\d{5})","$1 $2",["3(?:1[346]|[24-79])"],"0$1"],[,"(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["[235-79]|88"],"0$1"],[,"(\\d{3})(\\d{3})(\\d)(\\d{2,3})","$1 $2 $3 $4",["8"],"0$1"]],,[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],KH:[,[,,"1\\d{9}|[1-9]\\d{7,8}",,,,,,,[8,9,10],[6,7]],[,,"23(?:4(?:[2-4]|[56]\\d)|[568]\\d\\d)\\d{4}|23[236-9]\\d{5}|(?:2[4-6]|3[2-6]|4[2-4]|[5-7][2-5])(?:(?:[237-9]|4[56]|5\\d)\\d{5}|6\\d{5,6})",
,,,"23756789",,,[8,9],[6,7]],[,,"(?:(?:1[28]|3[18]|9[67])\\d|6[016-9]|7(?:[07-9]|[16]\\d)|8(?:[013-79]|8\\d))\\d{6}|(?:1\\d|9[0-57-9])\\d{6}|(?:2[3-6]|3[2-6]|4[2-4]|[5-7][2-5])48\\d{5}",,,,"91234567",,,[8,9]],[,,"1800(?:1\\d|2[019])\\d{4}",,,,"1800123456",,,[10]],[,,"1900(?:1\\d|2[09])\\d{4}",,,,"1900123456",,,[10]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],"KH",855,"00[14-9]","0",,,"0",,,,[[,"(\\d{2})(\\d{3})(\\d{3,4})","$1 $2 $3",["[1-9]"],"0$1"],[,"(\\d{4})(\\d{3})(\\d{3})","$1 $2 $3",["1"]]],
,[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],KI:[,[,,"(?:[37]\\d|6[0-79])\\d{6}|(?:[2-48]\\d|50)\\d{3}",,,,,,,[5,8]],[,,"(?:[24]\\d|3[1-9]|50|65(?:02[12]|12[56]|22[89]|[3-5]00)|7(?:27\\d\\d|3100|5(?:02[12]|12[56]|22[89]|[34](?:00|81)|500))|8[0-5])\\d{3}",,,,"31234"],[,,"(?:63\\d{3}|73(?:0[0-5]\\d|140))\\d{3}|[67]200[01]\\d{3}",,,,"72001234",,,[8]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,"30(?:0[01]\\d\\d|12(?:11|20))\\d\\d",,,,"30010000",,,[8]],
"KI",686,"00","0",,,"0",,,,,,[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],KM:[,[,,"[3478]\\d{6}",,,,,,,[7],[4]],[,,"7[4-7]\\d{5}",,,,"7712345",,,,[4]],[,,"[34]\\d{6}",,,,"3212345"],[,,,,,,,,,[-1]],[,,"8\\d{6}",,,,"8001234"],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],"KM",269,"00",,,,,,,,[[,"(\\d{3})(\\d{2})(\\d{2})","$1 $2 $3",["[3478]"]]],,[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],KN:[,[,,"(?:[58]\\d\\d|900)\\d{7}",,,,,,,[10],[7]],[,,"869(?:2(?:29|36)|302|4(?:6[015-9]|70))\\d{4}",
,,,"8692361234",,,,[7]],[,,"869(?:48[89]|5(?:5[6-8]|6[5-7])|66\\d|76[02-7])\\d{4}",,,,"8697652917",,,,[7]],[,,"8(?:00|33|44|55|66|77|88)[2-9]\\d{6}",,,,"8002123456"],[,,"900[2-9]\\d{6}",,,,"9002123456"],[,,,,,,,,,[-1]],[,,"52(?:35(?:[02-46-9]\\d|1[02-9]|5[0-46-9])|45(?:[034]\\d|1[02-9]|2[024-9]|5[0-46-9]))\\d{4}|52(?:3[2-46-9]|4[2-4])(?:[02-9]\\d|1[02-9])\\d{4}|5(?:00|2[12]|33|44|66|77|88)[2-9]\\d{6}",,,,"5002345678"],[,,,,,,,,,[-1]],"KN",1,"011","1",,,"1|([2-7]\\d{6})$","869$1",,,,,[,,,,,,,,,[-1]],
,"869",[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],KP:[,[,,"85\\d{6}|(?:19\\d|[2-7])\\d{7}",,,,,,,[8,10],[6,7]],[,,"(?:(?:195|2)\\d|3[19]|4[159]|5[37]|6[17]|7[39]|85)\\d{6}",,,,"21234567",,,,[6,7]],[,,"19[1-3]\\d{7}",,,,"1921234567",,,[10]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],"KP",850,"00|99","0",,,"0",,,,[[,"(\\d{2})(\\d{3})(\\d{3})","$1 $2 $3",["8"],"0$1"],[,"(\\d)(\\d{3})(\\d{4})","$1 $2 $3",["[2-7]"],"0$1"],[,"(\\d{3})(\\d{3})(\\d{4})","$1 $2 $3",
["1"],"0$1"]],,[,,,,,,,,,[-1]],,,[,,"238[02-9]\\d{4}|2(?:[0-24-9]\\d|3[0-79])\\d{5}",,,,,,,[8]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],KR:[,[,,"00[1-9]\\d{8,11}|(?:[12]|5\\d{3})\\d{7}|[13-6]\\d{9}|(?:[1-6]\\d|80)\\d{7}|[3-6]\\d{4,5}|(?:00|7)0\\d{8}",,,,,,,[5,6,8,9,10,11,12,13,14],[3,4,7]],[,,"(?:2|3[1-3]|[46][1-4]|5[1-5])[1-9]\\d{6,7}|(?:3[1-3]|[46][1-4]|5[1-5])1\\d{2,3}",,,,"22123456",,,[5,6,8,9,10],[3,4,7]],[,,"1(?:05(?:[0-8]\\d|9[0-5])|22[13]\\d)\\d{4,5}|1(?:0[1-46-9]|[16-9]\\d|2[013-9])\\d{6,7}",
,,,"1020000000",,,[9,10]],[,,"00(?:308\\d{6,7}|798\\d{7,9})|(?:00368|80)\\d{7}",,,,"801234567",,,[9,11,12,13,14]],[,,"60[2-9]\\d{6}",,,,"602345678",,,[9]],[,,,,,,,,,[-1]],[,,"50\\d{8,9}",,,,"5012345678",,,[10,11]],[,,"70\\d{8}",,,,"7012345678",,,[10]],"KR",82,"00(?:[125689]|3(?:[46]5|91)|7(?:00|27|3|55|6[126]))","0",,,"0(8(?:[1-46-8]|5\\d\\d))?",,,,[[,"(\\d{5})","$1",["1[016-9]1","1[016-9]11","1[016-9]114"],"0$1"],[,"(\\d{2})(\\d{3,4})","$1-$2",["(?:3[1-3]|[46][1-4]|5[1-5])1"],"0$1","0$CC-$1"],[,
"(\\d{4})(\\d{4})","$1-$2",["1"]],[,"(\\d)(\\d{3,4})(\\d{4})","$1-$2-$3",["2"],"0$1","0$CC-$1"],[,"(\\d{2})(\\d{3})(\\d{4})","$1-$2-$3",["60|8"],"0$1","0$CC-$1"],[,"(\\d{2})(\\d{3,4})(\\d{4})","$1-$2-$3",["[1346]|5[1-5]"],"0$1","0$CC-$1"],[,"(\\d{2})(\\d{4})(\\d{4})","$1-$2-$3",["[57]"],"0$1","0$CC-$1"],[,"(\\d{5})(\\d{3})(\\d{3})","$1 $2 $3",["003","0030"]],[,"(\\d{2})(\\d{5})(\\d{4})","$1-$2-$3",["5"],"0$1","0$CC-$1"],[,"(\\d{5})(\\d{3,4})(\\d{4})","$1 $2 $3",["0"]],[,"(\\d{5})(\\d{2})(\\d{3})(\\d{4})",
"$1 $2 $3 $4",["0"]]],[[,"(\\d{2})(\\d{3,4})","$1-$2",["(?:3[1-3]|[46][1-4]|5[1-5])1"],"0$1","0$CC-$1"],[,"(\\d{4})(\\d{4})","$1-$2",["1"]],[,"(\\d)(\\d{3,4})(\\d{4})","$1-$2-$3",["2"],"0$1","0$CC-$1"],[,"(\\d{2})(\\d{3})(\\d{4})","$1-$2-$3",["60|8"],"0$1","0$CC-$1"],[,"(\\d{2})(\\d{3,4})(\\d{4})","$1-$2-$3",["[1346]|5[1-5]"],"0$1","0$CC-$1"],[,"(\\d{2})(\\d{4})(\\d{4})","$1-$2-$3",["[57]"],"0$1","0$CC-$1"],[,"(\\d{2})(\\d{5})(\\d{4})","$1-$2-$3",["5"],"0$1","0$CC-$1"]],[,,"15\\d{7,8}",,,,"1523456789",
,,[9,10]],,,[,,"00(?:3(?:08\\d{6,7}|68\\d{7})|798\\d{7,9})",,,,,,,[11,12,13,14]],[,,"1(?:5(?:22|44|66|77|88|99)|6(?:[07]0|44|6[16]|88)|8(?:00|33|55|77|99))\\d{4}",,,,"15441234",,,[8]],,,[,,,,,,,,,[-1]]],KW:[,[,,"(?:18|[2569]\\d\\d)\\d{5}",,,,,,,[7,8]],[,,"2(?:[23]\\d\\d|4(?:[1-35-9]\\d|44)|5(?:0[034]|[2-46]\\d|5[1-3]|7[1-7]))\\d{4}",,,,"22345678",,,[8]],[,,"(?:5(?:2(?:22|5[25])|88[58])|6(?:222|444|70[013-9]|888|93[039])|9(?:11[01]|333|500))\\d{4}|(?:5(?:[05]\\d|1[0-7]|6[56])|6(?:0[034679]|5[015-9]|6\\d|7[67]|9[069])|9(?:0[09]|22|[4679]\\d|55|8[057-9]))\\d{5}",
,,,"50012345",,,[8]],[,,"18\\d{5}",,,,"1801234",,,[7]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],"KW",965,"00",,,,,,,,[[,"(\\d{4})(\\d{3,4})","$1 $2",["[169]|2(?:[235]|4[1-35-9])|52"]],[,"(\\d{3})(\\d{5})","$1 $2",["[25]"]]],,[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],KY:[,[,,"(?:345|[58]\\d\\d|900)\\d{7}",,,,,,,[10],[7]],[,,"345(?:2(?:22|3[23]|44|66)|333|444|6(?:23|38|40)|7(?:30|4[35-79]|6[6-9]|77)|8(?:00|1[45]|25|[48]8)|9(?:14|4[035-9]))\\d{4}",,,
,"3452221234",,,,[7]],[,,"345(?:32[1-9]|42[0-4]|5(?:1[67]|2[5-79]|4[6-9]|50|76)|649|9(?:1[679]|2[2-9]|3[06-9]|90))\\d{4}",,,,"3453231234",,,,[7]],[,,"8(?:00|33|44|55|66|77|88)[2-9]\\d{6}",,,,"8002345678"],[,,"(?:345976|900[2-9]\\d\\d)\\d{4}",,,,"9002345678"],[,,,,,,,,,[-1]],[,,"52(?:35(?:[02-46-9]\\d|1[02-9]|5[0-46-9])|45(?:[034]\\d|1[02-9]|2[024-9]|5[0-46-9]))\\d{4}|52(?:3[2-46-9]|4[2-4])(?:[02-9]\\d|1[02-9])\\d{4}|5(?:00|2[12]|33|44|66|77|88)[2-9]\\d{6}",,,,"5002345678"],[,,,,,,,,,[-1]],"KY",1,
"011","1",,,"1|([2-9]\\d{6})$","345$1",,,,,[,,"345849\\d{4}",,,,"3458491234"],,"345",[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],KZ:[,[,,"33622\\d{5}|(?:7\\d|80)\\d{8}",,,,,,,[10],[5,6,7]],[,,"(?:33622|7(?:1(?:0(?:[23]\\d|4[0-3]|59|63)|1(?:[23]\\d|4[0-79]|59)|2(?:[23]\\d|59)|3(?:2\\d|3[0-79]|4[0-35-9]|59)|4(?:[24]\\d|3[013-9]|5[1-9])|5(?:2\\d|3[1-9]|4[0-7]|59)|6(?:[2-4]\\d|5[19]|61)|72\\d|8(?:[27]\\d|3[1-46-9]|4[0-5]))|2(?:1(?:[23]\\d|4[46-9]|5[3469])|2(?:2\\d|3[0679]|46|5[12679])|3(?:[2-4]\\d|5[139])|4(?:2\\d|3[1-35-9]|59)|5(?:[23]\\d|4[0-246-8]|59|61)|6(?:2\\d|3[1-9]|4[0-4]|59)|7(?:[2379]\\d|40|5[279])|8(?:[23]\\d|4[0-3]|59)|9(?:2\\d|3[124578]|59))))\\d{5}",
,,,"7123456789",,,,[5,6,7]],[,,"7(?:0[0-25-8]|47|6[02-4]|7[15-8]|85)\\d{7}",,,,"7710009998"],[,,"800\\d{7}",,,,"8001234567"],[,,"809\\d{7}",,,,"8091234567"],[,,,,,,,,,[-1]],[,,"808\\d{7}",,,,"8081234567"],[,,"751\\d{7}",,,,"7511234567"],"KZ",7,"810","8",,,"8",,"8~10",,,,[,,,,,,,,,[-1]],,"33|7",[,,"751\\d{7}"],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],LA:[,[,,"[23]\\d{9}|3\\d{8}|(?:[235-8]\\d|41)\\d{6}",,,,,,,[8,9,10],[6]],[,,"(?:2[13]|[35-7][14]|41|8[1468])\\d{6}",,,,"21212862",,,[8],[6]],[,,"(?:20(?:[239]\\d|5[24-689]|7[6-8])|302\\d)\\d{6}",
,,,"2023123456",,,[10]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],"LA",856,"00","0",,,"0",,,,[[,"(\\d{2})(\\d{3})(\\d{3})","$1 $2 $3",["2[13]|3[14]|[4-8]"],"0$1"],[,"(\\d{2})(\\d{2})(\\d{2})(\\d{3})","$1 $2 $3 $4",["30[013-9]"],"0$1"],[,"(\\d{2})(\\d{2})(\\d{3})(\\d{3})","$1 $2 $3 $4",["[23]"],"0$1"]],,[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,"30[013-9]\\d{6}",,,,"301234567",,,[9]],,,[,,,,,,,,,[-1]]],LB:[,[,,"[7-9]\\d{7}|[13-9]\\d{6}",,,,,,,[7,8]],[,,"(?:(?:[14-69]\\d|8[02-9])\\d|7(?:[2-57]\\d|62|8[0-7]|9[04-9]))\\d{4}",
,,,"1123456",,,[7]],[,,"793(?:[01]\\d|2[0-4])\\d{3}|(?:(?:3|81)\\d|7(?:[01]\\d|6[013-9]|8[89]|9[12]))\\d{5}",,,,"71123456"],[,,,,,,,,,[-1]],[,,"9[01]\\d{6}",,,,"90123456",,,[8]],[,,"80\\d{6}",,,,"80123456",,,[8]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],"LB",961,"00","0",,,"0",,,,[[,"(\\d)(\\d{3})(\\d{3})","$1 $2 $3",["[13-69]|7(?:[2-57]|62|8[0-7]|9[04-9])|8[02-9]"],"0$1"],[,"(\\d{2})(\\d{3})(\\d{3})","$1 $2 $3",["[7-9]"]]],,[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],LC:[,[,,"(?:[58]\\d\\d|758|900)\\d{7}",
,,,,,,[10],[7]],[,,"758(?:234|4(?:30|5\\d|6[2-9]|8[0-2])|57[0-2]|(?:63|75)8)\\d{4}",,,,"7584305678",,,,[7]],[,,"758(?:28[4-7]|384|4(?:6[01]|8[4-9])|5(?:1[89]|20|84)|7(?:1[2-9]|2\\d|3[0-3])|812)\\d{4}",,,,"7582845678",,,,[7]],[,,"8(?:00|33|44|55|66|77|88)[2-9]\\d{6}",,,,"8002123456"],[,,"900[2-9]\\d{6}",,,,"9002123456"],[,,,,,,,,,[-1]],[,,"52(?:35(?:[02-46-9]\\d|1[02-9]|5[0-46-9])|45(?:[034]\\d|1[02-9]|2[024-9]|5[0-46-9]))\\d{4}|52(?:3[2-46-9]|4[2-4])(?:[02-9]\\d|1[02-9])\\d{4}|5(?:00|2[12]|33|44|66|77|88)[2-9]\\d{6}",
,,,"5002345678"],[,,,,,,,,,[-1]],"LC",1,"011","1",,,"1|([2-8]\\d{6})$","758$1",,,,,[,,,,,,,,,[-1]],,"758",[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],LI:[,[,,"90\\d{5}|(?:[2378]|6\\d\\d)\\d{6}",,,,,,,[7,9]],[,,"(?:2(?:01|1[27]|22|3\\d|6[02-578]|96)|3(?:33|40|7[0135-7]|8[048]|9[0269]))\\d{4}",,,,"2345678",,,[7]],[,,"(?:6(?:4(?:89|9\\d)|5[0-3]\\d|6(?:0[0-7]|10|2[06-9]|39))\\d|7(?:[37-9]\\d|42|56))\\d{4}",,,,"660234567"],[,,"80(?:02[28]|9\\d\\d)\\d\\d",,,,"8002222",,,[7]],[,,"90(?:02[258]|1(?:23|3[14])|66[136])\\d\\d",
,,,"9002222",,,[7]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],"LI",423,"00","0",,,"0|(1001)",,,,[[,"(\\d{3})(\\d{2})(\\d{2})","$1 $2 $3",["[237-9]"],,"$CC $1"],[,"(\\d{2})(\\d{3})(\\d{4})","$1 $2 $3",["69"],,"$CC $1"],[,"(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["6"],,"$CC $1"]],,[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,"870(?:28|87)\\d\\d",,,,"8702812",,,[7]],,,[,,"697(?:42|56|[78]\\d)\\d{4}",,,,"697861234",,,[9]]],LK:[,[,,"[1-9]\\d{8}",,,,,,,[9],[7]],[,,"(?:12[2-9]|602|8[12]\\d|9(?:1\\d|22|9[245]))\\d{6}|(?:11|2[13-7]|3[1-8]|4[157]|5[12457]|6[35-7])[2-57]\\d{6}",
,,,"112345678",,,,[7]],[,,"7[0-25-8]\\d{7}",,,,"712345678"],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],"LK",94,"00","0",,,"0",,,,[[,"(\\d{2})(\\d{3})(\\d{4})","$1 $2 $3",["7"],"0$1"],[,"(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["[1-689]"],"0$1"]],,[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,"1973\\d{5}",,,,"197312345"],,,[,,,,,,,,,[-1]]],LR:[,[,,"(?:2|33|5\\d|77|88)\\d{7}|[4-6]\\d{6}",,,,,,,[7,8,9]],[,,"(?:2\\d{3}|33333)\\d{4}",,,,"21234567",,,[8,9]],[,,"(?:(?:330|555|(?:77|88)\\d)\\d|4[67])\\d{5}|[56]\\d{6}",
,,,"770123456",,,[7,9]],[,,,,,,,,,[-1]],[,,"332(?:02|[34]\\d)\\d{4}",,,,"332021234",,,[9]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],"LR",231,"00","0",,,"0",,,,[[,"(\\d)(\\d{3})(\\d{3})","$1 $2 $3",["[4-6]"],"0$1"],[,"(\\d{2})(\\d{3})(\\d{3})","$1 $2 $3",["2"],"0$1"],[,"(\\d{2})(\\d{3})(\\d{4})","$1 $2 $3",["[3578]"],"0$1"]],,[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],LS:[,[,,"(?:[256]\\d\\d|800)\\d{5}",,,,,,,[8]],[,,"2\\d{7}",,,,"22123456"],[,,"[56]\\d{7}",,,,"50123456"],
[,,"800[256]\\d{4}",,,,"80021234"],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],"LS",266,"00",,,,,,,,[[,"(\\d{4})(\\d{4})","$1 $2",["[2568]"]]],,[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],LT:[,[,,"(?:[3469]\\d|52|[78]0)\\d{6}",,,,,,,[8]],[,,"(?:3[1478]|4[124-6]|52)\\d{6}",,,,"31234567"],[,,"6\\d{7}",,,,"61234567"],[,,"80[02]\\d{5}",,,,"80012345"],[,,"9(?:0[0239]|10)\\d{5}",,,,"90012345"],[,,"808\\d{5}",,,,"80812345"],[,,"70[05]\\d{5}",,,,"70012345"],[,
,"[89]01\\d{5}",,,,"80123456"],"LT",370,"00","8",,,"[08]",,,,[[,"(\\d)(\\d{3})(\\d{4})","$1 $2 $3",["52[0-7]"],"(8-$1)",,1],[,"(\\d{3})(\\d{2})(\\d{3})","$1 $2 $3",["[7-9]"],"8 $1",,1],[,"(\\d{2})(\\d{6})","$1 $2",["37|4(?:[15]|6[1-8])"],"(8-$1)",,1],[,"(\\d{3})(\\d{5})","$1 $2",["[3-6]"],"(8-$1)",,1]],,[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,"70[67]\\d{5}",,,,"70712345"],,,[,,,,,,,,,[-1]]],LU:[,[,,"35[013-9]\\d{4,8}|6\\d{8}|35\\d{2,4}|(?:[2457-9]\\d|3[0-46-9])\\d{2,9}",,,,,,,[4,5,6,7,8,9,10,11]],[,
,"(?:35[013-9]|80[2-9]|90[89])\\d{1,8}|(?:2[2-9]|3[0-46-9]|[457]\\d|8[13-9]|9[2-579])\\d{2,9}",,,,"27123456"],[,,"6(?:[269][18]|5[158]|7[189]|81)\\d{6}",,,,"628123456",,,[9]],[,,"800\\d{5}",,,,"80012345",,,[8]],[,,"90[015]\\d{5}",,,,"90012345",,,[8]],[,,"801\\d{5}",,,,"80112345",,,[8]],[,,,,,,,,,[-1]],[,,"20(?:1\\d{5}|[2-689]\\d{1,7})",,,,"20201234",,,[4,5,6,7,8,9,10]],"LU",352,"00",,,,"(15(?:0[06]|1[12]|[35]5|4[04]|6[26]|77|88|99)\\d)",,,,[[,"(\\d{2})(\\d{3})","$1 $2",["2(?:0[2-689]|[2-9])|[3-57]|8(?:0[2-9]|[13-9])|9(?:0[89]|[2-579])"],
,"$CC $1"],[,"(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3",["2(?:0[2-689]|[2-9])|[3-57]|8(?:0[2-9]|[13-9])|9(?:0[89]|[2-579])"],,"$CC $1"],[,"(\\d{2})(\\d{2})(\\d{3})","$1 $2 $3",["20[2-689]"],,"$CC $1"],[,"(\\d{2})(\\d{2})(\\d{2})(\\d{1,2})","$1 $2 $3 $4",["2(?:[0367]|4[3-8])"],,"$CC $1"],[,"(\\d{3})(\\d{2})(\\d{3})","$1 $2 $3",["80[01]|90[015]"],,"$CC $1"],[,"(\\d{2})(\\d{2})(\\d{2})(\\d{3})","$1 $2 $3 $4",["20"],,"$CC $1"],[,"(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["6"],,"$CC $1"],[,"(\\d{2})(\\d{2})(\\d{2})(\\d{2})(\\d{1,2})",
"$1 $2 $3 $4 $5",["2(?:[0367]|4[3-8])"],,"$CC $1"],[,"(\\d{2})(\\d{2})(\\d{2})(\\d{1,5})","$1 $2 $3 $4",["[3-57]|8[13-9]|9(?:0[89]|[2-579])|(?:2|80)[2-9]"],,"$CC $1"]],,[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],LV:[,[,,"(?:[268]\\d|90)\\d{6}",,,,,,,[8]],[,,"6\\d{7}",,,,"63123456"],[,,"2\\d{7}",,,,"21234567"],[,,"80\\d{6}",,,,"80123456"],[,,"90\\d{6}",,,,"90123456"],[,,"81\\d{6}",,,,"81123456"],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],"LV",371,"00",,,,,,,,[[,"(\\d{2})(\\d{3})(\\d{3})",
"$1 $2 $3",["[269]|8[01]"]]],,[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],LY:[,[,,"[2-9]\\d{8}",,,,,,,[9],[7]],[,,"(?:2(?:0[56]|[1-6]\\d|7[124579]|8[124])|3(?:1\\d|2[2356])|4(?:[17]\\d|2[1-357]|5[2-4]|8[124])|5(?:[1347]\\d|2[1-469]|5[13-5]|8[1-4])|6(?:[1-479]\\d|5[2-57]|8[1-5])|7(?:[13]\\d|2[13-79])|8(?:[124]\\d|5[124]|84))\\d{6}",,,,"212345678",,,,[7]],[,,"9[1-6]\\d{7}",,,,"912345678"],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],"LY",218,
"00","0",,,"0",,,,[[,"(\\d{2})(\\d{7})","$1-$2",["[2-9]"],"0$1"]],,[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],MA:[,[,,"[5-8]\\d{8}",,,,,,,[9]],[,,"5(?:29(?:[189][05]|2[29]|3[01])|38[89][05])\\d{4}|5(?:2(?:[015-7]\\d|2[02-9]|3[0-578]|4[02-46-8]|8[0235-7]|90)|3(?:[0-47]\\d|5[02-9]|6[02-8]|80|9[3-9])|(?:4[067]|5[03])\\d)\\d{5}",,,,"520123456"],[,,"(?:6(?:[0-79]\\d|8[0-247-9])|7(?:0[016-8]|6[1267]|7[0-27]))\\d{6}",,,,"650123456"],[,,"80\\d{7}",,,,"801234567"],[,,"89\\d{7}",,
,,"891234567"],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,"592(?:4[0-2]|93)\\d{4}",,,,"592401234"],"MA",212,"00","0",,,"0",,,,[[,"(\\d{5})(\\d{4})","$1-$2",["5(?:29|38)","5(?:29|38)[89]","5(?:29|38)[89]0"],"0$1"],[,"(\\d{3})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["5[45]"],"0$1"],[,"(\\d{4})(\\d{5})","$1-$2",["5(?:2[2-489]|3[5-9]|9)|892","5(?:2(?:[2-49]|8[235-9])|3[5-9]|9)|892"],"0$1"],[,"(\\d{2})(\\d{7})","$1-$2",["8"],"0$1"],[,"(\\d{3})(\\d{6})","$1-$2",["[5-7]"],"0$1"]],,[,,,,,,,,,[-1]],1,,[,,,,,,,,,[-1]],
[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],MC:[,[,,"870\\d{5}|(?:[349]|6\\d)\\d{7}",,,,,,,[8,9]],[,,"(?:870|9[2-47-9]\\d)\\d{5}",,,,"99123456",,,[8]],[,,"4(?:[46]\\d|5[1-9])\\d{5}|(?:3|6\\d)\\d{7}",,,,"612345678"],[,,"90\\d{6}",,,,"90123456",,,[8]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],"MC",377,"00","0",,,"0",,,,[[,"(\\d{3})(\\d{3})(\\d{2})","$1 $2 $3",["8"]],[,"(\\d{2})(\\d{3})(\\d{3})","$1 $2 $3",["4"],"0$1"],[,"(\\d{2})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[39]"]],[,"(\\d)(\\d{2})(\\d{2})(\\d{2})(\\d{2})",
"$1 $2 $3 $4 $5",["6"],"0$1"]],[[,"(\\d{2})(\\d{3})(\\d{3})","$1 $2 $3",["4"],"0$1"],[,"(\\d{2})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[39]"]],[,"(\\d)(\\d{2})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4 $5",["6"],"0$1"]],[,,,,,,,,,[-1]],,,[,,"870\\d{5}",,,,,,,[8]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],MD:[,[,,"(?:[235-7]\\d|[89]0)\\d{6}",,,,,,,[8]],[,,"(?:(?:2[1-9]|3[1-79])\\d|5(?:33|5[257]))\\d{5}",,,,"22212345"],[,,"562\\d{5}|(?:6\\d|7[16-9])\\d{6}",,,,"62112345"],[,,"800\\d{5}",,,,"80012345"],[,,"90[056]\\d{5}",
,,,"90012345"],[,,"808\\d{5}",,,,"80812345"],[,,,,,,,,,[-1]],[,,"3[08]\\d{6}",,,,"30123456"],"MD",373,"00","0",,,"0",,,,[[,"(\\d{3})(\\d{5})","$1 $2",["[89]"],"0$1"],[,"(\\d{2})(\\d{3})(\\d{3})","$1 $2 $3",["22|3"],"0$1"],[,"(\\d{3})(\\d{2})(\\d{3})","$1 $2 $3",["[25-7]"],"0$1"]],,[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,"803\\d{5}",,,,"80312345"],,,[,,,,,,,,,[-1]]],ME:[,[,,"(?:20|[3-79]\\d)\\d{6}|80\\d{6,7}",,,,,,,[8,9],[6]],[,,"(?:20[2-8]|3(?:[0-2][2-7]|3[24-7])|4(?:0[2-467]|1[2467])|5(?:0[2467]|1[24-7]|2[2-467]))\\d{5}",
,,,"30234567",,,[8],[6]],[,,"6(?:[07-9]\\d|3[024]|6[0-25])\\d{5}",,,,"67622901",,,[8]],[,,"80(?:[0-2578]|9\\d)\\d{5}",,,,"80080002"],[,,"9(?:4[1568]|5[178])\\d{5}",,,,"94515151",,,[8]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,"78[1-49]\\d{5}",,,,"78108780",,,[8]],"ME",382,"00","0",,,"0",,,,[[,"(\\d{2})(\\d{3})(\\d{3,4})","$1 $2 $3",["[2-9]"],"0$1"]],,[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,"77[1-9]\\d{5}",,,,"77273012",,,[8]],,,[,,,,,,,,,[-1]]],MF:[,[,,"(?:590|69\\d|976)\\d{6}",,,,,,,[9]],[,,"590(?:0[079]|[14]3|[27][79]|30|5[0-268]|87)\\d{4}",
,,,"590271234"],[,,"69(?:0\\d\\d|1(?:2[29]|3[0-5]))\\d{4}",,,,"690001234"],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,"976[01]\\d{5}",,,,"976012345"],"MF",590,"00","0",,,"0",,,,,,[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],MG:[,[,,"[23]\\d{8}",,,,,,,[9],[7]],[,,"2072[29]\\d{4}|20(?:2\\d|4[47]|5[3467]|6[279]|7[35]|8[268]|9[245])\\d{5}",,,,"202123456",,,,[7]],[,,"3[2-49]\\d{7}",,,,"321234567"],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,
,[-1]],[,,"22\\d{7}",,,,"221234567"],"MG",261,"00","0",,,"0|([24-9]\\d{6})$","20$1",,,[[,"(\\d{2})(\\d{2})(\\d{3})(\\d{2})","$1 $2 $3 $4",["[23]"],"0$1"]],,[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],MH:[,[,,"329\\d{4}|(?:[256]\\d|45)\\d{5}",,,,,,,[7]],[,,"(?:247|528|625)\\d{4}",,,,"2471234"],[,,"(?:(?:23|54)5|329|45[56])\\d{4}",,,,"2351234"],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,"635\\d{4}",,,,"6351234"],"MH",692,"011","1",,,"1",,,,[[,"(\\d{3})(\\d{4})",
"$1-$2",["[2-6]"]]],,[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],MK:[,[,,"[2-578]\\d{7}",,,,,,,[8],[6,7]],[,,"(?:2(?:[23]\\d|5[0-24578]|6[01]|82)|3(?:1[3-68]|[23][2-68]|4[23568])|4(?:[23][2-68]|4[3-68]|5[2568]|6[25-8]|7[24-68]|8[4-68]))\\d{5}",,,,"22012345",,,,[6,7]],[,,"7(?:4(?:60\\d|747)|94(?:[01]\\d|2[0-4]))\\d{3}|7(?:[0-25-8]\\d|3[2-4]|42|9[23])\\d{5}",,,,"72345678"],[,,"800\\d{5}",,,,"80012345"],[,,"5[02-9]\\d{6}",,,,"50012345"],[,,"8(?:0[1-9]|[1-9]\\d)\\d{5}",,,,"80123456"],
[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],"MK",389,"00","0",,,"0",,,,[[,"(\\d)(\\d{3})(\\d{4})","$1 $2 $3",["2"],"0$1"],[,"(\\d{2})(\\d{3})(\\d{3})","$1 $2 $3",["[347]"],"0$1"],[,"(\\d{3})(\\d)(\\d{2})(\\d{2})","$1 $2 $3 $4",["[58]"],"0$1"]],,[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],ML:[,[,,"[24-9]\\d{7}",,,,,,,[8]],[,,"2(?:07[0-8]|12[67])\\d{4}|(?:2(?:02|1[4-689])|4(?:0[0-4]|4[1-39]))\\d{5}",,,,"20212345"],[,,"2(?:0(?:01|79)|17\\d)\\d{4}|(?:5[01]|[679]\\d|8[239])\\d{6}",,,,"65012345"],
[,,"80\\d{6}",,,,"80012345"],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],"ML",223,"00",,,,,,,,[[,"(\\d{4})","$1",["67[057-9]|74[045]","67(?:0[09]|[59]9|77|8[89])|74(?:0[02]|44|55)"]],[,"(\\d{2})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[24-9]"]]],[[,"(\\d{2})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[24-9]"]]],[,,,,,,,,,[-1]],,,[,,"80\\d{6}"],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],MM:[,[,,"1\\d{5,7}|95\\d{6}|(?:[4-7]|9[0-46-9])\\d{6,8}|(?:2|8\\d)\\d{5,8}",,,,,,,[6,7,8,9,10],[5]],[,
,"(?:1(?:(?:2\\d|3[56]|[89][0-6])\\d|4(?:2[2-469]|39|46|6[25]|7[0-3]|83)|6)|2(?:2(?:00|8[34])|4(?:0\\d|2[246]|39|46|62|7[0-3]|83)|51\\d\\d)|4(?:2(?:2\\d\\d|48[0-3])|3(?:20\\d|4(?:70|83)|56)|420\\d|5470)|6(?:0(?:[23]|88\\d)|(?:124|[56]2\\d)\\d|247[23]|3(?:20\\d|470)|4(?:2[04]\\d|47[23])|7(?:(?:3\\d|8[01459])\\d|4(?:39|60|7[013]))))\\d{4}|5(?:2(?:2\\d{5,6}|47[023]\\d{4})|(?:347[23]|4(?:2(?:1|86)|470)|522\\d|6(?:20\\d|483)|7(?:20\\d|48[0-2])|8(?:20\\d|47[02])|9(?:20\\d|47[01]))\\d{4})|7(?:(?:0470|4(?:25\\d|470)|5(?:202|470|96\\d))\\d{4}|1(?:20\\d{4,5}|4(?:70|83)\\d{4}))|8(?:1(?:2\\d{5,6}|4(?:10|7[01]\\d)\\d{3})|2(?:2\\d{5,6}|(?:320|490\\d)\\d{3})|(?:3(?:2\\d\\d|470)|4[24-7]|5(?:2\\d|4[1-9]|51)\\d|6[23])\\d{4})|(?:1[2-6]\\d|4(?:2[24-8]|3[2-7]|[46][2-6]|5[3-5])|5(?:[27][2-8]|3[2-68]|4[24-8]|5[23]|6[2-4]|8[24-7]|9[2-7])|6(?:[19]20|42[03-6]|(?:52|7[45])\\d)|7(?:[04][24-8]|[15][2-7]|22|3[2-4])|8(?:1[2-689]|2[2-8]|[35]2\\d))\\d{4}|25\\d{5,6}|(?:2[2-9]|6(?:1[2356]|[24][2-6]|3[24-6]|5[2-4]|6[2-8]|7[235-7]|8[245]|9[24])|8(?:3[24]|5[245]))\\d{4}",
,,,"1234567",,,[6,7,8,9],[5]],[,,"(?:17[01]|9(?:2(?:[0-4]|[56]\\d\\d)|(?:3(?:[0-36]|4\\d)|(?:6[6-9]|8[89]|9[5-8])\\d|7(?:3|[5-9]\\d))\\d|4(?:(?:[0245]\\d|[1379])\\d|88)|5[0-6])\\d)\\d{4}|9[69]1\\d{6}|9(?:[68]\\d|9[089])\\d{5}",,,,"92123456",,,[7,8,9,10]],[,,"80080(?:[01][1-9]|2\\d)\\d{3}",,,,"8008001234",,,[10]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,"1333\\d{4}|[12]468\\d{4}",,,,"13331234",,,[8]],"MM",95,"00","0",,,"0",,,,[[,"(\\d)(\\d{2})(\\d{3})","$1 $2 $3",["16|2"],"0$1"],[,"(\\d{2})(\\d{2})(\\d{3})",
"$1 $2 $3",["[45]|6(?:0[23]|[1-689]|7[235-7])|7(?:[0-4]|5[2-7])|8[1-6]"],"0$1"],[,"(\\d)(\\d{3})(\\d{3,4})","$1 $2 $3",["[12]"],"0$1"],[,"(\\d{2})(\\d{3})(\\d{3,4})","$1 $2 $3",["[4-7]|8[1-35]"],"0$1"],[,"(\\d)(\\d{3})(\\d{4,6})","$1 $2 $3",["9(?:2[0-4]|[35-9]|4[137-9])"],"0$1"],[,"(\\d)(\\d{4})(\\d{4})","$1 $2 $3",["2"],"0$1"],[,"(\\d{3})(\\d{3})(\\d{4})","$1 $2 $3",["8"],"0$1"],[,"(\\d)(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3 $4",["92"],"0$1"],[,"(\\d)(\\d{5})(\\d{4})","$1 $2 $3",["9"],"0$1"]],,[,,,
,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],MN:[,[,,"[12]\\d{7,9}|[57-9]\\d{7}",,,,,,,[8,9,10],[4,5,6]],[,,"[12]2[1-3]\\d{5,6}|7(?:0[0-5]\\d|128)\\d{4}|(?:[12](?:1|27)|5[368])\\d{6}|[12](?:3[2-8]|4[2-68]|5[1-4689])\\d{6,7}",,,,"53123456",,,,[4,5,6]],[,,"(?:83[01]|920)\\d{5}|(?:5[05]|8[05689]|9[013-9])\\d{6}",,,,"88123456",,,[8]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,"712[0-79]\\d{4}|7(?:1[013-9]|[5-8]\\d)\\d{5}",,,,"75123456",,,[8]],"MN",976,"001",
"0",,,"0",,,,[[,"(\\d{2})(\\d{2})(\\d{4})","$1 $2 $3",["[12]1"],"0$1"],[,"(\\d{4})(\\d{4})","$1 $2",["[57-9]"]],[,"(\\d{3})(\\d{5,6})","$1 $2",["[12]2[1-3]"],"0$1"],[,"(\\d{4})(\\d{5,6})","$1 $2",["[12](?:27|3[2-8]|4[2-68]|5[1-4689])","[12](?:27|3[2-8]|4[2-68]|5[1-4689])[0-3]"],"0$1"],[,"(\\d{5})(\\d{4,5})","$1 $2",["[12]"],"0$1"]],,[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],MO:[,[,,"(?:28|[68]\\d)\\d{6}",,,,,,,[8]],[,,"(?:28[2-9]|8(?:11|[2-57-9]\\d))\\d{5}",,,,"28212345"],
[,,"6(?:[235]\\d\\d|6(?:0[0-5]|[1-9]\\d)|8(?:[02][5-9]|[146-8]\\d|[35][0-4]))\\d{4}",,,,"66123456"],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],"MO",853,"00",,,,,,,,[[,"(\\d{4})(\\d{4})","$1 $2",["[268]"]]],,[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],MP:[,[,,"[58]\\d{9}|(?:67|90)0\\d{7}",,,,,,,[10],[7]],[,,"670(?:2(?:3[3-7]|56|8[4-8])|32[1-38]|4(?:33|8[348])|5(?:32|55|88)|6(?:64|70|82)|78[3589]|8[3-9]8|989)\\d{4}",,,,"6702345678",,,,[7]],
[,,"670(?:2(?:3[3-7]|56|8[4-8])|32[1-38]|4(?:33|8[348])|5(?:32|55|88)|6(?:64|70|82)|78[3589]|8[3-9]8|989)\\d{4}",,,,"6702345678",,,,[7]],[,,"8(?:00|33|44|55|66|77|88)[2-9]\\d{6}",,,,"8002123456"],[,,"900[2-9]\\d{6}",,,,"9002123456"],[,,,,,,,,,[-1]],[,,"52(?:35(?:[02-46-9]\\d|1[02-9]|5[0-46-9])|45(?:[034]\\d|1[02-9]|2[024-9]|5[0-46-9]))\\d{4}|52(?:3[2-46-9]|4[2-4])(?:[02-9]\\d|1[02-9])\\d{4}|5(?:00|2[12]|33|44|66|77|88)[2-9]\\d{6}",,,,"5002345678"],[,,,,,,,,,[-1]],"MP",1,"011","1",,,"1|([2-9]\\d{6})$",
"670$1",,1,,,[,,,,,,,,,[-1]],,"670",[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],MQ:[,[,,"69\\d{7}|(?:59|97)6\\d{6}",,,,,,,[9]],[,,"596(?:0[0-7]|10|2[7-9]|3[05-9]|4[0-46-8]|[5-7]\\d|8[09]|9[4-8])\\d{4}",,,,"596301234"],[,,"69(?:6(?:[0-47-9]\\d|5[0-6]|6[0-4])|727)\\d{4}",,,,"696201234"],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,"976(?:6[1-9]|7[0-367])\\d{4}",,,,"976612345"],"MQ",596,"00","0",,,"0",,,,[[,"(\\d{3})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[569]"],"0$1"]],
,[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],MR:[,[,,"(?:[2-4]\\d\\d|800)\\d{5}",,,,,,,[8]],[,,"(?:25[08]|35\\d|45[1-7])\\d{5}",,,,"35123456"],[,,"[2-4][0-46-9]\\d{6}",,,,"22123456"],[,,"800\\d{5}",,,,"80012345"],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],"MR",222,"00",,,,,,,,[[,"(\\d{2})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[2-48]"]]],,[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],MS:[,[,,"(?:[58]\\d\\d|664|900)\\d{7}",,,,,
,,[10],[7]],[,,"6644(?:1[0-3]|91)\\d{4}",,,,"6644912345",,,,[7]],[,,"664(?:3(?:49|9[1-6])|49[2-6])\\d{4}",,,,"6644923456",,,,[7]],[,,"8(?:00|33|44|55|66|77|88)[2-9]\\d{6}",,,,"8002123456"],[,,"900[2-9]\\d{6}",,,,"9002123456"],[,,,,,,,,,[-1]],[,,"52(?:35(?:[02-46-9]\\d|1[02-9]|5[0-46-9])|45(?:[034]\\d|1[02-9]|2[024-9]|5[0-46-9]))\\d{4}|52(?:3[2-46-9]|4[2-4])(?:[02-9]\\d|1[02-9])\\d{4}|5(?:00|2[12]|33|44|66|77|88)[2-9]\\d{6}",,,,"5002345678"],[,,,,,,,,,[-1]],"MS",1,"011","1",,,"1|([34]\\d{6})$","664$1",
,,,,[,,,,,,,,,[-1]],,"664",[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],MT:[,[,,"3550\\d{4}|(?:[2579]\\d\\d|800)\\d{5}",,,,,,,[8]],[,,"2(?:0(?:[19]\\d|3[1-4]|6[059])|[1-357]\\d\\d)\\d{4}",,,,"21001234"],[,,"(?:7(?:210|[79]\\d\\d)|9(?:[29]\\d\\d|69[67]|8(?:1[1-3]|89|97)))\\d{4}",,,,"96961234"],[,,"800[3467]\\d{4}",,,,"80071234"],[,,"5(?:0(?:0(?:37|43)|(?:6\\d|70|9[0168])\\d)|[12]\\d0[1-5])\\d{3}",,,,"50037123"],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,"3550\\d{4}",,,,"35501234"],"MT",356,"00",,,,,
,,,[[,"(\\d{4})(\\d{4})","$1 $2",["[2357-9]"]]],,[,,"7117\\d{4}",,,,"71171234"],,,[,,,,,,,,,[-1]],[,,"501\\d{5}",,,,"50112345"],,,[,,,,,,,,,[-1]]],MU:[,[,,"(?:[2-468]|5\\d)\\d{6}",,,,,,,[7,8]],[,,"(?:2(?:[0346-8]\\d|1[0-7])|4(?:[013568]\\d|2[4-7])|54(?:[34]\\d|71)|6\\d\\d|8(?:14|3[129]))\\d{4}",,,,"54480123"],[,,"5(?:4(?:2[1-389]|7[1-9])|87[15-8])\\d{4}|5(?:2[589]|4[3489]|7\\d|8[0-689]|9[0-8])\\d{5}",,,,"52512345",,,[8]],[,,"80[0-2]\\d{4}",,,,"8001234",,,[7]],[,,"30\\d{5}",,,,"3012345",,,[7]],[,,
,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,"3(?:20|9\\d)\\d{4}",,,,"3201234",,,[7]],"MU",230,"0(?:0|[24-7]0|3[03])",,,,,,"020",,[[,"(\\d{3})(\\d{4})","$1 $2",["[2-46]|8[013]"]],[,"(\\d{4})(\\d{4})","$1 $2",["5"]]],,[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],MV:[,[,,"(?:800|9[0-57-9]\\d)\\d{7}|[34679]\\d{6}",,,,,,,[7,10]],[,,"(?:3(?:0[0-3]|3[0-59])|6(?:[57][02468]|6[024-68]|8[024689]))\\d{4}",,,,"6701234",,,[7]],[,,"46[46]\\d{4}|(?:7\\d|9[13-9])\\d{5}",,,,"7712345",,,[7]],[,,"800\\d{7}",
,,,"8001234567",,,[10]],[,,"900\\d{7}",,,,"9001234567",,,[10]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],"MV",960,"0(?:0|19)",,,,,,"00",,[[,"(\\d{3})(\\d{4})","$1-$2",["[3467]|9[13-9]"]],[,"(\\d{3})(\\d{3})(\\d{4})","$1 $2 $3",["[89]"]]],,[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,"4[05]0\\d{4}",,,,"4001234",,,[7]],,,[,,,,,,,,,[-1]]],MW:[,[,,"1\\d{6}(?:\\d{2})?|(?:[23]1|77|88|99)\\d{7}",,,,,,,[7,9]],[,,"(?:1[2-9]|21\\d\\d)\\d{5}",,,,"1234567"],[,,"111\\d{6}|(?:31|77|88|99)\\d{7}",,,,"991234567",,
,[9]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],"MW",265,"00","0",,,"0",,,,[[,"(\\d)(\\d{3})(\\d{3})","$1 $2 $3",["1[2-9]"],"0$1"],[,"(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["2"],"0$1"],[,"(\\d{3})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[137-9]"],"0$1"]],,[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],MX:[,[,,"(?:1(?:[01467]\\d|[2359][1-9]|8[1-79])|[2-9]\\d)\\d{8}",,,,,,,[10,11],[7,8]],[,,"(?:2(?:0[01]|2[1-9]|3[1-35-8]|4[13-9]|7[1-689]|8[1-578]|9[467])|3(?:1[1-79]|[2458][1-9]|3\\d|7[1-8]|9[1-5])|4(?:1[1-57-9]|[24-7][1-9]|3[1-8]|8[1-35-9]|9[2-689])|5(?:[56]\\d|88|9[1-79])|6(?:1[2-68]|[2-4][1-9]|5[1-3689]|6[1-57-9]|7[1-7]|8[67]|9[4-8])|7(?:[1-467][1-9]|5[13-9]|8[1-69]|9[17])|8(?:1\\d|2[13-689]|3[1-6]|4[124-6]|6[1246-9]|7[1-378]|9[12479])|9(?:1[346-9]|2[1-4]|3[2-46-8]|5[1348]|[69][1-9]|7[12]|8[1-8]))\\d{7}",
,,,"2001234567",,,[10],[7,8]],[,,"(?:1(?:2(?:2[1-9]|3[1-35-8]|4[13-9]|7[1-689]|8[1-578]|9[467])|3(?:1[1-79]|[2458][1-9]|3\\d|7[1-8]|9[1-5])|4(?:1[1-57-9]|[24-7][1-9]|3[1-8]|8[1-35-9]|9[2-689])|5(?:[56]\\d|88|9[1-79])|6(?:1[2-68]|[2-4][1-9]|5[1-3689]|6[1-57-9]|7[1-7]|8[67]|9[4-8])|7(?:[1-467][1-9]|5[13-9]|8[1-69]|9[17])|8(?:1\\d|2[13-689]|3[1-6]|4[124-6]|6[1246-9]|7[1-378]|9[12479])|9(?:1[346-9]|2[1-4]|3[2-46-8]|5[1348]|[69][1-9]|7[12]|8[1-8]))|2(?:2[1-9]|3[1-35-8]|4[13-9]|7[1-689]|8[1-578]|9[467])|3(?:1[1-79]|[2458][1-9]|3\\d|7[1-8]|9[1-5])|4(?:1[1-57-9]|[24-7][1-9]|3[1-8]|8[1-35-9]|9[2-689])|5(?:[56]\\d|88|9[1-79])|6(?:1[2-68]|[2-4][1-9]|5[1-3689]|6[1-57-9]|7[1-7]|8[67]|9[4-8])|7(?:[1-467][1-9]|5[13-9]|8[1-69]|9[17])|8(?:1\\d|2[13-689]|3[1-6]|4[124-6]|6[1246-9]|7[1-378]|9[12479])|9(?:1[346-9]|2[1-4]|3[2-46-8]|5[1348]|[69][1-9]|7[12]|8[1-8]))\\d{7}",
,,,"12221234567",,,,[7,8]],[,,"8(?:00|88)\\d{7}",,,,"8001234567",,,[10]],[,,"900\\d{7}",,,,"9001234567",,,[10]],[,,"300\\d{7}",,,,"3001234567",,,[10]],[,,"500\\d{7}",,,,"5001234567",,,[10]],[,,,,,,,,,[-1]],"MX",52,"0[09]","01",,,"0(?:[12]|4[45])|1",,"00",,[[,"(\\d{5})","$1",["53"]],[,"(\\d{2})(\\d{4})(\\d{4})","$1 $2 $3",["33|5[56]|81"],,,1],[,"(\\d{3})(\\d{3})(\\d{4})","$1 $2 $3",["[2-9]"],,,1],[,"(\\d)(\\d{2})(\\d{4})(\\d{4})","$2 $3 $4",["1(?:33|5[56]|81)"],,,1],[,"(\\d)(\\d{3})(\\d{3})(\\d{4})",
"$2 $3 $4",["1"],,,1]],[[,"(\\d{2})(\\d{4})(\\d{4})","$1 $2 $3",["33|5[56]|81"],,,1],[,"(\\d{3})(\\d{3})(\\d{4})","$1 $2 $3",["[2-9]"],,,1],[,"(\\d)(\\d{2})(\\d{4})(\\d{4})","$2 $3 $4",["1(?:33|5[56]|81)"],,,1],[,"(\\d)(\\d{3})(\\d{3})(\\d{4})","$2 $3 $4",["1"],,,1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],MY:[,[,,"1\\d{8,9}|(?:3\\d|[4-9])\\d{7}",,,,,,,[8,9,10],[6,7]],[,,"(?:3(?:2[0-36-9]|3[0-368]|4[0-278]|5[0-24-8]|6[0-467]|7[1246-9]|8\\d|9[0-57])\\d|4(?:2[0-689]|[3-79]\\d|8[1-35689])|5(?:2[0-589]|[3468]\\d|5[0-489]|7[1-9]|9[23])|6(?:2[2-9]|3[1357-9]|[46]\\d|5[0-6]|7[0-35-9]|85|9[015-8])|7(?:[2579]\\d|3[03-68]|4[0-8]|6[5-9]|8[0-35-9])|8(?:[24][2-8]|3[2-5]|5[2-7]|6[2-589]|7[2-578]|[89][2-9])|9(?:0[57]|13|[25-7]\\d|[3489][0-8]))\\d{5}",
,,,"323856789",,,[8,9],[6,7]],[,,"1(?:4400|8(?:47|8[27])[0-4])\\d{4}|1(?:0(?:[23568]\\d|4[0-6]|7[016-9]|9[0-8])|1(?:[1-5]\\d\\d|6(?:0[5-9]|[1-9]\\d)|7(?:0\\d|1[01]))|(?:(?:[269]|59)\\d|[37][1-9]|4[235-9])\\d|8(?:1[23]|[236]\\d|4[06]|5[7-9]|7[016-9]|8[01]|9[0-8]))\\d{5}",,,,"123456789",,,[9,10]],[,,"1[378]00\\d{6}",,,,"1300123456",,,[10]],[,,"1600\\d{6}",,,,"1600123456",,,[10]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,"15(?:4(?:6[0-4]\\d|8(?:0[125]|[17]\\d|21|3[01]|4[01589]|5[014]|6[02]))|6(?:32[0-6]|78\\d))\\d{4}",
,,,"1546012345",,,[10]],"MY",60,"00","0",,,"0",,,,[[,"(\\d)(\\d{3})(\\d{4})","$1-$2 $3",["[4-79]"],"0$1"],[,"(\\d{2})(\\d{3})(\\d{3,4})","$1-$2 $3",["1(?:[02469]|[378][1-9])|8"],"0$1"],[,"(\\d)(\\d{4})(\\d{4})","$1-$2 $3",["3"],"0$1"],[,"(\\d)(\\d{3})(\\d{2})(\\d{4})","$1-$2-$3-$4",["1[36-8]"]],[,"(\\d{3})(\\d{3})(\\d{4})","$1-$2 $3",["15"],"0$1"],[,"(\\d{2})(\\d{4})(\\d{4})","$1-$2 $3",["1"],"0$1"]],,[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],MZ:[,[,,"(?:2|8\\d)\\d{7}",
,,,,,,[8,9]],[,,"2(?:[1346]\\d|5[0-2]|[78][12]|93)\\d{5}",,,,"21123456",,,[8]],[,,"8[2-79]\\d{7}",,,,"821234567",,,[9]],[,,"800\\d{6}",,,,"800123456",,,[9]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],"MZ",258,"00",,,,,,,,[[,"(\\d{2})(\\d{3})(\\d{3,4})","$1 $2 $3",["2|8[2-79]"]],[,"(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["8"]]],,[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],NA:[,[,,"[68]\\d{7,8}",,,,,,,[8,9]],[,,"6(?:1(?:[02-4]\\d\\d|17)|2(?:17|54\\d|69|70)|3(?:17|2[0237]\\d|34|6[289]|7[01]|81)|4(?:17|(?:27|41|5[25])\\d|69|7[01])|5(?:17|2[236-8]\\d|69|7[01])|6(?:17|26\\d|38|42|69|7[01])|7(?:17|(?:2[2-4]|30)\\d|6[89]|7[01]))\\d{4}|6(?:1(?:2[2-7]|3[01378]|4[0-4]|69|7[014])|25[0-46-8]|32\\d|4(?:2[0-27]|4[016]|5[0-357])|52[02-9]|62[56]|7(?:2[2-69]|3[013]))\\d{4}",
,,,"61221234"],[,,"(?:60|8[1245])\\d{7}",,,,"811234567",,,[9]],[,,"80\\d{7}",,,,"800123456",,,[9]],[,,"8701\\d{5}",,,,"870123456",,,[9]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,"8(?:3\\d\\d|86)\\d{5}",,,,"88612345"],"NA",264,"00","0",,,"0",,,,[[,"(\\d{2})(\\d{3})(\\d{3})","$1 $2 $3",["88"],"0$1"],[,"(\\d{2})(\\d{3})(\\d{3,4})","$1 $2 $3",["6"],"0$1"],[,"(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["87"],"0$1"],[,"(\\d{2})(\\d{3})(\\d{4})","$1 $2 $3",["8"],"0$1"]],,[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,,,,,,,,
[-1]],,,[,,,,,,,,,[-1]]],NC:[,[,,"[2-57-9]\\d{5}",,,,,,,[6]],[,,"(?:2[03-9]|3[0-5]|4[1-7]|88)\\d{4}",,,,"201234"],[,,"(?:5[0-4]|[79]\\d|8[0-79])\\d{4}",,,,"751234"],[,,,,,,,,,[-1]],[,,"36\\d{4}",,,,"366711"],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],"NC",687,"00",,,,,,,,[[,"(\\d{3})","$1",["5[6-8]"]],[,"(\\d{2})(\\d{2})(\\d{2})","$1.$2.$3",["[2-57-9]"]]],[[,"(\\d{2})(\\d{2})(\\d{2})","$1.$2.$3",["[2-57-9]"]]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],NE:[,[,,"[0289]\\d{7}",
,,,,,,[8]],[,,"2(?:0(?:20|3[1-8]|4[13-5]|5[14]|6[14578]|7[1-578])|1(?:4[145]|5[14]|6[14-68]|7[169]|88))\\d{4}",,,,"20201234"],[,,"(?:23|8[014589]|9\\d)\\d{6}",,,,"93123456"],[,,"08\\d{6}",,,,"08123456"],[,,"09\\d{6}",,,,"09123456"],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],"NE",227,"00",,,,,,,,[[,"(\\d{2})(\\d{3})(\\d{3})","$1 $2 $3",["08"]],[,"(\\d{2})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[089]|2[013]"]]],,[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],NF:[,[,,"[13]\\d{5}",
,,,,,,[6],[5]],[,,"(?:1(?:06|17|28|39)|3[0-2]\\d)\\d{3}",,,,"106609",,,,[5]],[,,"(?:14|3[58])\\d{4}",,,,"381234",,,,[5]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],"NF",672,"00",,,,"([0-258]\\d{4})$","3$1",,,[[,"(\\d{2})(\\d{4})","$1 $2",["1[0-3]"]],[,"(\\d)(\\d{5})","$1 $2",["[13]"]]],,[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],NG:[,[,,"(?:[124-7]|9\\d{3})\\d{6}|[1-9]\\d{7}|[78]\\d{9,13}",,,,,,,[7,8,10,11,12,13,14],[5,6]],[,,"(?:(?:[1-356]\\d|4[02-8]|8[2-9])\\d|9(?:0[3-9]|[1-9]\\d))\\d{5}|7(?:0(?:[013-689]\\d|2[0-24-9])\\d{3,4}|[1-79]\\d{6})|(?:[12]\\d|4[147]|5[14579]|6[1578]|7[1-3578])\\d{5}",
,,,"18040123",,,[7,8],[5,6]],[,,"(?:702[0-24-9]|8(?:01|19)[01])\\d{6}|(?:70[13-689]|8(?:0[2-9]|1[0-8])|90[1-9])\\d{7}",,,,"8021234567",,,[10]],[,,"800\\d{7,11}",,,,"80017591759",,,[10,11,12,13,14]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],"NG",234,"009","0",,,"0",,,,[[,"(\\d{2})(\\d{2})(\\d{3})","$1 $2 $3",["78"],"0$1"],[,"(\\d)(\\d{3})(\\d{3,4})","$1 $2 $3",["[12]|9(?:0[3-9]|[1-9])"],"0$1"],[,"(\\d{2})(\\d{3})(\\d{2,3})","$1 $2 $3",["[3-7]|8[2-9]"],"0$1"],[,"(\\d{3})(\\d{3})(\\d{3,4})",
"$1 $2 $3",["[7-9]"],"0$1"],[,"(\\d{3})(\\d{4})(\\d{4,5})","$1 $2 $3",["[78]"],"0$1"],[,"(\\d{3})(\\d{5})(\\d{5,6})","$1 $2 $3",["[78]"],"0$1"]],,[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,"700\\d{7,11}",,,,"7001234567",,,[10,11,12,13,14]],,,[,,,,,,,,,[-1]]],NI:[,[,,"(?:1800|[25-8]\\d{3})\\d{4}",,,,,,,[8]],[,,"2\\d{7}",,,,"21234567"],[,,"(?:5(?:5[0-7]|[78]\\d)|6(?:20|3[035]|4[045]|5[05]|77|8[1-9]|9[059])|(?:7[5-8]|8\\d)\\d)\\d{5}",,,,"81234567"],[,,"1800\\d{4}",,,,"18001234"],[,,,,,,,,,[-1]],[,,,,,,,,,
[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],"NI",505,"00",,,,,,,,[[,"(\\d{4})(\\d{4})","$1 $2",["[125-8]"]]],,[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],NL:[,[,,"(?:[124-7]\\d\\d|3(?:[02-9]\\d|1[0-8]))\\d{6}|[89]\\d{6,9}|1\\d{4,5}",,,,,,,[5,6,7,8,9,10]],[,,"(?:1(?:[035]\\d|1[13-578]|6[124-8]|7[24]|8[0-467])|2(?:[0346]\\d|2[2-46-9]|5[125]|9[479])|3(?:[03568]\\d|1[3-8]|2[01]|4[1-8])|4(?:[0356]\\d|1[1-368]|7[58]|8[15-8]|9[23579])|5(?:[0358]\\d|[19][1-9]|2[1-57-9]|4[13-8]|6[126]|7[0-3578])|7\\d\\d)\\d{6}",
,,,"101234567",,,[9]],[,,"6[1-58]\\d{7}",,,,"612345678",,,[9]],[,,"800\\d{4,7}",,,,"8001234",,,[7,8,9,10]],[,,"90[069]\\d{4,7}",,,,"9061234",,,[7,8,9,10]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,"(?:85|91)\\d{7}",,,,"851234567",,,[9]],"NL",31,"00","0",,,"0",,,,[[,"(\\d{4})","$1",["1[238]|[34]"]],[,"(\\d{2})(\\d{3,4})","$1 $2",["14"]],[,"(\\d{6})","$1",["1"]],[,"(\\d{3})(\\d{4,7})","$1 $2",["[89]0"],"0$1"],[,"(\\d{2})(\\d{7})","$1 $2",["66"],"0$1"],[,"(\\d)(\\d{8})","$1 $2",["6"],"0$1"],[,"(\\d{3})(\\d{3})(\\d{3})",
"$1 $2 $3",["1[16-8]|2[259]|3[124]|4[17-9]|5[124679]"],"0$1"],[,"(\\d{2})(\\d{3})(\\d{4})","$1 $2 $3",["[1-57-9]"],"0$1"]],[[,"(\\d{3})(\\d{4,7})","$1 $2",["[89]0"],"0$1"],[,"(\\d{2})(\\d{7})","$1 $2",["66"],"0$1"],[,"(\\d)(\\d{8})","$1 $2",["6"],"0$1"],[,"(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["1[16-8]|2[259]|3[124]|4[17-9]|5[124679]"],"0$1"],[,"(\\d{2})(\\d{3})(\\d{4})","$1 $2 $3",["[1-57-9]"],"0$1"]],[,,"66\\d{7}",,,,"662345678",,,[9]],,,[,,"140(?:1[035]|2[0346]|3[03568]|4[0356]|5[0358]|8[458])|140(?:1[16-8]|2[259]|3[124]|4[17-9]|5[124679]|7)\\d",
,,,,,,[5,6]],[,,"140(?:1[035]|2[0346]|3[03568]|4[0356]|5[0358]|8[458])|(?:140(?:1[16-8]|2[259]|3[124]|4[17-9]|5[124679]|7)|8[478]\\d{6})\\d",,,,"14020",,,[5,6,9]],,,[,,,,,,,,,[-1]]],NO:[,[,,"(?:0|[2-9]\\d{3})\\d{4}",,,,,,,[5,8]],[,,"(?:2[1-4]|3[1-3578]|5[1-35-7]|6[1-4679]|7[0-8])\\d{6}",,,,"21234567",,,[8]],[,,"(?:4[015-8]|5[89]|9\\d)\\d{6}",,,,"40612345",,,[8]],[,,"80[01]\\d{5}",,,,"80012345",,,[8]],[,,"82[09]\\d{5}",,,,"82012345",,,[8]],[,,"810(?:0[0-6]|[2-8]\\d)\\d{3}",,,,"81021234",,,[8]],[,,
"880\\d{5}",,,,"88012345",,,[8]],[,,"85[0-5]\\d{5}",,,,"85012345",,,[8]],"NO",47,"00",,,,,,,,[[,"(\\d{3})(\\d{2})(\\d{3})","$1 $2 $3",["[489]|5[89]"]],[,"(\\d{2})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[235-7]"]]],,[,,,,,,,,,[-1]],1,"[02-689]|7[0-8]",[,,,,,,,,,[-1]],[,,"(?:0[2-9]|81(?:0(?:0[7-9]|1\\d)|5\\d\\d))\\d{3}",,,,"02000"],,,[,,"81[23]\\d{5}",,,,"81212345",,,[8]]],NP:[,[,,"9\\d{9}|[1-9]\\d{7}",,,,,,,[8,10],[6,7]],[,,"(?:1[0-6]\\d|99[02-6])\\d{5}|(?:2[13-79]|3[135-8]|4[146-9]|5[135-7]|6[13-9]|7[15-9]|8[1-46-9]|9[1-7])[2-6]\\d{5}",
,,,"14567890",,,[8],[6,7]],[,,"9(?:6[0-3]|7[245]|8[0-24-68])\\d{7}",,,,"9841234567",,,[10]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],"NP",977,"00","0",,,"0",,,,[[,"(\\d)(\\d{7})","$1-$2",["1[2-6]"],"0$1"],[,"(\\d{2})(\\d{6})","$1-$2",["[1-8]|9(?:[1-579]|6[2-6])"],"0$1"],[,"(\\d{3})(\\d{7})","$1-$2",["9"]]],,[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],NR:[,[,,"(?:444|(?:55|8\\d)\\d|666)\\d{4}",,,,,,,[7]],[,,"444\\d{4}",,,,"4441234"],[,
,"(?:55[3-9]|666|8\\d\\d)\\d{4}",,,,"5551234"],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],"NR",674,"00",,,,,,,,[[,"(\\d{3})(\\d{4})","$1 $2",["[4-68]"]]],,[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],NU:[,[,,"(?:[47]|888\\d)\\d{3}",,,,,,,[4,7]],[,,"[47]\\d{3}",,,,"7012",,,[4]],[,,"888[4-9]\\d{3}",,,,"8884012",,,[7]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],"NU",683,"00",,,,,,,,[[,"(\\d{3})(\\d{4})",
"$1 $2",["8"]]],,[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],NZ:[,[,,"2\\d{7,9}|(?:[34]\\d|6[0-35-9])\\d{6}|(?:508|[79]\\d)\\d{6,7}|8\\d{4,9}",,,,,,,[5,6,7,8,9,10]],[,,"24099\\d{3}|(?:3[2-79]|[49][2-9]|6[235-9]|7[2-57-9])\\d{6}",,,,"32345678",,,[8],[7]],[,,"2[0-27-9]\\d{7,8}|21\\d{6}",,,,"211234567",,,[8,9,10]],[,,"508\\d{6,7}|80\\d{6,8}",,,,"800123456",,,[8,9,10]],[,,"90\\d{6,7}",,,,"900123456",,,[8,9]],[,,,,,,,,,[-1]],[,,"70\\d{7}",,,,"701234567",,,[9]],[,,,,,,,,,[-1]],
"NZ",64,"0(?:0|161)","0",,,"0",,"00",,[[,"(\\d{2})(\\d{3,8})","$1 $2",["83"],"0$1"],[,"(\\d{3})(\\d{2})(\\d{3})","$1 $2 $3",["[89]0"],"0$1"],[,"(\\d)(\\d{3})(\\d{4})","$1-$2 $3",["24|[346]|7[2-57-9]|9[2-9]"],"0$1"],[,"(\\d{3})(\\d{3})(\\d{3,4})","$1 $2 $3",["2(?:10|74)|[59]|80"],"0$1"],[,"(\\d{2})(\\d{3,4})(\\d{4})","$1 $2 $3",["2[028]"],"0$1"],[,"(\\d{2})(\\d{3})(\\d{3,5})","$1 $2 $3",["2(?:[169]|7[0-35-9])|7|86"],"0$1"]],,[,,"[28]6\\d{6,7}",,,,"26123456",,,[8,9]],,,[,,,,,,,,,[-1]],[,,"83\\d{3,8}",
,,,"83012378"],,,[,,,,,,,,,[-1]]],OM:[,[,,"(?:1505|[279]\\d{3}|500)\\d{4}|8007\\d{4,5}",,,,,,,[7,8,9]],[,,"2[2-6]\\d{6}",,,,"23123456",,,[8]],[,,"(?:1505|90[1-9]\\d)\\d{4}|(?:7[1289]|9[1-9])\\d{6}",,,,"92123456",,,[8]],[,,"500\\d{4}|8007\\d{4,5}",,,,"80071234"],[,,"900\\d{5}",,,,"90012345",,,[8]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],"OM",968,"00",,,,,,,,[[,"(\\d{3})(\\d{4,6})","$1 $2",["[58]"]],[,"(\\d{2})(\\d{6})","$1 $2",["2"]],[,"(\\d{4})(\\d{4})","$1 $2",["[179]"]]],,[,,,,,,,,,[-1]],
,,[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],PA:[,[,,"(?:[1-57-9]|6\\d)\\d{6}",,,,,,,[7,8]],[,,"(?:1(?:0\\d|1[479]|2[37]|3[0137]|4[17]|5[05]|6[58]|7[0167]|8[258]|9[139])|2(?:[0235-79]\\d|1[0-7]|4[013-9]|8[026-9])|3(?:[089]\\d|1[014-7]|2[0-5]|33|4[0-79]|55|6[068]|7[03-8])|4(?:00|3[0-579]|4\\d|7[0-57-9])|5(?:[01]\\d|2[0-7]|[56]0|79)|7(?:0[09]|2[0-26-8]|3[03]|4[04]|5[05-9]|6[056]|7[0-24-9]|8[6-9]|90)|8(?:09|2[89]|3\\d|4[0-24-689]|5[014]|8[02])|9(?:0[5-9]|1[0135-8]|2[036-9]|3[35-79]|40|5[0457-9]|6[05-9]|7[04-9]|8[35-8]|9\\d))\\d{4}",
,,,"2001234",,,[7]],[,,"(?:1[16]1|21[89]|6(?:[02-9]\\d|1[0-6])\\d|8(?:1[01]|7[23]))\\d{4}",,,,"61234567"],[,,"800\\d{4}",,,,"8001234",,,[7]],[,,"(?:8(?:22|55|60|7[78]|86)|9(?:00|81))\\d{4}",,,,"8601234",,,[7]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],"PA",507,"00",,,,,,,,[[,"(\\d{3})(\\d{4})","$1-$2",["[1-57-9]"]],[,"(\\d{4})(\\d{4})","$1-$2",["6"]]],,[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],PE:[,[,,"(?:[14-8]|9\\d)\\d{7}",,,,,,,[8,9],[6,7]],[,,"(?:(?:4[34]|5[14])[0-8]\\d|7(?:173|3[0-8]\\d)|8(?:10[05689]|6(?:0[06-9]|1[6-9]|29)|7(?:0[569]|[56]0)))\\d{4}|(?:1[0-8]|4[12]|5[236]|6[1-7]|7[246]|8[2-4])\\d{6}",
,,,"11234567",,,[8],[6,7]],[,,"9\\d{8}",,,,"912345678",,,[9]],[,,"800\\d{5}",,,,"80012345",,,[8]],[,,"805\\d{5}",,,,"80512345",,,[8]],[,,"801\\d{5}",,,,"80112345",,,[8]],[,,"80[24]\\d{5}",,,,"80212345",,,[8]],[,,,,,,,,,[-1]],"PE",51,"19(?:1[124]|77|90)00","0"," Anexo ",,"0",,,,[[,"(\\d{3})(\\d{5})","$1 $2",["80"],"(0$1)"],[,"(\\d)(\\d{7})","$1 $2",["1"],"(0$1)"],[,"(\\d{2})(\\d{6})","$1 $2",["[4-8]"],"(0$1)"],[,"(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["9"]]],,[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,,,
,,,,,[-1]],,,[,,,,,,,,,[-1]]],PF:[,[,,"[48]\\d{7}|4\\d{5}",,,,,,,[6,8]],[,,"4(?:0[4-689]|9[4-68])\\d{5}",,,,"40412345",,,[8]],[,,"8[7-9]\\d{6}",,,,"87123456",,,[8]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,"499\\d{5}",,,,"49901234",,,[8]],"PF",689,"00",,,,,,,,[[,"(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3",["44"]],[,"(\\d{2})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[48]"]]],,[,,,,,,,,,[-1]],,,[,,"44\\d{4}",,,,,,,[6]],[,,"44\\d{4}",,,,"440123",,,[6]],,,[,,,,,,,,,[-1]]],PG:[,[,,
"(?:180|[78]\\d{3})\\d{4}|(?:[2-589]\\d|64)\\d{5}",,,,,,,[7,8]],[,,"(?:64[1-9]|7730|85[02-46-9])\\d{4}|(?:3[0-2]|4[257]|5[34]|77[0-24]|9[78])\\d{5}",,,,"3123456"],[,,"77(?:3[1-9]|[5-9]\\d)\\d{4}|(?:7[0-689]|81)\\d{6}",,,,"70123456",,,[8]],[,,"180\\d{4}",,,,"1801234",,,[7]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,"2(?:0[0-47]|7[568])\\d{4}",,,,"2751234",,,[7]],"PG",675,"00|140[1-3]",,,,,,"00",,[[,"(\\d{3})(\\d{4})","$1 $2",["18|[2-69]|85"]],[,"(\\d{4})(\\d{4})","$1 $2",["[78]"]]],,[,,"27[01]\\d{4}",
,,,"2700123",,,[7]],,,[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],PH:[,[,,"1800\\d{7,9}|(?:2|[89]\\d{4})\\d{5}|[2-8]\\d{8}|[28]\\d{7}",,,,,,,[6,8,9,10,11,12,13],[4,5,7]],[,,"(?:(?:2[3-8]|3[2-68]|4[2-9]|5[2-6]|6[2-58]|7[24578])\\d{3}|88(?:22\\d\\d|42))\\d{4}|2\\d{5}(?:\\d{2})?|8[2-8]\\d{7}",,,,"21234567",,,[6,8,9,10],[4,5,7]],[,,"(?:81[37]|9(?:0[5-9]|1[0-24-9]|2[0-35-9]|[35]\\d|4[235-9]|6[0-25-8]|7[1-9]|8[189]|9[4-9]))\\d{7}",,,,"9051234567",,,[10]],[,,"1800\\d{7,9}",,,,"180012345678",,,[11,
12,13]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],"PH",63,"00","0",,,"0",,,,[[,"(\\d)(\\d{5})","$1 $2",["2"],"(0$1)"],[,"(\\d)(\\d{3})(\\d{4})","$1 $2 $3",["2"],"(0$1)"],[,"(\\d{4})(\\d{4,6})","$1 $2",["3(?:23|39|46)|4(?:2[3-6]|[35]9|4[26]|76)|544|88[245]|(?:52|64|86)2","3(?:230|397|461)|4(?:2(?:35|[46]4|51)|396|4(?:22|63)|59[347]|76[15])|5(?:221|446)|642[23]|8(?:622|8(?:[24]2|5[13]))"],"(0$1)"],[,"(\\d{5})(\\d{4})","$1 $2",["346|4(?:27|9[35])|883","3469|4(?:279|9(?:30|56))|8834"],
"(0$1)"],[,"(\\d)(\\d{4})(\\d{4})","$1 $2 $3",["2"],"(0$1)"],[,"(\\d{2})(\\d{3})(\\d{4})","$1 $2 $3",["[3-7]|8[2-8]"],"(0$1)"],[,"(\\d{3})(\\d{3})(\\d{4})","$1 $2 $3",["[89]"],"0$1"],[,"(\\d{4})(\\d{3})(\\d{4})","$1 $2 $3",["1"]],[,"(\\d{4})(\\d{1,2})(\\d{3})(\\d{4})","$1 $2 $3 $4",["1"]]],,[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],PK:[,[,,"122\\d{6}|[24-8]\\d{10,11}|9(?:[013-9]\\d{8,10}|2(?:[01]\\d\\d|2(?:[06-8]\\d|1[01]))\\d{7})|(?:[2-8]\\d{3}|92(?:[0-7]\\d|8[1-9]))\\d{6}|[24-9]\\d{8}|[89]\\d{7}",
,,,,,,[8,9,10,11,12],[5,6,7]],[,,"(?:(?:21|42)[2-9]|58[126])\\d{7}|(?:2[25]|4[0146-9]|5[1-35-7]|6[1-8]|7[14]|8[16]|91)[2-9]\\d{6,7}|(?:2(?:3[2358]|4[2-4]|9[2-8])|45[3479]|54[2-467]|60[468]|72[236]|8(?:2[2-689]|3[23578]|4[3478]|5[2356])|9(?:2[2-8]|3[27-9]|4[2-6]|6[3569]|9[25-8]))[2-9]\\d{5,6}",,,,"2123456789",,,[9,10],[5,6,7,8]],[,,"3(?:[014]\\d|2[0-5]|3[0-7]|55|64)\\d{7}",,,,"3012345678",,,[10]],[,,"800\\d{5}",,,,"80012345",,,[8]],[,,"900\\d{5}",,,,"90012345",,,[8]],[,,,,,,,,,[-1]],[,,"122\\d{6}",
,,,"122044444",,,[9]],[,,,,,,,,,[-1]],"PK",92,"00","0",,,"0",,,,[[,"(\\d{3})(\\d{3})(\\d{2})","$1 $2 $3",["[89]0"],"0$1"],[,"(\\d{4})(\\d{5})","$1 $2",["1"]],[,"(\\d{3})(\\d{6,7})","$1 $2",["2(?:3[2358]|4[2-4]|9[2-8])|45[3479]|54[2-467]|60[468]|72[236]|8(?:2[2-689]|3[23578]|4[3478]|5[2356])|9(?:2[2-8]|3[27-9]|4[2-6]|6[3569]|9[25-8])","9(?:2[3-8]|98)|(?:2(?:3[2358]|4[2-4]|9[2-8])|45[3479]|54[2-467]|60[468]|72[236]|8(?:2[2-689]|3[23578]|4[3478]|5[2356])|9(?:22|3[27-9]|4[2-6]|6[3569]|9[25-7]))[2-9]"],
"(0$1)"],[,"(\\d{2})(\\d{7,8})","$1 $2",["(?:2[125]|4[0-246-9]|5[1-35-7]|6[1-8]|7[14]|8[16]|91)[2-9]"],"(0$1)"],[,"(\\d{5})(\\d{5})","$1 $2",["58"],"(0$1)"],[,"(\\d{3})(\\d{7})","$1 $2",["3"],"0$1"],[,"(\\d{2})(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3 $4",["2[125]|4[0-246-9]|5[1-35-7]|6[1-8]|7[14]|8[16]|91"],"(0$1)"],[,"(\\d{3})(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3 $4",["[24-9]"],"(0$1)"]],,[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,"(?:2(?:[125]|3[2358]|4[2-4]|9[2-8])|4(?:[0-246-9]|5[3479])|5(?:[1-35-7]|4[2-467])|6(?:0[468]|[1-8])|7(?:[14]|2[236])|8(?:[16]|2[2-689]|3[23578]|4[3478]|5[2356])|9(?:1|22|3[27-9]|4[2-6]|6[3569]|9[2-7]))111\\d{6}",
,,,"21111825888",,,[11,12]],,,[,,,,,,,,,[-1]]],PL:[,[,,"[1-57-9]\\d{6}(?:\\d{2})?|6\\d{5,8}",,,,,,,[6,7,8,9]],[,,"(?:1[2-8]|2[2-69]|3[2-4]|4[1-468]|5[24-689]|6[1-3578]|7[14-7]|8[1-79]|9[145])(?:[02-9]\\d{6}|1(?:[0-8]\\d{5}|9\\d{3}(?:\\d{2})?))",,,,"123456789",,,[7,9]],[,,"(?:45|5[0137]|6[069]|7[2389]|88)\\d{7}",,,,"512345678",,,[9]],[,,"800\\d{6}",,,,"800123456",,,[9]],[,,"70[01346-8]\\d{6}",,,,"701234567",,,[9]],[,,"801\\d{6}",,,,"801234567",,,[9]],[,,,,,,,,,[-1]],[,,"39\\d{7}",,,,"391234567",,,
[9]],"PL",48,"00",,,,,,,,[[,"(\\d{5})","$1",["19"]],[,"(\\d{3})(\\d{3})","$1 $2",["11|64"]],[,"(\\d{2})(\\d{2})(\\d{3})","$1 $2 $3",["(?:1[2-8]|2[2-69]|3[2-4]|4[1-468]|5[24-689]|6[1-3578]|7[14-7]|8[1-79]|9[145])1","(?:1[2-8]|2[2-69]|3[2-4]|4[1-468]|5[24-689]|6[1-3578]|7[14-7]|8[1-79]|9[145])19"]],[,"(\\d{3})(\\d{2})(\\d{2,3})","$1 $2 $3",["64"]],[,"(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["39|45|5[0137]|6[0469]|7[02389]|8[08]"]],[,"(\\d{2})(\\d{3})(\\d{2})(\\d{2})","$1 $2 $3 $4",["1[2-8]|[2-8]|9[145]"]]],
,[,,"64\\d{4,7}",,,,"641234567"],,,[,,,,,,,,,[-1]],[,,"804\\d{6}",,,,"804123456",,,[9]],,,[,,,,,,,,,[-1]]],PM:[,[,,"[45]\\d{5}",,,,,,,[6]],[,,"(?:4[1-3]|50)\\d{4}",,,,"430123"],[,,"(?:4[02-4]|5[05])\\d{4}",,,,"551234"],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],"PM",508,"00","0",,,"0",,,,[[,"(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3",["[45]"],"0$1"]],,[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],PR:[,[,,"(?:[589]\\d\\d|787)\\d{7}",,,,,,,[10],
[7]],[,,"(?:787|939)[2-9]\\d{6}",,,,"7872345678",,,,[7]],[,,"(?:787|939)[2-9]\\d{6}",,,,"7872345678",,,,[7]],[,,"8(?:00|33|44|55|66|77|88)[2-9]\\d{6}",,,,"8002345678"],[,,"900[2-9]\\d{6}",,,,"9002345678"],[,,,,,,,,,[-1]],[,,"52(?:35(?:[02-46-9]\\d|1[02-9]|5[0-46-9])|45(?:[034]\\d|1[02-9]|2[024-9]|5[0-46-9]))\\d{4}|52(?:3[2-46-9]|4[2-4])(?:[02-9]\\d|1[02-9])\\d{4}|5(?:00|2[12]|33|44|66|77|88)[2-9]\\d{6}",,,,"5002345678"],[,,,,,,,,,[-1]],"PR",1,"011","1",,,"1",,,1,,,[,,,,,,,,,[-1]],,"787|939",[,,,,
,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],PS:[,[,,"[2489]2\\d{6}|(?:1\\d|5)\\d{8}",,,,,,,[8,9,10],[7]],[,,"(?:22[2-47-9]|42[45]|82[014-68]|92[3569])\\d{5}",,,,"22234567",,,[8],[7]],[,,"5[69]\\d{7}",,,,"599123456",,,[9]],[,,"1800\\d{6}",,,,"1800123456",,,[10]],[,,,,,,,,,[-1]],[,,"1700\\d{6}",,,,"1700123456",,,[10]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],"PS",970,"00","0",,,"0",,,,[[,"(\\d)(\\d{3})(\\d{4})","$1 $2 $3",["[2489]"],"0$1"],[,"(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["5"],"0$1"],[,"(\\d{4})(\\d{3})(\\d{3})",
"$1 $2 $3",["1"]]],,[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],PT:[,[,,"(?:[26-9]\\d|30)\\d{7}",,,,,,,[9]],[,,"2(?:[12]\\d|[35][1-689]|4[1-59]|6[1-35689]|7[1-9]|8[1-69]|9[1256])\\d{6}",,,,"212345678"],[,,"6[356]9230\\d{3}|(?:6[036]93|9(?:[1-36]\\d\\d|480))\\d{5}",,,,"912345678"],[,,"80[02]\\d{6}",,,,"800123456"],[,,"(?:6(?:0[178]|4[68])\\d|76(?:0[1-57]|1[2-47]|2[237]))\\d{5}",,,,"760123456"],[,,"80(?:8\\d|9[1579])\\d{5}",,,,"808123456"],[,,"884[0-4689]\\d{5}",,,,"884123456"],
[,,"30\\d{7}",,,,"301234567"],"PT",351,"00",,,,,,,,[[,"(\\d{2})(\\d{3})(\\d{4})","$1 $2 $3",["2[12]"]],[,"(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["[236-9]"]]],,[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,"70(?:7\\d|8[17])\\d{5}",,,,"707123456"],,,[,,"600\\d{6}",,,,"600110000"]],PW:[,[,,"(?:[24-8]\\d\\d|345|900)\\d{4}",,,,,,,[7]],[,,"(?:2(?:55|77)|345|488|5(?:35|44|87)|6(?:22|54|79)|7(?:33|47)|8(?:24|55|76)|900)\\d{4}",,,,"2771234"],[,,"(?:45[0-5]|6[2-4689]0|(?:77|88)\\d)\\d{4}",,,,"6201234"],[,,,,,,,,,[-1]],
[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],"PW",680,"01[12]",,,,,,,,[[,"(\\d{3})(\\d{4})","$1 $2",["[2-9]"]]],,[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],PY:[,[,,"59\\d{4,6}|(?:[2-46-9]\\d|5[0-8])\\d{4,7}",,,,,,,[6,7,8,9],[5]],[,,"(?:[26]1|3[289]|4[1246-8]|7[1-3]|8[1-36])\\d{5,7}|(?:2(?:2[4-68]|[4-68]\\d|7[15]|9[1-5])|3(?:18|3[167]|4[2357]|51|[67]\\d)|4(?:3[12]|5[13]|9[1-47])|5(?:[1-4]\\d|5[02-4])|6(?:3[1-3]|44|7[1-8])|7(?:4[0-4]|5\\d|6[1-578]|75|8[0-8])|858)\\d{5,6}",
,,,"212345678",,,[7,8,9],[5,6]],[,,"9(?:51|6[129]|[78][1-6]|9[1-5])\\d{6}",,,,"961456789",,,[9]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,"8700[0-4]\\d{4}",,,,"870012345",,,[9]],"PY",595,"00","0",,,"0",,,,[[,"(\\d{3})(\\d{3,6})","$1 $2",["[2-9]0"],"0$1"],[,"(\\d{2})(\\d{5})","$1 $2",["[26]1|3[289]|4[1246-8]|7[1-3]|8[1-36]"],"(0$1)"],[,"(\\d{3})(\\d{4,5})","$1 $2",["2[279]|3[13-5]|4[359]|5|6(?:[34]|7[1-46-8])|7[46-8]|85"],"(0$1)"],[,"(\\d{2})(\\d{3})(\\d{3,4})","$1 $2 $3",
["2[14-68]|3[26-9]|4[1246-8]|6(?:1|75)|7[1-35]|8[1-36]"],"(0$1)"],[,"(\\d{2})(\\d{3})(\\d{4})","$1 $2 $3",["87"]],[,"(\\d{3})(\\d{6})","$1 $2",["9"],"0$1"],[,"(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["[2-8]"],"0$1"]],,[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,"[2-9]0\\d{4,7}",,,,"201234567"],,,[,,,,,,,,,[-1]]],QA:[,[,,"[2-7]\\d{7}|(?:2\\d\\d|800)\\d{4}",,,,,,,[7,8]],[,,"4[04]\\d{6}",,,,"44123456",,,[8]],[,,"(?:28|[35-7]\\d)\\d{6}",,,,"33123456",,,[8]],[,,"800\\d{4}",,,,"8001234",,,[7]],[,,,,,,,,,[-1]],[,
,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],"QA",974,"00",,,,,,,,[[,"(\\d{3})(\\d{4})","$1 $2",["2[126]|8"]],[,"(\\d{4})(\\d{4})","$1 $2",["[2-7]"]]],,[,,"2(?:[12]\\d|61)\\d{4}",,,,"2123456",,,[7]],,,[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],RE:[,[,,"9769\\d{5}|(?:26|[68]\\d)\\d{7}",,,,,,,[9]],[,,"26(?:2\\d\\d|30[01])\\d{4}",,,,"262161234"],[,,"(?:69(?:2\\d\\d|3(?:0[0-46]|1[013]|2[0-2]|3[0-39]|4\\d|5[05]|6[0-26]|7[0-27]|8[0-8]|9[0-479]))|9769\\d)\\d{4}",,,,"692123456"],[,,"80\\d{7}",,,
,"801234567"],[,,"89[1-37-9]\\d{6}",,,,"891123456"],[,,"8(?:1[019]|2[0156]|84|90)\\d{6}",,,,"810123456"],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],"RE",262,"00","0",,,"0",,,,[[,"(\\d{3})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[2689]"],"0$1"]],,[,,,,,,,,,[-1]],1,"26[23]|69|[89]",[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],RO:[,[,,"(?:[237]\\d|[89]0)\\d{7}|[23]\\d{5}",,,,,,,[6,9]],[,,"[23][13-6]\\d{7}|(?:2(?:19\\d|[3-6]\\d9)|31\\d\\d)\\d\\d",,,,"211234567"],[,,"7[01]20\\d{5}|7(?:0[013-9]|1[01]|[2-7]\\d|8[03-8]|9[09])\\d{6}",
,,,"712034567",,,[9]],[,,"800\\d{6}",,,,"800123456",,,[9]],[,,"90[0136]\\d{6}",,,,"900123456",,,[9]],[,,"801\\d{6}",,,,"801123456",,,[9]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],"RO",40,"00","0"," int ",,"0",,,,[[,"(\\d{3})(\\d{3})","$1 $2",["2[3-6]","2[3-6]\\d9"],"0$1"],[,"(\\d{2})(\\d{4})","$1 $2",["219|31"],"0$1"],[,"(\\d{2})(\\d{3})(\\d{4})","$1 $2 $3",["[23]1"],"0$1"],[,"(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["[237-9]"],"0$1"]],,[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,"(?:37\\d|80[578])\\d{6}",,,,"372123456",
,,[9]],,,[,,,,,,,,,[-1]]],RS:[,[,,"38[02-9]\\d{6,9}|6\\d{7,9}|90\\d{4,8}|38\\d{5,6}|(?:7\\d\\d|800)\\d{3,9}|(?:[12]\\d|3[0-79])\\d{5,10}",,,,,,,[6,7,8,9,10,11,12],[4,5]],[,,"(?:11[1-9]\\d|(?:2[389]|39)(?:0[2-9]|[2-9]\\d))\\d{3,8}|(?:1[02-9]|2[0-24-7]|3[0-8])[2-9]\\d{4,9}",,,,"10234567",,,[7,8,9,10,11,12],[4,5,6]],[,,"6(?:[0-689]|7\\d)\\d{6,7}",,,,"601234567",,,[8,9,10]],[,,"800\\d{3,9}",,,,"80012345"],[,,"(?:78\\d|90[0169])\\d{3,7}",,,,"90012345",,,[6,7,8,9,10]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,
,,,,,,,,[-1]],"RS",381,"00","0",,,"0",,,,[[,"(\\d{3})(\\d{3,9})","$1 $2",["(?:2[389]|39)0|[7-9]"],"0$1"],[,"(\\d{2})(\\d{5,10})","$1 $2",["[1-36]"],"0$1"]],,[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,"7[06]\\d{4,10}",,,,"700123456"],,,[,,,,,,,,,[-1]]],RU:[,[,,"[347-9]\\d{9}",,,,,,,[10],[7]],[,,"(?:3(?:0[12]|4[1-35-79]|5[1-3]|65|8[1-58]|9[0145])|4(?:01|1[1356]|2[13467]|7[1-5]|8[1-7]|9[1-689])|8(?:1[1-8]|2[01]|3[13-6]|4[0-8]|5[15]|6[1-35-79]|7[1-37-9]))\\d{7}",,,,"3011234567",,,,[7]],[,,"9\\d{9}",,,,"9123456789"],
[,,"80[04]\\d{7}",,,,"8001234567"],[,,"80[39]\\d{7}",,,,"8091234567"],[,,,,,,,,,[-1]],[,,"808\\d{7}",,,,"8081234567"],[,,,,,,,,,[-1]],"RU",7,"810","8",,,"8",,"8~10",,[[,"(\\d{3})(\\d{2})(\\d{2})","$1-$2-$3",["[0-79]"]],[,"(\\d{4})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["7(?:1[0-8]|2[1-9])","7(?:1(?:[0-6]2|7|8[27])|2(?:1[23]|[2-9]2))","7(?:1(?:[0-6]2|7|8[27])|2(?:13[03-69]|62[013-9]))|72[1-57-9]2"],"8 ($1)",,1],[,"(\\d{5})(\\d)(\\d{2})(\\d{2})","$1 $2 $3 $4",["7(?:1[0-68]|2[1-9])","7(?:1(?:[06][3-6]|[18]|2[35]|[3-5][3-5])|2(?:[13][3-5]|[24-689]|7[457]))",
"7(?:1(?:0(?:[356]|4[023])|[18]|2(?:3[013-9]|5)|3[45]|43[013-79]|5(?:3[1-8]|4[1-7]|5)|6(?:3[0-35-9]|[4-6]))|2(?:1(?:3[178]|[45])|[24-689]|3[35]|7[457]))|7(?:14|23)4[0-8]|71(?:33|45)[1-79]"],"8 ($1)",,1],[,"(\\d{3})(\\d{3})(\\d{4})","$1 $2 $3",["7"],"8 ($1)",,1],[,"(\\d{3})(\\d{3})(\\d{2})(\\d{2})","$1 $2-$3-$4",["[3489]"],"8 ($1)",,1]],[[,"(\\d{4})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["7(?:1[0-8]|2[1-9])","7(?:1(?:[0-6]2|7|8[27])|2(?:1[23]|[2-9]2))","7(?:1(?:[0-6]2|7|8[27])|2(?:13[03-69]|62[013-9]))|72[1-57-9]2"],
"8 ($1)",,1],[,"(\\d{5})(\\d)(\\d{2})(\\d{2})","$1 $2 $3 $4",["7(?:1[0-68]|2[1-9])","7(?:1(?:[06][3-6]|[18]|2[35]|[3-5][3-5])|2(?:[13][3-5]|[24-689]|7[457]))","7(?:1(?:0(?:[356]|4[023])|[18]|2(?:3[013-9]|5)|3[45]|43[013-79]|5(?:3[1-8]|4[1-7]|5)|6(?:3[0-35-9]|[4-6]))|2(?:1(?:3[178]|[45])|[24-689]|3[35]|7[457]))|7(?:14|23)4[0-8]|71(?:33|45)[1-79]"],"8 ($1)",,1],[,"(\\d{3})(\\d{3})(\\d{4})","$1 $2 $3",["7"],"8 ($1)",,1],[,"(\\d{3})(\\d{3})(\\d{2})(\\d{2})","$1 $2-$3-$4",["[3489]"],"8 ($1)",,1]],[,,,
,,,,,,[-1]],1,"3[04-689]|[489]",[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],RW:[,[,,"(?:06|[27]\\d\\d|[89]00)\\d{6}",,,,,,,[8,9]],[,,"(?:06|2[23568]\\d)\\d{6}",,,,"250123456"],[,,"7[238]\\d{7}",,,,"720123456",,,[9]],[,,"800\\d{6}",,,,"800123456",,,[9]],[,,"900\\d{6}",,,,"900123456",,,[9]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],"RW",250,"00","0",,,"0",,,,[[,"(\\d{2})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["0"]],[,"(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["[7-9]"],"0$1"],[,"(\\d{3})(\\d{3})(\\d{3})",
"$1 $2 $3",["2"]]],,[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],SA:[,[,,"92\\d{7}|(?:[15]|8\\d)\\d{8}",,,,,,,[9,10],[7]],[,,"1(?:1\\d|2[24-8]|3[35-8]|4[3-68]|6[2-5]|7[235-7])\\d{6}",,,,"112345678",,,[9],[7]],[,,"5(?:[013-689]\\d|7[0-36-8])\\d{6}",,,,"512345678",,,[9]],[,,"800\\d{7}",,,,"8001234567",,,[10]],[,,"925\\d{6}",,,,"925012345",,,[9]],[,,"920\\d{6}",,,,"920012345",,,[9]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],"SA",966,"00","0",,,"0",,,,[[,"(\\d{4})(\\d{5})","$1 $2",["9"]],
[,"(\\d{2})(\\d{3})(\\d{4})","$1 $2 $3",["1"],"0$1"],[,"(\\d{2})(\\d{3})(\\d{4})","$1 $2 $3",["5"],"0$1"],[,"(\\d{3})(\\d{3})(\\d{3,4})","$1 $2 $3",["81"],"0$1"],[,"(\\d{3})(\\d{3})(\\d{4})","$1 $2 $3",["8"]]],,[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,"811\\d{7}",,,,"8110123456",,,[10]],,,[,,,,,,,,,[-1]]],SB:[,[,,"(?:[1-6]|[7-9]\\d\\d)\\d{4}",,,,,,,[5,7]],[,,"(?:1[4-79]|[23]\\d|4[0-2]|5[03]|6[0-37])\\d{3}",,,,"40123",,,[5]],[,,"48\\d{3}|(?:(?:7[1-9]|8[4-9])\\d|9(?:1[2-9]|2[013-9]|3[0-2]|[46]\\d|5[0-46-9]|7[0-689]|8[0-79]|9[0-8]))\\d{4}",
,,,"7421234"],[,,"1[38]\\d{3}",,,,"18123",,,[5]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,"5[12]\\d{3}",,,,"51123",,,[5]],"SB",677,"0[01]",,,,,,,,[[,"(\\d{2})(\\d{5})","$1 $2",["7|8[4-9]|9(?:[1-8]|9[0-8])"]]],,[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],SC:[,[,,"8000\\d{3}|(?:[249]\\d|64)\\d{5}",,,,,,,[7]],[,,"4[2-46]\\d{5}",,,,"4217123"],[,,"2[5-8]\\d{5}",,,,"2510123"],[,,"8000\\d{3}",,,,"8000000"],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,"971\\d{4}|(?:64|95)\\d{5}",
,,,"6412345"],"SC",248,"010|0[0-2]",,,,,,"00",,[[,"(\\d)(\\d{3})(\\d{3})","$1 $2 $3",["[246]|9[57]"]]],,[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],SD:[,[,,"[19]\\d{8}",,,,,,,[9]],[,,"1(?:5\\d|8[35-7])\\d{6}",,,,"153123456"],[,,"(?:1[0-2]|9[0-3569])\\d{7}",,,,"911231234"],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],"SD",249,"00","0",,,"0",,,,[[,"(\\d{2})(\\d{3})(\\d{4})","$1 $2 $3",["[19]"],"0$1"]],,[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,
,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],SE:[,[,,"(?:[26]\\d\\d|9)\\d{9}|[1-9]\\d{8}|[1-689]\\d{7}|[1-4689]\\d{6}|2\\d{5}",,,,,,,[6,7,8,9,10,12]],[,,"(?:(?:[12][136]|3[356]|4[0246]|6[03]|8\\d)\\d|90[1-9])\\d{4,6}|(?:1(?:2[0-35]|4[0-4]|5[0-25-9]|7[13-6]|[89]\\d)|2(?:2[0-7]|4[0136-8]|5[0138]|7[018]|8[01]|9[0-57])|3(?:0[0-4]|1\\d|2[0-25]|4[056]|7[0-2]|8[0-3]|9[023])|4(?:1[013-8]|3[0135]|5[14-79]|7[0-246-9]|8[0156]|9[0-689])|5(?:0[0-6]|[15][0-5]|2[0-68]|3[0-4]|4\\d|6[03-5]|7[013]|8[0-79]|9[01])|6(?:1[1-3]|2[0-4]|4[02-57]|5[0-37]|6[0-3]|7[0-2]|8[0247]|9[0-356])|9(?:1[0-68]|2\\d|3[02-5]|4[0-3]|5[0-4]|[68][01]|7[0135-8]))\\d{5,6}",
,,,"8123456",,,[7,8,9]],[,,"7[02369]\\d{7}",,,,"701234567",,,[9]],[,,"20\\d{4,7}",,,,"20123456",,,[6,7,8,9]],[,,"649\\d{6}|9(?:00|39|44)[1-8]\\d{3,6}",,,,"9001234567",,,[7,8,9,10]],[,,"77[0-7]\\d{6}",,,,"771234567",,,[9]],[,,"75[1-8]\\d{6}",,,,"751234567",,,[9]],[,,,,,,,,,[-1]],"SE",46,"00","0",,,"0",,,,[[,"(\\d{2})(\\d{2,3})(\\d{2})","$1-$2 $3",["20"],"0$1"],[,"(\\d{3})(\\d{4})","$1-$2",["9(?:00|39|44)"],"0$1"],[,"(\\d{2})(\\d{3})(\\d{2})","$1-$2 $3",["[12][136]|3[356]|4[0246]|6[03]|90[1-9]"],"0$1"],
[,"(\\d)(\\d{2,3})(\\d{2})(\\d{2})","$1-$2 $3 $4",["8"],"0$1"],[,"(\\d{3})(\\d{2,3})(\\d{2})","$1-$2 $3",["1[2457]|2(?:[247-9]|5[0138])|3[0247-9]|4[1357-9]|5[0-35-9]|6(?:[125689]|4[02-57]|7[0-2])|9(?:[125-8]|3[02-5]|4[0-3])"],"0$1"],[,"(\\d{3})(\\d{2,3})(\\d{3})","$1-$2 $3",["9(?:00|39|44)"],"0$1"],[,"(\\d{2})(\\d{2,3})(\\d{2})(\\d{2})","$1-$2 $3 $4",["1[13689]|2[0136]|3[1356]|4[0246]|54|6[03]|90[1-9]"],"0$1"],[,"(\\d{2})(\\d{3})(\\d{2})(\\d{2})","$1-$2 $3 $4",["10|7"],"0$1"],[,"(\\d)(\\d{3})(\\d{3})(\\d{2})",
"$1-$2 $3 $4",["8"],"0$1"],[,"(\\d{3})(\\d{2})(\\d{2})(\\d{2})","$1-$2 $3 $4",["[13-5]|2(?:[247-9]|5[0138])|6(?:[124-689]|7[0-2])|9(?:[125-8]|3[02-5]|4[0-3])"],"0$1"],[,"(\\d{3})(\\d{2})(\\d{2})(\\d{3})","$1-$2 $3 $4",["9"],"0$1"],[,"(\\d{3})(\\d{2})(\\d{3})(\\d{2})(\\d{2})","$1-$2 $3 $4 $5",["[26]"],"0$1"]],[[,"(\\d{2})(\\d{2,3})(\\d{2})","$1 $2 $3",["20"]],[,"(\\d{3})(\\d{4})","$1 $2",["9(?:00|39|44)"]],[,"(\\d{2})(\\d{3})(\\d{2})","$1 $2 $3",["[12][136]|3[356]|4[0246]|6[03]|90[1-9]"]],[,"(\\d)(\\d{2,3})(\\d{2})(\\d{2})",
"$1 $2 $3 $4",["8"]],[,"(\\d{3})(\\d{2,3})(\\d{2})","$1 $2 $3",["1[2457]|2(?:[247-9]|5[0138])|3[0247-9]|4[1357-9]|5[0-35-9]|6(?:[125689]|4[02-57]|7[0-2])|9(?:[125-8]|3[02-5]|4[0-3])"]],[,"(\\d{3})(\\d{2,3})(\\d{3})","$1 $2 $3",["9(?:00|39|44)"]],[,"(\\d{2})(\\d{2,3})(\\d{2})(\\d{2})","$1 $2 $3 $4",["1[13689]|2[0136]|3[1356]|4[0246]|54|6[03]|90[1-9]"]],[,"(\\d{2})(\\d{3})(\\d{2})(\\d{2})","$1 $2 $3 $4",["10|7"]],[,"(\\d)(\\d{3})(\\d{3})(\\d{2})","$1 $2 $3 $4",["8"]],[,"(\\d{3})(\\d{2})(\\d{2})(\\d{2})",
"$1 $2 $3 $4",["[13-5]|2(?:[247-9]|5[0138])|6(?:[124-689]|7[0-2])|9(?:[125-8]|3[02-5]|4[0-3])"]],[,"(\\d{3})(\\d{2})(\\d{2})(\\d{3})","$1 $2 $3 $4",["9"]],[,"(\\d{3})(\\d{2})(\\d{3})(\\d{2})(\\d{2})","$1 $2 $3 $4 $5",["[26]"]]],[,,"74[02-9]\\d{6}",,,,"740123456",,,[9]],,,[,,,,,,,,,[-1]],[,,"10[1-8]\\d{6}",,,,"102345678",,,[9]],,,[,,"(?:25[245]|67[3-68])\\d{9}",,,,"254123456789",,,[12]]],SG:[,[,,"(?:(?:1\\d|8)\\d\\d|7000)\\d{7}|[3689]\\d{7}",,,,,,,[8,10,11]],[,,"662[0-24-9]\\d{4}|6(?:[1-578]\\d|6[013-57-9]|9[0-35-9])\\d{5}",
,,,"61234567",,,[8]],[,,"(?:8(?:[1-8]\\d\\d|9(?:[014]\\d|2[1-9]|3[0-489]))|9[0-8]\\d\\d)\\d{4}",,,,"81234567",,,[8]],[,,"(?:18|8)00\\d{7}",,,,"18001234567",,,[10,11]],[,,"1900\\d{7}",,,,"19001234567",,,[11]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,"(?:3[12]\\d|666)\\d{5}",,,,"31234567",,,[8]],"SG",65,"0[0-3]\\d",,,,,,,,[[,"(\\d{4,5})","$1",["1[013-9]|77","1(?:[013-8]|9(?:0[1-9]|[1-9]))|77"]],[,"(\\d{4})(\\d{4})","$1 $2",["[369]|8[1-9]"]],[,"(\\d{3})(\\d{3})(\\d{4})","$1 $2 $3",["8"]],[,"(\\d{4})(\\d{4})(\\d{3})",
"$1 $2 $3",["7"]],[,"(\\d{4})(\\d{3})(\\d{4})","$1 $2 $3",["1"]]],[[,"(\\d{4})(\\d{4})","$1 $2",["[369]|8[1-9]"]],[,"(\\d{3})(\\d{3})(\\d{4})","$1 $2 $3",["8"]],[,"(\\d{4})(\\d{4})(\\d{3})","$1 $2 $3",["7"]],[,"(\\d{4})(\\d{3})(\\d{4})","$1 $2 $3",["1"]]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,"7000\\d{7}",,,,"70001234567",,,[11]],,,[,,,,,,,,,[-1]]],SH:[,[,,"(?:[256]\\d|8)\\d{3}",,,,,,,[4,5]],[,,"2(?:[0-57-9]\\d|6[4-9])\\d\\d",,,,"22158"],[,,"[56]\\d{4}",,,,"51234",,,[5]],[,,,,,,,,,[-1]],[,,,,,,,,,
[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,"262\\d\\d",,,,"26212",,,[5]],"SH",290,"00",,,,,,,,,,[,,,,,,,,,[-1]],1,"[256]",[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],SI:[,[,,"[1-7]\\d{7}|8\\d{4,7}|90\\d{4,6}",,,,,,,[5,6,7,8]],[,,"(?:[1-357][2-8]|4[24-8])\\d{6}",,,,"12345678",,,[8],[7]],[,,"65(?:1\\d|55|[67]0)\\d{4}|(?:[37][01]|4[0139]|51|6[489])\\d{6}",,,,"31234567",,,[8]],[,,"80\\d{4,6}",,,,"80123456",,,[6,7,8]],[,,"89[1-3]\\d{2,5}|90\\d{4,6}",,,,"90123456"],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],
[,,"(?:59\\d\\d|8(?:1(?:[67]\\d|8[01389])|2(?:0\\d|2[0378]|8[0-2489])|3[389]\\d))\\d{4}",,,,"59012345",,,[8]],"SI",386,"00|10(?:22|66|88|99)","0",,,"0",,"00",,[[,"(\\d{2})(\\d{3,6})","$1 $2",["8[09]|9"],"0$1"],[,"(\\d{3})(\\d{5})","$1 $2",["59|8"],"0$1"],[,"(\\d{2})(\\d{3})(\\d{3})","$1 $2 $3",["[37][01]|4[0139]|51|6"],"0$1"],[,"(\\d)(\\d{3})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[1-57]"],"(0$1)"]],,[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],SJ:[,[,,"0\\d{4}|(?:[4589]\\d|79)\\d{6}",
,,,,,,[5,8]],[,,"79\\d{6}",,,,"79123456",,,[8]],[,,"(?:4[015-8]|5[89]|9\\d)\\d{6}",,,,"41234567",,,[8]],[,,"80[01]\\d{5}",,,,"80012345",,,[8]],[,,"82[09]\\d{5}",,,,"82012345",,,[8]],[,,"810(?:0[0-6]|[2-8]\\d)\\d{3}",,,,"81021234",,,[8]],[,,"880\\d{5}",,,,"88012345",,,[8]],[,,"85[0-5]\\d{5}",,,,"85012345",,,[8]],"SJ",47,"00",,,,,,,,,,[,,,,,,,,,[-1]],,"79",[,,,,,,,,,[-1]],[,,"(?:0[2-9]|81(?:0(?:0[7-9]|1\\d)|5\\d\\d))\\d{3}",,,,"02000"],,,[,,"81[23]\\d{5}",,,,"81212345",,,[8]]],SK:[,[,,"[2-689]\\d{8}|[2-59]\\d{6}|[2-5]\\d{5}",
,,,,,,[6,7,9]],[,,"(?:2(?:16|[2-9]\\d{3})|(?:(?:[3-5][1-8]\\d|819)\\d|601[1-5])\\d)\\d{4}|(?:2|[3-5][1-8])1[67]\\d{3}|[3-5][1-8]16\\d\\d",,,,"221234567"],[,,"909[1-9]\\d{5}|9(?:0[1-8]|1[0-24-9]|4[03-57-9]|5\\d)\\d{6}",,,,"912123456",,,[9]],[,,"800\\d{6}",,,,"800123456",,,[9]],[,,"9(?:00|[78]\\d)\\d{6}",,,,"900123456",,,[9]],[,,"8[5-9]\\d{7}",,,,"850123456",,,[9]],[,,,,,,,,,[-1]],[,,"6(?:02|5[0-4]|9[0-6])\\d{6}",,,,"690123456",,,[9]],"SK",421,"00","0",,,"0",,,,[[,"(\\d)(\\d{2})(\\d{3,4})","$1 $2 $3",
["21"],"0$1"],[,"(\\d{2})(\\d{2})(\\d{2,3})","$1 $2 $3",["[3-5][1-8]1","[3-5][1-8]1[67]"],"0$1"],[,"(\\d{4})(\\d{3})","$1 $2",["909","9090"],"0$1"],[,"(\\d)(\\d{3})(\\d{3})(\\d{2})","$1/$2 $3 $4",["2"],"0$1"],[,"(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["[689]"],"0$1"],[,"(\\d{2})(\\d{3})(\\d{2})(\\d{2})","$1/$2 $3 $4",["[3-5]"],"0$1"]],[[,"(\\d)(\\d{2})(\\d{3,4})","$1 $2 $3",["21"],"0$1"],[,"(\\d{2})(\\d{2})(\\d{2,3})","$1 $2 $3",["[3-5][1-8]1","[3-5][1-8]1[67]"],"0$1"],[,"(\\d)(\\d{3})(\\d{3})(\\d{2})",
"$1/$2 $3 $4",["2"],"0$1"],[,"(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["[689]"],"0$1"],[,"(\\d{2})(\\d{3})(\\d{2})(\\d{2})","$1/$2 $3 $4",["[3-5]"],"0$1"]],[,,"9090\\d{3}",,,,"9090123",,,[7]],,,[,,"9090\\d{3}|(?:602|8(?:00|[5-9]\\d)|9(?:00|[78]\\d))\\d{6}",,,,,,,[7,9]],[,,"96\\d{7}",,,,"961234567",,,[9]],,,[,,,,,,,,,[-1]]],SL:[,[,,"(?:[2378]\\d|66|99)\\d{6}",,,,,,,[8],[6]],[,,"22[2-4][2-9]\\d{4}",,,,"22221234",,,,[6]],[,,"(?:25|3[013-5]|66|7[5-9]|8[08]|99)\\d{6}",,,,"25123456"],[,,,,,,,,,[-1]],[,,,,
,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],"SL",232,"00","0",,,"0",,,,[[,"(\\d{2})(\\d{6})","$1 $2",["[236-9]"],"(0$1)"]],,[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],SM:[,[,,"(?:0549|[5-7]\\d)\\d{6}",,,,,,,[8,10],[6]],[,,"0549(?:8[0157-9]|9\\d)\\d{4}",,,,"0549886377",,,[10],[6]],[,,"6[16]\\d{6}",,,,"66661212",,,[8]],[,,,,,,,,,[-1]],[,,"7[178]\\d{6}",,,,"71123456",,,[8]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,"5[158]\\d{6}",,,,"58001110",,,[8]],"SM",378,"00",,
,,"([89]\\d{5})$","0549$1",,,[[,"(\\d{6})","$1",["[89]"]],[,"(\\d{2})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[5-7]"]],[,"(\\d{4})(\\d{6})","$1 $2",["0"]]],[[,"(\\d{2})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[5-7]"]],[,"(\\d{4})(\\d{6})","$1 $2",["0"]]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],SN:[,[,,"(?:[378]\\d{4}|93330)\\d{4}",,,,,,,[9]],[,,"3(?:0(?:1[0-2]|80)|282|3(?:8[1-9]|9[3-9])|611)\\d{5}",,,,"301012345"],[,,"7(?:[06-8]\\d|21|90)\\d{6}",,,,"701234567"],[,,"800\\d{6}",
,,,"800123456"],[,,"88[4689]\\d{6}",,,,"884123456"],[,,"81[02468]\\d{6}",,,,"810123456"],[,,,,,,,,,[-1]],[,,"93330\\d{4}|3(?:392|9[01]\\d)\\d{5}",,,,"933301234"],"SN",221,"00",,,,,,,,[[,"(\\d{3})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["8"]],[,"(\\d{2})(\\d{3})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[379]"]]],,[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],SO:[,[,,"[346-9]\\d{8}|[12679]\\d{7}|[1-5]\\d{6}|[1348]\\d{5}",,,,,,,[6,7,8,9]],[,,"(?:1\\d|2[0-79]|3[0-46-8]|4[0-7]|5[57-9])\\d{5}|(?:[134]\\d|8[125])\\d{4}",
,,,"4012345",,,[6,7]],[,,"28\\d{5}|(?:6[1-9]|79)\\d{6,7}|(?:15|24|(?:3[59]|4[89]|8[08])\\d|60|7[1-8]|9(?:0\\d|[2-9]))\\d{6}",,,,"71123456",,,[7,8,9]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],"SO",252,"00","0",,,"0",,,,[[,"(\\d{2})(\\d{4})","$1 $2",["8[125]"]],[,"(\\d{6})","$1",["[134]"]],[,"(\\d)(\\d{6})","$1 $2",["[15]|2[0-79]|3[0-46-8]|4[0-7]"]],[,"(\\d)(\\d{7})","$1 $2",["24|[67]"]],[,"(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["[3478]|64|90"]],[,"(\\d{2})(\\d{5,7})",
"$1 $2",["1|28|6[1-35-9]|9[2-9]"]]],,[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],SR:[,[,,"(?:[2-5]|68|[78]\\d)\\d{5}",,,,,,,[6,7]],[,,"(?:2[1-3]|3[0-7]|(?:4|68)\\d|5[2-58])\\d{4}",,,,"211234"],[,,"(?:7[124-7]|8[125-9])\\d{5}",,,,"7412345",,,[7]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,"56\\d{4}",,,,"561234",,,[6]],"SR",597,"00",,,,,,,,[[,"(\\d{2})(\\d{2})(\\d{2})","$1-$2-$3",["56"]],[,"(\\d{3})(\\d{3})","$1-$2",["[2-5]"]],[,"(\\d{3})(\\d{4})","$1-$2",
["[6-8]"]]],,[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],SS:[,[,,"[19]\\d{8}",,,,,,,[9]],[,,"1[89]\\d{7}",,,,"181234567"],[,,"(?:12|9[12579])\\d{7}",,,,"977123456"],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],"SS",211,"00","0",,,"0",,,,[[,"(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["[19]"],"0$1"]],,[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],ST:[,[,,"(?:22|9\\d)\\d{5}",,,,,,,[7]],[,,"22\\d{5}",,,,"2221234"],[,,"900[5-9]\\d{3}|9(?:0[1-9]|[89]\\d)\\d{4}",
,,,"9812345"],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],"ST",239,"00",,,,,,,,[[,"(\\d{3})(\\d{4})","$1 $2",["[29]"]]],,[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],SV:[,[,,"[267]\\d{7}|[89]00\\d{4}(?:\\d{4})?",,,,,,,[7,8,11]],[,,"2(?:[1-6]\\d{3}|[79]90[034]|890[0245])\\d{3}",,,,"21234567",,,[8]],[,,"66(?:[02-9]\\d\\d|1(?:[02-9]\\d|16))\\d{3}|(?:6[0-57-9]|7\\d)\\d{6}",,,,"70123456",,,[8]],[,,"800\\d{4}(?:\\d{4})?",,,,"8001234",,,[7,11]],
[,,"900\\d{4}(?:\\d{4})?",,,,"9001234",,,[7,11]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],"SV",503,"00",,,,,,,,[[,"(\\d{3})(\\d{4})","$1 $2",["[89]"]],[,"(\\d{4})(\\d{4})","$1 $2",["[267]"]],[,"(\\d{3})(\\d{4})(\\d{4})","$1 $2 $3",["[89]"]]],,[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],SX:[,[,,"7215\\d{6}|(?:[58]\\d\\d|900)\\d{7}",,,,,,,[10],[7]],[,,"7215(?:4[2-8]|8[239]|9[056])\\d{4}",,,,"7215425678",,,,[7]],[,,"7215(?:1[02]|2\\d|5[034679]|8[014-8])\\d{4}",,,,"7215205678",
,,,[7]],[,,"8(?:00|33|44|55|66|77|88)[2-9]\\d{6}",,,,"8002123456"],[,,"900[2-9]\\d{6}",,,,"9002123456"],[,,,,,,,,,[-1]],[,,"52(?:35(?:[02-46-9]\\d|1[02-9]|5[0-46-9])|45(?:[034]\\d|1[02-9]|2[024-9]|5[0-46-9]))\\d{4}|52(?:3[2-46-9]|4[2-4])(?:[02-9]\\d|1[02-9])\\d{4}|5(?:00|2[12]|33|44|66|77|88)[2-9]\\d{6}",,,,"5002345678"],[,,,,,,,,,[-1]],"SX",1,"011","1",,,"1|(5\\d{6})$","721$1",,,,,[,,,,,,,,,[-1]],,"721",[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],SY:[,[,,"[1-39]\\d{8}|[1-5]\\d{7}",,,,,,,[8,
9],[6,7]],[,,"21\\d{6,7}|(?:1(?:[14]\\d|[2356])|2[235]|3(?:[13]\\d|4)|4[134]|5[1-3])\\d{6}",,,,"112345678",,,,[6,7]],[,,"9(?:22|[3-589]\\d|6[02-9])\\d{6}",,,,"944567890",,,[9]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],"SY",963,"00","0",,,"0",,,,[[,"(\\d{2})(\\d{3})(\\d{3,4})","$1 $2 $3",["[1-5]"],"0$1",,1],[,"(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["9"],"0$1",,1]],,[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],SZ:[,[,,"0800\\d{4}|(?:[237]\\d|900)\\d{6}",
,,,,,,[8,9]],[,,"[23][2-5]\\d{6}",,,,"22171234",,,[8]],[,,"7[6-9]\\d{6}",,,,"76123456",,,[8]],[,,"0800\\d{4}",,,,"08001234",,,[8]],[,,"900\\d{6}",,,,"900012345",,,[9]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,"70\\d{6}",,,,"70012345",,,[8]],"SZ",268,"00",,,,,,,,[[,"(\\d{4})(\\d{4})","$1 $2",["[0237]"]],[,"(\\d{5})(\\d{4})","$1 $2",["9"]]],,[,,,,,,,,,[-1]],,,[,,"0800\\d{4}",,,,,,,[8]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],TA:[,[,,"8\\d{3}",,,,,,,[4]],[,,"8\\d{3}",,,,"8999"],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],
[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],"TA",290,"00",,,,,,,,,,[,,,,,,,,,[-1]],,"8",[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],TC:[,[,,"(?:[58]\\d\\d|649|900)\\d{7}",,,,,,,[10],[7]],[,,"649(?:266|712|9(?:4\\d|50))\\d{4}",,,,"6497121234",,,,[7]],[,,"649(?:2(?:3[129]|4[1-79])|3\\d\\d|4[34][1-3])\\d{4}",,,,"6492311234",,,,[7]],[,,"8(?:00|33|44|55|66|77|88)[2-9]\\d{6}",,,,"8002345678"],[,,"900[2-9]\\d{6}",,,,"9002345678"],[,,,,,,,,,[-1]],[,,"52(?:35(?:[02-46-9]\\d|1[02-9]|5[0-46-9])|45(?:[034]\\d|1[02-9]|2[024-9]|5[0-46-9]))\\d{4}|52(?:3[2-46-9]|4[2-4])(?:[02-9]\\d|1[02-9])\\d{4}|5(?:00|2[12]|33|44|66|77|88)[2-9]\\d{6}",
,,,"5002345678"],[,,"649(?:71[01]|966)\\d{4}",,,,"6497101234",,,,[7]],"TC",1,"011","1",,,"1|([2-479]\\d{6})$","649$1",,,,,[,,,,,,,,,[-1]],,"649",[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],TD:[,[,,"(?:22|[69]\\d|77)\\d{6}",,,,,,,[8]],[,,"22(?:[37-9]0|5[0-5]|6[89])\\d{4}",,,,"22501234"],[,,"(?:6[023568]|77|9\\d)\\d{6}",,,,"63012345"],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],"TD",235,"00|16",,,,,,"00",,[[,"(\\d{2})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",
["[2679]"]]],,[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],TG:[,[,,"[279]\\d{7}",,,,,,,[8]],[,,"2(?:2[2-7]|3[23]|4[45]|55|6[67]|77)\\d{5}",,,,"22212345"],[,,"(?:7[09]|9[0-36-9])\\d{6}",,,,"90112345"],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],"TG",228,"00",,,,,,,,[[,"(\\d{2})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[279]"]]],,[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],TH:[,[,,"1\\d{8,9}|(?:[2-57]|[689]\\d)\\d{7}",
,,,,,,[8,9,10]],[,,"(?:2\\d|3[2-9]|4[2-5]|5[2-6]|7[3-7])\\d{6}",,,,"21234567",,,[8]],[,,"(?:14|6[1-6]|[89]\\d)\\d{7}",,,,"812345678",,,[9]],[,,"1800\\d{6}",,,,"1800123456",,,[10]],[,,"1900\\d{6}",,,,"1900123456",,,[10]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,"6[08]\\d{7}",,,,"601234567",,,[9]],"TH",66,"00[1-9]","0",,,"0",,,,[[,"(\\d)(\\d{3})(\\d{4})","$1 $2 $3",["2"],"0$1"],[,"(\\d{2})(\\d{3})(\\d{3,4})","$1 $2 $3",["14|[3-9]"],"0$1"],[,"(\\d{4})(\\d{3})(\\d{3})","$1 $2 $3",["1"]]],,[,,,,,,,,,[-1]],,
,[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],TJ:[,[,,"(?:00|11|[3-579]\\d|88)\\d{7}",,,,,,,[9],[3,5,6,7]],[,,"(?:3(?:1[3-5]|2[245]|3[12]|4[24-7]|5[25]|72)|4(?:46|74|87))\\d{6}",,,,"372123456",,,,[3,5,6,7]],[,,"41[18]\\d{6}|(?:00|11|5[05]|7[07]|88|9\\d)\\d{7}",,,,"917123456"],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],"TJ",992,"810","8",,,"8",,"8~10",,[[,"(\\d{6})(\\d)(\\d{2})","$1 $2 $3",["331","3317"],,,1],[,"(\\d{3})(\\d{2})(\\d{4})","$1 $2 $3",["[34]7|91[78]"],
,,1],[,"(\\d{4})(\\d)(\\d{4})","$1 $2 $3",["3"],,,1],[,"(\\d{2})(\\d{3})(\\d{4})","$1 $2 $3",["[0457-9]|11"],,,1]],,[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],TK:[,[,,"[2-47]\\d{3,6}",,,,,,,[4,5,6,7]],[,,"(?:2[2-4]|[34]\\d)\\d{2,5}",,,,"3101"],[,,"7[2-4]\\d{2,5}",,,,"7290"],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],"TK",690,"00",,,,,,,,,,[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],TL:[,[,,"7\\d{7}|(?:[2-47]\\d|[89]0)\\d{5}",
,,,,,,[7,8]],[,,"(?:2[1-5]|3[1-9]|4[1-4])\\d{5}",,,,"2112345",,,[7]],[,,"7[2-8]\\d{6}",,,,"77212345",,,[8]],[,,"80\\d{5}",,,,"8012345",,,[7]],[,,"90\\d{5}",,,,"9012345",,,[7]],[,,,,,,,,,[-1]],[,,"70\\d{5}",,,,"7012345",,,[7]],[,,,,,,,,,[-1]],"TL",670,"00",,,,,,,,[[,"(\\d{3})(\\d{4})","$1 $2",["[2-489]|70"]],[,"(\\d{4})(\\d{4})","$1 $2",["7"]]],,[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],TM:[,[,,"[1-6]\\d{7}",,,,,,,[8]],[,,"(?:1(?:2\\d|3[1-9])|2(?:22|4[0-35-8])|3(?:22|4[03-9])|4(?:22|3[128]|4\\d|6[15])|5(?:22|5[7-9]|6[014-689]))\\d{5}",
,,,"12345678"],[,,"6\\d{7}",,,,"66123456"],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],"TM",993,"810","8",,,"8",,"8~10",,[[,"(\\d{2})(\\d{2})(\\d{2})(\\d{2})","$1 $2-$3-$4",["12"],"(8 $1)"],[,"(\\d{3})(\\d)(\\d{2})(\\d{2})","$1 $2-$3-$4",["[1-5]"],"(8 $1)"],[,"(\\d{2})(\\d{6})","$1 $2",["6"],"8 $1"]],,[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],TN:[,[,,"[2-57-9]\\d{7}",,,,,,,[8]],[,,"81200\\d{3}|(?:3[0-2]|7\\d)\\d{6}",,,,"30010123"],[,,
"3(?:001|[12]40)\\d{4}|(?:(?:[259]\\d|4[0-6])\\d|3(?:1[1-35]|6[0-4]|91))\\d{5}",,,,"20123456"],[,,"8010\\d{4}",,,,"80101234"],[,,"88\\d{6}",,,,"88123456"],[,,"8[12]10\\d{4}",,,,"81101234"],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],"TN",216,"00",,,,,,,,[[,"(\\d{2})(\\d{3})(\\d{3})","$1 $2 $3",["[2-57-9]"]]],,[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],TO:[,[,,"(?:0800|[5-8]\\d{3})\\d{3}|[2-8]\\d{4}",,,,,,,[5,7]],[,,"(?:2\\d|3[0-8]|4[0-4]|50|6[09]|7[0-24-69]|8[05])\\d{3}",,,,"20123",
,,[5]],[,,"6(?:3[02]|8[5-9])\\d{4}|(?:6[09]|7\\d|8[46-9])\\d{5}",,,,"7715123",,,[7]],[,,"0800\\d{3}",,,,"0800222",,,[7]],[,,"55[04]\\d{4}",,,,"5501234",,,[7]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],"TO",676,"00",,,,,,,,[[,"(\\d{2})(\\d{3})","$1-$2",["[2-4]|50|6[09]|7[0-24-69]|8[05]"]],[,"(\\d{4})(\\d{3})","$1 $2",["0"]],[,"(\\d{3})(\\d{4})","$1 $2",["[5-8]"]]],,[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],TR:[,[,,"(?:4|8\\d{5})\\d{6}|(?:[2-58]\\d\\d|900)\\d{7}",,,
,,,,[7,10,12]],[,,"(?:2(?:[13][26]|[28][2468]|[45][268]|[67][246])|3(?:[13][28]|[24-6][2468]|[78][02468]|92)|4(?:[16][246]|[23578][2468]|4[26]))\\d{7}",,,,"2123456789",,,[10]],[,,"56161\\d{5}|5(?:0[15-7]|1[06]|24|[34]\\d|5[1-59]|9[46])\\d{7}",,,,"5012345678",,,[10]],[,,"800\\d{7}(?:\\d{2})?",,,,"8001234567",,,[10,12]],[,,"(?:8[89]8|900)\\d{7}",,,,"9001234567",,,[10]],[,,,,,,,,,[-1]],[,,"592(?:21[12]|461)\\d{4}",,,,"5922121234",,,[10]],[,,,,,,,,,[-1]],"TR",90,"00","0",,,"0",,,,[[,"(\\d{3})(\\d)(\\d{3})",
"$1 $2 $3",["444"],,,1],[,"(\\d{3})(\\d{3})(\\d{4})","$1 $2 $3",["512|8[0589]|90"],"0$1",,1],[,"(\\d{3})(\\d{3})(\\d{2})(\\d{2})","$1 $2 $3 $4",["5(?:[0-59]|61)","5(?:[0-59]|616)","5(?:[0-59]|6161)"],"0$1",,1],[,"(\\d{3})(\\d{3})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[24][1-8]|3[1-9]"],"(0$1)",,1],[,"(\\d{3})(\\d{3})(\\d{6})","$1 $2 $3",["80"],"0$1",,1]],[[,"(\\d{3})(\\d{3})(\\d{4})","$1 $2 $3",["512|8[0589]|90"],"0$1",,1],[,"(\\d{3})(\\d{3})(\\d{2})(\\d{2})","$1 $2 $3 $4",["5(?:[0-59]|61)","5(?:[0-59]|616)",
"5(?:[0-59]|6161)"],"0$1",,1],[,"(\\d{3})(\\d{3})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[24][1-8]|3[1-9]"],"(0$1)",,1],[,"(\\d{3})(\\d{3})(\\d{6})","$1 $2 $3",["80"],"0$1",,1]],[,,"512\\d{7}",,,,"5123456789",,,[10]],,,[,,"444\\d{4}",,,,,,,[7]],[,,"(?:444|850\\d{3})\\d{4}",,,,"4441444",,,[7,10]],,,[,,,,,,,,,[-1]]],TT:[,[,,"(?:[58]\\d\\d|900)\\d{7}",,,,,,,[10],[7]],[,,"868(?:2(?:0[13]|1[89]|[23]\\d|4[0-2])|6(?:0[7-9]|1[02-8]|2[1-9]|[3-69]\\d|7[0-79])|82[124])\\d{4}",,,,"8682211234",,,,[7]],[,,"868(?:2(?:6[3-9]|[7-9]\\d)|(?:3\\d|4[6-9])\\d|6(?:20|78|8\\d)|7(?:0[1-9]|1[02-9]|[2-9]\\d))\\d{4}",
,,,"8682911234",,,,[7]],[,,"8(?:00|33|44|55|66|77|88)[2-9]\\d{6}",,,,"8002345678"],[,,"900[2-9]\\d{6}",,,,"9002345678"],[,,,,,,,,,[-1]],[,,"52(?:35(?:[02-46-9]\\d|1[02-9]|5[0-46-9])|45(?:[034]\\d|1[02-9]|2[024-9]|5[0-46-9]))\\d{4}|52(?:3[2-46-9]|4[2-4])(?:[02-9]\\d|1[02-9])\\d{4}|5(?:00|2[12]|33|44|66|77|88)[2-9]\\d{6}",,,,"5002345678"],[,,,,,,,,,[-1]],"TT",1,"011","1",,,"1|([2-46-8]\\d{6})$","868$1",,,,,[,,,,,,,,,[-1]],,"868",[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,"868619\\d{4}",,,,"8686191234",,,
,[7]]],TV:[,[,,"(?:2|7\\d\\d|90)\\d{4}",,,,,,,[5,6,7]],[,,"2[02-9]\\d{3}",,,,"20123",,,[5]],[,,"(?:7[01]\\d|90)\\d{4}",,,,"901234",,,[6,7]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],"TV",688,"00",,,,,,,,[[,"(\\d{2})(\\d{3})","$1 $2",["2"]],[,"(\\d{2})(\\d{4})","$1 $2",["90"]],[,"(\\d{2})(\\d{5})","$1 $2",["7"]]],,[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],TW:[,[,,"[2-689]\\d{8}|7\\d{9,10}|[2-8]\\d{7}|2\\d{6}",,,,,,,[7,8,9,10,11]],[,,
"(?:2[2-8]\\d|370|55[01]|7[1-9])\\d{6}|4(?:(?:0(?:0[1-9]|[2-48]\\d)|1[023]\\d)\\d{4,5}|(?:[239]\\d\\d|4(?:0[56]|12|49))\\d{5})|6(?:[01]\\d{7}|4(?:0[56]|12|24|4[09])\\d{4,5})|8(?:(?:2(?:3\\d|4[0-269]|[578]0|66)|36[24-9]|90\\d\\d)\\d{4}|4(?:0[56]|12|24|4[09])\\d{4,5})|(?:2(?:2(?:0\\d\\d|4(?:0[68]|[249]0|3[0-467]|5[0-25-9]|6[0235689]))|(?:3(?:[09]\\d|1[0-4])|(?:4\\d|5[0-49]|6[0-29]|7[0-5])\\d)\\d)|(?:(?:3[2-9]|5[2-8]|6[0-35-79]|8[7-9])\\d\\d|4(?:2(?:[089]\\d|7[1-9])|(?:3[0-4]|[78]\\d|9[01])\\d))\\d)\\d{3}",
,,,"221234567",,,[8,9]],[,,"(?:40001[0-2]|9[0-8]\\d{4})\\d{3}",,,,"912345678",,,[9]],[,,"80[0-79]\\d{6}|800\\d{5}",,,,"800123456",,,[8,9]],[,,"20(?:[013-9]\\d\\d|2)\\d{4}",,,,"203123456",,,[7,9]],[,,,,,,,,,[-1]],[,,"99\\d{7}",,,,"990123456",,,[9]],[,,"7010(?:[0-2679]\\d|3[0-7]|8[0-5])\\d{5}|70\\d{8}",,,,"7012345678",,,[10,11]],"TW",886,"0(?:0[25-79]|19)","0","#",,"0",,,,[[,"(\\d{2})(\\d)(\\d{4})","$1 $2 $3",["202"],"0$1"],[,"(\\d{2})(\\d{3})(\\d{3,4})","$1 $2 $3",["[258]0"],"0$1"],[,"(\\d)(\\d{3,4})(\\d{4})",
"$1 $2 $3",["[23568]|4(?:0[02-48]|[1-47-9])|7[1-9]","[23568]|4(?:0[2-48]|[1-47-9])|(?:400|7)[1-9]"],"0$1"],[,"(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["[49]"],"0$1"],[,"(\\d{2})(\\d{4})(\\d{4,5})","$1 $2 $3",["7"],"0$1"]],,[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,"50[0-46-9]\\d{6}",,,,"500123456",,,[9]],,,[,,,,,,,,,[-1]]],TZ:[,[,,"(?:[26-8]\\d|41|90)\\d{7}",,,,,,,[9]],[,,"2[2-8]\\d{7}",,,,"222345678"],[,,"77[2-9]\\d{6}|(?:6[2-9]|7[13-689])\\d{7}",,,,"621234567"],[,,"80[08]\\d{6}",,,,"800123456"],[,,"90\\d{7}",
,,,"900123456"],[,,"8(?:40|6[01])\\d{6}",,,,"840123456"],[,,,,,,,,,[-1]],[,,"41\\d{7}",,,,"412345678"],"TZ",255,"00[056]","0",,,"0",,,,[[,"(\\d{3})(\\d{2})(\\d{4})","$1 $2 $3",["[89]"],"0$1"],[,"(\\d{2})(\\d{3})(\\d{4})","$1 $2 $3",["[24]"],"0$1"],[,"(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["[67]"],"0$1"]],,[,,,,,,,,,[-1]],,,[,,"(?:8(?:[04]0|6[01])|90\\d)\\d{6}"],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],UA:[,[,,"[89]\\d{9}|[3-9]\\d{8}",,,,,,,[9,10],[5,6,7]],[,,"(?:3[1-8]|4[13-8]|5[1-7]|6[12459])\\d{7}",,,
,"311234567",,,[9],[5,6,7]],[,,"(?:50|6[36-8]|7[1-3]|9[1-9])\\d{7}",,,,"501234567",,,[9]],[,,"800[1-8]\\d{5,6}",,,,"800123456"],[,,"900[239]\\d{5,6}",,,,"900212345"],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,"89[1-579]\\d{6}",,,,"891234567",,,[9]],"UA",380,"00","0",,,"0",,"0~0",,[[,"(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["6[12][29]|(?:3[1-8]|4[136-8]|5[12457]|6[49])2|(?:56|65)[24]","6[12][29]|(?:35|4[1378]|5[12457]|6[49])2|(?:56|65)[24]|(?:3[1-46-8]|46)2[013-9]"],"0$1"],[,"(\\d{2})(\\d{3})(\\d{4})","$1 $2 $3",
["4[45][0-5]|5(?:0|6[37])|6(?:[12][018]|[36-8])|7|89|9[1-9]|(?:48|57)[0137-9]","4[45][0-5]|5(?:0|6(?:3[14-7]|7))|6(?:[12][018]|[36-8])|7|89|9[1-9]|(?:48|57)[0137-9]"],"0$1"],[,"(\\d{4})(\\d{5})","$1 $2",["[3-6]"],"0$1"],[,"(\\d{3})(\\d{3})(\\d{3,4})","$1 $2 $3",["[89]"],"0$1"]],,[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],UG:[,[,,"800\\d{6}|(?:[29]0|[347]\\d)\\d{7}",,,,,,,[9],[5,6,7]],[,,"20(?:(?:(?:24|81)0|30[67])\\d|6(?:00[0-2]|30[0-4]))\\d{3}|(?:20(?:[0147]\\d|2[5-9]|32|5[0-4]|6[15-9])|[34]\\d{3})\\d{5}",
,,,"312345678",,,,[5,6,7]],[,,"7260\\d{5}|7(?:[0157-9]\\d|20|36|4[0-4])\\d{6}",,,,"712345678"],[,,"800[1-3]\\d{5}",,,,"800123456"],[,,"90[1-3]\\d{6}",,,,"901123456"],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],"UG",256,"00[057]","0",,,"0",,,,[[,"(\\d{4})(\\d{5})","$1 $2",["202","2024"],"0$1"],[,"(\\d{3})(\\d{6})","$1 $2",["[27-9]|4(?:6[45]|[7-9])"],"0$1"],[,"(\\d{2})(\\d{7})","$1 $2",["[34]"],"0$1"]],,[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],US:[,[,,"[2-9]\\d{9}",,
,,,,,[10],[7]],[,,"(?:2(?:0[1-35-9]|1[02-9]|2[03-589]|3[149]|4[08]|5[1-46]|6[0279]|7[0269]|8[13])|3(?:0[1-57-9]|1[02-9]|2[0135]|3[0-24679]|4[167]|5[12]|6[014]|8[056])|4(?:0[124-9]|1[02-579]|2[3-5]|3[0245]|4[0235]|58|6[39]|7[0589]|8[04])|5(?:0[1-57-9]|1[0235-8]|20|3[0149]|4[01]|5[19]|6[1-47]|7[013-5]|8[056])|6(?:0[1-35-9]|1[024-9]|2[03689]|[34][016]|5[0179]|6[0-279]|78|8[0-29])|7(?:0[1-46-8]|1[2-9]|2[04-7]|3[1247]|4[037]|5[47]|6[02359]|7[02-59]|8[156])|8(?:0[1-68]|1[02-8]|2[08]|3[0-28]|4[3578]|5[046-9]|6[02-5]|7[028])|9(?:0[1346-9]|1[02-9]|2[0589]|3[0146-8]|4[0179]|5[12469]|7[0-389]|8[04-69]))[2-9]\\d{6}",
,,,"2015550123",,,,[7]],[,,"(?:2(?:0[1-35-9]|1[02-9]|2[03-589]|3[149]|4[08]|5[1-46]|6[0279]|7[0269]|8[13])|3(?:0[1-57-9]|1[02-9]|2[0135]|3[0-24679]|4[167]|5[12]|6[014]|8[056])|4(?:0[124-9]|1[02-579]|2[3-5]|3[0245]|4[0235]|58|6[39]|7[0589]|8[04])|5(?:0[1-57-9]|1[0235-8]|20|3[0149]|4[01]|5[19]|6[1-47]|7[013-5]|8[056])|6(?:0[1-35-9]|1[024-9]|2[03689]|[34][016]|5[0179]|6[0-279]|78|8[0-29])|7(?:0[1-46-8]|1[2-9]|2[04-7]|3[1247]|4[037]|5[47]|6[02359]|7[02-59]|8[156])|8(?:0[1-68]|1[02-8]|2[08]|3[0-28]|4[3578]|5[046-9]|6[02-5]|7[028])|9(?:0[1346-9]|1[02-9]|2[0589]|3[0146-8]|4[0179]|5[12469]|7[0-389]|8[04-69]))[2-9]\\d{6}",
,,,"2015550123",,,,[7]],[,,"8(?:00|33|44|55|66|77|88)[2-9]\\d{6}",,,,"8002345678"],[,,"900[2-9]\\d{6}",,,,"9002345678"],[,,,,,,,,,[-1]],[,,"52(?:35(?:[02-46-9]\\d|1[02-9]|5[0-46-9])|45(?:[034]\\d|1[02-9]|2[024-9]|5[0-46-9]))\\d{4}|52(?:3[2-46-9]|4[2-4])(?:[02-9]\\d|1[02-9])\\d{4}|5(?:00|2[12]|33|44|66|77|88)[2-9]\\d{6}",,,,"5002345678"],[,,,,,,,,,[-1]],"US",1,"011","1",,,"1",,,1,[[,"(\\d{3})(\\d{4})","$1-$2",["[2-9]"]],[,"(\\d{3})(\\d{3})(\\d{4})","($1) $2-$3",["[2-9]"],,,1]],[[,"(\\d{3})(\\d{3})(\\d{4})",
"$1-$2-$3",["[2-9]"]]],[,,,,,,,,,[-1]],1,,[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],UY:[,[,,"(?:[249]\\d\\d|80)\\d{5}|9\\d{6}",,,,,,,[7,8]],[,,"(?:2\\d|4[2-7])\\d{6}",,,,"21231234",,,[8],[7]],[,,"9[1-9]\\d{6}",,,,"94231234",,,[8]],[,,"80[05]\\d{4}",,,,"8001234",,,[7]],[,,"90[0-8]\\d{4}",,,,"9001234",,,[7]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],"UY",598,"0(?:0|1[3-9]\\d)","0"," int. ",,"0",,"00",,[[,"(\\d{3})(\\d{4})","$1 $2",["8|90"],"0$1"],[,"(\\d{2})(\\d{3})(\\d{3})","$1 $2 $3",
["9"],"0$1"],[,"(\\d{4})(\\d{4})","$1 $2",["[24]"]]],,[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],UZ:[,[,,"(?:[679]\\d|88)\\d{7}",,,,,,,[9]],[,,"(?:6(?:1(?:22|3[124]|4[1-4]|5[1-3578]|64)|2(?:22|3[0-57-9]|41)|5(?:22|3[3-7]|5[024-8])|6\\d\\d|7(?:[23]\\d|7[69])|9(?:22|4[1-8]|6[135]))|7(?:0(?:5[4-9]|6[0146]|7[124-6]|9[135-8])|(?:1[12]|8\\d)\\d|2(?:22|3[13-57-9]|4[1-3579]|5[14])|3(?:2\\d|3[1578]|4[1-35-7]|5[1-57]|61)|4(?:2\\d|3[1-579]|7[1-79])|5(?:22|5[1-9]|6[1457])|6(?:22|3[12457]|4[13-8])|9(?:22|5[1-9])))\\d{5}",
,,,"669050123"],[,,"(?:6(?:1(?:2(?:2[01]|98)|35[0-4]|50\\d|61[23]|7(?:[01][017]|4\\d|55|9[5-9]))|2(?:(?:11|7\\d)\\d|2(?:[12]1|9[01379])|5(?:[126]\\d|3[0-4]))|5(?:19[01]|2(?:27|9[26])|(?:30|59|7\\d)\\d)|6(?:2(?:1[5-9]|2[0367]|38|41|52|60)|(?:3[79]|9[0-3])\\d|4(?:56|83)|7(?:[07]\\d|1[017]|3[07]|4[047]|5[057]|67|8[0178]|9[79]))|7(?:2(?:24|3[237]|4[5-9]|7[15-8])|5(?:7[12]|8[0589])|7(?:0\\d|[39][07])|9(?:0\\d|7[079]))|9(?:2(?:1[1267]|3[01]|5\\d|7[0-4])|(?:5[67]|7\\d)\\d|6(?:2[0-26]|8\\d)))|7(?:[07]\\d{3}|1(?:13[01]|6(?:0[47]|1[67]|66)|71[3-69]|98\\d)|2(?:2(?:2[79]|95)|3(?:2[5-9]|6[0-6])|57\\d|7(?:0\\d|1[17]|2[27]|3[37]|44|5[057]|66|88))|3(?:2(?:1[0-6]|21|3[469]|7[159])|(?:33|9[4-6])\\d|5(?:0[0-4]|5[579]|9\\d)|7(?:[0-3579]\\d|4[0467]|6[67]|8[078]))|4(?:2(?:29|5[0257]|6[0-7]|7[1-57])|5(?:1[0-4]|8\\d|9[5-9])|7(?:0\\d|1[024589]|2[0-27]|3[0137]|[46][07]|5[01]|7[5-9]|9[079])|9(?:7[015-9]|[89]\\d))|5(?:112|2(?:0\\d|2[29]|[49]4)|3[1568]\\d|52[6-9]|7(?:0[01578]|1[017]|[23]7|4[047]|[5-7]\\d|8[78]|9[079]))|6(?:2(?:2[1245]|4[2-4])|39\\d|41[179]|5(?:[349]\\d|5[0-2])|7(?:0[017]|[13]\\d|22|44|55|67|88))|9(?:22[128]|3(?:2[0-4]|7\\d)|57[02569]|7(?:2[05-9]|3[37]|4\\d|60|7[2579]|87|9[07])))|(?:88|9[0-57-9])\\d{3})\\d{4}",
,,,"912345678"],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],"UZ",998,"810","8",,,"8",,"8~10",,[[,"(\\d{2})(\\d{3})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[6-9]"],"8 $1"]],,[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],VA:[,[,,"0\\d{5,10}|3[0-8]\\d{7,10}|55\\d{8}|8\\d{5}(?:\\d{2,4})?|(?:1\\d|39)\\d{7,8}",,,,,,,[6,7,8,9,10,11,12]],[,,"06698\\d{1,6}",,,,"0669812345",,,[6,7,8,9,10,11]],[,,"3[1-9]\\d{8}|3[2-9]\\d{7}",,,,"3123456789",,,[9,10]],[,,"80(?:0\\d{3}|3)\\d{3}",
,,,"800123456",,,[6,9]],[,,"(?:0878\\d\\d|89(?:2|4[5-9]\\d))\\d{3}|89[45][0-4]\\d\\d|(?:1(?:44|6[346])|89(?:5[5-9]|9))\\d{6}",,,,"899123456",,,[6,8,9,10]],[,,"84(?:[08]\\d{3}|[17])\\d{3}",,,,"848123456",,,[6,9]],[,,"1(?:78\\d|99)\\d{6}",,,,"1781234567",,,[9,10]],[,,"55\\d{8}",,,,"5512345678",,,[10]],"VA",39,"00",,,,,,,,,,[,,,,,,,,,[-1]],,"06698",[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,"3[2-8]\\d{9,10}",,,,"33101234501",,,[11,12]]],VC:[,[,,"(?:[58]\\d\\d|784|900)\\d{7}",,,,,,,[10],[7]],[,,"784(?:266|3(?:6[6-9]|7\\d|8[0-6])|4(?:38|5[0-36-8]|8[0-8])|5(?:55|7[0-2]|93)|638|784)\\d{4}",
,,,"7842661234",,,,[7]],[,,"784(?:4(?:3[0-5]|5[45]|89|9[0-8])|5(?:2[6-9]|3[0-4])|720)\\d{4}",,,,"7844301234",,,,[7]],[,,"8(?:00|33|44|55|66|77|88)[2-9]\\d{6}",,,,"8002345678"],[,,"900[2-9]\\d{6}",,,,"9002345678"],[,,,,,,,,,[-1]],[,,"52(?:35(?:[02-46-9]\\d|1[02-9]|5[0-46-9])|45(?:[034]\\d|1[02-9]|2[024-9]|5[0-46-9]))\\d{4}|52(?:3[2-46-9]|4[2-4])(?:[02-9]\\d|1[02-9])\\d{4}|5(?:00|2[12]|33|44|66|77|88)[2-9]\\d{6}",,,,"5002345678"],[,,,,,,,,,[-1]],"VC",1,"011","1",,,"1|([2-7]\\d{6})$","784$1",,,,,[,,
,,,,,,,[-1]],,"784",[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],VE:[,[,,"[68]00\\d{7}|(?:[24]\\d|[59]0)\\d{8}",,,,,,,[10],[7]],[,,"(?:2(?:12|3[457-9]|[467]\\d|[58][1-9]|9[1-6])|[4-6]00)\\d{7}",,,,"2121234567",,,,[7]],[,,"4(?:1[24-8]|2[46])\\d{7}",,,,"4121234567"],[,,"800\\d{7}",,,,"8001234567"],[,,"90[01]\\d{7}",,,,"9001234567"],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],"VE",58,"00","0",,,"0",,,,[[,"(\\d{3})(\\d{7})","$1-$2",["[24-689]"],"0$1","$CC $1"]],,[,,,,,,,,,[-1]],,,[,,,,,,,,,
[-1]],[,,"501\\d{7}",,,,"5010123456",,,,[7]],,,[,,,,,,,,,[-1]]],VG:[,[,,"(?:284|[58]\\d\\d|900)\\d{7}",,,,,,,[10],[7]],[,,"284496[0-5]\\d{3}|284(?:229|4(?:22|9[45])|774|8(?:52|6[459]))\\d{4}",,,,"2842291234",,,,[7]],[,,"284496[6-9]\\d{3}|284(?:245|3(?:0[0-3]|4[0-7]|68|9[34])|4(?:4[0-6]|68|99)|5(?:4[0-7]|68|9[69]))\\d{4}",,,,"2843001234",,,,[7]],[,,"8(?:00|33|44|55|66|77|88)[2-9]\\d{6}",,,,"8002345678"],[,,"900[2-9]\\d{6}",,,,"9002345678"],[,,,,,,,,,[-1]],[,,"52(?:35(?:[02-46-9]\\d|1[02-9]|5[0-46-9])|45(?:[034]\\d|1[02-9]|2[024-9]|5[0-46-9]))\\d{4}|52(?:3[2-46-9]|4[2-4])(?:[02-9]\\d|1[02-9])\\d{4}|5(?:00|2[12]|33|44|66|77|88)[2-9]\\d{6}",
,,,"5002345678"],[,,,,,,,,,[-1]],"VG",1,"011","1",,,"1|([2-578]\\d{6})$","284$1",,,,,[,,,,,,,,,[-1]],,"284",[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],VI:[,[,,"[58]\\d{9}|(?:34|90)0\\d{7}",,,,,,,[10],[7]],[,,"340(?:2(?:0[12]|2[06-8]|4[49]|77)|3(?:32|44)|4(?:2[23]|44|7[34]|89)|5(?:1[34]|55)|6(?:2[56]|4[23]|77|9[023])|7(?:1[2-57-9]|2[57]|7\\d)|884|998)\\d{4}",,,,"3406421234",,,,[7]],[,,"340(?:2(?:0[12]|2[06-8]|4[49]|77)|3(?:32|44)|4(?:2[23]|44|7[34]|89)|5(?:1[34]|55)|6(?:2[56]|4[23]|77|9[023])|7(?:1[2-57-9]|2[57]|7\\d)|884|998)\\d{4}",
,,,"3406421234",,,,[7]],[,,"8(?:00|33|44|55|66|77|88)[2-9]\\d{6}",,,,"8002345678"],[,,"900[2-9]\\d{6}",,,,"9002345678"],[,,,,,,,,,[-1]],[,,"52(?:35(?:[02-46-9]\\d|1[02-9]|5[0-46-9])|45(?:[034]\\d|1[02-9]|2[024-9]|5[0-46-9]))\\d{4}|52(?:3[2-46-9]|4[2-4])(?:[02-9]\\d|1[02-9])\\d{4}|5(?:00|2[12]|33|44|66|77|88)[2-9]\\d{6}",,,,"5002345678"],[,,,,,,,,,[-1]],"VI",1,"011","1",,,"1|([2-9]\\d{6})$","340$1",,1,,,[,,,,,,,,,[-1]],,"340",[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],VN:[,[,,"[12]\\d{9}|[135-9]\\d{8}|[16]\\d{7}|[16-8]\\d{6}",
,,,,,,[7,8,9,10]],[,,"2(?:0[3-9]|1[0-689]|2[0-25-9]|3[2-9]|4[2-8]|5[124-9]|6[0-39]|7[0-7]|8[2-79]|9[0-4679])\\d{7}",,,,"2101234567",,,[10]],[,,"(?:52[238]|89[689]|99[013-9])\\d{6}|(?:3\\d|5[689]|7[06-9]|8[1-8]|9[0-8])\\d{7}",,,,"912345678",,,[9]],[,,"1800\\d{4,6}|12(?:03|28)\\d{4}",,,,"1800123456",,,[8,9,10]],[,,"1900\\d{4,6}",,,,"1900123456",,,[8,9,10]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,"672\\d{6}",,,,"672012345",,,[9]],"VN",84,"00","0",,,"0",,,,[[,"(\\d{3})(\\d{4})","$1 $2",["[17]99"],"0$1",,1],
[,"(\\d{2})(\\d{5})","$1 $2",["80"],"0$1",,1],[,"(\\d{3})(\\d{4,5})","$1 $2",["69"],"0$1",,1],[,"(\\d{4})(\\d{4,6})","$1 $2",["1"],,,1],[,"(\\d{2})(\\d{3})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[69]"],"0$1",,1],[,"(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["[3578]"],"0$1",,1],[,"(\\d{2})(\\d{4})(\\d{4})","$1 $2 $3",["2[48]"],"0$1",,1],[,"(\\d{3})(\\d{4})(\\d{3})","$1 $2 $3",["2"],"0$1",,1]],[[,"(\\d{2})(\\d{5})","$1 $2",["80"],"0$1",,1],[,"(\\d{4})(\\d{4,6})","$1 $2",["1"],,,1],[,"(\\d{2})(\\d{3})(\\d{2})(\\d{2})",
"$1 $2 $3 $4",["[69]"],"0$1",,1],[,"(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["[3578]"],"0$1",,1],[,"(\\d{2})(\\d{4})(\\d{4})","$1 $2 $3",["2[48]"],"0$1",,1],[,"(\\d{3})(\\d{4})(\\d{3})","$1 $2 $3",["2"],"0$1",,1]],[,,,,,,,,,[-1]],,,[,,"[17]99\\d{4}|69\\d{5,6}",,,,,,,[7,8]],[,,"(?:[17]99|80\\d)\\d{4}|69\\d{5,6}",,,,"1992000",,,[7,8]],,,[,,,,,,,,,[-1]]],VU:[,[,,"(?:[23]\\d|[48]8)\\d{3}|(?:[57]\\d|90)\\d{5}",,,,,,,[5,7]],[,,"(?:38[0-8]|48[4-9])\\d\\d|(?:2[02-9]|3[4-7]|88)\\d{3}",,,,"22123",,,[5]],[,,"(?:5\\d|7[013-7])\\d{5}",
,,,"5912345",,,[7]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,"90[1-9]\\d{4}",,,,"9010123",,,[7]],"VU",678,"00",,,,,,,,[[,"(\\d{3})(\\d{4})","$1 $2",["[579]"]]],,[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,"(?:3[03]|900\\d)\\d{3}",,,,"30123"],,,[,,,,,,,,,[-1]]],WF:[,[,,"(?:[45]0|68|72|8\\d)\\d{4}",,,,,,,[6]],[,,"(?:50|68|72)\\d{4}",,,,"501234"],[,,"(?:50|68|72|8[23])\\d{4}",,,,"501234"],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],"WF",681,"00",
,,,,,,,[[,"(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3",["[4-8]"]]],,[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,"[48]0\\d{4}",,,,"401234"]],WS:[,[,,"(?:[2-6]|8\\d{5})\\d{4}|[78]\\d{6}|[68]\\d{5}",,,,,,,[5,6,7,10]],[,,"6[1-9]\\d{3}|(?:[2-5]|60)\\d{4}",,,,"22123",,,[5,6]],[,,"(?:7[235-7]|8(?:[3-7]|9\\d{3}))\\d{5}",,,,"7212345",,,[7,10]],[,,"800\\d{3}",,,,"800123",,,[6]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],"WS",685,"0",,,,,,,,[[,"(\\d{5})","$1",["[2-5]|6[1-9]"]],[,"(\\d{3})(\\d{3,7})",
"$1 $2",["[68]"]],[,"(\\d{2})(\\d{5})","$1 $2",["7"]]],,[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],XK:[,[,,"[23]\\d{7,8}|(?:4\\d\\d|[89]00)\\d{5}",,,,,,,[8,9]],[,,"(?:2[89]|39)0\\d{6}|[23][89]\\d{6}",,,,"28012345"],[,,"4[3-9]\\d{6}",,,,"43201234",,,[8]],[,,"800\\d{5}",,,,"80001234",,,[8]],[,,"900\\d{5}",,,,"90001234",,,[8]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],"XK",383,"00","0",,,"0",,,,[[,"(\\d{3})(\\d{5})","$1 $2",["[89]"],"0$1"],[,"(\\d{2})(\\d{3})(\\d{3})",
"$1 $2 $3",["[2-4]"],"0$1"],[,"(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["[23]"],"0$1"]],,[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],YE:[,[,,"(?:1|7\\d)\\d{7}|[1-7]\\d{6}",,,,,,,[7,8,9],[6]],[,,"78[0-7]\\d{4}|17\\d{6}|(?:[12][2-68]|3[2358]|4[2-58]|5[2-6]|6[3-58]|7[24-6])\\d{5}",,,,"1234567",,,[7,8],[6]],[,,"7[0137]\\d{7}",,,,"712345678",,,[9]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],"YE",967,"00","0",,,"0",,,,[[,"(\\d)(\\d{3})(\\d{3,4})",
"$1 $2 $3",["[1-6]|7[24-68]"],"0$1"],[,"(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["7"],"0$1"]],,[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],YT:[,[,,"80\\d{7}|(?:26|63)9\\d{6}",,,,,,,[9]],[,,"269(?:0[67]|5[0-2]|6\\d|[78]0)\\d{4}",,,,"269601234"],[,,"639(?:0[0-79]|1[019]|[267]\\d|3[09]|[45]0|9[04-79])\\d{4}",,,,"639012345"],[,,"80\\d{7}",,,,"801234567"],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],"YT",262,"00","0",,,"0",,,,,,[,,,,,,,,,[-1]],,"269|63",[,,,,,,
,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],ZA:[,[,,"[1-9]\\d{8}|8\\d{4,7}",,,,,,,[5,6,7,8,9]],[,,"(?:1[0-8]|2[1-378]|3[1-69]|4\\d|5[1346-8])\\d{7}",,,,"101234567",,,[9]],[,,"(?:1(?:3492[0-25]|4495[0235]|549(?:20|5[01]))|4[34]492[01])\\d{3}|8[1-4]\\d{3,7}|(?:2[27]|47|54)4950\\d{3}|(?:1(?:049[2-4]|9[12]\\d\\d)|(?:6\\d|7[0-46-9])\\d{3}|8(?:5\\d{3}|7(?:08[67]|158|28[5-9]|310)))\\d{4}|(?:1[6-8]|28|3[2-69]|4[025689]|5[36-8])4920\\d{3}|(?:12|[2-5]1)492\\d{4}",,,,"711234567"],[,,"80\\d{7}",,,,"801234567",
,,[9]],[,,"(?:86[2-9]|9[0-2]\\d)\\d{6}",,,,"862345678",,,[9]],[,,"860\\d{6}",,,,"860123456",,,[9]],[,,,,,,,,,[-1]],[,,"87(?:08[0-589]|15[0-79]|28[0-4]|31[1-9])\\d{4}|87(?:[02][0-79]|1[0-46-9]|3[02-9]|[4-9]\\d)\\d{5}",,,,"871234567",,,[9]],"ZA",27,"00","0",,,"0",,,,[[,"(\\d{2})(\\d{3,4})","$1 $2",["8[1-4]"],"0$1"],[,"(\\d{2})(\\d{3})(\\d{2,3})","$1 $2 $3",["8[1-4]"],"0$1"],[,"(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["860"],"0$1"],[,"(\\d{2})(\\d{3})(\\d{4})","$1 $2 $3",["[1-9]"],"0$1"]],,[,,,,,,,,,[-1]],
,,[,,,,,,,,,[-1]],[,,"861\\d{6}",,,,"861123456",,,[9]],,,[,,,,,,,,,[-1]]],ZM:[,[,,"(?:63|80)0\\d{6}|(?:21|[79]\\d)\\d{7}",,,,,,,[9],[6]],[,,"21[1-8]\\d{6}",,,,"211234567",,,,[6]],[,,"(?:7[679]|9[5-8])\\d{7}",,,,"955123456"],[,,"800\\d{6}",,,,"800123456"],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,"630\\d{6}",,,,"630012345"],"ZM",260,"00","0",,,"0",,,,[[,"(\\d{3})(\\d{3})","$1 $2",["[1-9]"]],[,"(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["[28]"],"0$1"],[,"(\\d{2})(\\d{7})","$1 $2",["[79]"],"0$1"]],
[[,"(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["[28]"],"0$1"],[,"(\\d{2})(\\d{7})","$1 $2",["[79]"],"0$1"]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],ZW:[,[,,"2(?:[0-57-9]\\d{6,8}|6[0-24-9]\\d{6,7})|[38]\\d{9}|[35-8]\\d{8}|[3-6]\\d{7}|[1-689]\\d{6}|[1-3569]\\d{5}|[1356]\\d{4}",,,,,,,[5,6,7,8,9,10],[3,4]],[,,"(?:1(?:(?:3\\d|9)\\d|[4-8])|2(?:(?:(?:0(?:2[014]|5)|(?:2[0157]|31|84|9)\\d\\d|[56](?:[14]\\d\\d|20)|7(?:[089]|2[03]|[35]\\d\\d))\\d|4(?:2\\d\\d|8))\\d|1(?:2|[39]\\d{4}))|3(?:(?:123|(?:29\\d|92)\\d)\\d\\d|7(?:[19]|[56]\\d))|5(?:0|1[2-478]|26|[37]2|4(?:2\\d{3}|83)|5(?:25\\d\\d|[78])|[689]\\d)|6(?:(?:[16-8]21|28|52[013])\\d\\d|[39])|8(?:[1349]28|523)\\d\\d)\\d{3}|(?:4\\d\\d|9[2-9])\\d{4,5}|(?:(?:2(?:(?:(?:0|8[146])\\d|7[1-7])\\d|2(?:[278]\\d|92)|58(?:2\\d|3))|3(?:[26]|9\\d{3})|5(?:4\\d|5)\\d\\d)\\d|6(?:(?:(?:[0-246]|[78]\\d)\\d|37)\\d|5[2-8]))\\d\\d|(?:2(?:[569]\\d|8[2-57-9])|3(?:[013-59]\\d|8[37])|6[89]8)\\d{3}",
,,,"1312345",,,,[3,4]],[,,"7(?:[17]\\d|[38][1-9])\\d{6}",,,,"712345678",,,[9]],[,,"80(?:[01]\\d|20|8[0-8])\\d{3}",,,,"8001234",,,[7]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,"86(?:1[12]|22|30|44|55|77|8[368])\\d{6}",,,,"8686123456",,,[10]],"ZW",263,"00","0",,,"0",,,,[[,"(\\d{3})(\\d{3,5})","$1 $2",["2(?:0[45]|2[278]|[49]8)|3(?:[09]8|17)|6(?:[29]8|37|75)|[23][78]|(?:33|5[15]|6[68])[78]"],"0$1"],[,"(\\d)(\\d{3})(\\d{2,4})","$1 $2 $3",["[49]"],"0$1"],[,"(\\d{3})(\\d{4})","$1 $2",["80"],"0$1"],
[,"(\\d{2})(\\d{7})","$1 $2",["24|8[13-59]|(?:2[05-79]|39|5[45]|6[15-8])2","2(?:02[014]|4|[56]20|[79]2)|392|5(?:42|525)|6(?:[16-8]21|52[013])|8[13-59]"],"(0$1)"],[,"(\\d{2})(\\d{3})(\\d{4})","$1 $2 $3",["7"],"0$1"],[,"(\\d{3})(\\d{3})(\\d{3,4})","$1 $2 $3",["2(?:1[39]|2[0157]|[378]|[56][14])|3(?:12|29)","2(?:1[39]|2[0157]|[378]|[56][14])|3(?:123|29)"],"0$1"],[,"(\\d{4})(\\d{6})","$1 $2",["8"],"0$1"],[,"(\\d{2})(\\d{3,5})","$1 $2",["1|2(?:0[0-36-9]|12|29|[56])|3(?:1[0-689]|[24-6])|5(?:[0236-9]|1[2-4])|6(?:[013-59]|7[0-46-9])|(?:33|55|6[68])[0-69]|(?:29|3[09]|62)[0-79]"],
"0$1"],[,"(\\d{2})(\\d{3})(\\d{3,4})","$1 $2 $3",["29[013-9]|39|54"],"0$1"],[,"(\\d{4})(\\d{3,5})","$1 $2",["(?:25|54)8","258|5483"],"0$1"]],,[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],800:[,[,,"[1-9]\\d{7}",,,,,,,[8]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,"[1-9]\\d{7}",,,,"12345678"],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],"001",800,,,,,,,,1,[[,"(\\d{4})(\\d{4})","$1 $2",["[1-9]"]]],,[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],
808:[,[,,"[1-9]\\d{7}",,,,,,,[8]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,"[1-9]\\d{7}",,,,"12345678"],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],"001",808,,,,,,,,1,[[,"(\\d{4})(\\d{4})","$1 $2",["[1-9]"]]],,[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],870:[,[,,"[35-7]\\d{8}",,,,,,,[9]],[,,,,,,,,,[-1]],[,,"(?:[356]\\d|7[6-8])\\d{7}",,,,"301234567"],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],"001",870,,,,,,,,,[[,"(\\d{3})(\\d{3})(\\d{3})",
"$1 $2 $3",["[35-7]"]]],,[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],878:[,[,,"10\\d{10}",,,,,,,[12]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,"10\\d{10}",,,,"101234567890"],"001",878,,,,,,,,1,[[,"(\\d{2})(\\d{5})(\\d{5})","$1 $2 $3",["1"]]],,[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],881:[,[,,"[0-36-9]\\d{8}",,,,,,,[9]],[,,,,,,,,,[-1]],[,,"[0-36-9]\\d{8}",,,,"612345678"],[,,,,,,,,,[-1]],[,
,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],"001",881,,,,,,,,,[[,"(\\d)(\\d{3})(\\d{5})","$1 $2 $3",["[0-36-9]"]]],,[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],882:[,[,,"[13]\\d{6}(?:\\d{2,5})?|285\\d{9}|[19]\\d{7}",,,,,,,[7,8,9,10,11,12]],[,,,,,,,,,[-1]],[,,"3(?:37\\d\\d|42)\\d{4}|3(?:2|47|7\\d{3})\\d{7}",,,,"3421234",,,[7,9,10,12]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,"1(?:3(?:0[0347]|[13][0139]|2[035]|4[013568]|6[0459]|7[06]|8[15-8]|9[0689])\\d{4}|6\\d{5,10})|(?:(?:285\\d\\d|3(?:45|[69]\\d{3}))\\d|9[89])\\d{6}",
,,,"390123456789"],"001",882,,,,,,,,,[[,"(\\d{2})(\\d{5})","$1 $2",["16|342"]],[,"(\\d{2})(\\d{2})(\\d{4})","$1 $2 $3",["[19]"]],[,"(\\d{2})(\\d{4})(\\d{3})","$1 $2 $3",["3[23]"]],[,"(\\d{2})(\\d{3,4})(\\d{4})","$1 $2 $3",["1"]],[,"(\\d{2})(\\d{4})(\\d{4})","$1 $2 $3",["34[57]"]],[,"(\\d{3})(\\d{4})(\\d{4})","$1 $2 $3",["34"]],[,"(\\d{2})(\\d{4,5})(\\d{5})","$1 $2 $3",["[1-3]"]]],,[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,"348[57]\\d{7}",,,,"34851234567",,,[11]]],883:[,[,,"51\\d{7}(?:\\d{3})?",
,,,,,,[9,12]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,"51[013]0\\d{8}|5100\\d{5}",,,,"510012345"],"001",883,,,,,,,,1,[[,"(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["510"]],[,"(\\d{3})(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3 $4",["510"]],[,"(\\d{4})(\\d{4})(\\d{4})","$1 $2 $3",["5"]]],,[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]]],888:[,[,,"\\d{11}",,,,,,,[11]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,
,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],"001",888,,,,,,,,1,[[,"(\\d{3})(\\d{3})(\\d{5})","$1 $2 $3"]],,[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,"\\d{11}",,,,"12345678901"],,,[,,,,,,,,,[-1]]],979:[,[,,"[1359]\\d{8}",,,,,,,[9],[8]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,"[1359]\\d{8}",,,,"123456789",,,,[8]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],"001",979,,,,,,,,1,[[,"(\\d)(\\d{4})(\\d{4})","$1 $2 $3",["[1359]"]]],,[,,,,,,,,,[-1]],,,[,,,,,,,,,[-1]],[,,,,,,,,,[-1]],,,[,,,,,,,,
,[-1]]]};/*

 Copyright (C) 2010 The Libphonenumber Authors.

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
*/
function M(){this.a={}}M.c=void 0;M.a=function(){return M.c?M.c:M.c=new M};
var xa={0:"0",1:"1",2:"2",3:"3",4:"4",5:"5",6:"6",7:"7",8:"8",9:"9","\uff10":"0","\uff11":"1","\uff12":"2","\uff13":"3","\uff14":"4","\uff15":"5","\uff16":"6","\uff17":"7","\uff18":"8","\uff19":"9","\u0660":"0","\u0661":"1","\u0662":"2","\u0663":"3","\u0664":"4","\u0665":"5","\u0666":"6","\u0667":"7","\u0668":"8","\u0669":"9","\u06f0":"0","\u06f1":"1","\u06f2":"2","\u06f3":"3","\u06f4":"4","\u06f5":"5","\u06f6":"6","\u06f7":"7","\u06f8":"8","\u06f9":"9"},ya={0:"0",1:"1",2:"2",3:"3",4:"4",5:"5",6:"6",
7:"7",8:"8",9:"9","\uff10":"0","\uff11":"1","\uff12":"2","\uff13":"3","\uff14":"4","\uff15":"5","\uff16":"6","\uff17":"7","\uff18":"8","\uff19":"9","\u0660":"0","\u0661":"1","\u0662":"2","\u0663":"3","\u0664":"4","\u0665":"5","\u0666":"6","\u0667":"7","\u0668":"8","\u0669":"9","\u06f0":"0","\u06f1":"1","\u06f2":"2","\u06f3":"3","\u06f4":"4","\u06f5":"5","\u06f6":"6","\u06f7":"7","\u06f8":"8","\u06f9":"9",A:"2",B:"2",C:"2",D:"3",E:"3",F:"3",G:"4",H:"4",I:"4",J:"5",K:"5",L:"5",M:"6",N:"6",O:"6",P:"7",
Q:"7",R:"7",S:"7",T:"8",U:"8",V:"8",W:"9",X:"9",Y:"9",Z:"9"},N=/^[+\uff0b]+/,za=/([0-9\uff10-\uff19\u0660-\u0669\u06f0-\u06f9])/,Aa=/[+\uff0b0-9\uff10-\uff19\u0660-\u0669\u06f0-\u06f9]/,Ba=/[\\\/] *x/,Ca=/[^0-9\uff10-\uff19\u0660-\u0669\u06f0-\u06f9A-Za-z#]+$/,Da=/(?:.*?[A-Za-z]){3}.*/,Ea=/(?:;ext=([0-9\uff10-\uff19\u0660-\u0669\u06f0-\u06f9]{1,7})|[ \u00a0\t,]*(?:e?xt(?:ensi(?:o\u0301?|\u00f3))?n?|\uff45?\uff58\uff54\uff4e?|\u0434\u043e\u0431|[;,x\uff58#\uff03~\uff5e]|int|anexo|\uff49\uff4e\uff54)[:\.\uff0e]?[ \u00a0\t,-]*([0-9\uff10-\uff19\u0660-\u0669\u06f0-\u06f9]{1,7})#?|[- ]+([0-9\uff10-\uff19\u0660-\u0669\u06f0-\u06f9]{1,5})#)$/i,
Fa=/^[0-9\uff10-\uff19\u0660-\u0669\u06f0-\u06f9]{2}$|^[+\uff0b]*(?:[-x\u2010-\u2015\u2212\u30fc\uff0d-\uff0f \u00a0\u00ad\u200b\u2060\u3000()\uff08\uff09\uff3b\uff3d.\[\]/~\u2053\u223c\uff5e*]*[0-9\uff10-\uff19\u0660-\u0669\u06f0-\u06f9]){3,}[-x\u2010-\u2015\u2212\u30fc\uff0d-\uff0f \u00a0\u00ad\u200b\u2060\u3000()\uff08\uff09\uff3b\uff3d.\[\]/~\u2053\u223c\uff5e*A-Za-z0-9\uff10-\uff19\u0660-\u0669\u06f0-\u06f9]*(?:;ext=([0-9\uff10-\uff19\u0660-\u0669\u06f0-\u06f9]{1,7})|[ \u00a0\t,]*(?:e?xt(?:ensi(?:o\u0301?|\u00f3))?n?|\uff45?\uff58\uff54\uff4e?|\u0434\u043e\u0431|[;,x\uff58#\uff03~\uff5e]|int|anexo|\uff49\uff4e\uff54)[:\.\uff0e]?[ \u00a0\t,-]*([0-9\uff10-\uff19\u0660-\u0669\u06f0-\u06f9]{1,7})#?|[- ]+([0-9\uff10-\uff19\u0660-\u0669\u06f0-\u06f9]{1,5})#)?$/i,
Ga=/(\$\d)/;function Ha(a){var b=a.search(Aa);0<=b?(a=a.substring(b),a=a.replace(Ca,""),b=a.search(Ba),0<=b&&(a=a.substring(0,b))):a="";return a}function Ia(a){return 2>a.length?!1:O(Fa,a)}function Ja(a){return O(Da,a)?P(a,ya):P(a,xa)}function Ka(a){var b=Ja(a.toString());a.c="";a.a(b)}function La(a){return null!=a&&(1!=A(a,9)||-1!=w(a,9)[0])}function P(a,b){for(var c=new F,d,e=a.length,f=0;f<e;++f)d=a.charAt(f),d=b[d.toUpperCase()],null!=d&&c.a(d);return c.toString()}
function Q(a){return null!=a&&isNaN(a)&&a.toUpperCase()in wa}
function Ma(a,b,c){if(0==t(b,2)&&null!=b.a[5]){var d=y(b,5);if(0<d.length)return d}d=y(b,1);var e=R(b);if(0==c)return Na(d,0,e,"");if(!(d in K))return e;a=S(a,d,T(d));b=null!=b.a[3]&&0!=t(b,3).length?3==c?";ext="+t(b,3):null!=a.a[13]?t(a,13)+y(b,3):" ext. "+y(b,3):"";a:{a=0==w(a,20).length||2==c?w(a,19):w(a,20);for(var f,g=a.length,h=0;h<g;++h){f=a[h];var l=A(f,3);if(0==l||0==e.search(t(f,3,l-1)))if(l=new RegExp(t(f,1)),O(l,e)){a=f;break a}}a=null}null!=a&&(g=a,a=y(g,2),f=new RegExp(t(g,1)),y(g,5),
g=y(g,4),e=2==c&&null!=g&&0<g.length?e.replace(f,a.replace(Ga,g)):e.replace(f,a),3==c&&(e=e.replace(/^[-x\u2010-\u2015\u2212\u30fc\uff0d-\uff0f \u00a0\u00ad\u200b\u2060\u3000()\uff08\uff09\uff3b\uff3d.\[\]/~\u2053\u223c\uff5e]+/,""),e=e.replace(/[-x\u2010-\u2015\u2212\u30fc\uff0d-\uff0f \u00a0\u00ad\u200b\u2060\u3000()\uff08\uff09\uff3b\uff3d.\[\]/~\u2053\u223c\uff5e]+/g,"-")));return Na(d,c,e,b)}function S(a,b,c){return"001"==c?U(a,""+b):U(a,c)}
function R(a){if(null==a.a[2])return"";var b=""+t(a,2);return null!=a.a[4]&&t(a,4)&&0<y(a,8)?Array(y(a,8)+1).join("0")+b:b}function Na(a,b,c,d){switch(b){case 0:return"+"+a+c+d;case 1:return"+"+a+" "+c+d;case 3:return"tel:+"+a+"-"+c+d;default:return c+d}}
function V(a,b){switch(b){case 4:return t(a,5);case 3:return t(a,4);case 1:return t(a,3);case 0:case 2:return t(a,2);case 5:return t(a,6);case 6:return t(a,8);case 7:return t(a,7);case 8:return t(a,21);case 9:return t(a,25);case 10:return t(a,28);default:return t(a,1)}}function W(a,b){return X(a,t(b,1))?X(a,t(b,5))?4:X(a,t(b,4))?3:X(a,t(b,6))?5:X(a,t(b,8))?6:X(a,t(b,7))?7:X(a,t(b,21))?8:X(a,t(b,25))?9:X(a,t(b,28))?10:X(a,t(b,2))?t(b,18)||X(a,t(b,3))?2:0:!t(b,18)&&X(a,t(b,3))?1:-1:-1}
function U(a,b){if(null==b)return null;b=b.toUpperCase();var c=a.a[b];if(null==c){c=wa[b];if(null==c)return null;c=(new E).a(I.f(),c);a.a[b]=c}return c}function X(a,b){var c=a.length;return 0<A(b,9)&&-1==p(w(b,9),c)?!1:O(y(b,2),a)}
function Oa(a,b){if(null==b)return null;var c=y(b,1);c=K[c];if(null==c)a=null;else if(1==c.length)a=c[0];else a:{b=R(b);for(var d,e=c.length,f=0;f<e;f++){d=c[f];var g=U(a,d);if(null!=g.a[23]){if(0==b.search(t(g,23))){a=d;break a}}else if(-1!=W(b,g)){a=d;break a}}a=null}return a}function T(a){a=K[a];return null==a?"ZZ":a[0]}
function Y(a,b,c,d){var e=V(c,d),f=0==A(e,9)?w(t(c,1),9):w(e,9);e=w(e,10);if(2==d)if(La(V(c,0)))a=V(c,1),La(a)&&(f=f.concat(0==A(a,9)?w(t(c,1),9):w(a,9)),q(f),0==e.length?e=w(a,10):(e=e.concat(w(a,10)),q(e)));else return Y(a,b,c,1);if(-1==f[0])return 5;b=b.length;if(-1<p(e,b))return 4;c=f[0];return c==b?0:c>b?2:f[f.length-1]<b?3:-1<p(f,b,1)?0:5}function Pa(a,b){var c=R(b);b=y(b,1);if(!(b in K))return 1;b=S(a,b,T(b));return Y(a,c,b,-1)}
function Qa(a,b,c,d,e,f){if(0==b.length)return 0;b=new F(b);var g;null!=c&&(g=t(c,11));null==g&&(g="NonMatch");var h=b.toString();if(0==h.length)g=20;else if(N.test(h))h=h.replace(N,""),b.c="",b.a(Ja(h)),g=1;else{h=new RegExp(g);Ka(b);g=b.toString();if(0==g.search(h)){h=g.match(h)[0].length;var l=g.substring(h).match(za);l&&null!=l[1]&&0<l[1].length&&"0"==P(l[1],xa)?g=!1:(b.c="",b.a(g.substring(h)),g=!0)}else g=!1;g=g?5:20}e&&u(f,6,g);if(20!=g){if(2>=b.c.length)throw Error("Phone number too short after IDD");
a:{a=b.toString();if(0!=a.length&&"0"!=a.charAt(0))for(e=a.length,b=1;3>=b&&b<=e;++b)if(c=parseInt(a.substring(0,b),10),c in K){d.a(a.substring(b));d=c;break a}d=0}if(0!=d)return u(f,1,d),d;throw Error("Invalid country calling code");}if(null!=c&&(g=y(c,10),h=""+g,l=b.toString(),0==l.lastIndexOf(h,0)&&(h=new F(l.substring(h.length)),l=t(c,1),l=new RegExp(y(l,2)),Ra(h,c,null),h=h.toString(),!O(l,b.toString())&&O(l,h)||3==Y(a,b.toString(),c,-1))))return d.a(h),e&&u(f,6,10),u(f,1,g),g;u(f,1,0);return 0}
function Ra(a,b,c){var d=a.toString(),e=d.length,f=t(b,15);if(0!=e&&null!=f&&0!=f.length){var g=new RegExp("^(?:"+f+")");if(e=g.exec(d)){f=new RegExp(y(t(b,1),2));var h=O(f,d),l=e.length-1;b=t(b,16);if(null==b||0==b.length||null==e[l]||0==e[l].length){if(!h||O(f,d.substring(e[0].length)))null!=c&&0<l&&null!=e[l]&&c.a(e[1]),a.set(d.substring(e[0].length))}else if(d=d.replace(g,b),!h||O(f,d))null!=c&&0<l&&c.a(e[1]),a.set(d)}}}
function Z(a,b,c){if(!Q(c)&&0<b.length&&"+"!=b.charAt(0))throw Error("Invalid country calling code");return Sa(a,b,c,!0)}
function Sa(a,b,c,d){if(null==b)throw Error("The string supplied did not seem to be a phone number");if(250<b.length)throw Error("The string supplied is too long to be a phone number");var e=new F,f=b.indexOf(";phone-context=");if(0<=f){var g=f+15;if("+"==b.charAt(g)){var h=b.indexOf(";",g);0<h?e.a(b.substring(g,h)):e.a(b.substring(g))}g=b.indexOf("tel:");e.a(b.substring(0<=g?g+4:0,f))}else e.a(Ha(b));f=e.toString();g=f.indexOf(";isub=");0<g&&(e.c="",e.a(f.substring(0,g)));if(!Ia(e.toString()))throw Error("The string supplied did not seem to be a phone number");
f=e.toString();if(!(Q(c)||null!=f&&0<f.length&&N.test(f)))throw Error("Invalid country calling code");f=new J;d&&u(f,5,b);a:{b=e.toString();g=b.search(Ea);if(0<=g&&Ia(b.substring(0,g))){h=b.match(Ea);for(var l=h.length,z=1;z<l;++z)if(null!=h[z]&&0<h[z].length){e.c="";e.a(b.substring(0,g));b=h[z];break a}}b=""}0<b.length&&u(f,3,b);g=U(a,c);b=new F;h=0;l=e.toString();try{h=Qa(a,l,g,b,d,f)}catch(L){if("Invalid country calling code"==L.message&&N.test(l)){if(l=l.replace(N,""),h=Qa(a,l,g,b,d,f),0==h)throw L;
}else throw L;}0!=h?(e=T(h),e!=c&&(g=S(a,h,e))):(Ka(e),b.a(e.toString()),null!=c?(h=y(g,10),u(f,1,h)):d&&(delete f.a[6],f.c&&delete f.c[6]));if(2>b.c.length)throw Error("The string supplied is too short to be a phone number");null!=g&&(c=new F,e=new F(b.toString()),Ra(e,g,c),a=Y(a,e.toString(),g,-1),2!=a&&4!=a&&5!=a&&(b=e,d&&0<c.toString().length&&u(f,7,c.toString())));d=b.toString();a=d.length;if(2>a)throw Error("The string supplied is too short to be a phone number");if(17<a)throw Error("The string supplied is too long to be a phone number");
if(1<d.length&&"0"==d.charAt(0)){u(f,4,!0);for(a=1;a<d.length-1&&"0"==d.charAt(a);)a++;1!=a&&u(f,8,a)}u(f,2,parseInt(d,10));return f}function O(a,b){return(a="string"==typeof a?b.match("^(?:"+a+")$"):b.match(a))&&a[0].length==b.length?!0:!1};m("intlTelInputUtils",{});m("intlTelInputUtils.formatNumber",function(a,b,c){try{var d=M.a(),e=Z(d,a,b),f=Pa(d,e);return 0==f||4==f?Ma(d,e,"undefined"==typeof c?0:c):a}catch(g){return a}});m("intlTelInputUtils.getExampleNumber",function(a,b,c){try{var d=M.a();a:{if(Q(a)){var e=V(U(d,a),c);try{if(null!=e.a[6]){var f=t(e,6);var g=Sa(d,f,a,!1);break a}}catch(h){}}g=null}return Ma(d,g,b?2:1)}catch(h){return""}});m("intlTelInputUtils.getExtension",function(a,b){try{return t(Z(M.a(),a,b),3)}catch(c){return""}});
m("intlTelInputUtils.getNumberType",function(a,b){try{var c=M.a();var d=Z(c,a,b),e=Oa(c,d),f=S(c,y(d,1),e);if(null==f)var g=-1;else{var h=R(d);g=W(h,f)}return g}catch(l){return-99}});
m("intlTelInputUtils.getValidationError",function(a,b){try{var c=M.a(),d=Z(c,a,b);return Pa(c,d)}catch(e){return"Invalid country calling code"==e.message?1:"Phone number too short after IDD"==e.message||"The string supplied is too short to be a phone number"==e?2:"The string supplied is too long to be a phone number"==e.message?3:-99}});
m("intlTelInputUtils.isValidNumber",function(a,b){try{var c=M.a(),d=Z(c,a,b);var e=Oa(c,d),f=y(d,1),g=S(c,f,e),h;if(!(h=null==g)){var l;if(l="001"!=e){var z=U(c,e);if(null==z)throw Error("Invalid region code: "+e);var L=y(z,10);l=f!=L}h=l}if(h)var va=!1;else{var Ta=R(d);va=-1!=W(Ta,g)}return va}catch(Ua){return!1}});m("intlTelInputUtils.numberFormat",{E164:0,INTERNATIONAL:1,NATIONAL:2,RFC3966:3});
m("intlTelInputUtils.numberType",{FIXED_LINE:0,MOBILE:1,FIXED_LINE_OR_MOBILE:2,TOLL_FREE:3,PREMIUM_RATE:4,SHARED_COST:5,VOIP:6,PERSONAL_NUMBER:7,PAGER:8,UAN:9,VOICEMAIL:10,UNKNOWN:-1});m("intlTelInputUtils.validationError",{IS_POSSIBLE:0,INVALID_COUNTRY_CODE:1,TOO_SHORT:2,TOO_LONG:3,IS_POSSIBLE_LOCAL_ONLY:4,INVALID_LENGTH:5});})();

class Offers {
  // add hasMarkDown flag instead of markDown type

  static promptTenancyOffer(listing, item, itemSecurityDeposit, callback) {
    if (!itemSecurityDeposit) {
      itemSecurityDeposit = 0;
    }
    var submitButton = null;  // populated when modal opens.
    var financial = JSON.parse(JSON.stringify(item['rent_payments']));

    // TODO(sami): Default to items if yearly is not set.
    var yearlyValue;
    var currency;
    if (item['yearly_rent_value'] && item['yearly_rent_value']['value'] > 0) {
      yearlyValue = item['yearly_rent_value']['value'];
      currency = item['yearly_rent_value']['currency'] || 'AED';
    } else {
      yearlyValue = (item['annual_market_rent'] && item['annual_market_rent']['value']) ?
        item['annual_market_rent']['value'] : 0;
      currency = (item['annual_market_rent'] && item['annual_market_rent']['currency']) ?
        item['annual_market_rent']['currency'] : 'AED';
    }

    var contractDurationQuantity = item['duration'] ?
      item['duration']['number'] :
      (listing['duration'] ? listing['duration']['number'] : 0);
    var contractDurationPeriod = item['duration'] ?
      item['duration']['period'] :
      listing['duration']['period'];

    const periodsPerAnnum = {
      'year': 1,
      'quarter': 4,
      'month': 12,
      'day': 365,
    };
    var installmentChoices = [];
    financial.forEach(record => {
      if (periodsPerAnnum[contractDurationPeriod.toLowerCase()] > periodsPerAnnum[record['frequency']]) {
        // If contract is daily, cannot pay yearly.
        return;
      }
      // 
      var periodRatio = periodsPerAnnum[record['frequency']] / periodsPerAnnum[contractDurationPeriod.toLowerCase()];

      record['currency'] = currency;

      var installmentYearlyAmount = yearlyValue;
      if (record['amount_type'] == 'specified_amount') {
        installmentYearlyAmount = record['more_than_annual'];
      } else if (record['amount_type'] == 'fixed_more') {
        installmentYearlyAmount += record['more_than_annual'];
      } else if (record['amount_type'] == 'percent_more') {
        installmentYearlyAmount *= 1 + (record['more_than_annual'] / 100.0);
      }

      var installmentAmount = installmentYearlyAmount / periodRatio;
      var numberOfPayments = contractDurationQuantity * periodRatio;
      var paymentsStr = [
        'Rent to be paid over ', Math.ceil(numberOfPayments), ' payment',
        ' (once per ', record['frequency'], '), each with average amount ', Math.round((100 * installmentAmount) / 100), ' ', currency, ', totalling to ', Math.round((numberOfPayments * installmentAmount * 100) / 100), ' ', currency];
      if (numberOfPayments > 1) {
        paymentsStr[2] += 's';
      }
      // installmentChoices.push({
      //   'd': paymentsStr.join(''),
      //   'n': record['frequency'],
      // });
      installmentChoices.push({
        'd': `${Math.ceil(numberOfPayments)} ${'Payment'}${numberOfPayments > 1 ? 's' : ''}`,
        'n': record['frequency'],
        'content': paymentsStr.join(''),
        'value': Math.round((100 * installmentAmount) / 100),
        'currency': currency
      });
    });

    var values = {
      'financial_offer': financial,
      'security_deposit': { 'value': itemSecurityDeposit, 'currency': currency },
      'intro':
        `<div style="font-size: 15px; margin-bottom: -15px; margin-top: -15px; cursor:unset">
        <span>Dear landlord</span>
        <div>
          <span>I would like to offer you on the below property details</span>
          <table class="table table-bordered table-hover mt-2">
            <tr style="line-height: 13px;">
              <td>Property Name</td>
              <td class="font-weight-bold">${item.name && typeof (item.name) != 'object' ? item.name : ''}</td>
            </tr>
            <tr style="line-height: 13px;">
              <td>Property No.</td>
              <td class="font-weight-bold">${item.property_number && typeof (item.property_number) != 'object' ? item.property_number : ''}</td>
            </tr>
            <tr style="line-height: 13px;">
              <td>Unit Number</td>
              <td class="font-weight-bold">${item.unit_number && typeof (item.unit_number) != 'object' ? item.unit_number : ''}</td>
            </tr>
            <tr style="line-height: 13px;">
              <td>Permises Number</td>
              <td class="font-weight-bold">${item.premise_number && typeof (item.premise_number) != 'object' ? item.premise_number : ''}</td>
            </tr>
          </table>
        </div>
      </div>`
    };

    var schema = subFields(
      WIRE.schemaManager.schema['tenancy_offer'],
      ['behalf', 'intro', 'movein_date', 'notes', 'security_deposit', 'rent_installments', /*'financial_offer',*/],
      true /*copy*/);
    /*if (!listing['is_rent_negotiable']) {
      var amountField = getField(getField(schema['fields'], 'financial_offer')['fields'], 'amount');
      amountField['readonly'] = 1
    }*/
    var fieldDict = SchemaManager.fieldsDict(schema['fields']);
    fieldDict["movein_date"]["validate_fn"] = "(f, v) => v? '' : 'Field is required'";
    //TODO: Above value should be amended on schema.json
    // fieldDict['rent_installments']['choices'] = installmentChoices;
    fieldDict['rent_installments']['t'] = 'tenantofferpayments';
    fieldDict['rent_installments']['d'] = installmentChoices.length > 1 ?
      'Choose the number of payments' : '';
    fieldDict['rent_installments']['tabs'] = installmentChoices;
    fieldDict['rent_installments']['is_rent_negotiable'] = item['is_rent_negotiable'];

    var formId = 'tenantoffer-' + Guid.generate();

    var modalDom = $(`
      <div>
        <div id="input"></div>
        <div id="output"></div>
      </div>`);

    var lastRentValues = {};  // Only invokes server calculation if these values change.

    var onValuesChange = function () {
      var offerValues = WIRE.editableObjects[formId].getValues(true);
      if (!offerValues) {
        return;
      }
      if (!offerValues['rent_installments']) {
        return;
      }
      if (!offerValues['movein_date']) {
        return;
      }


      if (lastRentValues['movein_date'] == offerValues['movein_date'] &&
        lastRentValues['rent_installments'] == offerValues['rent_installments']) {
        return;
      }

      if (!mouseUp) {
        return;
      }

      lastRentValues['movein_date'] = offerValues['movein_date'];
      lastRentValues['rent_installments'] = offerValues['rent_installments'];
      if (submitButton) {
        submitButton.attr('disabled', false);
      }

      var paymentsInfo = offerValues['rent_installments'];
      if (paymentsInfo['suggestedPayment']) {
        offerValues['tenant_negotiated_rate'] = Number(paymentsInfo['tenant_negotiated_rate']);
      }
      offerValues['rent_installments'] = paymentsInfo['frequency'];

      var outputDiv = modalDom.find('div#output');
      var calcPaymentsArgs = {
        'contract_duration': [contractDurationQuantity, contractDurationPeriod],
        'yearly_value': { 'value': yearlyValue, 'currency': currency },
        'installments': financial.filter(r => r['frequency'] == offerValues['rent_installments'])[0],
        'movein_date': offerValues['movein_date'],
        'security_deposit_percent': item['security_deposit_percent'] || 0,
        'security_deposit_fixed': item['security_deposit_fixed'] ?
          (Number(item['security_deposit_fixed']) ? Number(item['security_deposit_fixed']) :
            (Number(item['security_deposit_fixed']['value']) || 0)) : 0,
        'tenant_negotiated_rate': Number(paymentsInfo['tenant_negotiated_rate'])
      };
      WIRE.callWithCache('public::calculate_rent_payments', calcPaymentsArgs, function (calculatedPayments) {
        calculatedPayments = JSON.parse(JSON.stringify(calculatedPayments));  // Deep copy.
        console.log('response of calculate_rent_payments');
        console.log(calculatedPayments);
        submitButton.attr('disabled', false);

        calculatedPayments['payments'].forEach(payment => {
          //var dayObj = parseIntDay(payment['day'])
          payment['due'] = 'At contract signing';//[dayObj.year, dayObj.month, dayObj.day].join('-');
          payment['value_cur'] = [payment['value'], payment['currency']].join(' ');
          payment['for'] = 'Rent';
        });
        calculatedPayments['payments'].splice(0, 0, {
          'due': 'At offer acceptance',
          'value_cur': [itemSecurityDeposit, currency].join(' '),
          'for': 'Security Deposit',
        });
        // calculatedPayments['payments'].push({
        //   'due': 'after move-out inspection',
        //   'value_cur': [-itemSecurityDeposit, currency].join(' '),
        //   'for': 'Security Deposit Refund',
        // });
        // Render read-only value.
        var outputDivTemp = $(`<div id="output"></div>`);
        EditableTableField.renderReadOnlyValue(outputDivTemp, calculatedPayments['payments'], {
          "t": "table",
          "show_thead": true,
          "fields": [
            { "n": "due", "d": "Payment due" },
            { "n": "for", "d": "Description" },
            { "n": "value_cur", "d": "Amount" },
          ],
        });
        outputDiv.replaceWith(outputDivTemp);
        // Auto scroll the containing modal to bottom, 
        // after rendering the above table
        modalDom.parent('.modal-body').animate({
          scrollTop: modalDom.find('#output').offset().top
        });

        // var modalBody = modalDom.parent('.modal-body');
        // modalBody.animate({ scrollTop: modalBody.prop("scrollHeight")}, 1000);
      });
    };


    var editableObject = u('EditableObject', [formId, schema, values, onValuesChange]);
    WIRE.unrollRecursive(editableObject, $(modalDom.find('div#input')[0]));
    var modal;
    var modalButtons = [{
      label: "Submit Offer",
      color: "btn-primary",
      onClick: function () {
        var offer = WIRE.getEditableValues(formId);

        var paymentsInfo = offer['rent_installments'];
        if (paymentsInfo['suggestedPayment']) {
          // offer['installment_amount'] = Number(offer['rent_installments']['value']);
          offer['tenant_negotiated_rate'] = Number(paymentsInfo['tenant_negotiated_rate']);
        }
        offer['rent_installments'] = paymentsInfo['frequency'];

        offer['item'] = '!obj!' + item._id;
        offer['listing'] = '!obj!' + listing._id;
        WIRE.callWithSpinner('business::make_tenancy_offer', offer, function (response) {
          if (response['msg']) {
            // User has been alerted.
            modal.close();
          }
        });
      }
    }];
    modal = Specto.ui.Modal.showModal(
      modalDom,
      'Make Offer to Lease Property',
      modalButtons,
      { sizeMode: "full" });
    submitButton = modal.modalButtons[0];
    submitButton.attr('disabled', true);

    // prevent rendering "installments table"
    // while changing ionSlider values
    var mouseUp = 1;
    var ionSlidrInstance = modal.modalContainer.find('.slider-input').data('ionRangeSlider');
    ionSlidrInstance.options.onChange = function (data) {
      mouseUp = 0;
    };
    ionSlidrInstance.options.onFinish = function (data) {
      mouseUp = 1;
      onValuesChange();
    };

    onValuesChange();
  }

  /*

  static refreshTerms($scope, readonly) {
    debugger;
    var refreshTermUI = function (term) {
      if (term.type == "markDown" || term.type == "SecurityDeposit") {
        var markdownTerm = $scope.terms[term.id] || {};
        var value = markdownTerm.value || {};
        var text = value.text || "";
        //if(jqTerm.length){
          if(readonly){
            var converter = new showdown.Converter(),
            html = converter.makeHtml(text);
            $scope.dom.find("#showdown_"+ term.id).html(html);
          }
          else{
            $scope.markDowns = $scope.markDowns || {};
            if (!$scope.markDowns[term.id])
              $scope.markDowns[term.id] = new SimpleMDE({ element: $scope.dom.find("#markdown_"+ term.id)[0] });
              $scope.markDowns[term.id].value(value.text);
          }
        //}
      }
    };
    
    $.each($scope.offerCall.smart_offer_terms, function (id, smartTerm) {
      if($scope.terms[id]){
      $scope.terms[id].value = $.extend({}, $scope.terms[id].value, smartTerm);
      $scope.terms[id].active = true;
      var term = $scope.terms[id];
      setTimeout(() => {
        refreshTermUI(term);
      }, 10);
    }
    else{
      delete $scope.offerCall.smart_offer_terms[id];
      debugger;
    }
    });
    $scope.$applyAsync();
 
  }

  static showOfferCallPopup(offerCall) {
    var modal = {};
    offerCall = offerCall || {};
    console.log("offer call: {0}", JSON.stringify(offerCall));
    var viewScope = {};
    //debugger;
    var modalButtons = [
      {
        label: "Save & Close",
        onClick: function() {
          saveOfferSettings(true);
          modal.close();
        },
        color: "btn btn-primary"
      }
    ];

    modal = WIRE.modal(
      "Offer Settings",
      u("Form", [
        "",
        [
          u("AJS", [
            "call_for_offers",
            offerCall,
            function(scope) {
              viewScope = scope;
            }
          ])
        ]
      ]),
      modalButtons,
      { sizeMode:"xLarge" }
    );

    function saveOfferSettings(withClose) {
      //debugger;
      offerCall = viewScope.getValue();
      WIRE.purgeObject(offerCall);
      WIRE.call("business::save_offer_call", offerCall, function() {
        // WIRE.informModal(
        //   "Smart offer terms is successfully saved",
        //   null,
        //   function(modal) {
        //     if (withClose) {
        //       modal.closeAll();
        //     } else {
        //       modal.close();
        //     }
        //   }
        // );
      });
    }
  }

  static renderOfferCall(offerCall, renderOnJq) {
    var viewScope = {};
    WIRE.renderAJS(renderOnJq, "call_for_offers_view", offerCall, scope => {
      viewScope = scope;
    });
  }
}

Offers.terms = {
  SecurityDeposit: {
    order: -1,
    agreeRequired: true,
    id: "SecurityDeposit",
    type: "SecurityDeposit",
    title: "Security Deposit",
    iconClass: "fa fa-lock",
    value: {
      amount: 0,
      currency: "AED",
      text:
        `
The security deposit will be held in a separate bank account, owned by the landlord, called "Security Deposit Account". After termination of contract, tenant will receive the security deposit in full, minus costs incurred by the tenant including, but not limited to:

* Unpaid rent.
* Early termination fees, if applicable.
* Damage on the property (other than normal wear and tear).
* Unpaid government bills, including internet, water, and electricty bills.

`
    },
    required: true

  },
  ContractDuration: {
    order: 0,
    agreeRequired: true,
    id: "ContractDuration",
    type: "ContractDuration",
    title: "Duration of Contract",
    iconClass: "fa fa-clock-o",
    required: true,
    value: {
      quantity: 1,
      unit: "Year"
    }
  },
  Rent: {
    order: 1,
    agreeRequired: false,
    id: "Rent",
    title: "Rent",
    type: "Rent",
    iconClass: "fa fa-home",
    value: { feesDetails: [] },
    required: true
  },
  Termination: {
    order: 2,
    agreeRequired: true,
    id: "Termination",
    title: "Termination",
    type: "Termination",
    iconClass: "fa fa-user-times",
    value: {
      renewal: {
        fee: 0,
        currency: "AED",
        notify_quantity: 1,
        notify_unit: "Month",
        apply_quantity: 2,
        apply_unit: "Month"
      },
      extension: {
        fee: 0,
        currency: "AED",
        notify_quantity: 1,
        notify_unit: "Month",
        apply_quantity: 2,
        apply_unit: "Month"
      },
      earlyTermination: {
        quantity: 2,
        unit: "Month"
      },
      breakLease: {}
    },
    required: true
  },
  Swimming: {
    order: 3,
    agreeRequired: true,
    id: "Swimming",
    title: "Swimming",
    type: "markDown",
    iconClass: "fa fa-tint",
    value: {
      text:
        `
Swimming pool is for use of tenants. There are no life guards on duty.
No unaccompanied kids under the age of 14.
The landlord is not liable for any injuries related to the use of the pool.
Use the pool at your own risk.
`,
    }
  },
  Gym: {
    order: 4,
    agreeRequired: true,
    id: "Gym",
    title: "Gym",
    type: "markDown",
    iconClass: "fa fa-trophy",
    value: {
      text:
        `
Gym is for use of tenants.
No unaccompanied kids under the age of 14.
The landlord is not liable for any injuries related to the use of the gym.
Use the gym at your own risk.
`
    }
  },
  SmartKey: {
    order: 5,
    agreeRequired: true,
    id: "SmartKey",
    title: "Smart Key",
    type: "SmartKey",
    iconClass: "fa fa-key",
    value: {canAssign: false}
  },
  NumberOfOccupants: {
    order: 6,
    agreeRequired: true,
    id: "NumberOfOccupants",
    title: "Number of Occupants",
    type: "NumberofOccupants",
    iconClass: "fa fa-users",
    value: { maxQuantity: 0 }
  },
  PetsNoPets: {
    order: 7,
    agreeRequired: false,
    id: "PetsNoPets",
    title: "Pets / No Pets",
    type: "Pets",
    iconClass: "fa fa-paw",
    value: { allowPets: false, PetsDetails: [] }
  },
  Sublease: {
    order: 8,
    agreeRequired: true,
    id: "Sublease",
    title: "Sub-lease",
    type: "Sublease",
    iconClass: "fa fa-file-o",
    value: { isAllowed: false }
  },
  // ServiceContracts: {
  //   order: 9,
  //   id: "ServiceContracts",
  //   title: "Service Contracts",
  //   type: "markDown",
  //   iconClass: "fa fa-wrench",
  //   value: {}
  // },
  MasterTenant: {
    order: 10,
    agreeRequired: true,
    id: "MasterTenant",
    title: "Master Tenant",
    type: "MasterTenant",
    iconClass: "fa fa-user",
    value: {
      allowEquip: false,
      allowOccupy: false,
      allowSignupTransportation: false,
      allowSignupCatering: false,
    }
  }
  */
}

class Dashboard {
  constructor(tabsData) {
    this.tabsData = tabsData;
  }

  render(container, chosenWallet = '') {
    container.addClass('js-page-content');

    var colors = [{ 'color1': '#967bbd', 'color2': '#e9ecef' },
    { 'color1': '#2196F3', 'color2': '#e9ecef' },
    { 'color1': '#ffca5b', 'color2': '#e9ecef' },
    { 'color1': '#21dfcb', 'color2': '#e9ecef' },
    { 'color1': '#6e4e9e', 'color2': '#e9ecef' },
    { 'color1': '#1ab3a3', 'color2': '#e9ecef' },
    { 'color1': '#fd3995', 'color2': '#e9ecef' },
    { 'color1': '#ffc241', 'color2': '#e9ecef' },
    { 'color1': '#ff0000', 'color2': '#e9ecef' },
    { 'color1': '#00e600', 'color2': '#e9ecef' },
    { 'color1': '#ff0066', 'color2': '#e9ecef' },
    { 'color1': '#24a89b', 'color2': '#e9ecef' },
    ];

    var walletsDisplay = 'panels'; // panels, tabs

    window.isSmallDevice = window.matchMedia('(max-width: 767.98px)').matches ? true : false;

    (Object.keys(this.tabsData) || []).forEach(function (tabKey, index) {
      var element = this.tabsData[tabKey];
      var tabWalletName = tabKey.split('_')[0];
      var isWalletChosen = chosenWallet ?
        tabWalletName.trimAll().toLowerCase() == chosenWallet.trimAll().toLowerCase() :
        true;
      if (element && isWalletChosen) {
        var tabWalletNameUIId = tabWalletName.trimAll().replaceAll(':', '-');

        var walletPanelContent = container.find(`#${tabWalletNameUIId}.wallet-dashboard-container`);

        if (!walletPanelContent || !walletPanelContent.length) {
          switch (walletsDisplay) {
            case 'tabs':
              var navTabs = container.find('.dashborad-wallets-tabs');
              var navTabsContent = container.find('.dashborad-wallets-tabs-content');
              if (!navTabs || !navTabs.length) {
                var navTabs = $(`<ul class="nav nav-tabs dashborad-wallets-tabs" role="tablist"></ul>`)
                  .appendTo(container);
                navTabsContent = $(`<div class="tab-content border border-top-0 p-3 dashborad-wallets-tabs-content"></div>`)
                  .appendTo(container);
              }
              var walletNavTabContent = navTabsContent.find(`.tab-pane#${tabWalletNameUIId}`);
              if (!walletNavTabContent || !walletNavTabContent.length) {
                var walletNavTab = $(`<li class="nav-item">
                  <a class="nav-link ${index == 0 ? 'active' : ''}" data-toggle="tab" href="#${tabWalletNameUIId}" role="tab">
                    ${tabWalletName + ' Dashboard'}
                  </a>
              </li>`)
                  .appendTo(navTabs);

                walletNavTabContent = $(`<div class="tab-pane fade ${index == 0 ? 'show active' : ''}" id="${tabWalletNameUIId}" role="tabpanel">`)
                  .appendTo(navTabsContent);
              }
              walletPanelContent = $('<div>')
                .attr('id', tabWalletNameUIId)
                .addClass('wallet-dashboard-container mb-2')
                .appendTo(walletNavTabContent);
              break;

            case 'panels':
              var randomId = Guid.generate();
              var walletPanel = $(`
                <div class="panel" id="${randomId}">
                  <div class="panel-hdr light-primary cursor-pointer" data-action="panel-collapse" >
                    <h2 class="text-primary" style="font-weight: 700;">${tabWalletName + ' Dashboard'}</h2>
                    <div class="panel-toolbar dashboard-panel">
                      <div class="group-header-collapse-icon mr-2 ml-2" data-action="panel-collapse" data-toggle="tooltip" data-offset="0,10" data-original-title="Collapse" style="font-size: 14px;">
                        <i class="fa text-black fa-window-minimize" style="margin-left: -2px; margin-top: -3px;"></i>
                      </div>
                      <div class="group-header-collapse-icon text-primary" data-action="panel-fullscreen" data-toggle="tooltip" data-offset="0,10">
                        <i class=" fa fa-expand fa-angle-double-up" style="margin-left: -1px;" data-action="panel-fullscreen"></i></div>
                      </div>                    
                    </div>
                  <div class="panel-container show">
                    <div class="panel-content wallet-dashboard-container" id="${tabWalletNameUIId}">
                    </div>
                  </div>
                </div>`)
                .appendTo(container);

              walletPanelContent = walletPanel.find(`#${tabWalletNameUIId}.wallet-dashboard-container`);
              break;
          }
        }

        (element.categories || []).forEach(function (cat) {
          var categoryContainer = walletPanelContent.find(`.row.dashboard-sub-container.${cat.type.toLowerCase().replaceAll(':', '-')}`);
          if (!categoryContainer || !categoryContainer.length) {
            var categoryHeader = $(`
              <div class="subheader mb-2">
                <h1 class="subheader-title mt-2">
                  <i class="subheader-icon fal fa-chart-area"></i> ${cat.type.replaceAll('_', ' ').capitalizeEachWord()}
                </h1>
              </div>`);
            categoryContainer = $(`<div class="row d-flex dashboard-sub-container ${cat.type.toLowerCase()} mx-1 pt-4 px-2"
              style="border: 1px solid #e5cbff; background: #f9f4ff;"></div>`)
              .disableSelection();

            if (window.isSmallDevice) {
              categoryContainer.sortable({ disabled: true })
            } else {
              categoryContainer.sortable({ enabled: true })
            }

            // To keep the order of the categories => (actionable_items, summary,...)
            var actionableItemsCategoryContainer = walletPanelContent.find('.actionable_items');
            if (cat.type.toLowerCase() == 'actionable_items' ||
              (cat.type.toLowerCase() == 'summary' &&
                (!actionableItemsCategoryContainer ||
                  !actionableItemsCategoryContainer.length)
              )) {
              categoryContainer.prependTo(walletPanelContent);
              categoryHeader.prependTo(walletPanelContent);
            } else if (cat.type.toLowerCase() == 'summary' &&
              actionableItemsCategoryContainer &&
              actionableItemsCategoryContainer.length) {
              categoryContainer.insertAfter(actionableItemsCategoryContainer);
              categoryHeader.insertAfter(actionableItemsCategoryContainer);
            } else {
              categoryHeader.appendTo(walletPanelContent);
              categoryContainer.appendTo(walletPanelContent);
            }
          }

          var viewCol = $('<div>').addClass('mb-2');
          var viewGroup = cat['view_options']['group'];
          if (viewGroup) {
            var groupId = viewGroup.trimAll().replaceAll(':', '-');
            var groupContainer = walletPanelContent.find(`#${groupId}`);
            if (!groupContainer || groupContainer.length == 0) {
              var viewContainer = $('<div>')
                .addClass('col-lg-6 col-12 order-lg-6 order-12')
                .appendTo(categoryContainer);

              var groupRandomId = Guid.generate();
              var groupContainerPanel = $(`<div class="panel" id="${groupRandomId}">
                  <div class="panel-hdr cursor-pointer" data-action="panel-collapse">
                    <h2>${viewGroup}</h2>
                  </div>
                  <div class="panel-container show">
                    <div class="panel-content">
                      <div class="row" id="${groupId}">
                      </div>
                    </div>
                  </div>
                </div>`)
                .appendTo(viewContainer);

              groupContainer = groupContainerPanel.find(`#${groupId}`).removeClass('row');
            }
            viewCol.appendTo(groupContainer);
          } else {
            viewCol.appendTo(categoryContainer);
          }

          switch (cat.view_type) {
            case "calendar":
              viewGroup ? viewCol.addClass('col-12 order-12') :
                viewCol.addClass(`col-xl-${cat.view_options.col || 6} col-12 order-xl-${cat.view_options.col || 6} order-12`);
              this._renderCalendar(viewCol, cat.aggregated_data);
              break;
            case "table":
              viewGroup ? viewCol.addClass('col-12 order-12') :
                viewCol.addClass(`col-xl-${cat.view_options.col || 12} col-12 order-xl-${cat.view_options.col || 12} order-12`);
              this._renderTable(viewCol, cat.aggregated_data);
              break;
            case "piechart":
            case "barchart":
            case "linechart":
            case "areachart":
            case "donutchart":
              viewGroup ? viewCol.addClass('col-12 order-12') :
                viewCol.addClass(`col-xl-${cat.view_options.col || 3} col-lg-4 col-md-6 col-12 order-xl-${cat.view_options.col || 3} order-lg-4 order-md-6 order-12`);
              this._renderChart(viewCol, cat.view_type, cat.objects, cat.view_options,
                element.go_to_tab, tabKey);
              break;
            case "donutcount":
              viewGroup ? viewCol.addClass('col-6 order-6') :
                viewCol.addClass(`col-lg-${cat.view_options.col || 3} col-6 order-lg-${cat.view_options.col || 3} order-6`);
              cat.view_options.color1 = cat.view_options.color1 || (colors[index] ? colors[index].color1 : colors[index % colors.length].color1);
              cat.view_options.color2 = cat.view_options.color2 || (colors[index] ? colors[index].color2 : colors[index % colors.length].color2);
              var value = (cat.objects && cat.objects.length) ? cat.objects.length : cat.aggregated_data.value;
              this._renderDonutCount(viewCol, value, cat.aggregated_data.total, cat.view_options);
              break;
            case "barcount":
              if (viewGroup) {
                viewCol.addClass('mr-2 w-sm-100 float-left')
                  .removeClass('mb-2')
                  .css({ 'min-width': '190px' })
                  .closest('.panel-content').addClass('pt-1');
                if (viewContainer) {
                  viewContainer.removeClass('col-lg-6 col-12 order-lg-6 order-12')
                    .addClass('w-sm-100')
                    .css({ 'padding': '0 0.75rem' });
                }
              } else {
                viewCol.addClass(`col-xl-${cat.view_options.col || 3} col-lg-4 col-6 order-xl-${cat.view_options.col || 3} order-lg-4 order-6`);
              }
              cat.view_options.color1 = cat.view_options.color1 || (colors[index] ? colors[index].color1 : colors[index % colors.length].color1);
              cat.view_options.color2 = cat.view_options.color2 || (colors[index] ? colors[index].color2 : colors[index % colors.length].color2);
              var value = (cat.objects && cat.objects.length) ? cat.objects.length : cat.aggregated_data.value;
              this._renderBarCount(viewCol, value, cat.aggregated_data.total, cat.view_options,
                element.go_to_tab, tabKey);
              break;
            case "blockcount":
              if (cat.aggregated_data.value) {
                viewGroup ? viewCol.addClass('col-xl-6 col-lg-12 col-md-6 col-12 order-xl-6 order-lg-12 order-md-6 order-12') :
                  viewCol.addClass(`col-xl-${cat.view_options.col || 4} col-md-6 col-12 order-xl-${cat.view_options.col || 4} order-md-6 order-12`);
                this._renderBlock(viewCol, cat.aggregated_data, cat.view_options,
                  element.go_to_tab, tabKey);
              }
              else {
                viewCol.remove();
                return;
              }
              break;
            case 'timeline':
              viewCol.addClass('col-12 order-12');
              this._renderTimeLine(viewCol, cat.objects, cat.view_options,
                element.go_to_tab, tabKey);
              break;
            case 'message':
              viewCol.addClass('col-lg-6 col-12 order-lg-6 order-12');
              this._renderMessage(viewCol, cat.view_options, tabKey);
              break;
          }

        }.bind(this))
      }
    }.bind(this));

    /* Activate smart panels */
    // container.smartPanel()
  }

  _renderChart(container, chartType, objects, viewOptions, goToTab = false, tabKey = '') {
    // charts' slices colors
    var colors = [color.success._400, color.danger._400, color.info._400,
    color.primary._500, color.warning._400, color.fusion._50,
    color.success._900, color.danger._900, color.info._900,
    color.primary._900, color.warning._800,
    color.success._100, color.danger._100, color.info._100,
    color.primary._100
    ];

    var chartEle;
    var randomId = Guid.generate();
    var chartId = `#${viewOptions.caption.trimAll() || ""}${randomId}`.replaceAll(':', '-');
    switch (chartType) {
      case "piechart":
        var columns = [];
        objects.columns ? columns = objects.columns : Object.keys(objects).map(obj => { columns.push([obj, objects[obj]]) });
        chartEle = {
          bindto: chartId,
          data: {
            columns: columns,
            type: 'pie',
            //onclick: function (d, i) { alert(`${d.name}: ${d.ratio}`); },
          },
          color:
          {
            pattern: colors
          },
        };
        break;
      case "barchart":
        var columns = [];
        objects.columns ? columns = objects.columns : Object.keys(objects).map(obj => { columns.push([obj, objects[obj]]) });
        chartEle = {
          bindto: chartId,
          data: {
            columns: columns,
            type: 'bar',
            //onclick: function (d, i) { alert(`${d.name}: ${d.value}`); },
          },
          transition: {
            duration: 500
          },
          color:
          {
            pattern: colors
          },
        };
        break;
      case "linechart":
        var columns = [];
        objects.columns ? columns = objects.columns : Object.keys(objects).map(obj => { columns.push([obj, objects[obj]]) });
        chartEle = {
          bindto: chartId,
          data: {
            columns: columns,
            type: 'line',
            //onclick: function (d, i) { alert(`${d.name}: ${d.value}`); },
          },
          color:
          {
            pattern: colors
          },
          zoom: {
            enabled: true
          }
        };
        break;
      case "areachart":
        var columns = [];
        objects.columns ? columns = objects.columns : Object.keys(objects).map(obj => { columns.push([obj, objects[obj]]) });
        chartEle = {
          bindto: chartId,
          data: {
            columns: columns,
            types: {
              data1: 'area',
              data2: 'area-spline'
            },
            //onclick: function (d, i) { alert(`${d.name}: ${d.value}`); },
          },
          color:
          {
            pattern: colors
          },
        };
        break;
      case "donutchart":
        var columns = [];
        objects.columns ? columns = objects.columns : Object.keys(objects).map(obj => { columns.push([obj, objects[obj]]) });
        chartEle = {
          bindto: chartId,
          data: {
            columns: columns,
            type: 'donut',
            //onclick: function (d, i) { alert(`${d.name}: ${ d.ratio}`); },
          },
          color:
          {
            pattern: colors
          },
        };
        break;
      case 'timelinechart':

        break;
    }

    var caption = viewOptions.caption || '';
    this._renderGenericChart(container, chartEle, caption, goToTab, tabKey);
  }

  _renderGenericChart(container, element, caption, goToTab = false, tabKey = '') {
    var randomId = Guid.generate();
    // draw a panel container
    var panelContainer = $(`<div class="panel" id="${randomId}">
          <div class="panel-hdr d-flex flex-md-wrap flex-sm-nowrap flex-wrap cursor-pointer">
            <div class="header-container d-flex flex-column">
              <h2 class='hdr-title no-wrap' style="line-height: 2rem;">${caption}</h2>
            </div>
            
            <div class="panel-toolbar dashboard-panel dashboard-chart-toolbar d-flex flex-row-reverse mb-md-1 mb-sm-0 mb-1" style="width: 100%">
              <div class="group-header-collapse-icon mr-2 ml-2" data-action="panel-collapse" data-toggle="tooltip" data-offset="0,10" data-original-title="Collapse" style="font-size: 14px;">
                <i class="fa text-black  fa-window-minimize" style="margin-left: -2px; margin-top: -3px;"></i>
              </div>
              <div class="group-header-collapse-icon text-primary" data-action="panel-fullscreen" data-toggle="tooltip" data-offset="0,10">
                <i class="fa fa-expand fa-angle-double-up" style="margin-left: -1px;" data-action="panel-fullscreen"></i>
              </div>
            </div>              
          </div>
          <div class="panel-container show">
              <div class="panel-content">
                  <div class="dashboard-chart-container" id="${element.bindto.replace('#', '')}" style="width:100%; height:300px;"></div>
              </div>
          </div>
      </div>`)
      .appendTo(container);

    if (goToTab) {
      var tabLink = $(`<a href='#${tabKey.replace('/', '').replace(/_/g, '/').trimAll()}' class="text-primary" style="cursor:pointer;">Go to Tab</a>`)
        .appendTo(panelContainer.find('.header-container'));
      this._setUnderlineText(tabLink);

      // tabLink.on('click', function (e) {
      //   // window.location.hash = '#' + tabKey.replace('/', '').replace('_', '/').trimAll();
      //   // window.location.reload();
      //   e.preventDefault();
      //   this._showTab(tabKey.replace('/', '').trimAll());
      //   //e.stopPropagation();
      // }.bind(this));
    }
    // run 'c3' charts
    c3.generate(element);

    // remove the chart svg border which is drawn by c3 plugin
    panelContainer.find(element.bindto).find('svg').css('border', 'none');
  }

  _renderCalendar(container, data) {
    var randomId = Guid.generate();
    var calendarPanel = $(`<div class="panel" id="${randomId}">
        <div class="panel-hdr" data-action="panel-collapse">
            <h2 class="js-get-date"></h2>
            <div class="panel-toolbar">
              <button class="btn btn-panel waves-effect waves-themed" data-action="panel-collapse" data-toggle="tooltip" data-offset="0,10" data-original-title="Collapse"></button>
              <button class="btn btn-panel waves-effect waves-themed" data-action="panel-fullscreen" data-toggle="tooltip" data-offset="0,10" data-original-title="Fullscreen"></button>
            </div>
        </div>
        <div class="panel-container show">
            <div class="panel-content">            
              <div id="calendar"></div>
            </div>
        </div>
    </div>`);
    calendarPanel.appendTo(container);
    var calendarEl = calendarPanel.find('#calendar');
    var items = data.details;
    var COLORS = {
      0: "bg-white border-primary text-primary", // waiting for response
      1: "bg-primary-300 border-primary text-white", // yes attending 
      2: "bg-red pattern-1 text-gray maybe-attend", // unsure
      3: "border-info text-white cannot-attend", // cannot attend
    };

    if (items && items.length) {
      // var todayDate = moment().startOf('day');
      // var YM = todayDate.format('YYYY-MM');
      // var YESTERDAY = todayDate.clone().subtract(1, 'day').format('YYYY-MM-DD');
      // var TODAY = todayDate.format('YYYY-MM-DD');
      // var TOMORROW = todayDate.clone().add(1, 'day').format('YYYY-MM-DD');

      var eventsData = items.map(item => {
        var eventData = {
          'start': item['start'],
          // '_id': item._id,
          'title': item['title'],
          // 'className': COLORS[1],
          // 'editable': false,
        };
        if ('color' in item) {
          var colorId = item['color'];
          eventData['className'] = COLORS[colorId];
        }
        if ('end' in item) {
          eventData['end'] = item['end'];
        }
        return eventData;
      });

      var calendar = new FullCalendar.Calendar(calendarEl[0],
        {
          plugins: ['dayGrid', 'list', 'timeGrid', 'interaction', 'bootstrap'],
          themeSystem: 'bootstrap',
          timeZone: 'UTC',
          //dateAlignment: "month", //week, month
          buttonText:
          {
            today: 'today',
            month: 'month',
            week: 'week',
            day: 'day',
            list: 'list'
          },
          eventTimeFormat:
          {
            hour: 'numeric',
            minute: '2-digit',
            meridiem: 'short'
          },
          navLinks: true,
          header:
          {
            left: 'prev,next today', //addEventButton
            center: 'title',
            right: 'dayGridMonth,timeGridWeek,timeGridDay,listWeek'
          },
          footer:
          {
            left: '',
            center: '',
            right: ''
          },
          eventLimit: true, // allow "more" link when too many events
          views:
          {
            sevenDays:
            {
              type: 'agenda',
              buttonText: '7 Days',
              visibleRange: function (currentDate) {
                return {
                  start: currentDate.clone().subtract(2, 'days'),
                  end: currentDate.clone().add(5, 'days'),
                };
              },
              duration:
              {
                days: 7
              },
              dateIncrement:
              {
                days: 1
              },
            },
          },
          events: eventsData,
          eventClick: function (event) {
            var obj = wire.d(event.event._def.extendedProps._id);
            wire.popupObjectView(obj);
          }
        });

      var viewDict = {
        "month": "dayGridMonth",
        "week": "timeGridWeek",
        "day": "timeGridDay",
        "list": "listWeek"
      }
      calendar.changeView("dayGridMonth");
      calendar.render();
    }
  }

  _renderDonutCount(container, dountValue, total, viewOptions) {
    var subContainer = $(`
      <div class="d-flex mr-2">
        <div class="mr-2">
            <span class="peity-donut" data-peity='{ "fill": ["${viewOptions.color1}", "${viewOptions.color2}"], "innerRadius": 25, "radius": 30 }'>${(`${dountValue}/${total}`)}</span>
        </div>        
        <div>
          <label class="fs-sm mb-0 mt-2 mt-md-0">${viewOptions.caption || ""}</label>
          <h5 class="font-weight-bold mb-0">${(`${dountValue}/${total}`)}</h5>
        </div>
      </div>`)
      .appendTo(container);

    var subContainer2 = $(`
    <div class="js-easy-pie-chart color-fusion-500 position-relative d-inline-flex align-items-center justify-content-center" data-percent="${(dountValue / total) * 100}" data-piesize="0" data-linewidth="1" data-linecap="round" scaleLength="2">
        <div class="d-flex flex-column align-items-center justify-content-center position-absolute pos-left pos-right pos-top pos-bottom fw-300 fs-lg">
            <span class="js-percent d-block text-dark">${(`${dountValue} / ${total}`)}</span>
        </div>
    </div>`)
      .appendTo(container);

    //subContainer.find('span').peity("donut");
    subContainer.find('span').peity("donut");
    // subContainer.find('span').attr("style", 'display: block;');

    subContainer2.easyPieChart();
  }

  _renderBarCount(container, barValue, total, viewOptions, goToTab = false, tabKey = '') {
    var subContainer = (`
        <div class="d-flex mt-2">
           ${viewOptions.caption}
            <span class="d-inline-block ml-auto">${barValue + `/${total}`}</span>
        </div>
        <div class="progress progress-sm mb-1" style="background-color:${viewOptions.color2} !important;">
            <div class="progress-bar" role="progressbar" style="width: ${(barValue / total) * 100}%; background-color:${viewOptions.color1} !important;" aria-valuenow="${(barValue / total) * 100}" aria-valuemin="0" aria-valuemax="${total}"></div>
        </div>`);
    container.append(subContainer);

    if (goToTab) {
      var tabLink = $(`<p class="help-block"><a href='#${tabKey.replace('/', '').replace(/_/g, '/').trimAll()}' class="text-primary" style="cursor:pointer;">Go to Tab</a></p>`)
        .appendTo(container);
      // tabLink.on('click', function (e) {
      //   // window.location.hash = '#' + tabKey.replace('/', '').replace('_', '/').trimAll();
      //   // window.location.reload();
      //   e.preventDefault();
      //   this._showTab(tabKey.replace('/', '').trimAll());
      //   //e.stopPropagation();
      // }.bind(this));
      this._setUnderlineText(tabLink.find('a'));
    }
  }

  _renderTable(container, data) {
    var table = $(`<table id="dt-basic-example" class="table table-bordered table-hover table-striped w-100">
      <thead class="bg-warning-200">
        <tr></tr>
      </thead>
      <tbody>
      </tbody>
      <tfoot>
        <tr></tr>
      </tfoot>
    </table>`);

    var tableHeaderRow = table.find('thead').find('tr');
    var tableFooterRow = table.find('tfoot').find('tr');
    data.columnsHeaders.forEach(h => {
      $('<th>').html(h).appendTo(tableHeaderRow);
      $('<th>').html(h).appendTo(tableFooterRow);
    });

    var tableBody = table.find('tbody');
    data.rows.forEach(row => {
      var rowEle = $('<tr>').appendTo(tableBody);
      row.forEach(d => {
        $('<td>').html(d).appendTo(rowEle);
      });
    });

    table.appendTo(container);

    /* init datatables */
    table.dataTable(
      {
        responsive: true,
        dom: "<'row mb-3'<'col-sm-12 col-md-6 d-flex align-items-center justify-content-start'f><'col-sm-12 col-md-6 d-flex align-items-center justify-content-end'B>>" +
          "<'row'<'col-sm-12'tr>>" +
          "<'row'<'col-sm-12 col-md-5'i><'col-sm-12 col-md-7'p>>",
        buttons: [
          {
            extend: 'colvis',
            text: 'Column Visibility',
            titleAttr: 'Col visibility',
            className: 'btn-outline-default'
          },
          {
            extend: 'csvHtml5',
            text: 'CSV',
            titleAttr: 'Generate CSV',
            className: 'btn-outline-default'
          },
          {
            extend: 'copyHtml5',
            text: 'Copy',
            titleAttr: 'Copy to clipboard',
            className: 'btn-outline-default'
          },
          {
            extend: 'print',
            text: '<i class="fal fa-print"></i>',
            titleAttr: 'Print Table',
            className: 'btn-outline-default'
          }
        ],
        columnDefs: [
          {
            targets: -1,
            title: '',
            orderable: false,
            render: function (data, type, full, meta) {

              /*
              -- ES6
              -- convert using https://babeljs.io online transpiler
              return `
              <a href='javascript:void(0);' class='btn btn-sm btn-icon btn-outline-danger rounded-circle mr-1' title='Delete Record'>
                <i class="fal fa-times"></i>
              </a>
              <div class='dropdown d-inline-block dropleft '>
                <a href='#'' class='btn btn-sm btn-icon btn-outline-primary rounded-circle shadow-0' data-toggle='dropdown' aria-expanded='true' title='More options'>
                  <i class="fal fa-ellipsis-v"></i>
                </a>
                <div class='dropdown-menu'>
                  <a class='dropdown-item' href='javascript:void(0);'>Change Status</a>
                  <a class='dropdown-item' href='javascript:void(0);'>Generate Report</a>
                </div>
              </div>`;
                
              ES5 example below:	
   
              */
              return "\n\t\t\t\t\t\t<a href='javascript:void(0);' class='btn btn-sm btn-icon btn-outline-danger rounded-circle mr-1' title='Delete Record'>\n\t\t\t\t\t\t\t<i class=\"fal fa-times\"></i>\n\t\t\t\t\t\t</a>\n\t\t\t\t\t\t<div class='dropdown d-inline-block dropleft'>\n\t\t\t\t\t\t\t<a href='#'' class='btn btn-sm btn-icon btn-outline-primary rounded-circle shadow-0' data-toggle='dropdown' aria-expanded='true' title='More options'>\n\t\t\t\t\t\t\t\t<i class=\"fal fa-ellipsis-v\"></i>\n\t\t\t\t\t\t\t</a>\n\t\t\t\t\t\t\t<div class='dropdown-menu'>\n\t\t\t\t\t\t\t\t<a class='dropdown-item' href='javascript:void(0);'>Change Status</a>\n\t\t\t\t\t\t\t\t<a class='dropdown-item' href='javascript:void(0);'>Generate Report</a>\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t</div>";
            },
          },

        ]

      });
  }

  _renderBlock(container, data, viewOptions, goToTab = false, tabKey = '') {
    var blockCard = $(`<div class="card mb-2 rounded-top">
          <div class="row no-gutters row-grid">
              <div class="col-8">
                  <div class="text-center p-2">
                      <h5 class="mb-0 fw-700 text-primary">
                        ${viewOptions.caption.titleCase()}
                      </h5>
                  </div>
              </div>
              <div class="col-4 d-flex justify-content-center align-items-center">
                  <div class="text-center">
                      <h4 class="mb-0 fw-700">
                      <span class="badge bg-danger-800 mb-0">${data.value}</span>
                      </h4>
                  </div>
              </div>
              
          </div>
      </div>`)
      .appendTo(container);

    if (goToTab) {
      blockCard.find('.row-grid').append($(`<div class="col-12">
      <div class="p-2 text-center">
        <a href="#${tabKey.replace('_NOGRP_', '_').replace('/', '').replace(/_/g, '/').trimAll()}" class="btn btn-primary btn-sm text-white waves-effect waves-themed">Go to Tab</a>
      </div>
    </div>`));

      // blockCard.find('button').click((function (e) {
      //   // window.location.hash = '#' + tabKey.replace('/', '').replace('_', '/').trimAll();
      //   // window.location.reload();
      //   e.preventDefault();
      //   this._showTab(tabKey.replace('/', '').trimAll());
      //   //e.stopPropagation();
      // }.bind(this)));
    }

    // $(`<div class="d-flex flex-column flex-grow-1 mr-2">
    //          <h4><a href="#" class="font-weight-bold text-danger text-hover-primary font-size-lg mb-1">${data.caption.titleCase()}</a></h4>
    //         <span class="text-muted font-weight-bold">${'lll'}</span>
    //     </div>
    //     <h4><span class="badge badge-danger font-weight-bolder">${data.value}</span></h4>`)
    //   .appendTo(container);
  }

  _renderTimeLine(container, objects, viewOptions, goToTab = false, tabKey = false) {
    var randomId = Guid.generate();
    // draw a panel container
    var panelContainer = $(`
    <div class="panel panel-sortablse" role="wodget" id="${randomId}">
    <div class="panel-hdr cursor-pointer">
        <h2 class='hdr-title no-wrap' data-action="panel-collapse">${viewOptions.caption}</h2>
        <div class="panel-toolbar dashboard-panel">
          <div class="group-header-collapse-icon mr-2 ml-2" data-action="panel-collapse" data-toggle="tooltip" data-offset="0,10" data-original-title="Collapse" style="font-size: 14px;">
            <i class="fa text-black  fa-window-minimize" style="margin-left: -2px; margin-top: -3px;"></i>
          </div>
          <div class="group-header-collapse-icon text-primary" data-action="panel-fullscreen" data-toggle="tooltip" data-offset="0,10">
            <i class=" fa fa-expand fa-angle-double-up" style="margin-left: -1px;" data-action="panel-fullscreen"></i></div>
          </div>
        </div>
    <div class="panel-container show">
        <div class="panel-content" style="overflow:auto;">   
            <div class="px-4">      
              <div class="dashboard-timeline timeline">         
              </div>
            </div>
        </div>
    </div>
</div>`)
      .appendTo(container);

    var timeline = panelContainer.find('.dashboard-timeline');

    var badgeColors = ['badge-warning',
      'badge-success',
      'badge-primary',
      'badge-danger'];

    // convert objects dict to array, to be sorted
    var items = Object.keys(objects).map(function (key) {
      return [key, objects[key]];
    });

    items.sort(function (first, second) {
      return first[1].day - second[1].day;
    });
    var years = [];
    var days = [];
    var timelineCards;
    var timelineCardContent;
    const monthNames = ["Jan", "Feb", "Mar", "Apr", "May", "Jun",
      "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"
    ];
    items.forEach(function (item, index) {
      var year = dateIntToStr(item[1].day).split('-')[0];
      var month = dateIntToStr(item[1].day).split('-')[1];
      var day = dateIntToStr(item[1].day).split('-')[2];
      // draw timeline group for each different year
      if (!years.includes(year)) {
        var timelineGroup = $(`<div id="${year}" class="timeline__group" style="cursor: default">`).appendTo(timeline);
        $(`<span class="timeline__year time cursor-default" aria-hidden="true">${year}</span>`).appendTo(timelineGroup);
        timelineCards = $(`<div class="timeline__cards">`).appendTo(timelineGroup);
      }
      var doesDayExist = days.filter(itemDay =>
        (itemDay.year == year && itemDay.month == monthNames[month - 1] && itemDay.day == day))
        .length > 0;
      // draw timeline card for each different day
      if (!doesDayExist) {
        var timelineCard = $(`<div class="timeline__card card mt-2">`)
          .appendTo(timelineCards);
        $(`<header class="card__header position-relative">
            <time class="time text-primary cursor-default">
              <span class="time__month cursor-default bg-danger d-block">${monthNames[month - 1]}</span>
              <span class="time__day cursor-default pt-2 d-block text-center text-primary">${day}</span>
            </time>          
          </header>`)
          .appendTo(timelineCard);
        timelineCardContent = $('<div class="card__content">')
          .appendTo(timelineCard);
      }
      $(`<p style="animation: cd-bounce-2-inverse 1s; "><i class="fa fa-arrow-right text-success" style="font-size: 16px"></i>
         <span class="text-danger font-weight-normal cursor-default">(${item[1].start}-${item[1].end})</span> ${item[1].title} 
         </p>`)
        .appendTo(timelineCardContent);
      days.push({ year: year, month: monthNames[month - 1], day: day });
      years.push(year);
    });


    if (goToTab) {
      var tabLink = $(`<a href='#${tabKey.replace('/', '').replace(/_/g, '/').trimAll()}' class="text-primary" style="cursor:pointer;">Go to Tab</a>`).insertAfter(panelContainer.find('.hdr-title'));

      // tabLink.on('click', function (e) {
      //   // window.location.hash = '#' + tabKey.replace('/', '').replace('_', '/').trimAll();
      //   // window.location.reload();
      //   e.preventDefault();
      //   this._showTab(tabKey.replace('/', '').trimAll());
      //   //e.stopPropagation();
      // }.bind(this));

      this._setUnderlineText(tabLink);
    }
  }

  _renderMessage(container, viewOptions, tabKey) {
    var message = $(`
      <div class="alert border-primary bg-white text-primary fade show mb-2" onclick="location.href='#${tabKey.replace('/', '').replace(/_/g, '/').trimAll()}';" style="cursor: pointer;">
        <div class="d-flex flex-wrap justify-content-center align-items-center">
          <div class="alert-icon">
              <i class="fal fa-info-circle"></i>
          </div>
          <div class="flex-1">
              <span class="h5 m-0 fw-700">${viewOptions['text']}</span>
          </div>
          <a class="btn btn-primary btn-pills btn-sm btn-w-m mr-1">Take Action</a>
        </div>
      </div>`)
      .appendTo(container);

    // message.hover(function () {
    //   debugger;
    //   $(this).removeClass('bg-white text-primary').addClass('bg-primary text-white');
    //   $(this).find('.btn-pills').removeClass('btn-primary').addClass('btn-white');
    // });
  }

  _showTab(tabKey) {
    $('#js-nav-menu').find(`#${tabKey}`)[0].click();
  }

  getTabNotifications(name, group, wallet) {
    var count = 0;
    var tab = this.tabsData[(`${wallet}_${group}_${name}`).trimAll()] || {};
    var notifiedCategories = (tab['categories'] || []).filter(t => (t['notifiable_fn'] || t['has_notifiable_data']) && t['objects']);
    (notifiedCategories || []).forEach(function (cat) {
      var notifiedTabObjects = []
      if (Array.isArray(cat['objects'])) {
        notifiedTabObjects = (cat['objects'] || [])
          .map(o => WIRE.d(o))
          .filter(eval(cat['notifiable_fn']));
      } else {
        count = (cat['aggregated_data'] && cat['aggregated_data']['total']) ?
          cat['aggregated_data']['total'] :
          (Object.values(cat['objects']) || []).reduce((a, b) => a + b, 0);
      }


      // TODO delete the obj id from (this.tabsData)
      if (notifiedTabObjects && notifiedTabObjects.length) {
        count = notifiedTabObjects.length;

        // TODO notify the dashboard
        // var notifiedTabObjectsIds = notifiedTabObjects.map(obj => {
        //   var objID = obj._id
        //   if (!obj._id.startsWith('!obj!')) {
        //     objID = '!obj!' + obj._id;
        //   }
        //   return objID;
        // });

        // var tabsObjectsChanged = false;
        // Array.isArray(cat['objects'])
        //   ? cat['objects'].forEach(val => {
        //     if (!notifiedTabObjectsIds.includes(val))
        //       tabsObjectsChanged = true;
        //   })
        //   : Object.keys(cat['objects']).forEach(val => {
        //     if (!notifiedTabObjectsIds.includes(val))
        //       tabsObjectsChanged = true;
        //   });

        // if (tabsObjectsChanged) {
        //   var newData = {};
        //   tab['categories']
        //     .forEach(function (t, index) {
        //       if (t == cat) {
        //         if (Array.isArray(t['objects'])) {
        //           // t['objects'] = notifiedTabObjectsIds;
        //           newData = { 'index': index, 'objects': notifiedTabObjectsIds }
        //         }
        //         else {
        //           var deletedKeys = Object.keys(t['objects']).map(k => !notifiedTabObjectsIds.includes(k));
        //           var objs = t['objects'];
        //           deletedKeys.forEach(k => delete objs[k]);
        //           newData = { 'index': index, 'objects': objs };
        //         }
        //       }
        //     }.bind(this));

        //this.tabsData[(`${wallet}_${group}_${name}`).trimAll()]['categories'][newData['index']]['objects']
        //     = newData['objects'];
        // }

      }
    }.bind(this));
    //return (notifiedCategories && notifiedCategories['objects']) ? notifiedCategories['objects'].length : 0;
    return count;
  }


  _setUnderlineText(obj) {
    obj.hover(function () {
      this.setAttribute('style', 'text-decoration:underline !important');
    }, function () {
      this.setAttribute('style', 'text-decoration:none !important');
    });
  }
}
var card=function(r){var e={};function t(a){if(e[a])return e[a].exports;var n=e[a]={i:a,l:!1,exports:{}};return r[a].call(n.exports,n,n.exports,t),n.l=!0,n.exports}return t.m=r,t.c=e,t.d=function(r,e,a){t.o(r,e)||Object.defineProperty(r,e,{enumerable:!0,get:a})},t.r=function(r){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(r,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(r,"__esModule",{value:!0})},t.t=function(r,e){if(1&e&&(r=t(r)),8&e)return r;if(4&e&&"object"==typeof r&&r&&r.__esModule)return r;var a=Object.create(null);if(t.r(a),Object.defineProperty(a,"default",{enumerable:!0,value:r}),2&e&&"string"!=typeof r)for(var n in r)t.d(a,n,function(e){return r[e]}.bind(null,n));return a},t.n=function(r){var e=r&&r.__esModule?function(){return r.default}:function(){return r};return t.d(e,"a",e),e},t.o=function(r,e){return Object.prototype.hasOwnProperty.call(r,e)},t.p="",t(t.s=0)}([function(r,e,t){var a,n,o=[].slice;n=t(1),(a=t(15)).card={},a.card.fn={},a.fn.card=function(r){return a.card.fn.construct.apply(this,r)},a.fn.extend({card:function(){var r,e;return e=arguments[0],r=2<=arguments.length?o.call(arguments,1):[],this.each((function(){var t,o;if((o=(t=a(this)).data("card"))||(a.each(e,(function(r,t){if(t instanceof jQuery)return e[r]=t[0]})),e.form=this,t.data("card",o=new n(e))),"string"==typeof e)return o[e].apply(o,r)}))}})},function(r,e,t){(function(e){var a,n,o;t(3),n=t(7),t(8),o=t(9),a=function(){var r,e;function t(r){var e,t,a;this.maskCardNumber=(e=this.maskCardNumber,t=this,function(){return e.apply(t,arguments)}),this.options=o(!0,this.defaults,r),this.options.form?(this.$el=n(this.options.form),this.options.container?(this.$container=n(this.options.container),(a=n.isDOMElement(this.$container)?this.$container:this.$container[0]).getAttribute(this.initializedDataAttr)||(a.setAttribute(this.initializedDataAttr,!0),this.render(),this.attachHandlers(),this.handleInitialPlaceholders())):console.log("Please provide a container")):console.log("Please provide a form")}return t.prototype.initializedDataAttr="data-jp-card-initialized",t.prototype.cardTemplate='<div class="jp-card-container"><div class="jp-card"><div class="jp-card-front"><div class="jp-card-logo jp-card-elo"><div class="e">e</div><div class="l">l</div><div class="o">o</div></div><div class="jp-card-logo jp-card-visa">Visa</div><div class="jp-card-logo jp-card-visaelectron">Visa<div class="elec">Electron</div></div><div class="jp-card-logo jp-card-mastercard">Mastercard</div><div class="jp-card-logo jp-card-maestro">Maestro</div><div class="jp-card-logo jp-card-amex"></div><div class="jp-card-logo jp-card-discover">discover</div><div class="jp-card-logo jp-card-unionpay">UnionPay</div><div class="jp-card-logo jp-card-dinersclub"></div><div class="jp-card-logo jp-card-hipercard">Hipercard</div><div class="jp-card-logo jp-card-troy">troy</div><div class="jp-card-logo jp-card-dankort"><div class="dk"><div class="d"></div><div class="k"></div></div></div><div class="jp-card-logo jp-card-jcb"><div class="j">J</div><div class="c">C</div><div class="b">B</div></div><div class="jp-card-lower"><div class="jp-card-shiny"></div><div class="jp-card-cvc jp-card-display">{{cvc}}</div><div class="jp-card-number jp-card-display">{{number}}</div><div class="jp-card-name jp-card-display">{{name}}</div><div class="jp-card-expiry jp-card-display" data-before="{{monthYear}}" data-after="{{validDate}}">{{expiry}}</div></div></div><div class="jp-card-back"><div class="jp-card-bar"></div><div class="jp-card-cvc jp-card-display">{{cvc}}</div><div class="jp-card-shiny"></div></div></div></div>',t.prototype.template=function(r,e){return r.replace(/\{\{(.*?)\}\}/g,(function(r,t,a){return e[t]}))},t.prototype.cardTypes=["jp-card-amex","jp-card-dankort","jp-card-dinersclub","jp-card-discover","jp-card-unionpay","jp-card-jcb","jp-card-laser","jp-card-maestro","jp-card-mastercard","jp-card-troy","jp-card-unionpay","jp-card-visa","jp-card-visaelectron","jp-card-elo","jp-card-hipercard"],t.prototype.defaults={formatting:!0,formSelectors:{numberInput:'input[name="number"]',expiryInput:'input[name="expiry"]',cvcInput:'input[name="cvc"]',nameInput:'input[name="name"]'},cardSelectors:{cardContainer:".jp-card-container",card:".jp-card",numberDisplay:".jp-card-number",expiryDisplay:".jp-card-expiry",cvcDisplay:".jp-card-cvc",nameDisplay:".jp-card-name"},messages:{validDate:"valid\nthru",monthYear:"month/year"},placeholders:{number:"&bull;&bull;&bull;&bull; &bull;&bull;&bull;&bull; &bull;&bull;&bull;&bull; &bull;&bull;&bull;&bull;",cvc:"&bull;&bull;&bull;",expiry:"&bull;&bull;/&bull;&bull;",name:"Full Name"},masks:{cardNumber:!1},classes:{valid:"jp-card-valid",invalid:"jp-card-invalid"},debug:!1},t.prototype.render=function(){var r,e,t,a,i,d,c,p;for(t in n.append(this.$container,this.template(this.cardTemplate,o({},this.options.messages,this.options.placeholders))),i=this.options.cardSelectors)c=i[t],this["$"+t]=n.find(this.$container,c);for(t in d=this.options.formSelectors)c=d[t],c=this.options[t]?this.options[t]:c,!(a=n.find(this.$el,c)).length&&this.options.debug&&console.error("Card can't find a "+t+" in your form."),this["$"+t]=a;if(this.options.formatting&&(Payment.formatCardNumber(this.$numberInput),Payment.formatCardCVC(this.$cvcInput),Payment.formatCardExpiry(this.$expiryInput)),this.options.width&&(r=n(this.options.cardSelectors.cardContainer)[0],e=parseInt(r.clientWidth||window.getComputedStyle(r).width),r.style.transform="scale("+this.options.width/e+")"),("undefined"!=typeof navigator&&null!==navigator?navigator.userAgent:void 0)&&-1!==(p=navigator.userAgent.toLowerCase()).indexOf("safari")&&-1===p.indexOf("chrome")&&n.addClass(this.$card,"jp-card-safari"),/MSIE 10\./i.test(navigator.userAgent)&&n.addClass(this.$card,"jp-card-ie-10"),/rv:11.0/i.test(navigator.userAgent))return n.addClass(this.$card,"jp-card-ie-11")},t.prototype.attachHandlers=function(){var e,t;return t=[this.validToggler("cardNumber")],this.options.masks.cardNumber&&t.push(this.maskCardNumber),r(this.$numberInput,this.$numberDisplay,{fill:!1,filters:t}),n.on(this.$numberInput,"payment.cardType",this.handle("setCardType")),(e=[function(r){return r.replace(/(\s+)/g,"")}]).push(this.validToggler("cardExpiry")),r(this.$expiryInput,this.$expiryDisplay,{join:function(r){return 2===r[0].length||r[1]?"/":""},filters:e}),r(this.$cvcInput,this.$cvcDisplay,{filters:this.validToggler("cardCVC")}),n.on(this.$cvcInput,"focus",this.handle("flipCard")),n.on(this.$cvcInput,"blur",this.handle("unflipCard")),r(this.$nameInput,this.$nameDisplay,{fill:!1,filters:this.validToggler("cardHolderName"),join:" "})},t.prototype.handleInitialPlaceholders=function(){var r,e,t,a;for(e in a=[],t=this.options.formSelectors)t[e],(r=this["$"+e])instanceof NodeList&&(r=r[0]),n.val(r)?(n.trigger(r,"paste"),a.push(function(r){return setTimeout((function(){return n.trigger(r,"keyup")}))}(r))):a.push(void 0);return a},t.prototype.handle=function(r){return e=this,function(t){var a;return(a=Array.prototype.slice.call(arguments)).unshift(t.target),e.handlers[r].apply(e,a)};var e},t.prototype.validToggler=function(r){var e,t;return"cardExpiry"===r?e=function(r){var e;return e=Payment.fns.cardExpiryVal(r),Payment.fns.validateCardExpiry(e.month,e.year)}:"cardCVC"===r?(t=this,e=function(r){return Payment.fns.validateCardCVC(r,t.cardType)}):"cardNumber"===r?e=function(r){return Payment.fns.validateCardNumber(r)}:"cardHolderName"===r&&(e=function(r){return""!==r}),function(r){return function(t,a,n){var o;return o=e(t),r.toggleValidClass(a,o),r.toggleValidClass(n,o),t}}(this)},t.prototype.toggleValidClass=function(r,e){return n.toggleClass(r,this.options.classes.valid,e),n.toggleClass(r,this.options.classes.invalid,!e)},t.prototype.maskCardNumber=function(r,e,t){var a,n;return a=this.options.masks.cardNumber,(n=r.split(" ")).length>=3?(n.forEach((function(r,e){if(e!==n.length-1)return n[e]=n[e].replace(/\d/g,a)})),n.join(" ")):r.replace(/\d/g,a)},t.prototype.handlers={setCardType:function(r,e){var t;if(t=e.data,!n.hasClass(this.$card,t))return n.removeClass(this.$card,"jp-card-unknown"),n.removeClass(this.$card,this.cardTypes.join(" ")),n.addClass(this.$card,"jp-card-"+t),n.toggleClass(this.$card,"jp-card-identified","unknown"!==t),this.cardType=t},flipCard:function(){return n.addClass(this.$card,"jp-card-flipped")},unflipCard:function(){return n.removeClass(this.$card,"jp-card-flipped")}},r=function(r,t,a){var o,i,d;return null==a&&(a={}),a.fill=a.fill||!1,a.filters=a.filters||[],a.filters instanceof Array||(a.filters=[a.filters]),a.join=a.join||"","function"!=typeof a.join&&(o=a.join,a.join=function(){return o}),d=function(){var r,e,a;for(a=[],r=0,e=t.length;r<e;r++)i=t[r],a.push(i.textContent);return a}(),e(r,t,d,a),n.on(r,"focus",(function(){return n.addClass(t,"jp-card-focused")})),n.on(r,"blur",(function(){return n.removeClass(t,"jp-card-focused")})),n.on(r,"keyup change paste",(function(n){return e(r,t,d,a)})),r},e=function(r,e,t,a){var o,i,d,c,p,l,s,f,u,g,b,j;for(j=function(){var e,t,a;for(a=[],e=0,t=r.length;e<t;e++)o=r[e],a.push(n.val(o));return a}(),c=a.join(j),(j=j.join(c))===c&&(j=""),d=0,l=(g=a.filters).length;d<l;d++)j=(0,g[d])(j,r,e);for(b=[],i=p=0,s=e.length;p<s;i=++p)f=e[i],u=a.fill?j+t[i].substring(j.length):j||t[i],b.push(f.textContent=u);return b},t}(),r.exports=a,e.Card=a}).call(this,t(2))},function(r,e){var t;t=function(){return this}();try{t=t||new Function("return this")()}catch(r){"object"==typeof window&&(t=window)}r.exports=t},function(r,e,t){var a=t(4);"string"==typeof a&&(a=[[r.i,a,""]]);t(6)(a,{});a.locals&&(r.exports=a.locals)},function(r,e,t){(r.exports=t(5)()).push([r.i,'.jp-card.jp-card-safari.jp-card-identified .jp-card-front:before,.jp-card.jp-card-safari.jp-card-identified .jp-card-back:before{background-image:repeating-linear-gradient(45deg, rgba(255,255,255,0) 1px, rgba(255,255,255,0.03) 2px, rgba(255,255,255,0.04) 3px, rgba(255,255,255,0.05) 4px),repeating-linear-gradient(135deg, rgba(255,255,255,0.05) 1px, rgba(255,255,255,0) 2px, rgba(255,255,255,0.04) 3px, rgba(255,255,255,0.03) 4px),repeating-linear-gradient(90deg, rgba(255,255,255,0) 1px, rgba(255,255,255,0.03) 2px, rgba(255,255,255,0.04) 3px, rgba(255,255,255,0.05) 4px),repeating-linear-gradient(210deg, rgba(255,255,255,0) 1px, rgba(255,255,255,0.03) 2px, rgba(255,255,255,0.04) 3px, rgba(255,255,255,0.05) 4px),-webkit-linear-gradient(-245deg, rgba(255,255,255,0) 50%,rgba(255,255,255,0.2) 70%,rgba(255,255,255,0) 90%);background-image:repeating-linear-gradient(45deg, rgba(255,255,255,0) 1px, rgba(255,255,255,0.03) 2px, rgba(255,255,255,0.04) 3px, rgba(255,255,255,0.05) 4px),repeating-linear-gradient(135deg, rgba(255,255,255,0.05) 1px, rgba(255,255,255,0) 2px, rgba(255,255,255,0.04) 3px, rgba(255,255,255,0.03) 4px),repeating-linear-gradient(90deg, rgba(255,255,255,0) 1px, rgba(255,255,255,0.03) 2px, rgba(255,255,255,0.04) 3px, rgba(255,255,255,0.05) 4px),repeating-linear-gradient(210deg, rgba(255,255,255,0) 1px, rgba(255,255,255,0.03) 2px, rgba(255,255,255,0.04) 3px, rgba(255,255,255,0.05) 4px),linear-gradient(-25deg, rgba(255,255,255,0) 50%,rgba(255,255,255,0.2) 70%,rgba(255,255,255,0) 90%)}.jp-card.jp-card-ie-10.jp-card-flipped,.jp-card.jp-card-ie-11.jp-card-flipped{-webkit-transform:0deg;-moz-transform:0deg;-ms-transform:0deg;-o-transform:0deg;transform:0deg}.jp-card.jp-card-ie-10.jp-card-flipped .jp-card-front,.jp-card.jp-card-ie-11.jp-card-flipped .jp-card-front{-webkit-transform:rotateY(0deg);-moz-transform:rotateY(0deg);-ms-transform:rotateY(0deg);-o-transform:rotateY(0deg);transform:rotateY(0deg)}.jp-card.jp-card-ie-10.jp-card-flipped .jp-card-back,.jp-card.jp-card-ie-11.jp-card-flipped .jp-card-back{-webkit-transform:rotateY(0deg);-moz-transform:rotateY(0deg);-ms-transform:rotateY(0deg);-o-transform:rotateY(0deg);transform:rotateY(0deg)}.jp-card.jp-card-ie-10.jp-card-flipped .jp-card-back:after,.jp-card.jp-card-ie-11.jp-card-flipped .jp-card-back:after{left:18%}.jp-card.jp-card-ie-10.jp-card-flipped .jp-card-back .jp-card-cvc,.jp-card.jp-card-ie-11.jp-card-flipped .jp-card-back .jp-card-cvc{-webkit-transform:rotateY(180deg);-moz-transform:rotateY(180deg);-ms-transform:rotateY(180deg);-o-transform:rotateY(180deg);transform:rotateY(180deg);left:5%}.jp-card.jp-card-ie-10.jp-card-flipped .jp-card-back .jp-card-shiny,.jp-card.jp-card-ie-11.jp-card-flipped .jp-card-back .jp-card-shiny{left:84%}.jp-card.jp-card-ie-10.jp-card-flipped .jp-card-back .jp-card-shiny:after,.jp-card.jp-card-ie-11.jp-card-flipped .jp-card-back .jp-card-shiny:after{left:-480%;-webkit-transform:rotateY(180deg);-moz-transform:rotateY(180deg);-ms-transform:rotateY(180deg);-o-transform:rotateY(180deg);transform:rotateY(180deg)}.jp-card.jp-card-ie-10.jp-card-amex .jp-card-back,.jp-card.jp-card-ie-11.jp-card-amex .jp-card-back{display:none}.jp-card-logo{height:36px;width:60px;font-style:italic}.jp-card-logo,.jp-card-logo:before,.jp-card-logo:after{box-sizing:border-box}.jp-card-logo.jp-card-amex{text-transform:uppercase;font-size:4px;font-weight:bold;color:white;background-image:repeating-radial-gradient(circle at center, #fff 1px, #999 2px);background-image:repeating-radial-gradient(circle at center, #fff 1px, #999 2px);border:1px solid #EEE}.jp-card-logo.jp-card-amex:before,.jp-card-logo.jp-card-amex:after{width:28px;display:block;position:absolute;left:16px}.jp-card-logo.jp-card-amex:before{height:28px;content:"american";top:3px;text-align:left;padding-left:2px;padding-top:11px;background:#267AC3}.jp-card-logo.jp-card-amex:after{content:"express";bottom:11px;text-align:right;padding-right:2px}.jp-card.jp-card-amex.jp-card-flipped{-webkit-transform:none;-moz-transform:none;-ms-transform:none;-o-transform:none;transform:none}.jp-card.jp-card-amex.jp-card-identified .jp-card-front:before,.jp-card.jp-card-amex.jp-card-identified .jp-card-back:before{background-color:#108168}.jp-card.jp-card-amex.jp-card-identified .jp-card-front .jp-card-logo.jp-card-amex{opacity:1}.jp-card.jp-card-amex.jp-card-identified .jp-card-front .jp-card-cvc{visibility:visible}.jp-card.jp-card-amex.jp-card-identified .jp-card-front:after{opacity:1}.jp-card-logo.jp-card-discover{background:#f60;color:#111;text-transform:uppercase;font-style:normal;font-weight:bold;font-size:10px;text-align:center;overflow:hidden;z-index:1;padding-top:9px;letter-spacing:.03em;border:1px solid #EEE}.jp-card-logo.jp-card-discover:before,.jp-card-logo.jp-card-discover:after{content:" ";display:block;position:absolute}.jp-card-logo.jp-card-discover:before{background:white;width:200px;height:200px;border-radius:200px;bottom:-5%;right:-80%;z-index:-1}.jp-card-logo.jp-card-discover:after{width:8px;height:8px;border-radius:4px;top:10px;left:27px;background-color:#f60;background-image:-webkit-radial-gradient(#f60,#fff);background-image:radial-gradient(  #f60,#fff);content:"network";font-size:4px;line-height:24px;text-indent:-7px}.jp-card .jp-card-front .jp-card-logo.jp-card-discover{right:12%;top:18%}.jp-card.jp-card-discover.jp-card-identified .jp-card-front:before,.jp-card.jp-card-discover.jp-card-identified .jp-card-back:before{background-color:#86B8CF}.jp-card.jp-card-discover.jp-card-identified .jp-card-logo.jp-card-discover{opacity:1}.jp-card.jp-card-discover.jp-card-identified .jp-card-front:after{-webkit-transition:400ms;-moz-transition:400ms;transition:400ms;content:" ";display:block;background-color:#f60;background-image:-webkit-linear-gradient(#f60,#ffa366,#f60);background-image:linear-gradient(#f60,#ffa366,#f60);height:50px;width:50px;border-radius:25px;position:absolute;left:100%;top:15%;margin-left:-25px;box-shadow:inset 1px 1px 3px 1px rgba(0,0,0,0.5)}.jp-card-logo.jp-card-unionpay{width:60px;display:block;height:40px;background:#e21836;-webkit-transform:skew(-15deg);-moz-transform:skew(20deg);-o-transform:skew(20deg);border-radius:5px;font-size:10px;z-index:1;line-height:33px;color:#fff;text-align:center;font-family:"Sans-serif", "Microsoft Yahei", "\\5FAE\\8F6F\\96C5\\9ED1", "Hiragino Sans", "Gulim", "\\5B8B\\4F53";font-weight:bold}.jp-card-logo.jp-card-unionpay:after,.jp-card-logo.jp-card-unionpay:before{display:block;margin:0 auto;position:absolute;height:40px;top:0;z-index:-1}.jp-card-logo.jp-card-unionpay:before{content:" ";width:28px;background:#00447c;left:14px;border-top-left-radius:5px;border-bottom-left-radius:5px}.jp-card-logo.jp-card-unionpay:after{content:"\\94F6\\8054";width:26px;background:#007b84;left:34px;border-radius:5px;font-size:10px;line-height:54px;text-indent:-17px}.jp-card.jp-card-unionpay.jp-card-identified .jp-card-back:before,.jp-card.jp-card-unionpay.jp-card-identified .jp-card-front:before{background-color:#987c00}.jp-card.jp-card-unionpay.jp-card-identified .jp-card-logo.jp-card-unionpay{opacity:1}.jp-card-logo.jp-card-visa{text-transform:uppercase;color:white;text-align:center;font-weight:bold;font-size:24px;line-height:18px;margin-top:5px}.jp-card-logo.jp-card-visa:before,.jp-card-logo.jp-card-visa:after{content:" ";display:block;width:100%;height:25%}.jp-card-logo.jp-card-visa:before{position:absolute;left:-4px;width:0;height:0;border-style:solid;border-width:0 12px 6px 0;border-color:transparent #ffffff transparent transparent}.jp-card.jp-card-visa.jp-card-identified .jp-card-front:before,.jp-card.jp-card-visa.jp-card-identified .jp-card-back:before{background-color:#191278}.jp-card.jp-card-visa.jp-card-identified .jp-card-logo.jp-card-visa{opacity:1;box-shadow:none}.jp-card-logo.jp-card-visaelectron{background:white;text-transform:uppercase;color:#1A1876;text-align:center;font-weight:bold;font-size:15px;line-height:18px}.jp-card-logo.jp-card-visaelectron:before,.jp-card-logo.jp-card-visaelectron:after{content:" ";display:block;width:100%;height:25%}.jp-card-logo.jp-card-visaelectron:before{background:#1A1876}.jp-card-logo.jp-card-visaelectron:after{background:#E79800}.jp-card-logo.jp-card-visaelectron .elec{float:right;font-family:arial;font-size:9px;margin-right:1px;margin-top:-5px;text-transform:none}.jp-card.jp-card-visaelectron.jp-card-identified .jp-card-front:before,.jp-card.jp-card-visaelectron.jp-card-identified .jp-card-back:before{background-color:#191278}.jp-card.jp-card-visaelectron.jp-card-identified .jp-card-logo.jp-card-visaelectron{opacity:1}.jp-card-logo.jp-card-mastercard{color:white;font-style:normal;text-transform:lowercase;font-weight:bold;text-align:center;font-size:9px;line-height:84px;z-index:1;text-shadow:1px 1px rgba(0,0,0,0.6)}.jp-card-logo.jp-card-mastercard:before,.jp-card-logo.jp-card-mastercard:after{content:" ";display:block;width:36px;top:0;position:absolute;height:36px;border-radius:18px}.jp-card-logo.jp-card-mastercard:before{left:0;background:#EB001B;z-index:-1;opacity:0.9}.jp-card-logo.jp-card-mastercard:after{right:0;background:#FF5F00;z-index:-2}.jp-card.jp-card-mastercard.jp-card-identified .jp-card-front .jp-card-logo.jp-card-mastercard,.jp-card.jp-card-mastercard.jp-card-identified .jp-card-back .jp-card-logo.jp-card-mastercard{box-shadow:none}.jp-card.jp-card-mastercard.jp-card-identified .jp-card-front:before,.jp-card.jp-card-mastercard.jp-card-identified .jp-card-back:before{background-color:#0061A8}.jp-card.jp-card-mastercard.jp-card-identified .jp-card-logo.jp-card-mastercard{opacity:1}.jp-card-logo.jp-card-maestro{color:white;font-style:normal;text-transform:lowercase;font-weight:bold;text-align:center;font-size:14px;line-height:84px;z-index:1;text-shadow:1px 1px rgba(0,0,0,0.6)}.jp-card-logo.jp-card-maestro:before,.jp-card-logo.jp-card-maestro:after{content:" ";display:block;width:36px;top:0;position:absolute;height:36px;border-radius:18px}.jp-card-logo.jp-card-maestro:before{left:0;background:#EB001B;z-index:-2}.jp-card-logo.jp-card-maestro:after{right:0;background:#00A2E5;z-index:-1;opacity:0.8}.jp-card.jp-card-maestro.jp-card-identified .jp-card-front .jp-card-logo.jp-card-maestro,.jp-card.jp-card-maestro.jp-card-identified .jp-card-back .jp-card-logo.jp-card-maestro{box-shadow:none}.jp-card.jp-card-maestro.jp-card-identified .jp-card-front:before,.jp-card.jp-card-maestro.jp-card-identified .jp-card-back:before{background-color:#0B2C5F}.jp-card.jp-card-maestro.jp-card-identified .jp-card-logo.jp-card-maestro{opacity:1}.jp-card-logo.jp-card-dankort{width:60px;height:36px;padding:3px;border-radius:8px;border:#000 1px solid;background-color:#fff}.jp-card-logo.jp-card-dankort .dk{position:relative;width:100%;height:100%;overflow:hidden}.jp-card-logo.jp-card-dankort .dk:before{background-color:#ED1C24;content:\'\';position:absolute;width:100%;height:100%;display:block;border-radius:6px}.jp-card-logo.jp-card-dankort .dk:after{content:\'\';position:absolute;top:50%;margin-top:-7.7px;right:0;width:0;height:0;border-style:solid;border-width:7px 7px 10px 0;border-color:transparent #ED1C24 transparent transparent;z-index:1}.jp-card-logo.jp-card-dankort .d,.jp-card-logo.jp-card-dankort .k{position:absolute;top:50%;width:50%;display:block;height:15.4px;margin-top:-7.7px;background:white}.jp-card-logo.jp-card-dankort .d{left:0;border-radius:0 8px 10px 0}.jp-card-logo.jp-card-dankort .d:before{content:\'\';position:absolute;top:50%;left:50%;display:block;background:#ED1C24;border-radius:2px 4px 6px 0px;height:5px;width:7px;margin:-3px 0 0 -4px}.jp-card-logo.jp-card-dankort .k{right:0}.jp-card-logo.jp-card-dankort .k:before,.jp-card-logo.jp-card-dankort .k:after{content:\'\';position:absolute;right:50%;width:0;height:0;border-style:solid;margin-right:-1px}.jp-card-logo.jp-card-dankort .k:before{top:0;border-width:8px 5px 0 0;border-color:#ED1C24 transparent transparent transparent}.jp-card-logo.jp-card-dankort .k:after{bottom:0;border-width:0 5px 8px 0;border-color:transparent transparent #ED1C24 transparent}.jp-card.jp-card-dankort.jp-card-identified .jp-card-front:before,.jp-card.jp-card-dankort.jp-card-identified .jp-card-back:before{background-color:#0055C7}.jp-card.jp-card-dankort.jp-card-identified .jp-card-logo.jp-card-dankort{opacity:1}.jp-card-logo.jp-card-elo{height:50px;width:50px;border-radius:100%;background:black;color:white;text-align:center;text-transform:lowercase;font-size:21px;font-style:normal;letter-spacing:1px;font-weight:bold;padding-top:13px}.jp-card-logo.jp-card-elo .e,.jp-card-logo.jp-card-elo .l,.jp-card-logo.jp-card-elo .o{display:inline-block;position:relative}.jp-card-logo.jp-card-elo .e{-webkit-transform:rotate(-15deg);-moz-transform:rotate(-15deg);-ms-transform:rotate(-15deg);-o-transform:rotate(-15deg);transform:rotate(-15deg)}.jp-card-logo.jp-card-elo .o{position:relative;display:inline-block;width:12px;height:12px;right:0;top:7px;border-radius:100%;background-image:-webkit-linear-gradient( #ff0 50%,red 50%);background-image:linear-gradient( #ff0 50%,red 50%);-webkit-transform:rotate(40deg);-moz-transform:rotate(40deg);-ms-transform:rotate(40deg);-o-transform:rotate(40deg);transform:rotate(40deg);text-indent:-9999px}.jp-card-logo.jp-card-elo .o:before{content:"";position:absolute;width:49%;height:49%;background:black;border-radius:100%;text-indent:-99999px;top:25%;left:25%}.jp-card.jp-card-elo.jp-card-identified .jp-card-front:before,.jp-card.jp-card-elo.jp-card-identified .jp-card-back:before{background-color:#6F6969}.jp-card.jp-card-elo.jp-card-identified .jp-card-logo.jp-card-elo{opacity:1}.jp-card-logo.jp-card-jcb{border-radius:5px 0px 5px 0px;-moz-border-radius:5px 0px 5px 0px;-webkit-border-radius:5px 0px 5px 0px;background-color:white;font-style:normal;color:white;width:50px;padding:2px 0 0 2px}.jp-card-logo.jp-card-jcb>div{width:15px;margin-right:1px;display:inline-block;text-align:center;text-shadow:1px 1px rgba(0,0,0,0.6);border-radius:5px 0px 5px 0px;-moz-border-radius:5px 0px 5px 0px;-webkit-border-radius:5px 0px 5px 0px}.jp-card-logo.jp-card-jcb>div:before,.jp-card-logo.jp-card-jcb>div:after{content:" ";display:block;height:8px}.jp-card-logo.jp-card-jcb>div.j{background-color:#000063;background-image:-webkit-linear-gradient(left, #000063,#008cff);background-image:linear-gradient(to right,#000063,#008cff)}.jp-card-logo.jp-card-jcb>div.c{background-color:#630000;background-image:-webkit-linear-gradient(left, #630000,#ff008d);background-image:linear-gradient(to right,#630000,#ff008d)}.jp-card-logo.jp-card-jcb>div.b{background-color:#006300;background-image:-webkit-linear-gradient(left, #006300,lime);background-image:linear-gradient(to right,#006300,lime)}.jp-card.jp-card-jcb.jp-card-identified .jp-card-front:before,.jp-card.jp-card-jcb.jp-card-identified .jp-card-back:before{background-color:#CB8000}.jp-card.jp-card-jcb.jp-card-identified .jp-card-logo.jp-card-jcb{opacity:1;box-shadow:none}.jp-card-logo.jp-card-dinersclub{font-family:serif;height:40px;width:100px;color:white;font-size:17px;font-style:normal;letter-spacing:1px}.jp-card-logo.jp-card-dinersclub::before,.jp-card-logo.jp-card-dinersclub::after{display:block;position:relative}.jp-card-logo.jp-card-dinersclub::before{content:\'Diners Club\'}.jp-card-logo.jp-card-dinersclub::after{content:\'International\';text-transform:uppercase;font-size:0.6em}.jp-card.jp-card-dinersclub .jp-card-front .jp-card-logo{box-shadow:none !important}.jp-card.jp-card-dinersclub.jp-card-identified .jp-card-front:before,.jp-card.jp-card-dinersclub.jp-card-identified .jp-card-back:before{background-color:#999}.jp-card.jp-card-dinersclub.jp-card-identified .jp-card-logo.jp-card-dinersclub{opacity:1}.jp-card-logo.jp-card-hipercard{height:20px;width:100px;color:white;font-size:21px;font-style:italic;font-weight:bold}.jp-card-logo.jp-card-hipercard::before,.jp-card-logo.jp-card-hipercard::after{display:block;position:relative}.jp-card.jp-card-hipercard.jp-card-identified .jp-card-front:before,.jp-card.jp-card-hipercard.jp-card-identified .jp-card-back:before{background-color:#770304}.jp-card.jp-card-hipercard.jp-card-identified .jp-card-logo.jp-card-hipercard{opacity:1;box-shadow:none}.jp-card-logo.jp-card-troy{text-transform:lowercase;color:#fff;text-align:center;font-weight:700;font-size:24px;line-height:18px;margin-top:5px}.jp-card-logo.jp-card-troy:before,.jp-card-logo.jp-card-troy:after{content:\\"\\";display:block;width:26%;height:6%;background:#22b8c3;right:32%;top:24%;position:absolute;transform:rotate(105deg)}.jp-card.jp-card-troy.jp-card-identified .jp-card-front:before,.jp-card.jp-card-troy.jp-card-identified .jp-card-back:before{background-color:#01adba}.jp-card.jp-card-troy.jp-card-identified .jp-card-logo.jp-card-troy{opacity:1;box-shadow:none}.jp-card-container{-webkit-perspective:1000px;-moz-perspective:1000px;perspective:1000px;width:350px;max-width:100%;height:200px;margin:auto;z-index:1;position:relative}.jp-card{font-family:"Helvetica Neue",Helvetica,Arial,sans-serif;line-height:1;position:relative;width:100%;height:100%;min-width:315px;border-radius:10px;-webkit-transform-style:preserve-3d;-moz-transform-style:preserve-3d;-ms-transform-style:preserve-3d;-o-transform-style:preserve-3d;transform-style:preserve-3d;-webkit-transition:all 400ms linear;-moz-transition:all 400ms linear;transition:all 400ms linear}.jp-card>*,.jp-card>*:after,.jp-card>*:before{-moz-box-sizing:border-box;-webkit-box-sizing:border-box;box-sizing:border-box;font-family:inherit}.jp-card.jp-card-flipped{-webkit-transform:rotateY(180deg);-moz-transform:rotateY(180deg);-ms-transform:rotateY(180deg);-o-transform:rotateY(180deg);transform:rotateY(180deg)}.jp-card .jp-card-back,.jp-card .jp-card-front{-webkit-backface-visibility:hidden;backface-visibility:hidden;-webkit-transform-style:preserve-3d;-moz-transform-style:preserve-3d;-ms-transform-style:preserve-3d;-o-transform-style:preserve-3d;transform-style:preserve-3d;-webkit-transition:all 400ms linear;-moz-transition:all 400ms linear;transition:all 400ms linear;width:100%;height:100%;position:absolute;top:0;left:0;overflow:hidden;border-radius:10px;background:#ddd}.jp-card .jp-card-back:before,.jp-card .jp-card-front:before{content:" ";display:block;position:absolute;width:100%;height:100%;top:0;left:0;opacity:0;border-radius:10px;-webkit-transition:all 400ms ease;-moz-transition:all 400ms ease;transition:all 400ms ease}.jp-card .jp-card-back:after,.jp-card .jp-card-front:after{content:" ";display:block}.jp-card .jp-card-back .jp-card-display,.jp-card .jp-card-front .jp-card-display{color:#fff;font-weight:normal;opacity:0.5;-webkit-transition:opacity 400ms linear;-moz-transition:opacity 400ms linear;transition:opacity 400ms linear}.jp-card .jp-card-back .jp-card-display.jp-card-focused,.jp-card .jp-card-front .jp-card-display.jp-card-focused{opacity:1;font-weight:700}.jp-card .jp-card-back .jp-card-cvc,.jp-card .jp-card-front .jp-card-cvc{font-family:"Bitstream Vera Sans Mono",Consolas,Courier,monospace;font-size:14px}.jp-card .jp-card-back .jp-card-shiny,.jp-card .jp-card-front .jp-card-shiny{width:50px;height:35px;border-radius:5px;background:#ccc;position:relative}.jp-card .jp-card-back .jp-card-shiny:before,.jp-card .jp-card-front .jp-card-shiny:before{content:" ";display:block;width:70%;height:60%;border-top-right-radius:5px;border-bottom-right-radius:5px;background:#d9d9d9;position:absolute;top:20%}.jp-card .jp-card-front .jp-card-logo{position:absolute;opacity:0;right:5%;top:8%;-webkit-transition:400ms;-moz-transition:400ms;transition:400ms}.jp-card .jp-card-front .jp-card-lower{width:80%;position:absolute;left:10%;bottom:30px}@media only screen and (max-width: 480px){.jp-card .jp-card-front .jp-card-lower{width:90%;left:5%}}.jp-card .jp-card-front .jp-card-lower .jp-card-cvc{visibility:hidden;float:right;position:relative;bottom:5px}.jp-card .jp-card-front .jp-card-lower .jp-card-number{font-family:"Bitstream Vera Sans Mono",Consolas,Courier,monospace;font-size:24px;clear:both;margin-bottom:30px}.jp-card .jp-card-front .jp-card-lower .jp-card-expiry{font-family:"Bitstream Vera Sans Mono",Consolas,Courier,monospace;letter-spacing:0;position:relative;float:right;width:25%}.jp-card .jp-card-front .jp-card-lower .jp-card-expiry:after,.jp-card .jp-card-front .jp-card-lower .jp-card-expiry:before{font-family:"Helvetica Neue",Helvetica,Arial,sans-serif;font-weight:bold;font-size:7px;white-space:pre;display:block;opacity:0.5}.jp-card .jp-card-front .jp-card-lower .jp-card-expiry:before{content:attr(data-before);margin-bottom:2px;font-size:7px;text-transform:uppercase}.jp-card .jp-card-front .jp-card-lower .jp-card-expiry:after{position:absolute;content:attr(data-after);text-align:right;right:100%;margin-right:5px;margin-top:2px;bottom:0}.jp-card .jp-card-front .jp-card-lower .jp-card-name{text-transform:uppercase;font-family:"Bitstream Vera Sans Mono",Consolas,Courier,monospace;font-size:20px;max-height:45px;position:absolute;bottom:0;width:190px;display:-webkit-box;-webkit-line-clamp:2;-webkit-box-orient:horizontal;overflow:hidden;text-overflow:ellipsis}.jp-card .jp-card-back{-webkit-transform:rotateY(180deg);-moz-transform:rotateY(180deg);-ms-transform:rotateY(180deg);-o-transform:rotateY(180deg);transform:rotateY(180deg)}.jp-card .jp-card-back .jp-card-bar{background-color:#444;background-image:-webkit-linear-gradient(#444,#333);background-image:linear-gradient(#444,#333);width:100%;height:20%;position:absolute;top:10%}.jp-card .jp-card-back:after{content:" ";display:block;background-color:#fff;background-image:-webkit-linear-gradient(#fff,#fff);background-image:linear-gradient(#fff,#fff);width:80%;height:16%;position:absolute;top:40%;left:2%}.jp-card .jp-card-back .jp-card-cvc{position:absolute;top:40%;left:85%;-webkit-transition-delay:600ms;-moz-transition-delay:600ms;transition-delay:600ms}.jp-card .jp-card-back .jp-card-shiny{position:absolute;top:66%;left:2%}.jp-card .jp-card-back .jp-card-shiny:after{content:"This card has been issued by Jesse Pollak and is licensed for anyone to use anywhere for free. It comes with no warranty. For support issues, please visit: github.com/jessepollak/card.";position:absolute;left:120%;top:5%;color:white;font-size:7px;width:230px;opacity:0.5}.jp-card.jp-card-identified{box-shadow:0 0 20px rgba(0,0,0,0.3)}.jp-card.jp-card-identified .jp-card-back,.jp-card.jp-card-identified .jp-card-front{background-color:#000;background-color:rgba(0,0,0,0.5)}.jp-card.jp-card-identified .jp-card-back:before,.jp-card.jp-card-identified .jp-card-front:before{-webkit-transition:all 400ms ease;-moz-transition:all 400ms ease;transition:all 400ms ease;background-image:repeating-linear-gradient(45deg, rgba(255,255,255,0) 1px, rgba(255,255,255,0.03) 2px, rgba(255,255,255,0.04) 3px, rgba(255,255,255,0.05) 4px),repeating-linear-gradient(135deg, rgba(255,255,255,0.05) 1px, rgba(255,255,255,0) 2px, rgba(255,255,255,0.04) 3px, rgba(255,255,255,0.03) 4px),repeating-linear-gradient(90deg, rgba(255,255,255,0) 1px, rgba(255,255,255,0.03) 2px, rgba(255,255,255,0.04) 3px, rgba(255,255,255,0.05) 4px),repeating-linear-gradient(210deg, rgba(255,255,255,0) 1px, rgba(255,255,255,0.03) 2px, rgba(255,255,255,0.04) 3px, rgba(255,255,255,0.05) 4px),repeating-radial-gradient(circle at 30% 30%, rgba(255,255,255,0) 1px, rgba(255,255,255,0.03) 2px, rgba(255,255,255,0.04) 3px, rgba(255,255,255,0.05) 4px),repeating-radial-gradient(circle at 70% 70%, rgba(255,255,255,0) 1px, rgba(255,255,255,0.03) 2px, rgba(255,255,255,0.04) 3px, rgba(255,255,255,0.05) 4px),repeating-radial-gradient(circle at 90% 20%, rgba(255,255,255,0) 1px, rgba(255,255,255,0.03) 2px, rgba(255,255,255,0.04) 3px, rgba(255,255,255,0.05) 4px),repeating-radial-gradient(circle at 15% 80%, rgba(255,255,255,0) 1px, rgba(255,255,255,0.03) 2px, rgba(255,255,255,0.04) 3px, rgba(255,255,255,0.05) 4px),-webkit-linear-gradient(-245deg, rgba(255,255,255,0) 50%,rgba(255,255,255,0.2) 70%,rgba(255,255,255,0) 90%);background-image:repeating-linear-gradient(45deg, rgba(255,255,255,0) 1px, rgba(255,255,255,0.03) 2px, rgba(255,255,255,0.04) 3px, rgba(255,255,255,0.05) 4px),repeating-linear-gradient(135deg, rgba(255,255,255,0.05) 1px, rgba(255,255,255,0) 2px, rgba(255,255,255,0.04) 3px, rgba(255,255,255,0.03) 4px),repeating-linear-gradient(90deg, rgba(255,255,255,0) 1px, rgba(255,255,255,0.03) 2px, rgba(255,255,255,0.04) 3px, rgba(255,255,255,0.05) 4px),repeating-linear-gradient(210deg, rgba(255,255,255,0) 1px, rgba(255,255,255,0.03) 2px, rgba(255,255,255,0.04) 3px, rgba(255,255,255,0.05) 4px),repeating-radial-gradient(circle at 30% 30%, rgba(255,255,255,0) 1px, rgba(255,255,255,0.03) 2px, rgba(255,255,255,0.04) 3px, rgba(255,255,255,0.05) 4px),repeating-radial-gradient(circle at 70% 70%, rgba(255,255,255,0) 1px, rgba(255,255,255,0.03) 2px, rgba(255,255,255,0.04) 3px, rgba(255,255,255,0.05) 4px),repeating-radial-gradient(circle at 90% 20%, rgba(255,255,255,0) 1px, rgba(255,255,255,0.03) 2px, rgba(255,255,255,0.04) 3px, rgba(255,255,255,0.05) 4px),repeating-radial-gradient(circle at 15% 80%, rgba(255,255,255,0) 1px, rgba(255,255,255,0.03) 2px, rgba(255,255,255,0.04) 3px, rgba(255,255,255,0.05) 4px),linear-gradient(-25deg, rgba(255,255,255,0) 50%,rgba(255,255,255,0.2) 70%,rgba(255,255,255,0) 90%);opacity:1}.jp-card.jp-card-identified .jp-card-back .jp-card-logo,.jp-card.jp-card-identified .jp-card-front .jp-card-logo{box-shadow:0 0 0 2px rgba(255,255,255,0.3)}.jp-card.jp-card-identified.no-radial-gradient .jp-card-back:before,.jp-card.jp-card-identified.no-radial-gradient .jp-card-front:before{background-image:repeating-linear-gradient(45deg, rgba(255,255,255,0) 1px, rgba(255,255,255,0.03) 2px, rgba(255,255,255,0.04) 3px, rgba(255,255,255,0.05) 4px),repeating-linear-gradient(135deg, rgba(255,255,255,0.05) 1px, rgba(255,255,255,0) 2px, rgba(255,255,255,0.04) 3px, rgba(255,255,255,0.03) 4px),repeating-linear-gradient(90deg, rgba(255,255,255,0) 1px, rgba(255,255,255,0.03) 2px, rgba(255,255,255,0.04) 3px, rgba(255,255,255,0.05) 4px),repeating-linear-gradient(210deg, rgba(255,255,255,0) 1px, rgba(255,255,255,0.03) 2px, rgba(255,255,255,0.04) 3px, rgba(255,255,255,0.05) 4px),-webkit-linear-gradient(-245deg, rgba(255,255,255,0) 50%,rgba(255,255,255,0.2) 70%,rgba(255,255,255,0) 90%);background-image:repeating-linear-gradient(45deg, rgba(255,255,255,0) 1px, rgba(255,255,255,0.03) 2px, rgba(255,255,255,0.04) 3px, rgba(255,255,255,0.05) 4px),repeating-linear-gradient(135deg, rgba(255,255,255,0.05) 1px, rgba(255,255,255,0) 2px, rgba(255,255,255,0.04) 3px, rgba(255,255,255,0.03) 4px),repeating-linear-gradient(90deg, rgba(255,255,255,0) 1px, rgba(255,255,255,0.03) 2px, rgba(255,255,255,0.04) 3px, rgba(255,255,255,0.05) 4px),repeating-linear-gradient(210deg, rgba(255,255,255,0) 1px, rgba(255,255,255,0.03) 2px, rgba(255,255,255,0.04) 3px, rgba(255,255,255,0.05) 4px),linear-gradient(-25deg, rgba(255,255,255,0) 50%,rgba(255,255,255,0.2) 70%,rgba(255,255,255,0) 90%)}@media (max-width: 450px){.card-wrapper{max-width:80vw;width:100%;margin:20px auto;overflow-x:hidden}.card-wrapper>.jp-card-container{transform:scale(0.625);transform-origin:left center}}\n',""])},function(r,e){r.exports=function(){var r=[];return r.toString=function(){for(var r=[],e=0;e<this.length;e++){var t=this[e];t[2]?r.push("@media "+t[2]+"{"+t[1]+"}"):r.push(t[1])}return r.join("")},r.i=function(e,t){"string"==typeof e&&(e=[[null,e,""]]);for(var a={},n=0;n<this.length;n++){var o=this[n][0];"number"==typeof o&&(a[o]=!0)}for(n=0;n<e.length;n++){var i=e[n];"number"==typeof i[0]&&a[i[0]]||(t&&!i[2]?i[2]=t:t&&(i[2]="("+i[2]+") and ("+t+")"),r.push(i))}},r}},function(r,e){var t={},a=function(r){var e;return function(){return void 0===e&&(e=r.apply(this,arguments)),e}},n=a((function(){return/msie [6-9]\b/.test(self.navigator.userAgent.toLowerCase())})),o=a((function(){return document.head||document.getElementsByTagName("head")[0]})),i=null,d=0,c=[];function p(r,e){for(var a=0;a<r.length;a++){var n=r[a],o=t[n.id];if(o){o.refs++;for(var i=0;i<o.parts.length;i++)o.parts[i](n.parts[i]);for(;i<n.parts.length;i++)o.parts.push(g(n.parts[i],e))}else{var d=[];for(i=0;i<n.parts.length;i++)d.push(g(n.parts[i],e));t[n.id]={id:n.id,refs:1,parts:d}}}}function l(r){for(var e=[],t={},a=0;a<r.length;a++){var n=r[a],o=n[0],i={css:n[1],media:n[2],sourceMap:n[3]};t[o]?t[o].parts.push(i):e.push(t[o]={id:o,parts:[i]})}return e}function s(r,e){var t=o(),a=c[c.length-1];if("top"===r.insertAt)a?a.nextSibling?t.insertBefore(e,a.nextSibling):t.appendChild(e):t.insertBefore(e,t.firstChild),c.push(e);else{if("bottom"!==r.insertAt)throw new Error("Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.");t.appendChild(e)}}function f(r){r.parentNode.removeChild(r);var e=c.indexOf(r);e>=0&&c.splice(e,1)}function u(r){var e=document.createElement("style");return e.type="text/css",s(r,e),e}function g(r,e){var t,a,n;if(e.singleton){var o=d++;t=i||(i=u(e)),a=h.bind(null,t,o,!1),n=h.bind(null,t,o,!0)}else r.sourceMap&&"function"==typeof URL&&"function"==typeof URL.createObjectURL&&"function"==typeof URL.revokeObjectURL&&"function"==typeof Blob&&"function"==typeof btoa?(t=function(r){var e=document.createElement("link");return e.rel="stylesheet",s(r,e),e}(e),a=v.bind(null,t),n=function(){f(t),t.href&&URL.revokeObjectURL(t.href)}):(t=u(e),a=m.bind(null,t),n=function(){f(t)});return a(r),function(e){if(e){if(e.css===r.css&&e.media===r.media&&e.sourceMap===r.sourceMap)return;a(r=e)}else n()}}r.exports=function(r,e){if("undefined"!=typeof DEBUG&&DEBUG&&"object"!=typeof document)throw new Error("The style-loader cannot be used in a non-browser environment");void 0===(e=e||{}).singleton&&(e.singleton=n()),void 0===e.insertAt&&(e.insertAt="bottom");var a=l(r);return p(a,e),function(r){for(var n=[],o=0;o<a.length;o++){var i=a[o];(d=t[i.id]).refs--,n.push(d)}r&&p(l(r),e);for(o=0;o<n.length;o++){var d;if(0===(d=n[o]).refs){for(var c=0;c<d.parts.length;c++)d.parts[c]();delete t[d.id]}}}};var b,j=(b=[],function(r,e){return b[r]=e,b.filter(Boolean).join("\n")});function h(r,e,t,a){var n=t?"":a.css;if(r.styleSheet)r.styleSheet.cssText=j(e,n);else{var o=document.createTextNode(n),i=r.childNodes;i[e]&&r.removeChild(i[e]),i.length?r.insertBefore(o,i[e]):r.appendChild(o)}}function m(r,e){var t=e.css,a=e.media;if(a&&r.setAttribute("media",a),r.styleSheet)r.styleSheet.cssText=t;else{for(;r.firstChild;)r.removeChild(r.firstChild);r.appendChild(document.createTextNode(t))}}function v(r,e){var t=e.css,a=e.sourceMap;a&&(t+="\n/*# sourceMappingURL=data:application/json;base64,"+btoa(unescape(encodeURIComponent(JSON.stringify(a))))+" */");var n=new Blob([t],{type:"text/css"}),o=r.href;r.href=URL.createObjectURL(n),o&&URL.revokeObjectURL(o)}},function(r,e){(function(){var e,t,a;(e=function(r){return e.isDOMElement(r)?r:document.querySelectorAll(r)}).isDOMElement=function(r){return r&&null!=r.nodeName},a=/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,e.trim=function(r){return null===r?"":(r+"").replace(a,"")},t=/\r/g,e.val=function(r,e){var a;return arguments.length>1?r.value=e:"string"==typeof(a=r.value)?a.replace(t,""):null===a?"":a},e.preventDefault=function(r){if("function"!=typeof r.preventDefault)return r.returnValue=!1,!1;r.preventDefault()},e.normalizeEvent=function(r){var t;return null==(r={which:null!=(t=r).which?t.which:void 0,target:t.target||t.srcElement,preventDefault:function(){return e.preventDefault(t)},originalEvent:t,data:t.data||t.detail}).which&&(r.which=null!=t.charCode?t.charCode:t.keyCode),r},e.on=function(r,t,a){var n,o,i,d,c,p,l,s;if(r.length)for(o=0,d=r.length;o<d;o++)n=r[o],e.on(n,t,a);else{if(!t.match(" "))return l=a,a=function(r){return r=e.normalizeEvent(r),l(r)},r.addEventListener?r.addEventListener(t,a,!1):r.attachEvent?(t="on"+t,r.attachEvent(t,a)):void(r["on"+t]=a);for(i=0,c=(s=t.split(" ")).length;i<c;i++)p=s[i],e.on(r,p,a)}},e.addClass=function(r,t){var a;return r.length?function(){var n,o,i;for(i=[],n=0,o=r.length;n<o;n++)a=r[n],i.push(e.addClass(a,t));return i}():r.classList?r.classList.add(t):r.className+=" "+t},e.hasClass=function(r,t){var a,n,o,i;if(r.length){for(n=!0,o=0,i=r.length;o<i;o++)a=r[o],n=n&&e.hasClass(a,t);return n}return r.classList?r.classList.contains(t):new RegExp("(^| )"+t+"( |$)","gi").test(r.className)},e.removeClass=function(r,t){var a,n,o,i,d,c;if(r.length)return function(){var a,o,i;for(i=[],a=0,o=r.length;a<o;a++)n=r[a],i.push(e.removeClass(n,t));return i}();if(r.classList){for(c=[],o=0,i=(d=t.split(" ")).length;o<i;o++)a=d[o],c.push(r.classList.remove(a));return c}return r.className=r.className.replace(new RegExp("(^|\\b)"+t.split(" ").join("|")+"(\\b|$)","gi")," ")},e.toggleClass=function(r,t,a){var n;return r.length?function(){var o,i,d;for(d=[],o=0,i=r.length;o<i;o++)n=r[o],d.push(e.toggleClass(n,t,a));return d}():a?e.hasClass(r,t)?void 0:e.addClass(r,t):e.removeClass(r,t)},e.append=function(r,t){var a;return r.length?function(){var n,o,i;for(i=[],n=0,o=r.length;n<o;n++)a=r[n],i.push(e.append(a,t));return i}():r.insertAdjacentHTML("beforeend",t)},e.find=function(r,e){return(r instanceof NodeList||r instanceof Array)&&(r=r[0]),r.querySelectorAll(e)},e.trigger=function(r,e,t){var a,n;try{n=new CustomEvent(e,{detail:t})}catch(a){a,(n=document.createEvent("CustomEvent")).initCustomEvent?n.initCustomEvent(e,!0,!0,t):n.initEvent(e,!0,!0,t)}return r.dispatchEvent(n)},r.exports=e}).call(this)},function(r,e){!function(r){var e={};function t(a){if(e[a])return e[a].exports;var n=e[a]={i:a,l:!1,exports:{}};return r[a].call(n.exports,n,n.exports,t),n.l=!0,n.exports}t.m=r,t.c=e,t.d=function(r,e,a){t.o(r,e)||Object.defineProperty(r,e,{enumerable:!0,get:a})},t.r=function(r){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(r,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(r,"__esModule",{value:!0})},t.t=function(r,e){if(1&e&&(r=t(r)),8&e)return r;if(4&e&&"object"==typeof r&&r&&r.__esModule)return r;var a=Object.create(null);if(t.r(a),Object.defineProperty(a,"default",{enumerable:!0,value:r}),2&e&&"string"!=typeof r)for(var n in r)t.d(a,n,function(e){return r[e]}.bind(null,n));return a},t.n=function(r){var e=r&&r.__esModule?function(){return r.default}:function(){return r};return t.d(e,"a",e),e},t.o=function(r,e){return Object.prototype.hasOwnProperty.call(r,e)},t.p="",t(t.s=0)}([function(r,e,t){var a,n,o,i,d,c,p,l,s,f,u,g,b,j,h,m,v,x,y,w,k,C,E,z,$,D,N=[].indexOf||function(r){for(var e=0,t=this.length;e<t;e++)if(e in this&&this[e]===r)return e;return-1};h=t(1)(),n=t(4),d=[{type:"amex",pattern:/^3[47]/,format:/(\d{1,4})(\d{1,6})?(\d{1,5})?/,length:[15],cvcLength:[4],luhn:!0},{type:"dankort",pattern:/^5019/,format:p=/(\d{1,4})/g,length:[16],cvcLength:[3],luhn:!0},{type:"dinersclub",pattern:/^(36|38|30[0-5])/,format:/(\d{1,4})(\d{1,6})?(\d{1,4})?/,length:[14],cvcLength:[3],luhn:!0},{type:"discover",pattern:/^(6011|65|64[4-9]|622)/,format:p,length:[16],cvcLength:[3],luhn:!0},{type:"elo",pattern:/^401178|^401179|^431274|^438935|^451416|^457393|^457631|^457632|^504175|^627780|^636297|^636369|^636368|^(506699|5067[0-6]\d|50677[0-8])|^(50900\d|5090[1-9]\d|509[1-9]\d{2})|^65003[1-3]|^(65003[5-9]|65004\d|65005[0-1])|^(65040[5-9]|6504[1-3]\d)|^(65048[5-9]|65049\d|6505[0-2]\d|65053[0-8])|^(65054[1-9]|6505[5-8]\d|65059[0-8])|^(65070\d|65071[0-8])|^65072[0-7]|^(65090[1-9]|65091\d|650920)|^(65165[2-9]|6516[6-7]\d)|^(65500\d|65501\d)|^(65502[1-9]|6550[3-4]\d|65505[0-8])|^(65092[1-9]|65097[0-8])/,format:p,length:[16],cvcLength:[3],luhn:!0},{type:"hipercard",pattern:/^(384100|384140|384160|606282|637095|637568|60(?!11))/,format:p,length:[14,15,16,17,18,19],cvcLength:[3],luhn:!0},{type:"jcb",pattern:/^(308[8-9]|309[0-3]|3094[0]{4}|309[6-9]|310[0-2]|311[2-9]|3120|315[8-9]|333[7-9]|334[0-9]|35)/,format:p,length:[16,19],cvcLength:[3],luhn:!0},{type:"laser",pattern:/^(6706|6771|6709)/,format:p,length:[16,17,18,19],cvcLength:[3],luhn:!0},{type:"maestro",pattern:/^(50|5[6-9]|6007|6220|6304|6703|6708|6759|676[1-3])/,format:p,length:[12,13,14,15,16,17,18,19],cvcLength:[3],luhn:!0},{type:"mastercard",pattern:/^(5[1-5]|677189)|^(222[1-9]|2[3-6]\d{2}|27[0-1]\d|2720)/,format:p,length:[16],cvcLength:[3],luhn:!0},{type:"mir",pattern:/^220[0-4][0-9][0-9]\d{10}$/,format:p,length:[16],cvcLength:[3],luhn:!0},{type:"troy",pattern:/^9792/,format:p,length:[16],cvcLength:[3],luhn:!0},{type:"unionpay",pattern:/^62/,format:p,length:[16,17,18,19],cvcLength:[3],luhn:!1},{type:"visaelectron",pattern:/^4(026|17500|405|508|844|91[37])/,format:p,length:[16],cvcLength:[3],luhn:!0},{type:"visa",pattern:/^4/,format:p,length:[13,16,19],cvcLength:[3],luhn:!0}],o=function(r){var e,t,a,n,o;for(r=(r+"").replace(/\D/g,""),t=void 0,a=0,n=d.length;a<n;a++)e=d[a],(o=r.match(e.pattern))&&(!t||o[0].length>t[1][0].length)&&(t=[e,o]);return t&&t[0]},i=function(r){var e,t,a;for(t=0,a=d.length;t<a;t++)if((e=d[t]).type===r)return e},v=function(r){var e,t,a,n,o,i;for(o=!0,i=0,a=0,n=(t=(r+"").split("").reverse()).length;a<n;a++)e=t[a],e=parseInt(e,10),(o=!o)&&(e*=2),e>9&&(e-=9),i+=e;return i%10==0},m=function(r){var e,t;try{if(null!=r.selectionStart&&r.selectionStart!==r.selectionEnd)return!0;if(null!=("undefined"!=typeof document&&null!==document&&null!=(t=document.selection)?t.createRange:void 0)&&document.selection.createRange().text)return!0}catch(e){e}return!1},x=function(r){return setTimeout((function(){var e,t;return e=r.target,t=n.val(e),t=a.fns.formatCardNumber(t),c(e,t),n.trigger(e,"change")}))},f=function(r){return function(e){var t,a,i,d,c,p,l,s,f,u,g;if(e.which>0?(a=String.fromCharCode(e.which),g=n.val(e.target)+a):(a=e.data,g=n.val(e.target)),/^\d+$/.test(a)){for(s=e.target,t=o(g),p=g.replace(/\D/g,"").length,u=[16],t&&(u=t.length),r&&(u=u.filter((function(e){return e<=r}))),i=d=0,c=u.length;d<c;i=++d)if(!(p>=(f=u[i])&&u[i+1])&&p>=f)return;if(!m(s))return l=t&&"amex"===t.type?/^(\d{4}|\d{4}\s\d{6})$/:/(?:^|\s)(\d{4})$/,g=g.substring(0,g.length-1),l.test(g)?(e.preventDefault(),n.val(s,g+" "+a),n.trigger(s,"change")):void 0}}},l=function(r){var e,t;if(e=r.target,t=n.val(e),!r.meta&&8===r.which&&!m(e))return/\d\s$/.test(t)?(r.preventDefault(),n.val(e,t.replace(/\d\s$/,"")),n.trigger(e,"change")):/\s\d?$/.test(t)?(r.preventDefault(),n.val(e,t.replace(/\s\d?$/,"")),n.trigger(e,"change")):void 0},u=function(r){var e,t,a;if(t=r.target,r.which>0?(e=String.fromCharCode(r.which),a=n.val(t)+e):(e=r.data,a=n.val(t)),/^\d+$/.test(e))return/^\d$/.test(a)&&"0"!==a&&"1"!==a?(r.preventDefault(),n.val(t,"0"+a+" / "),n.trigger(t,"change")):/^\d\d$/.test(a)?(r.preventDefault(),n.val(t,a+" / "),n.trigger(t,"change")):void 0},j=function(r){var e,t,a;if(e=String.fromCharCode(r.which),/^\d+$/.test(e))return t=r.target,a=n.val(t)+e,/^\d$/.test(a)&&"0"!==a&&"1"!==a?(r.preventDefault(),n.val(t,"0"+a),n.trigger(t,"change")):/^\d\d$/.test(a)?(r.preventDefault(),n.val(t,""+a),n.trigger(t,"change")):void 0},g=function(r){var e,t,a;if(e=String.fromCharCode(r.which),/^\d+$/.test(e))return t=r.target,a=n.val(t),/^\d\d$/.test(a)?(n.val(t,a+" / "),n.trigger(t,"change")):void 0},b=function(r){var e,t;if("/"===String.fromCharCode(r.which))return e=r.target,t=n.val(e),/^\d$/.test(t)&&"0"!==t?(n.val(e,"0"+t+" / "),n.trigger(e,"change")):void 0},s=function(r){var e,t;if(!r.metaKey&&(e=r.target,t=n.val(e),8===r.which&&!m(e)))return/\d(\s|\/)+$/.test(t)?(r.preventDefault(),n.val(e,t.replace(/\d(\s|\/)*$/,"")),n.trigger(e,"change")):/\s\/\s?\d?$/.test(t)?(r.preventDefault(),n.val(e,t.replace(/\s\/\s?\d?$/,"")),n.trigger(e,"change")):void 0},z=function(r){var e;return!(!r.metaKey&&!r.ctrlKey)||(32===r.which?r.preventDefault():0===r.which||(r.which<33||(e=String.fromCharCode(r.which),/[\d\s]/.test(e)?void 0:r.preventDefault())))},w=function(r){return function(e){var t,a,i,d,c;if(d=e.target,a=String.fromCharCode(e.which),/^\d+$/.test(a)&&!m(d))return c=(n.val(d)+a).replace(/\D/g,""),i=16,(t=o(c))&&(i=t.length[t.length.length-1]),r&&(i=Math.min(i,r)),c.length<=i?void 0:e.preventDefault()}},C=function(r,e){var t,a;if(a=r.target,t=String.fromCharCode(r.which),/^\d+$/.test(t)&&!m(a))return(n.val(a)+t).replace(/\D/g,"").length>e?r.preventDefault():void 0},k=function(r){return C(r,6)},E=function(r){return C(r,2)},$=function(r){return C(r,4)},y=function(r){var e,t;if(t=r.target,e=String.fromCharCode(r.which),/^\d+$/.test(e)&&!m(t))return(n.val(t)+e).length<=4?void 0:r.preventDefault()},D=function(r){var e,t,o,i,c;if(i=r.target,c=n.val(i),o=a.fns.cardType(c)||"unknown",!n.hasClass(i,o))return e=function(){var r,e,a;for(a=[],r=0,e=d.length;r<e;r++)t=d[r],a.push(t.type);return a}(),n.removeClass(i,"unknown"),n.removeClass(i,e.join(" ")),n.addClass(i,o),n.toggleClass(i,"identified","unknown"!==o),n.trigger(i,"payment.cardType",o)},c=function(r,e){var t;if(t=r.selectionEnd,n.val(r,e),t)return r.selectionEnd=t},a=function(){function r(){}return r.J=n,r.fns={cardExpiryVal:function(r){var e,t,a;return e=(t=(r=r.replace(/\s/g,"")).split("/",2))[0],2===(null!=(a=t[1])?a.length:void 0)&&/^\d+$/.test(a)&&(a=(new Date).getFullYear().toString().slice(0,2)+a),{month:e=parseInt(e,10),year:a=parseInt(a,10)}},validateCardNumber:function(r){var e,t;return r=(r+"").replace(/\s+|-/g,""),!!/^\d+$/.test(r)&&(!!(e=o(r))&&(t=r.length,N.call(e.length,t)>=0&&(!1===e.luhn||v(r))))},validateCardExpiry:function(e,t){var a,o,i,d;return"object"==typeof e&&"month"in e?(e=(i=e).month,t=i.year):"string"==typeof e&&N.call(e,"/")>=0&&(e=(d=r.fns.cardExpiryVal(e)).month,t=d.year),!(!e||!t)&&(e=n.trim(e),t=n.trim(t),!!/^\d+$/.test(e)&&(!!/^\d+$/.test(t)&&(!!((e=parseInt(e,10))&&e<=12)&&(2===t.length&&(t=(new Date).getFullYear().toString().slice(0,2)+t),o=new Date(t,e),a=new Date,o.setMonth(o.getMonth()-1),o.setMonth(o.getMonth()+1,1),o>a))))},validateCardCVC:function(r,e){var t,a;return r=n.trim(r),!!/^\d+$/.test(r)&&(e&&i(e)?(t=r.length,N.call(null!=(a=i(e))?a.cvcLength:void 0,t)>=0):r.length>=3&&r.length<=4)},cardType:function(r){var e;return r&&(null!=(e=o(r))?e.type:void 0)||null},formatCardNumber:function(r){var e,t,a,n;return(e=o(r))?(n=e.length[e.length.length-1],r=(r=r.replace(/\D/g,"")).slice(0,n),e.format.global?null!=(a=r.match(e.format))?a.join(" "):void 0:null!=(t=e.format.exec(r))?(t.shift(),(t=t.filter((function(r){return r}))).join(" ")):void 0):r}},r.restrictNumeric=function(r){return n.on(r,"keypress",z),n.on(r,"input",z)},r.cardExpiryVal=function(e){return r.fns.cardExpiryVal(n.val(e))},r.formatCardCVC=function(e){return r.restrictNumeric(e),n.on(e,"keypress",y),n.on(e,"input",y),e},r.formatCardExpiry=function(e){var t,a;return r.restrictNumeric(e),e.length&&2===e.length?(t=e[0],a=e[1],this.formatCardExpiryMultiple(t,a)):(n.on(e,"keypress",k),n.on(e,"keypress",u),n.on(e,"keypress",b),n.on(e,"keypress",g),n.on(e,"keydown",s),n.on(e,"input",u)),e},r.formatCardExpiryMultiple=function(r,e){return n.on(r,"keypress",E),n.on(r,"keypress",j),n.on(r,"input",j),n.on(e,"keypress",$),n.on(e,"input",$)},r.formatCardNumber=function(e,t){return r.restrictNumeric(e),n.on(e,"keypress",w(t)),n.on(e,"keypress",f(t)),n.on(e,"keydown",l),n.on(e,"keyup blur",D),n.on(e,"paste",x),n.on(e,"input",f(t)),e},r.getCardArray=function(){return d},r.setCardArray=function(r){return d=r,!0},r.addToCardArray=function(r){return d.push(r)},r.removeFromCardArray=function(r){var e;for(e in d)d[e].type===r&&d.splice(e,1);return!0},r}(),r.exports=a,h.Payment=a},function(r,e,t){"use strict";(function(e){var a=t(3);r.exports=function(){return"object"==typeof e&&e&&e.Math===Math&&e.Array===Array?e:a}}).call(this,t(2))},function(r,e){var t;t=function(){return this}();try{t=t||new Function("return this")()}catch(r){"object"==typeof window&&(t=window)}r.exports=t},function(r,e,t){"use strict";"undefined"!=typeof self?r.exports=self:"undefined"!=typeof window?r.exports=window:r.exports=Function("return this")()},function(r,e){(function(){var e,t,a;(e=function(r){return e.isDOMElement(r)?r:document.querySelectorAll(r)}).isDOMElement=function(r){return r&&null!=r.nodeName},a=/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,e.trim=function(r){return null===r?"":(r+"").replace(a,"")},t=/\r/g,e.val=function(r,e){var a;return arguments.length>1?r.value=e:"string"==typeof(a=r.value)?a.replace(t,""):null===a?"":a},e.preventDefault=function(r){if("function"!=typeof r.preventDefault)return r.returnValue=!1,!1;r.preventDefault()},e.normalizeEvent=function(r){var t;return null==(r={which:null!=(t=r).which?t.which:void 0,target:t.target||t.srcElement,preventDefault:function(){return e.preventDefault(t)},originalEvent:t,data:t.data||t.detail}).which&&(r.which=null!=t.charCode?t.charCode:t.keyCode),r},e.on=function(r,t,a){var n,o,i,d,c,p,l,s;if(r.length)for(o=0,d=r.length;o<d;o++)n=r[o],e.on(n,t,a);else{if(!t.match(" "))return l=a,a=function(r){return r=e.normalizeEvent(r),l(r)},r.addEventListener?r.addEventListener(t,a,!1):r.attachEvent?(t="on"+t,r.attachEvent(t,a)):void(r["on"+t]=a);for(i=0,c=(s=t.split(" ")).length;i<c;i++)p=s[i],e.on(r,p,a)}},e.addClass=function(r,t){var a;return r.length?function(){var n,o,i;for(i=[],n=0,o=r.length;n<o;n++)a=r[n],i.push(e.addClass(a,t));return i}():r.classList?r.classList.add(t):r.className+=" "+t},e.hasClass=function(r,t){var a,n,o,i;if(r.length){for(n=!0,o=0,i=r.length;o<i;o++)a=r[o],n=n&&e.hasClass(a,t);return n}return r.classList?r.classList.contains(t):new RegExp("(^| )"+t+"( |$)","gi").test(r.className)},e.removeClass=function(r,t){var a,n,o,i,d,c;if(r.length)return function(){var a,o,i;for(i=[],a=0,o=r.length;a<o;a++)n=r[a],i.push(e.removeClass(n,t));return i}();if(r.classList){for(c=[],o=0,i=(d=t.split(" ")).length;o<i;o++)a=d[o],c.push(r.classList.remove(a));return c}return r.className=r.className.replace(new RegExp("(^|\\b)"+t.split(" ").join("|")+"(\\b|$)","gi")," ")},e.toggleClass=function(r,t,a){var n;return r.length?function(){var o,i,d;for(d=[],o=0,i=r.length;o<i;o++)n=r[o],d.push(e.toggleClass(n,t,a));return d}():a?e.hasClass(r,t)?void 0:e.addClass(r,t):e.removeClass(r,t)},e.append=function(r,t){var a;return r.length?function(){var n,o,i;for(i=[],n=0,o=r.length;n<o;n++)a=r[n],i.push(e.append(a,t));return i}():r.insertAdjacentHTML("beforeend",t)},e.find=function(r,e){return(r instanceof NodeList||r instanceof Array)&&(r=r[0]),r.querySelectorAll(e)},e.trigger=function(r,e,t){var a,n;try{n=new CustomEvent(e,{detail:t})}catch(a){a,(n=document.createEvent("CustomEvent")).initCustomEvent?n.initCustomEvent(e,!0,!0,t):n.initEvent(e,!0,!0,t)}return r.dispatchEvent(n)},r.exports=e}).call(this)}])},function(r,e,t){"use strict";r.exports=t(10)},function(r,e,t){"use strict";
/*!
 * node.extend
 * Copyright 2011, John Resig
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * @fileoverview
 * Port of jQuery.extend that actually works on node.js
 */var a=t(11),n=t(12),o=Object.defineProperty,i=Object.getOwnPropertyDescriptor,d=function(r,e,t){o&&"__proto__"===e?o(r,e,{enumerable:!0,configurable:!0,value:t,writable:!0}):r[e]=t},c=function(r,e){if("__proto__"===e){if(!n(r,e))return;if(i)return i(r,e).value}return r[e]};function p(){var r,e,t,n,o,i,l=arguments[0]||{},s=1,f=arguments.length,u=!1;for("boolean"==typeof l&&(u=l,l=arguments[1]||{},s=2),"object"==typeof l||a.fn(l)||(l={});s<f;s++)if(null!=(r=arguments[s]))for(e in"string"==typeof r&&(r=r.split("")),r)t=c(l,e),l!==(n=c(r,e))&&(u&&n&&(a.hash(n)||(o=a.array(n)))?(o?(o=!1,i=t&&a.array(t)?t:[]):i=t&&a.hash(t)?t:{},d(l,e,p(u,i,n))):void 0!==n&&d(l,e,n));return l}p.version="1.1.7",r.exports=p},function(r,e,t){"use strict";
/**!
 * is
 * the definitive JavaScript type testing library
 *
 * @copyright 2013-2014 Enrico Marino / Jordan Harband
 * @license MIT
 */var a,n,o=Object.prototype,i=o.hasOwnProperty,d=o.toString;"function"==typeof Symbol&&(a=Symbol.prototype.valueOf),"function"==typeof BigInt&&(n=BigInt.prototype.valueOf);var c=function(r){return r!=r},p={boolean:1,number:1,string:1,undefined:1},l=/^([A-Za-z0-9+/]{4})*([A-Za-z0-9+/]{4}|[A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{2}==)$/,s=/^[A-Fa-f0-9]+$/,f={};f.a=f.type=function(r,e){return typeof r===e},f.defined=function(r){return void 0!==r},f.empty=function(r){var e,t=d.call(r);if("[object Array]"===t||"[object Arguments]"===t||"[object String]"===t)return 0===r.length;if("[object Object]"===t){for(e in r)if(i.call(r,e))return!1;return!0}return!r},f.equal=function(r,e){if(r===e)return!0;var t,a=d.call(r);if(a!==d.call(e))return!1;if("[object Object]"===a){for(t in r)if(!f.equal(r[t],e[t])||!(t in e))return!1;for(t in e)if(!f.equal(r[t],e[t])||!(t in r))return!1;return!0}if("[object Array]"===a){if((t=r.length)!==e.length)return!1;for(;t--;)if(!f.equal(r[t],e[t]))return!1;return!0}return"[object Function]"===a?r.prototype===e.prototype:"[object Date]"===a&&r.getTime()===e.getTime()},f.hosted=function(r,e){var t=typeof e[r];return"object"===t?!!e[r]:!p[t]},f.instance=f.instanceof=function(r,e){return r instanceof e},f.nil=f.null=function(r){return null===r},f.undef=f.undefined=function(r){return void 0===r},f.args=f.arguments=function(r){var e="[object Arguments]"===d.call(r),t=!f.array(r)&&f.arraylike(r)&&f.object(r)&&f.fn(r.callee);return e||t},f.array=Array.isArray||function(r){return"[object Array]"===d.call(r)},f.args.empty=function(r){return f.args(r)&&0===r.length},f.array.empty=function(r){return f.array(r)&&0===r.length},f.arraylike=function(r){return!!r&&!f.bool(r)&&i.call(r,"length")&&isFinite(r.length)&&f.number(r.length)&&r.length>=0},f.bool=f.boolean=function(r){return"[object Boolean]"===d.call(r)},f.false=function(r){return f.bool(r)&&!1===Boolean(Number(r))},f.true=function(r){return f.bool(r)&&!0===Boolean(Number(r))},f.date=function(r){return"[object Date]"===d.call(r)},f.date.valid=function(r){return f.date(r)&&!isNaN(Number(r))},f.element=function(r){return void 0!==r&&"undefined"!=typeof HTMLElement&&r instanceof HTMLElement&&1===r.nodeType},f.error=function(r){return"[object Error]"===d.call(r)},f.fn=f.function=function(r){if("undefined"!=typeof window&&r===window.alert)return!0;var e=d.call(r);return"[object Function]"===e||"[object GeneratorFunction]"===e||"[object AsyncFunction]"===e},f.number=function(r){return"[object Number]"===d.call(r)},f.infinite=function(r){return r===1/0||r===-1/0},f.decimal=function(r){return f.number(r)&&!c(r)&&!f.infinite(r)&&r%1!=0},f.divisibleBy=function(r,e){var t=f.infinite(r),a=f.infinite(e),n=f.number(r)&&!c(r)&&f.number(e)&&!c(e)&&0!==e;return t||a||n&&r%e==0},f.integer=f.int=function(r){return f.number(r)&&!c(r)&&r%1==0},f.maximum=function(r,e){if(c(r))throw new TypeError("NaN is not a valid value");if(!f.arraylike(e))throw new TypeError("second argument must be array-like");for(var t=e.length;--t>=0;)if(r<e[t])return!1;return!0},f.minimum=function(r,e){if(c(r))throw new TypeError("NaN is not a valid value");if(!f.arraylike(e))throw new TypeError("second argument must be array-like");for(var t=e.length;--t>=0;)if(r>e[t])return!1;return!0},f.nan=function(r){return!f.number(r)||r!=r},f.even=function(r){return f.infinite(r)||f.number(r)&&r==r&&r%2==0},f.odd=function(r){return f.infinite(r)||f.number(r)&&r==r&&r%2!=0},f.ge=function(r,e){if(c(r)||c(e))throw new TypeError("NaN is not a valid value");return!f.infinite(r)&&!f.infinite(e)&&r>=e},f.gt=function(r,e){if(c(r)||c(e))throw new TypeError("NaN is not a valid value");return!f.infinite(r)&&!f.infinite(e)&&r>e},f.le=function(r,e){if(c(r)||c(e))throw new TypeError("NaN is not a valid value");return!f.infinite(r)&&!f.infinite(e)&&r<=e},f.lt=function(r,e){if(c(r)||c(e))throw new TypeError("NaN is not a valid value");return!f.infinite(r)&&!f.infinite(e)&&r<e},f.within=function(r,e,t){if(c(r)||c(e)||c(t))throw new TypeError("NaN is not a valid value");if(!f.number(r)||!f.number(e)||!f.number(t))throw new TypeError("all arguments must be numbers");return f.infinite(r)||f.infinite(e)||f.infinite(t)||r>=e&&r<=t},f.object=function(r){return"[object Object]"===d.call(r)},f.primitive=function(r){return!r||!("object"==typeof r||f.object(r)||f.fn(r)||f.array(r))},f.hash=function(r){return f.object(r)&&r.constructor===Object&&!r.nodeType&&!r.setInterval},f.regexp=function(r){return"[object RegExp]"===d.call(r)},f.string=function(r){return"[object String]"===d.call(r)},f.base64=function(r){return f.string(r)&&(!r.length||l.test(r))},f.hex=function(r){return f.string(r)&&(!r.length||s.test(r))},f.symbol=function(r){return"function"==typeof Symbol&&"[object Symbol]"===d.call(r)&&"symbol"==typeof a.call(r)},f.bigint=function(r){return"function"==typeof BigInt&&"[object BigInt]"===d.call(r)&&"bigint"==typeof n.call(r)},r.exports=f},function(r,e,t){"use strict";var a=t(13);r.exports=a.call(Function.call,Object.prototype.hasOwnProperty)},function(r,e,t){"use strict";var a=t(14);r.exports=Function.prototype.bind||a},function(r,e,t){"use strict";var a="Function.prototype.bind called on incompatible ",n=Array.prototype.slice,o=Object.prototype.toString;r.exports=function(r){var e=this;if("function"!=typeof e||"[object Function]"!==o.call(e))throw new TypeError(a+e);for(var t,i=n.call(arguments,1),d=function(){if(this instanceof t){var a=e.apply(this,i.concat(n.call(arguments)));return Object(a)===a?a:this}return e.apply(r,i.concat(n.call(arguments)))},c=Math.max(0,e.length-i.length),p=[],l=0;l<c;l++)p.push("$"+l);if(t=Function("binder","return function ("+p.join(",")+"){ return binder.apply(this,arguments); }")(d),e.prototype){var s=function(){};s.prototype=e.prototype,t.prototype=new s,s.prototype=null}return t}},function(r,e){r.exports=jQuery}]);